<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>单词环</title>
    <url>/2021/07/12/Algorithm-Improvement/Chapter3---Gragh-Theory/Negative-Circle/%E5%8D%95%E8%AF%8D%E7%8E%AF/</url>
    <content><![CDATA[<h1 id="单词环"><a href="#单词环" class="headerlink" title="单词环"></a>单词环</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210712192242.png" alt="image-20210712192242017"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>这题主要是要用到spfa判断正环+01分数规划+spfa玄学优化</p>
<p>我们先来思考一下该怎么建图呢？</p>
<p>如果按照常规思路，我们把一个字符串看作一个节点，那么题目最多有$10^5$个节点，那么会最多会有多少条边呢？我们来考虑最坏情况，这$10^5$个字符串都是相同的，以3个完全相同的字符串为栗子，比如：</p>
<ul>
<li>【1】$aaaaa$</li>
<li>【2】$aaaaa$</li>
<li>【3】$aaaaa$</li>
</ul>
<p>可以发现对于【1】来说，它可以接到【2】和【3】上，那么有$3-1=2$种可能，也就是说要从【1】引出两条有向边，分别指向【2】和【3】。同理分析可知，如果$10^5$个字符串都相同，则对于每个字符串来说，都会引出$10^5-1$条边，为了方便起见，就看作是引出$10^5$条边。有$10^5$个节点，每个节点会引出$10^5$条有向边，因此总共有$10^5\times 10^5=10^{10}$条有向边。很明显，点数为$10^5$，边数为$10^{10}$，存储空间要爆炸。因此，我们需要思考该怎么建图呢？</p>
<p>从题目描述中，我们可以知道，一个字符串除了前面的2个字符和后面的2个字符有用之外，字符串中间的其他所有字符都没有用，因此，我们可以这样建图：</p>
<p>直接hash前面的两个字符和后面的两个字符作为节点，该字符串的长度作为这两个节点之间的边的权值。对于一个字符串来说，它后面的两个字符，每个字符都有26种可能，因此这两个字符产生了$26\times26=676$种可能，也就是最多会有$676$个节点。例如题目中的第一个字符串$ababc$，它后面的$bc$就确定了图中的一个顶点，第二个字符串$bckjaca$，它后面的$ca$就确定了图中的一个顶点，第三个字符串$caahoynaab$，它后面的$ab$就确定了图中的一个顶点。也就是说对于后面两个字符所确定的一种可能，都会对应地确定了图中的一个顶点。那么有$26\times 26$种可能，也就是确定了图中最多会有$676$个顶点。由之前分析可知，每个节点最多很引出$10^5$条有向边。因此这种建图方式最多会引出$676\times 10^5=6.76\times 10^7$条有向边，空间还算好一些。</p>
<p>如下图解释题目中的栗子：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210712194716.png" alt="image-20210712194716858"></p>
<p>知道了该怎么建图后，我们再来思考题目要求的是什么？题目想要求的是形成环的这个串它的平均长度最大，转换到我们建好的图中，意思就是：边权之和/节点个数 最大。即$\dfrac {\sum w_i}{\sum 1}$要最大</p>
<p>要求这个值最大，满足单调性，很明显这就是一个01分数规划问题，那么就可以使用二分算法来二分答案了。我们设某一时刻二分出来的答案为$mid$（但不保证这就是最终正确想要的最大的那个答案），如果当前这个答案$mid$不够大，则说明还可以更大，即</p>
<p>$\dfrac {\sum w_i}{\sum 1}&gt;mid$</p>
<p>$\iff$ $\sum w_i&gt;mid*\sum 1$</p>
<p>$\iff$ $\sum w_i-mid*\sum 1&gt;0$</p>
<p>$\iff$$\sum w_i-\sum mid*1&gt;0$</p>
<p>$\iff$ $\sum (w_i-mid*1)$</p>
<p>那么也就是说，对于每一条边，给它赋权值为$w_i-mid*1$，如果存在正环，也就意味着有一个环的权值和大于0，也就是$\sum (w_i-mid\times 1)&gt;0$，就意味着$mid$需要更大，由于是单调递增的，那么此时就应该执行$L=mid$，否则就是执行$R=mid$。</p>
<p>这里还要思考一下二分的区间是啥？由于$\sum w_i$和$\sum 1$都是正数，因此相除的话一定是大于0的，注意这里是浮点数相除哦！因此左范围一定大于0。由$\dfrac {\sum w_i}{\sum 1}$式子可知，要想取最大，则分子要最大，分子要最小，由于最多有$10^5$条边，每条边的权值最大是$1000$，所以$\sum w_i$最大是$1000\times 10^5$。由于最多有$10^5$条边，所以至少有$10^5$个节点，所以$\sum 1$最小为$10^5$，于是$\dfrac {\sum w_i}{\sum 1}=\dfrac {1000\times 10^5}{10^5}$最大为$1000$。因此答案区间就是$(0,1000]$。</p>
<p>题目说了不一定存在环串，那么我们该怎么知道呢？从$w_i-mid\times1$可知，这是一个递减的线性函数，当$mid$取0时，有最大值，因此我们可以先尝试$mid=0$，如果$w_i-mid\times 1\leq 0$，那么$\sum w_i-mid\times 1\leq0$，因此对于剩下的所有节点，必定是$\sum w_i-mid\times 1\leq0$，但是这个式子显然与$\sum (w_i-mid\times 1)&gt;0$这个存在正环的式子不矛盾。因此，只要带入$mid=0$，验证一下看看这个式子$\sum (w_i-mid*1)$是否满足正环，如果不满足，那么全部都不满足，输出无解，否则说明可以求解。</p>
<p>一般来说，如果题目要求保留$k$位小数，那么我们一般把精度多控制两位，即精度位$eps=1e^{-(k+2)}$</p>
<blockquote>
<p>问题：如何理解一下代码呢？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> left=(s[<span class="number">0</span>]-<span class="string">&#x27;a&#x27;</span>)*<span class="number">26</span>+(s[<span class="number">1</span>]-<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">int</span> right=(s[len<span class="number">-2</span>]-<span class="string">&#x27;a&#x27;</span>)*<span class="number">26</span>+s[len<span class="number">-1</span>]-<span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>我们这里是以字符串的前面两个字符和后面两个字符来作为节点，那么这个节点该怎么编号呢？其实我们可以利用字符串hash的思想，把这两个字符hash成对应的一个整数值。比如字符串$ababc$前面的两个字符$ab$其实就是$(‘a’-‘a’)\times 26^1+(‘b’-‘a’)\times 26^0=1$，所以字符$ab$这个节点的编号就是1；比如字符$ababc$后面的两个字符$bc$其实就是$(‘b’-‘a’)\times 26^1+(‘c’-‘a’)\times 26^0=28$，所以字符$bc$这个节点的编号就是28</p>
</blockquote>
<p>这里还有一个spfa判环的玄学优化（不太常用）：</p>
<p>当图中所有顶点的更新次数（入队次数)<code>count</code>大于图中顶点的个数的2倍时，则认为存在环。如果2倍不行，那就长度3倍、4倍…  这玩意很玄学</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">700</span>, M = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps=<span class="number">1e-4</span>;  <span class="comment">//控制精度</span></span><br><span class="line"><span class="keyword">int</span> h[N], e[M], w[M], ne[M], idx;</span><br><span class="line"><span class="keyword">double</span> dist[N];</span><br><span class="line"><span class="keyword">int</span> q[N], cnt[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="comment">//建图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    w[idx] = c;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//spfa判正环</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">double</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">-0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> cnt);</span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//图中最多有676个顶点,一开始就把原图中的所有顶点都放入队列q中</span></span><br><span class="line">    <span class="comment">//就等效于建立了一个虚拟源点和其他676个节点的新图</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">676</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        q[tt ++ ] = i;</span><br><span class="line">        <span class="comment">//初始化该虚拟源点到其他676个节点的权值为0</span></span><br><span class="line">        dist[i]=<span class="number">0</span>;</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;  <span class="comment">//统计图中所有节点的更新次数即所有节点的入队次数</span></span><br><span class="line">    <span class="keyword">while</span> (hh != tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = q[hh ++ ];</span><br><span class="line">        <span class="keyword">if</span> (hh == N) </span><br><span class="line">        hh = <span class="number">0</span>;</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &lt; dist[t] + w[i] - mid)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i] - mid;</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">                count++;    <span class="comment">//更新次数+1  即入队次数+1</span></span><br><span class="line">                <span class="comment">//一般经验上来说是count &gt;2N 但是这里点数少,边数实在太多了 </span></span><br><span class="line">                <span class="comment">//那么就3N,4N...一直尝试吧</span></span><br><span class="line">                <span class="keyword">if</span> (count&gt; <span class="number">10</span>*N) </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 经验上的trick</span></span><br><span class="line">                <span class="comment">//说明存在正环</span></span><br><span class="line">                <span class="keyword">if</span> (cnt[j] &gt;= N) </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q[tt ++ ] = j;</span><br><span class="line">                    <span class="keyword">if</span> (tt == N) tt = <span class="number">0</span>;</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//说明不存在正环</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">1010</span>]; <span class="comment">//字符串</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T), T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//初始化表头</span></span><br><span class="line">        <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//T个字符串</span></span><br><span class="line">        <span class="keyword">while</span>(T--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">            <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">            <span class="keyword">if</span> (len &gt;= <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//该字符串的前面两个字符  hash 成一个整数值 作为 一个节点的编号</span></span><br><span class="line">                <span class="keyword">int</span> left = (str[<span class="number">0</span>] - <span class="string">&#x27;a&#x27;</span>) * <span class="number">26</span> + str[<span class="number">1</span>] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="comment">//该字符串的后面两个字符  hash 成一个整数值 作为 一个节点的编号</span></span><br><span class="line">                <span class="keyword">int</span> right = (str[len - <span class="number">2</span>] - <span class="string">&#x27;a&#x27;</span>) * <span class="number">26</span> + str[len - <span class="number">1</span>] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="comment">//从left节点想right节点连一条长度为len的有向边</span></span><br><span class="line">                <span class="built_in">add</span>(left, right, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果把0带进去计算都不能得到正环的话,那么1,2,...,1000就不可能得到正环</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">check</span>(<span class="number">0</span>)) </span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;No solution&quot;</span>);</span><br><span class="line">        <span class="comment">//说明还是可以得到正环的</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">double</span> l = <span class="number">0</span>, r = <span class="number">1000</span>;</span><br><span class="line">            <span class="comment">//二分答案</span></span><br><span class="line">            <span class="keyword">while</span> (l+eps&lt;r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">                <span class="comment">//由于答案是单调递增的 </span></span><br><span class="line">                <span class="comment">//所以当满足性质时  往右侧收缩 寻找答案</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) </span><br><span class="line">                l = mid;</span><br><span class="line">                <span class="comment">//否则不满足性质  往左侧收缩 寻找答案</span></span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//输出最终的答案</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>负环</category>
      </categories>
      <tags>
        <tag>负环</tag>
      </tags>
  </entry>
  <entry>
    <title>虫洞</title>
    <url>/2021/07/11/Algorithm-Improvement/Chapter3---Gragh-Theory/Negative-Circle/%E8%99%AB%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="虫洞"><a href="#虫洞" class="headerlink" title="虫洞"></a>虫洞</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210711231829.png" alt="image-20210711231829264"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>这题主要是要读懂题目，刚开始读不懂，后来再理解这题其实就是一个裸的求负环。</p>
<p>虫洞它是单向边，路径是双向边，因此建图时，图中就会既有单项边，又有双向边。”通过虫洞，它可以回到过去的某个时刻“这句话的意思其实就是说明虫洞的单向边是负值</p>
<p>读懂题目的意思后，用spfa求负环就好了</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//边数=路径的双向边2500*2+虫洞的单向边200=5200</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">510</span>,M=<span class="number">5210</span>;</span><br><span class="line"><span class="comment">//n表示田地的数量  m1表示路径的数量  m2表示虫洞单向边的数量</span></span><br><span class="line"><span class="keyword">int</span> n,m1,m2;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],w[M],idx;</span><br><span class="line"><span class="keyword">int</span> q[N],cnt[N],dist[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="comment">//建图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    w[idx]=c;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//spfa求负环</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//有多组测试数据 要初始化</span></span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);  <span class="comment">//求负环时  对于dist数组没有任何要求,不用初始化都可以</span></span><br><span class="line">    <span class="built_in">memset</span>(st,<span class="number">0</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span> cnt);</span><br><span class="line">    <span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//在新图中添加一个虚拟源点就等效于 一开始将原图中的所有节点都加入循环队列q中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        q[tt++]=i;</span><br><span class="line">        <span class="comment">//这里从初始化为0 其实含义就是：在新图中,虚拟源点到其他n个节点连一条长度为0的边</span></span><br><span class="line">        dist[i]=<span class="number">0</span>;</span><br><span class="line">        st[i]=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(hh!=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=q[hh++];</span><br><span class="line">        <span class="keyword">if</span>(hh==N)</span><br><span class="line">        hh=<span class="number">0</span>;</span><br><span class="line">        st[t]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j]&gt;dist[t]+w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j]=dist[t]+w[i];</span><br><span class="line">                cnt[j]=cnt[t]+<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//存在负环  那么他可以回到过去</span></span><br><span class="line">                <span class="keyword">if</span>(cnt[j]&gt;=n) </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q[tt++]=j;</span><br><span class="line">                    <span class="keyword">if</span>(tt==N)</span><br><span class="line">                    tt=<span class="number">0</span>;</span><br><span class="line">                    st[j]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//说明不存在负环  那么他不可用回到过去</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">        idx=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m1,&amp;m2);</span><br><span class="line">        <span class="comment">//给路径的双向边建图</span></span><br><span class="line">        <span class="keyword">while</span>(m1--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a,b,c;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">            <span class="built_in">add</span>(a,b,c);</span><br><span class="line">            <span class="built_in">add</span>(b,a,c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//给虫洞的单向边建图</span></span><br><span class="line">        <span class="keyword">while</span>(m2--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a,b,c;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">            <span class="comment">//注意边的权值是-c</span></span><br><span class="line">            <span class="built_in">add</span>(a,b,-c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//存在负环 则可以回到过去</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">spfa</span>())</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">        <span class="comment">//不存在负环 则不可以回到过去</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>负环</category>
      </categories>
      <tags>
        <tag>负环</tag>
      </tags>
  </entry>
  <entry>
    <title>二分图最大匹配的应用</title>
    <url>/2021/07/14/Algorithm-Improvement/Chapter3---Gragh-Theory/%E4%BA%8C%E5%88%86%E5%9B%BE/%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h1 id="二分图最大匹配的应用"><a href="#二分图最大匹配的应用" class="headerlink" title="二分图最大匹配的应用"></a>二分图最大匹配的应用</h1><hr>
<p>对于二分图最大匹配来说，更重要的是对一些实质问题的转化，比如通过求解二分图最大匹配，我们可以得到一个二分图的最小顶点覆盖，最小边覆盖，最大独立集、最大完全子图、最小路径覆盖 等等。</p>
<p><strong>引理：</strong></p>
<p>在二分图最大匹配中，每条匹配边连接的两个顶点$(u,v)$最多只有一个与非匹配点有连边。</p>
<p><strong>证明：</strong></p>
<p>假设存在一条匹配边连接的两个顶点$(u,v)$，分别存在非匹配边$(u,x)$和$(v,y)$，且$x$和$y$都是匹配点，可以让$(u,v)$断开，从而成为失配边，那么 $(u,x)$和$(v,y)$变成匹配边。因此此时匹配数目相对之前增加了1个，这与最大匹配矛盾。故得证</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210714082435.png" alt="image-20210714082435281"></p>
<p>假设我们已经找到了二分图最大匹配，并且$(1,6)$是匹配边，$(1,8)$和$(3,6)$是非匹配边，其中$3$和$8$是非匹配点，那么可以将$(1,8)$和$(6,3)$变成匹配边，$(1,6)$变成非匹配边，那么就会使得匹配数量+1，因此这与最大匹配矛盾了。</p>
<hr>
<h3 id="最小顶点覆盖"><a href="#最小顶点覆盖" class="headerlink" title="最小顶点覆盖"></a>最小顶点覆盖</h3><p><code>点覆盖</code>的含义：一个点集合$S\subseteq V$，使得每一条边中至少有一个端点是在点集合$S$中</p>
<p><code>最小顶点覆盖</code>的含义：选择最少的点来覆盖所有的边</p>
<p>如下图，最小顶点覆盖是$(2,4,6)$三个点组成的点集。因为顶点2覆盖的边有$(2,5)$和$(2,8)$，顶点4覆盖的边有$(4,7)$和$(4,6)$，顶点6覆盖的边有$(1,6)$和$(3,6)$，可以发现这个顶点集合就已经完全覆盖了图中所有的边，而且它也已经是最小点集了。</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210714084437.png" alt="image-20210714084437304"></p>
<p><strong>结论：二分图最小顶点覆盖 = 二分图最大匹配</strong></p>
<p>要想证明$=$，那么可以先证明$\geq$，然后再证明$\leq$，由夹逼定理可知，就可以证明出$=$了</p>
<p>证明如下：</p>
<p>对于二分图$G$，设匹配图为$M$，最大匹配数为$m$：</p>
<ul>
<li>先来证明二分图的最小顶点覆盖$\geq $二分图的最大匹配。我们可以构造一个点集，这个点集是从最大匹配$M$里面取出来的，对于每一条匹配边，选择那个与非匹配点有连边的点（根据引理，这个点最多只有一个）加入点集$S$；如果不存在非匹配点，也就是说这个二分图其实就是最大匹配，即$M$就是$G$，那么匹配边的两侧端点都是匹配点，因此我们只需要从这一条匹配边中随便选择一个点即可，那么有$m$条匹配边，因此就需要选择$m$个点来覆盖。如上图所示：三条匹配边$(1,6)、(2,5)、(4,7)$，点集$S$构造的时候，$(1,6)$这条边选择$6$这个顶点，$(2,5)$这条边选择$2$这个点，$(4,7)$这条边选择$4$这个点。因此这种对于存在非匹配点的二分图来说，对于这$m$条匹配边，就需要$m$个点来覆盖，还存在非匹配边，那么可能还需要用一些点来覆盖这些匹配边，因此最小顶点集$S$肯定是$\geq m$的，即<strong>二分图的最小顶点覆盖$\geq $二分图的最大匹配</strong>。</li>
<li>再来证明二分图的最小顶点覆盖$\leq $二分图的最大匹配。如果$G$中的边除了$M$中匹配边以外没有其它非匹配边，那么最小顶点覆盖就是$m$。否则，还存在非匹配边，如果这条非匹配边的两个端点都在非匹配点上，那么可以构成一条新的匹配边，从而和最大匹配矛盾；所以这些非匹配边一定是其中一个端点在匹配点上，另一个端点在非匹配点上；令一条非匹配边上的一个端点为$u$，且$u$在非匹配点上，那么如果存在一条边$(u,v)$，点$v$必定是在我们构造出来的点集 $S$中的，于是边$(u,v)$一定可以被这个点集覆盖。所以<strong>二分图的最小顶点覆盖$\leq$二分图的最大匹配</strong>。</li>
</ul>
<p>简单理解为：</p>
<ul>
<li>$m$个点是必须的，即二分图的最小顶点覆盖$\geq $二分图的最大匹配。匹配的这$m$条边，它们的端点各不相同，因此要覆盖这$m$条匹配边，就需至少需要$m$个点。</li>
<li>$m$个点是足够的，即二分图的最小顶点覆盖$\leq $二分图的最大匹配。假设最小顶点覆盖为$n$，那么一定可以构造出$n$条匹配边，又由于我们已经知道了二分图的最大匹配是$m$，也就是说最大匹配边是$m$，因此必定有$n\leq m$。即假设覆盖完这$m$条匹配边后，如果还有某条边$e$还没有被覆盖，那么把$e$加入后会使得匹配数量+1，那么就会大于给定的最大匹配数目$m$，这与二分图最大匹配矛盾。</li>
</ul>
<hr>
<h3 id="最小边覆盖"><a href="#最小边覆盖" class="headerlink" title="最小边覆盖"></a>最小边覆盖</h3><p><code>边覆盖</code>的含义：选一条边就相当于覆盖了它的两个端点。</p>
<p><code>最小边覆盖</code>的含义：选择最少的边集，覆盖所有的点集</p>
<p>如下图所示，最小边覆盖为$E=${$(2,9),(3,8),(5,10),(4,9),(3,11)$}，答案是5。注意：<strong>孤立节点不需要用边来覆盖！</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210714093506.png" alt="image-20210714093506209"></p>
<p><strong>结论：二分图的最小边覆盖 = 顶点总数 - 孤立点数 - 二分图最大匹配</strong></p>
<p>证明：</p>
<p>为了使边数最少，又因为一条边最多能干掉两个点，所以尽量用边干掉两个点。也就是选择有匹配的那些边，因为它们一次能干掉两个节点，而且我们希望有匹配的边越多越好，那么就是最大匹配了，因为最大匹配才会有最多的匹配边。我们设左侧节点数目为$L$，右侧节点数目为$R$，孤立节点数目为$A$，设二分图最大匹配数目为$M$，节点总数就是$V=L+R$。由于孤立节点不需要边覆盖，因此需要考虑的点有$V-A$。</p>
<p>我们先用最大匹配边去干掉两侧的节点，那么就可以干掉$2\times M$个节点，剩下的就是要解决那些没有被匹配的点，那么这些没有被匹配的点的数目为$(V-A)-2\times M$，那么这些没有被匹配的点就需要用边去覆盖，因此还需要$(V-A)-2\times M$条边。因此总的需要最少的边数=$M+(V-A-2\times M)=V-A-M$，即二分图的最小边覆盖=顶点总数-孤立点数-二分图最大匹配。</p>
<p>如上图所示，绿色边表示匹配边，黑色边表示非匹配边。那么匹配边有3条，干掉了$2,3,5,8,9,10$节点，那么还剩下$4,11$没有被干掉，覆盖这两个点还需要2条边，因此最小边覆盖为$3+2=5$，这正好就是$12-4-3=5$</p>
<hr>
<h3 id="最大独立集"><a href="#最大独立集" class="headerlink" title="最大独立集"></a>最大独立集</h3><p><code>最大独立集合含义</code>：选取最多的点，使得图中任意两点都没有关系</p>
<p>如下图所示，最大独立集合为$A=${$1,3,5,7,8$}</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210714095317.png" alt="image-20210714095317247"></p>
<p><strong>结论：二分图的最大独立集 = 顶点总数 - 最小顶点覆盖</strong></p>
<p>证明：</p>
<p>首先，由最小顶点覆盖的含义可知，它已经覆盖了图中的所有边，因此我们把最小顶点集$S$中的顶点都从图中去掉，那么所有的边也就消失了，那么还剩下$V-S$个顶点，这些节点两两之间都不相邻了（因为没有边相连，不存在关联），那么这些剩余的节点就构成了一个独立集（为$A=V-S)$。由这个式子可以知道，因为$V$是定值，要想$A$最大，那么需要$S$最小。又由于最小顶点覆盖已经是最少的能够覆盖图中所有边的点集了，不能再少了，因此当取到最小顶点覆盖时，$S$达到最小，那么剩下的节点就是最大的。因此二分图的最大独立集 = 顶点总数 - 最小顶点覆盖</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210714101105.png" alt="image-20210714101105273"></p>
<hr>
<h3 id="最大完全子图（最大团）"><a href="#最大完全子图（最大团）" class="headerlink" title="最大完全子图（最大团）"></a>最大完全子图（最大团）</h3><p><code>完全图</code>的含义：任意两点都恰有一条边相连的图(任意两点都相邻)</p>
<p><code>完全子图</code>的含义：满足任意两点都恰有一条边相连的<strong>子图</strong>，也叫<strong>团</strong></p>
<p><code>最大完全子图</code>的含义：所有完全子图中<strong>顶点数最大的团</strong>，即<strong>最大团</strong>。最大指的是点数最多。即选取最多的点，使得图中任意两点都有关系</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210714102723.png" alt="image-20210714102723336"></p>
<p>图中{$a,b,d$}，${a,e}$，${c,f,g}$等都是完全子图，但是最大完全子图是${a,b,d,e}$</p>
<p><code>补图</code>的含义：一个$n$阶完全图中去掉原图$G$上的所有边，剩下的所有边所构成的一个图就是该图$G$的补图$G’$</p>
<p>如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210714104214.png" alt="image-20210714104214360"></p>
<p><strong>结论：二分图的最大团 = 补图的最大独立集</strong></p>
<p>证明：</p>
<p>对比最大团的含义和最大独立集的含义，我们知道它俩是相反的，那么我们就可以知道其实二分图的最大独立集的相反就是二分图的最大团。那么我们该怎么表达最大独立集的相反呢？这里就需要用到补图了。设原图为$G$，那么原图的相反其实就是原图的补图$G’$。因此我们想要求出原图$G$的最大团，那么就是要求出补图$G’$的最大独立集。</p>
<p>求最大完全子图的问题，如果不是二分图，这将是一个 NP 问题，但如果是个二分图，我们可以用上面的方法求解</p>
<hr>
<h3 id="有向无环图的最小路径覆盖"><a href="#有向无环图的最小路径覆盖" class="headerlink" title="有向无环图的最小路径覆盖"></a>有向无环图的最小路径覆盖</h3><h4 id="不相交的情况"><a href="#不相交的情况" class="headerlink" title="不相交的情况"></a>不相交的情况</h4><p>定义：选择一些路径，覆盖所有的点集，且各路径的点集之间不允许有交集，要求路径数最少。</p>
<p>如下图所示，得到的路径是：$(1\to2\to4\to5)$，$(6\to7)$，$(3)$。最小（不相交）路径覆盖为3</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210714105315.png" alt="image-20210714105315325"></p>
<p><strong>结论：有向无环图的最小(不相交)路径覆盖 = 原图结点数 - 拆点后二分图最大匹配数</strong></p>
<p>证明：</p>
<ul>
<li><p>初始状态，所有顶点都是一条路径，那么总共有$n$条路径</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210714111347.png" alt="image-20210714111347242"></p>
</li>
<li><p>每当增加一对匹配时，对应到原图中就是用一条边连接了两个节点，并且这两个结点一定不在同一个连通块（下文会证明），那么总的连通块数目减一（比如连接节点1和节点2，那么此时它俩处于同一个连通块，但它俩原来都是独立的连通块），也就是路径数目减一（二分图里找一条匹配边就相当于把两条路径合成了一条路径）；所以找到了几条匹配边，路径数就减少了多少。那么要想使得路径数最少，那么应该有更多的匹配边，因此想到应该是二分图的最大匹配。所以有最小路径覆盖=原图的结点数-拆点后新图的最大匹配数。</p>
</li>
<li><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210714111920.png" alt="image-20210714111920874"></p>
</li>
</ul>
<p>证明：每增加一条匹配边，在原图中的两个点必然不在一个连通块内</p>
<ul>
<li><p>每增加一对匹配边：$u_l\to v_r$，对应原图中就是增加了一条$u\to v$的边，反证法：假设$u$和$v$在同一个连通块内，那么会有如下的四种情况（橙色边为原本的连接情况，红色边为当前增加匹配后增加的新边）：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210714112425.png" alt="image-20210714112425763"></p>
</li>
<li><p>(a)如上图，对于节点$u$来说，它有两条出边，对于节点$v$来说，它有两条入边，但是对于二分图匹配来说，两个节点之间应该是只有一条出边和一条入边，因此这与 二分图匹配的 定义矛盾，因此，这种情况是不合法的</p>
</li>
<li><p>(b)如上图，节点$u,v$产生了圈，形成了环，这与 二分图匹配的 定义矛盾，因此，这种情况是不合法的</p>
</li>
<li><p>(c)如上图，对于节点$u$来说，它有两条出边，分别连向两点不同的节点，这对应到二分图和两个点进行了匹配，但在二分图匹配中，是一夫一妻制，而不能一夫多妻，因此这与 二分图匹配的 定义矛盾，因此，这种情况是不合法的</p>
</li>
<li><p>(d)如上图，对于节点$v$来说，它有两条入边，分别有两个不同的节点指向它，这对应到二分图和两个点进行了匹配，但在二分图匹配中，是一妻一夫制，而不是一妻多夫，因此这与 二分图匹配的 定义矛盾，因此，这种情况是不合法的</p>
</li>
<li><p>基于以上四种情况都不合法，所以每增加一条匹配边，在原图中的两个点必然不在一个连通块内，得证</p>
</li>
</ul>
<p>举个栗子：</p>
<p>首先将每个节点$u$拆成两个节点$u_l$和$u_r$，如果原图存在边$u\to v$，则在拆点后的图上建立边：$u_l\to v_r$。由于原图是有向无环图，所以拆点后的图是一个二分图。如图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210714141226.png" alt="image-20210714141226353"></p>
<p>对拆点后的图求一次二分图最大匹配，得到：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210714141427.png" alt="image-20210714141427393"></p>
<p>那么有向无环图的最小(不相交)路径覆盖 = 原图结点数 -  拆点后二分图最大匹配数=$7-4=3$</p>
<h4 id="相交的情况"><a href="#相交的情况" class="headerlink" title="相交的情况"></a>相交的情况</h4><p>定义：选择一些路径，覆盖所有的点集，且各路径的点集之间允许有交集，要求路径数最少。</p>
<p>举个栗子：</p>
<p>如下图所示，得到的路径为：$(1\to 2\to 4\to 5)$，$(3\to 4\to 6\to 7)$，最小（相交）路径覆盖为2</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210714142307.png" alt="image-20210714142307071"></p>
<p><strong>结论：首先对原图求一次传递闭包得到一个新图，有向无环图的最小(相交)路径覆盖 = 新图结点数 - 拆点后二分图最大匹配数</strong>。</p>
<p>证明：</p>
<p>因为路径之间是允许相交的，所以对于 2 条路径$x\to p\to y$和$a\to p\to b$，那么多建立两条边$(x\to y)$和$(a\to b)$，那么我们发现$x\to y$其实是 $x\to p$，$p\to y$求传递闭包得到的，同理分析$a\to b$也是求传递闭包得到的。对图中所有的这样的边都这样操作一次，相当于求了一个传递闭包。然后再求拆点二分图的最大匹配，就可以当成求最小不相交路径覆盖的情况来求解了。</p>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>二分图最小顶点覆盖 = 二分图最大匹配</li>
<li>二分图的最小边覆盖 = 顶点总数 - 孤立点数 - 二分图最大匹配</li>
<li>二分图的最大独立集 = 顶点总数 - 最小顶点覆盖</li>
<li>有向无环图的最小(不相交)路径覆盖 = 原图结点数 - 拆点后二分图最大匹配数</li>
<li>首先对原图求一次传递闭包得到一个新图，有向无环图的最小(相交)路径覆盖 = 新图结点数 - 拆点后二分图最大匹配数</li>
</ol>
<hr>
]]></content>
      <categories>
        <category>二分图</category>
      </categories>
      <tags>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title>观光奶牛</title>
    <url>/2021/07/12/Algorithm-Improvement/Chapter3---Gragh-Theory/Negative-Circle/%E8%A7%82%E5%85%89%E5%A5%B6%E7%89%9B/</url>
    <content><![CDATA[<h1 id="观光奶牛"><a href="#观光奶牛" class="headerlink" title="观光奶牛"></a>观光奶牛</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210712160410.png" alt="image-20210712160410274"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>一般来说，求 点权之和/边权之和 的最值问题，都属于01分数规划问题。</p>
<p>图论的01分数规划问题的步骤：</p>
<ul>
<li>确认答案区间，然后用二分算法，判断性质</li>
<li>借助二分出来的中点，推导出性质的公式</li>
<li>套用图论模板</li>
</ul>
<p>本题要求我们求一个环内$\dfrac {\sum f_i}{\sum t_i}$的最大值，而这个答案本身就是具有单调性，因此可以用二分算法，来二分出最终的答案。</p>
<p>首先来确定答案的区间：</p>
<p>我们设$c =\dfrac {\sum f_i}{\sum t_i}$</p>
<ul>
<li>要想求出区间的左范围，那么分子应该最小，分母应该最大，那么分子应该取一个点，该点的点权为1；分母应该取5000条边，边权为1000，那么此时$c=\dfrac {1\times1}{5000\times1000}$，很难明显，这个$c$不为0，肯定是大于0的，注意这里不能理解为C++中的整除会向下取整，这里应该理解为浮点数的除法，因为题目说了要保留两位小数。因此，我们确定了左范围是大于0的</li>
<li>要想求出区间的右范围，那么分子应该最大，分母应该最小，那么分子应该取1000个点，每个点的点权都为1000；由于有了1000个点，那么对于环来说，至少得是1000条边（注意不可能说有1000个点，然后取1条边，这样不能形成环），这1000条边的权值都为1，那么此时$c=\dfrac {1000\times1000}{1000\times1}=1000$。因此，我们确定了右范围是1000</li>
<li>所以，答案区间就是<code>(0,1000]</code></li>
</ul>
<p>由于我们发现答案区间是单调递增的，也就是说具有单调性，那么就可以用二分算法，来快速地求出$c$。我们设$L=0,R=1000$，假设某个时刻，我们设中点为$mid$，那么：</p>
<p>$\dfrac {\sum f_i}{\sum t_i}&gt;mid$</p>
<p>$\iff$ $\sum f_i&gt;mid*\sum t_i$</p>
<p>$\iff$ $\sum f_i-mid*\sum t_i&gt;0$</p>
<p>$\iff$ $\sum (f_i-mid*t_i)&gt;0$</p>
<p>根据上述推导的公式可知，对于满足要求的$mid$，就是要满足图中存在一个<code>环</code>，它的$\sum (f_i-mid*t_i)&gt;0$ ，要求一个环，它的权值之和大于0，这不就是想让我们求正环嘛？</p>
<p>因此，原问题就转换为 求图中是否存在一个正环 的问题了</p>
<p>我们每次二分出一个$mid$，然后$check(mid)$，如果它满足上面的这个式子，那么由于答案是单调递增的，我们想要求出最大的$mid$，因此此时左范围$L$应该往右侧收缩，即$L=mid$，不可能让右范围往左收缩吧，即不可能是$R=mid$（如果这样的话，那么更新过后的区间的最大值不就小于$mid$了嘛，这就不可能找到最大值了）。因此一旦二分出的$mid$满足上述式子，那么就往右侧收缩$L=mid$，这样会更快地逼近最大值；如果二分出的这个$mid$不满足上述式子，则说明答案肯定比当前二分的$mid$还小，那么就要往左侧收缩$R=mid$，因为右边已经不可能了。</p>
<p>浮点数的二分比较简单，就是执行$L=mid$或者$R=mid$。</p>
<p>这里还有个问题，就是我们该怎么处理点权和边权呢？我们以前都只是见过有边权的情况。其实，我们可以把节点的点权放到它的出边上，那么此时就只有边权的情况了，不存在点权。为什么可以这么做呢？</p>
<ul>
<li>假设同时存在点权和边权，那么所有点权之和为$\sum f_i$，所有边权之和为$\sum t_i$，因此，总的权值之和为$\sum f_i+\sum t_i$</li>
<li>假设把点权放到出边上，此时只有边权，那么某个出边的权值为$f_i+t_i$，因此，总的权值之和为$\sum (f_i+t_i)$</li>
<li>由于$\sum$是可以分开的，因此$\sum(f_i+t_i)=\sum f_i+\sum t_i$</li>
</ul>
<p>有了上面的处理之和，我们建图就会更加方便了，只需要处理边权就好了。</p>
<p>我们来看这个式子 $\sum(f_i-mid\times t_i)$，那么其实就是$\sum (f_i+(-mid\times t_i))&gt;0=\sum f_i+\sum-mid\times t_i$，也就是说把原来的边权$t_i$换成了$f_i-mid\times t_i$来存储了，把每个点的权值都放入它的出边中。</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>,M=<span class="number">5010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="comment">//点权</span></span><br><span class="line"><span class="keyword">int</span> wf[N];</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],wt[M],idx;  <span class="comment">//wt是边权</span></span><br><span class="line"><span class="keyword">int</span> q[N],cnt[N];</span><br><span class="line"><span class="keyword">double</span> dist[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    wt[idx]=c;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//spfa判断正环</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">double</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">-0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">memset</span>(st,<span class="number">0</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span> cnt);</span><br><span class="line">    <span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//一开始将原图中所有点加入队列q中就  等效于建立了一个带有虚拟源点的新图 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        q[tt++]=i;</span><br><span class="line">        dist[i]=<span class="number">0</span>;</span><br><span class="line">        st[i]=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(hh!=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=q[hh++];</span><br><span class="line">        <span class="keyword">if</span>(hh==N)</span><br><span class="line">        hh=<span class="number">0</span>;</span><br><span class="line">        st[t]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];</span><br><span class="line">            <span class="comment">//wf[t]-mid*wt[i]是将点权放到了边上</span></span><br><span class="line">            <span class="keyword">if</span>(dist[j]&lt;dist[t]+wf[t]-mid*wt[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j]=dist[t]+wf[t]-mid*wt[i];</span><br><span class="line">                cnt[j]=cnt[t]+<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//说明存在正环</span></span><br><span class="line">                <span class="keyword">if</span>(cnt[j]&gt;=n)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q[tt++]=j;</span><br><span class="line">                    <span class="keyword">if</span>(tt==N)</span><br><span class="line">                    tt=<span class="number">0</span>;</span><br><span class="line">                    st[j]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//说明不存在正环</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;wf[i]);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a,b,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> l=<span class="number">0</span>,r=<span class="number">1e4</span>;</span><br><span class="line">    <span class="comment">//二分找到答案</span></span><br><span class="line">    <span class="keyword">while</span>(l+<span class="number">1e-4</span>&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//满足条件 则向右侧收缩</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid))</span><br><span class="line">        l=mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        r=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>,l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>负环</category>
      </categories>
      <tags>
        <tag>负环</tag>
      </tags>
  </entry>
  <entry>
    <title>二分图的最大匹配</title>
    <url>/2021/07/13/Algorithm-Improvement/Chapter3---Gragh-Theory/%E4%BA%8C%E5%88%86%E5%9B%BE/%E4%BA%8C%E5%88%86%E5%9B%BE%E7%9A%84%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h1 id="二分图的最大匹配"><a href="#二分图的最大匹配" class="headerlink" title="二分图的最大匹配"></a>二分图的最大匹配</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210713135825.png" alt="image-20210713135825492"></p>
<hr>
<h3 id="二分图的最大匹配-1"><a href="#二分图的最大匹配-1" class="headerlink" title="二分图的最大匹配"></a>二分图的最大匹配</h3><p>从题目中给出的二分图匹配的定义可知，匹配其实也是一张图，并且图中的点数是边数的2倍。</p>
<p>如下图所示：二分图的匹配</p>
<p>红色边组成的 4 个结点、2条边就是这个二分图的一个匹配了；</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210713140235.png" alt="image-20210713140235437"></p>
<p><strong>二分图最大匹配定义</strong>：最大匹配就是找到一个子图，满足是匹配，并且边数（点数）最多。</p>
<p>如下图所示：二分图的最大匹配</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210713140350.png" alt="image-20210713140350842"></p>
<hr>
<h3 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h3><p>匈牙利算法可以用来求解二分图的最大匹配问题。匈牙利算法也被戏称为“相亲算法”，它的大致过程是这样的：</p>
<ul>
<li><p>有两个点集，分别是男生和女生，$X$点集中全部都是男生，$Y$点集中全部都是女生</p>
</li>
<li><p>然后男生取追求女生，如果男生$X_a$对女生$Y_b$有好感，并且女生$Y_b$也有男生$X_a$有好感，那么男生$X_a$就有很大机会可以追到女生$Y_b$，否则如果女生$Y_b$不喜欢男生$X_a$，那么男生$X_a$就不会再追求女生$Y_b$，而是继续去寻找其他女生  （不想当<del>舔狗</del>)</p>
</li>
<li><p>作为一个男人，要主动出击。因此约定都是男生追女生，即开始先从点集$X$出发</p>
</li>
<li><p>每个男生可以选遍所有他喜欢的女生：如果某位女生还是单身并且没有其他男生追求她，那么 女人 拿来吧你，恭喜你，直接配对；如果特别喜欢的这个女生已经有男朋友了，则这个女生会让她男朋友再去找其他女生（爱情就是这么<del>不堪一击</del>)，又转化成了另一个男生去寻找女生的过程，继续递归找；</p>
</li>
<li><p>那么最终的结果就有两种情况：</p>
<ul>
<li><p>由于这个男生的插足，导致最后可能有一个男生被抛弃，这是不道德的行为，所以不能干这种事情！（如下图，结局好惨）</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210713142754.png" alt="image-20210713142754572"></p>
</li>
<li><p>由于这个男人的插足，导致所有的男女关系都进行了一次轮换，但是匹配的对数多了一对；（成功<del>横刀夺爱</del>）</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210713143031.png" alt="image-20210713143030993"></p>
</li>
</ul>
</li>
</ul>
<p>以上就是匈牙利算法的相亲过程，算法很简单也很有趣，教会了<del>恋爱丛林法则</del></p>
<hr>
<h3 id="匈牙利算法实现"><a href="#匈牙利算法实现" class="headerlink" title="匈牙利算法实现"></a>匈牙利算法实现</h3><p>先来给出以下变量的定义：</p>
<ul>
<li><code>st[j]</code>这个是个bool类型数组，用来表示某个女生有没有被男生访问联系过，如果$st[j]=true$，表示$j$这个女生已经某个男生联系过了</li>
<li><code>match[j]</code>是个int类型的数组，用来表示$j$这个女生她现任男友的编号，如果$match[j]=a$，表示$j$这个女生她现任男友的编号为$a$</li>
</ul>
<p>算法流程：</p>
<ul>
<li>将男生和女生分成点集$X$和$Y$</li>
<li>由于是男生掌握主动权，所以只需要建立有向图，从男生节点向女生节点引出有向边即可</li>
<li>从男生点集$X$出发，假设某个男生$u$，遍历$u$这个节点所有的邻接点$v$（即他喜欢的所有女生）<ul>
<li>如果这个女生$v$处于单身状态，$v$还没有匹配，那么此时$(u,v)$就是一组成功的匹配（在一起了），所以匹配的数量+1</li>
<li>如果这个女生$v$虽然有男朋友了，但是她可能对这个男生$u$有点意思，所以让她现任男友$c$去寻找其他女生，假设男生$c$是个<del>海王</del>（本来就是），他确实有很多青青草原，然后他找到了后宫中的女生$d$，最终女生$d$答应了他，于是他俩就在一起了，那么此时女生$v$就处于单身状态，于是男生$u$就成功和她在一起了，可以发现此时又成功匹配了一对情侣，所以匹配数目+1；但是如果后宫中的女生$d$知道男生$c$是海王，拒绝了他，那么男生$c$和她女友$v$说 我还是只爱你一人，因此他俩还是继续在一起，那么很可惜男生$u$还是<del>单身狗</del>。因此这次$u$的匹配失败。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>, M = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n1, n2, m;<span class="comment">//n1表示左侧男生的个数  n2表示右侧女生的个数</span></span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="comment">//match[j]=a,表示女孩j的现有配对男友是a</span></span><br><span class="line"><span class="keyword">int</span> match[N];<span class="comment">//右边女生所对应的左边男孩,即女生现在和哪个男生的在一起</span></span><br><span class="line"><span class="keyword">bool</span> st[N];<span class="comment">//临时预定数组，st[j]=a表示一轮模拟匹配中，女孩j被男孩a预定了。 避免重复搜索女孩</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断x这个男生能不能找到匹配的女生</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//依次遍历自己喜欢的女孩</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];<span class="comment">//获取女孩在图中的顶点的编号</span></span><br><span class="line">        <span class="comment">//如果j这个女孩之前还没有被考虑过，在这一轮模拟匹配中,这个女孩尚未被预定</span></span><br><span class="line">        <span class="keyword">if</span> (!st[j])<span class="comment">//j这个女孩还没有被男生x访问过</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//标记j这个女孩被男生x访问过了</span></span><br><span class="line">            st[j] = <span class="literal">true</span>;<span class="comment">//表示j这个女孩已经被x男孩看上了，被考虑过啦，x男孩已经预定了j这个女孩</span></span><br><span class="line">            <span class="comment">//match[j]==0表示j这个女孩还没有匹配任何男孩，即j女孩还没有男朋友 j目前没有任何可以匹配的节点</span></span><br><span class="line">            <span class="comment">//find(match[j])=true表示j这个女孩虽然已经匹配了某个男孩,但是她匹配的这个男孩是个海王</span></span><br><span class="line">            <span class="comment">//留有后手随时可以找到其他女孩来代替她，那么此时j女孩被甩处于单身状态,j告诉x说我们在一起吧</span></span><br><span class="line">            <span class="comment">//那么执着追j女孩的这个x男子就击败了j女孩的所有暗恋者，有机会了</span></span><br><span class="line">            <span class="comment">//也就是说j有和它匹配的点(现任男友),但是呢这个点(现任男友)能够通过一些办法来找到新的匹配</span></span><br><span class="line">            <span class="keyword">if</span> (match[j] == <span class="number">0</span> || <span class="built_in">find</span>(match[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                match[j] = x;<span class="comment">//表示j女孩已经匹配成功了，现有配对男友是x</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//返回true表示配对成功</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果遍历过x男子所喜欢的女生中，都没能找到合适的，自己中意的全部都被预定了。</span></span><br><span class="line">    <span class="comment">//配对失败。即没有配对成功，则返回false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n1, &amp;n2, &amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a, b);<span class="comment">//虽然是无向图，但是因为是左侧男生去找女朋友，单向追求，所以用“有向图”就行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;<span class="comment">//res表示匹配的数量</span></span><br><span class="line">    <span class="comment">//依次枚举左半部分的男生该去找哪个女孩</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//要保证每个女孩只被考虑一遍</span></span><br><span class="line">        <span class="comment">//因为每次模拟匹配的预定情况都是不一样的所以每轮模拟都要初始化</span></span><br><span class="line">        <span class="comment">//如果不初始化则当男生i进行匹配操作后会修改st的内容  那么会保留这个内容</span></span><br><span class="line">        <span class="comment">//当下一个男生i+1进行匹配操作时 就会用到上一个男生i保留的st的内容  就会出错</span></span><br><span class="line">        <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);<span class="comment">//把每个女孩的匹配状态清空，表示这些女孩还没有被考虑过</span></span><br><span class="line">        <span class="comment">//如果i这个男子成功的找到了匹配的妹子  那么匹配个数+1</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find</span>(i))</span><br><span class="line">            res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>二分图</category>
      </categories>
      <tags>
        <tag>匈牙利算法</tag>
      </tags>
  </entry>
  <entry>
    <title>关押罪犯</title>
    <url>/2021/07/14/Algorithm-Improvement/Chapter3---Gragh-Theory/%E4%BA%8C%E5%88%86%E5%9B%BE/%E5%85%B3%E6%8A%BC%E7%BD%AA%E7%8A%AF/</url>
    <content><![CDATA[<h1 id="关押罪犯"><a href="#关押罪犯" class="headerlink" title="关押罪犯"></a>关押罪犯</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210714161314.png" alt="image-20210714161314811"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>从题干中，警察局长会把怒气值从大到小排序送给市长看，而市长只会看第一个最大的那个怒气值，如果这个最大的怒气值达到某种程度，则警察局长会被撤职。题目想让我们求的就是：有没有一个分配囚犯的方案，使得那个最大的怒气值，能够达到最小。</p>
<p>一般求 最大值最小 或者 最小值最大，都可以考虑用二分算法。 这里是想求最大值最小，因此，我们可以考虑一下使用二分算法。那么该如何进行二分呢？</p>
<p>考虑这样一个判定问题：是否存在一种分配罪犯的方案，使得$Z$市长看到的那个冲突事件的影响力不超过$mid$。对于当$mid$满足要求时，那么所有大于$mid$也是满足要求的。也就是说题目的答案是具有单调性的，一旦具有单调性，那么一定可以用二分算法。</p>
<blockquote>
<p>问题：为什么对于当$mid$满足要求时，那么所有大于$mid$也是满足要求的呢？</p>
<p>设当前二分的值为$mid$，那么对于那些怒气值大于$mid$的囚犯应该关在不同的监狱。假设它俩关在同一所监狱，那么他们会产生更大的影响力（设其值为$a$)，这个影响力会大于现优解$mid$，即$a&gt;mid$，那么$a$就要在排行榜上当第一了，又由于市长只看第一，因此市长看到更大的$a$就会撤换警察局长，相对来说如果让$mid$在排行榜上当第一，那么影响力会更小一些。</p>
<p>举个栗子，假设当前$mid=50$，如果有两个囚犯，他们之间的怒气值为$100$，假设它俩关在同一个监狱$A$，那么监狱$A$就会产生影响力$100$，但是如果我们让它俩关在不同的监狱$A$和$B$，那么此时监狱$A$产生的影响力为0。因此，我们发现，当怒气值大于$mid$时，我们就更应该把它俩放到不同的监狱，这样会使得同一个监狱内的怒气值相对降低。但是如果他们之间的怒气值小于$mid$，那么就算把他俩放到不同监狱，此时排行榜上第一仍然是$mid$，并没有让第一的值减小，反而还浪费了一次分配机，这导致后面如果有大于$mid$的囚犯本应该被分配到两个不同的监狱却因为位置不够而被迫关在同一个监狱，导致这个监狱内的怒气值大于$mid$，排行榜上第一的值增大，这与我们想要的结果事与愿违。</p>
<p>这也就证明了 当$mid$满足要求时，那些怒气值大于$mid$就更能满足要求了，而那些怒气值$\leq mid$的就不满足条件了。</p>
</blockquote>
<p>二分答案，设当前二分的值为$mid$。此时，任意两个仇恨程度大于$mid$的囚犯都必须被安排在不同的监狱。我们把每个囚犯都看作是一个节点，如果两个囚犯之间的仇恨程度大于$mid$，那么我们就在这两个囚犯之间连一条无向边，这样最终就会得到一张无向图。由于两个囚犯被分配到两个不同的监狱，因此这两个节点属于不同的点集合，也就是说这张无向图需要被分成两个点集合。由于我们把怒气值大于$mid$的两个囚犯分别关到两个不同的监狱中了，那么此时同一个监狱内的囚犯之间的怒气值必然是$\leq mid$。而我们定义了当怒气值大于$mid$才连边，所以对于怒气值$\leq mid$都不需要连边。也就是说每个集合内部都没有边（同一个监狱内没有仇恨程度大于$mid$的罪犯）。我们发现，这种把节点划分成两种点集合，并且只能从一个点集合向另一个点集合连边，这种做法不正是二分图的定义嘛？</p>
<p>刚开始，我们对输入的数据都进行无向图$T$，然后再这张图中，如果边权怒气值$\leq mid$，那么我们就不看这些边（可以认为是从原图$G$中删除这些边），然后如果边权怒气值$&gt;mid$，则保留，那么最终全部保留下来的这个子图也就是一张无向图，设为$G$。然后我们对这个无向图$G$判定是否为二分图。</p>
<p>因此总的算法思路如下：</p>
<ul>
<li>先二分一个答案$mid$，此时$mid$其实就是对应一种分配罪犯的方案。</li>
<li>对每一个$ mid$，都使用染色法来check一下，来判定这个无向图$G$是否为二分图<ul>
<li>如果$check(mid)$成功，则说明是二分图，点$mid$位于右侧绿色满足性质的区间，那么对于所有大于$mid$的分配方案都是合理的，即$mid$右侧都满足，为了求最小，我们让$r=mid$，往左侧收缩，找到最小值</li>
<li>如果$check(mid)$失败，则说明不是二分图，点$mid$位于左侧红色不满足性质的区间，那么此时应该让左侧边界跳到$mid$的下一个位置，即$l=mid+1$，这样才能满足性质</li>
</ul>
</li>
</ul>
<p>那么该如何确定二分的边界呢？由于题目说了$0\leq c\leq 1e9$，因此答案最小值为$0$，最大值为$1e9$，因此二分的区间为<code>[0,1e9]</code>。</p>
<p>题目要求“如果本年内监狱中未发生任何冲突事件，请输出 $0$”，这个我们并不需要特殊处理，因为我们二分的答案区间中就包含了$0$。因此我们的算法一定可以考虑到这种情况。</p>
<p>设二分的性质为 <strong>当同一个监狱的两个囚犯之间的怒气值很大，则分配到两个不同的监狱中</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210714170229.png" alt="image-20210714170229547"></p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//题目给的边数为1e5 但是由于是二分图 它是无向图 所以边数要开2倍</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>,M=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],w[M],idx;</span><br><span class="line"><span class="keyword">int</span> color[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    w[idx]=c;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//染色法判定二分图</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> c,<span class="keyword">int</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    color[u]=c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];~i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j=e[i];</span><br><span class="line">        <span class="comment">//在mid左侧的都在红色不满足性质的区间</span></span><br><span class="line">        <span class="keyword">if</span>(w[i]&lt;=mid)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//如果j还没有被染色</span></span><br><span class="line">        <span class="keyword">if</span>(!color[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">dfs</span>(j,<span class="number">3</span>-c,mid))<span class="comment">//染色有矛盾</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//j被染过色了,但是它的颜色与相邻节点的颜色都是相同的 染色有矛盾</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(color[j]==c)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//说明染色无矛盾  是二分图</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(color,<span class="number">0</span>,<span class="keyword">sizeof</span> color);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!color[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">dfs</span>(i,<span class="number">1</span>,mid))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        <span class="comment">//建图</span></span><br><span class="line">        <span class="built_in">add</span>(a,b,c);</span><br><span class="line">        <span class="built_in">add</span>(b,a,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>,r=<span class="number">1e9</span>;</span><br><span class="line">    <span class="comment">//二分答案</span></span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//判断mid是否在绿色满足性质的区间 如果在则说明是二分图</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid))</span><br><span class="line">        r=mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>二分图</category>
      </categories>
      <tags>
        <tag>二分算法+二分图</tag>
      </tags>
  </entry>
  <entry>
    <title>机器任务</title>
    <url>/2021/07/19/Algorithm-Improvement/Chapter3---Gragh-Theory/%E4%BA%8C%E5%88%86%E5%9B%BE/%E6%9C%BA%E5%99%A8%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="机器任务"><a href="#机器任务" class="headerlink" title="机器任务"></a>机器任务</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210719155448.png" alt="image-20210719155448461"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>这一题其实是二分图最大匹配的应用。</p>
<p>结论：<strong>二分图的最小顶点覆盖=二分图的最大匹配</strong></p>
<p>最小顶点覆盖：用最少的顶点来覆盖图中所有的边</p>
<p>二分图最小顶点覆盖的模型特点是：<strong>每条边有2个端点，二者至少选择一个</strong>。我们称之为“2要素”。如果一个题目具有“2要素”的特点，那么就可以尝试抽象成二分图最小顶点覆盖模型来求解</p>
<p>在这道题目中，每个任务要么在机器$A$上以模式$a[i]$执行，要么在机器$B$上以模式$b[i]$执行，二者必选其一。因此，我们可以把机器$A$的$N$种模式作为$N$个顶点放在左部点集合中，把机器$B$的$M$种模式作为$M$个顶点放在右部点集合中，每个任务当作是一条无向边，连接左边的$a[i]$模式（第$a[i]$个节点）和右边的$b[i]$模式（第$b[i]$个节点）。</p>
<p>由于每台机器转换一次模式就需要重启一次，要想使得重启次数最少，那么就需要某种模式它能处理多种任务，即一个节点能够连接多个无向边。那么要使重启次数最少，即用最少的顶点来覆盖掉所有的无向边。那么这就是要求二分图的最小顶点覆盖，根据前面的结论可知，只需要求出二分图的最大匹配即可。</p>
<p>这里有个坑点，两台机器一开始的模式都是0，因此每个任务如果可以在模式为0的情况下都可以直接进行，则不需要进行重启，因此建图时碰到$a[i]$或者$b[i]$为0，则直接跳过不考虑把它建立到图中即可。</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="keyword">int</span> match[N];</span><br><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//遍历机器B中的这m个模式   即寻找右边的女生集合</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果x这个男生还没有访问过i这个女生</span></span><br><span class="line">        <span class="comment">//并且 此时并不是处于模式0</span></span><br><span class="line">        <span class="keyword">if</span>(!st[i]&amp;&amp;g[x][i]==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            st[i]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(match[i]==<span class="number">-1</span>||<span class="built_in">find</span>(match[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                match[i]=x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n),n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//有多组测试数据  因此每次都要进行初始化</span></span><br><span class="line">        <span class="built_in">memset</span>(match,<span class="number">-1</span>,<span class="keyword">sizeof</span> match);</span><br><span class="line">        <span class="built_in">memset</span>(g,<span class="number">0</span>,<span class="keyword">sizeof</span> g);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;m,&amp;k);</span><br><span class="line">        <span class="keyword">while</span>(k--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> id,a,b;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;id,&amp;a,&amp;b);</span><br><span class="line">            <span class="comment">//如果机器A处于模式0或者机器B处于模式0 那么g[a][b]=0;否则g[a][b]=1</span></span><br><span class="line">            <span class="keyword">if</span>(a&amp;&amp;b)</span><br><span class="line">            g[a][b]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//机器A的n个模式看成是左边的男生集合  从男生集合出发进行匹配</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memset</span>(st,<span class="number">0</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(i))</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>二分图</category>
      </categories>
      <tags>
        <tag>最小顶点覆盖</tag>
      </tags>
  </entry>
  <entry>
    <title>骑士放置</title>
    <url>/2021/07/19/Algorithm-Improvement/Chapter3---Gragh-Theory/%E4%BA%8C%E5%88%86%E5%9B%BE/%E9%AA%91%E5%A3%AB%E6%94%BE%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="骑士放置"><a href="#骑士放置" class="headerlink" title="骑士放置"></a>骑士放置</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210719171846.png" alt="image-20210719171846826"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>最大独立集：选出最多的点，使得选出的点之间没有边</p>
<p>在二分图中，求最大独立集合$\iff$去掉最少的点，使得将所有边都破坏掉$\iff$ 找到最小顶点覆盖$m$$\iff$ 找到最大匹配$m$</p>
<p>结论：最大独立集=总点数-孤立节点数-最小顶点覆盖数</p>
<p>这个题目和“棋盘覆盖”这个题目是类似的，可以对棋盘进行黑白染色，黑色的格子、白色的格子分别作为二分图的左、右部节点。</p>
<p>如果两个格子是“日”字的对角（能互相攻击到），则在这两个格子之间连一条无向边。这个题目是想要求出最多能放多少个不能互相攻击的骑士，由于我们把有攻击的节点都连边了，因此考虑用最少的点来覆盖这些边，那么就会尽可能的剩下多的节点（骑士）了，因此先求出最小顶点覆盖，然后用总点数减去最小顶点覆盖，再减去孤立节点数即可。因此，抽象题意其实就是要求最大独立集。而且，“日”字的两个对角格子的颜色一定不相同。因此，我们建立的图一定是一张二分图。那么我们用匈牙利算法求出二分图的最大匹配，就可以很容易求出二分图的最大独立集了。</p>
<p>如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210719172823.png" alt="image-20210719172823092"></p>
<p>两个格子的马若能互相攻击，则这两个格子之间能连上一条边。若两只马能够互相攻击，则这两只马的格子一定是两种不同颜色的格子。</p>
<p>这里要注意，题目中说了有一些格子禁止放棋子，因此这些格子都会被认为是孤立节点。计算最大独立集时，要记得减去这些孤立节点。</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">110</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;PII;</span><br><span class="line"><span class="keyword">int</span> n,m,t;</span><br><span class="line"><span class="comment">//邻接矩阵 g[i][j]=1表示(i,j)这个格子可以放置  g[i][j]=0表示(i,j)这个格子不可以放置</span></span><br><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line">PII match[N][N];</span><br><span class="line"><span class="keyword">bool</span> st[N][N];</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">8</span>]=&#123;<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">8</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-2</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="comment">//寻找(x,y)这个男生的女友</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//遍历(x,y)这个格子周围的8个方向 即遍历它周围的女生集合</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a=x+dx[i];</span><br><span class="line">        <span class="keyword">int</span> b=y+dy[i];</span><br><span class="line">        <span class="keyword">if</span>(a&gt;=<span class="number">1</span>&amp;&amp;a&lt;=n&amp;&amp;b&gt;=<span class="number">1</span>&amp;&amp;b&lt;=m&amp;&amp;!st[a][b]&amp;&amp;!g[a][b])</span><br><span class="line">        &#123;</span><br><span class="line">            st[a][b]=<span class="literal">true</span>;</span><br><span class="line">            PII t=match[a][b];</span><br><span class="line">            <span class="keyword">if</span>(t.first==<span class="number">-1</span>||<span class="built_in">find</span>(t.first,t.second))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//(a,b)这个格子的女生她的现配成功男友是(x,y)</span></span><br><span class="line">                match[a][b]=&#123;x,y&#125;;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(match,<span class="number">-1</span>,<span class="keyword">sizeof</span> match);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;t);</span><br><span class="line">    <span class="comment">//输入t个不能放置的格子</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        g[a][b]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//(i+j)%2==0表示男生集合</span></span><br><span class="line">            <span class="comment">//g[i][j]==0表示(i,j)这个格子可以放置</span></span><br><span class="line">            <span class="keyword">if</span>((i+j)%<span class="number">2</span>==<span class="number">0</span>&amp;&amp;g[i][j]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">memset</span>(st,<span class="number">0</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">find</span>(i,j))</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最大独立集=总点数-孤立节点数-最小顶点覆盖</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,n*m-t-res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>二分图</category>
      </categories>
      <tags>
        <tag>最大独立集</tag>
      </tags>
  </entry>
  <entry>
    <title>染色法判定二分图</title>
    <url>/2021/07/13/Algorithm-Improvement/Chapter3---Gragh-Theory/%E4%BA%8C%E5%88%86%E5%9B%BE/%E6%9F%93%E8%89%B2%E6%B3%95%E5%88%A4%E5%AE%9A%E4%BA%8C%E5%88%86%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="染色法判定二分图"><a href="#染色法判定二分图" class="headerlink" title="染色法判定二分图"></a>染色法判定二分图</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210713124859.png" alt="image-20210713124859893"></p>
<hr>
<h3 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h3><p>二分图的含义：二分图是有两组点集$X$和$Y$组成的无向图，其中点集$X$中的点之间互相没有关联，点集$Y$中的点之间互相没有关联，但是点集$X$中的点和点集$Y$中的点之间可能存在关联，用一条无向边来表示这种关联。</p>
<p>如下图所示：</p>
<p>橙色节点都属于点集$X$，互相之间没有边相连；蓝色节点都属于点集$Y$，互相之间没有边相连。绿色代表无向边，用来连接点集$X$和点集$Y$中的节点。</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210713125403.png" alt="image-20210713125403160"></p>
<hr>
<h3 id="二分图的判定"><a href="#二分图的判定" class="headerlink" title="二分图的判定"></a>二分图的判定</h3><h4 id="圈的定义"><a href="#圈的定义" class="headerlink" title="圈的定义"></a>圈的定义</h4><p>图论中圈的定义是：任选一个顶点为起点，沿着不重复的边，经过不重复的顶点，之后又回到起点的闭合路径。</p>
<p>如下图所示：</p>
<p>$1-&gt;2-&gt;4-&gt;3-&gt;1$就是一个圈</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210713130025.png" alt="image-20210713130025270"></p>
<ul>
<li>偶数圈就是经过路径中的顶点数为偶数的圈，如上图，$1-&gt;2-&gt;4-&gt;3-&gt;1$</li>
<li>奇数圈就是经过路径中的顶点数为奇数的圈，如下图，$1-&gt;2-&gt;4-&gt;5-&gt;3-&gt;1$</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210713131614.png" alt="image-20210713131614073"></p>
<h4 id="二分图的判定性质"><a href="#二分图的判定性质" class="headerlink" title="二分图的判定性质"></a>二分图的判定性质</h4><p><strong>判定性质：判断一个图是不是二分图，其实就是判断这个图有没有奇圈</strong></p>
<p>如下图所示：</p>
<p>我们把这个图划分成了两个点集$X$和$Y$</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210713130951.png" alt="image-20210713130951633"></p>
<p>但是如果存在奇圈的话，就会变成如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210713131058.png" alt="image-20210713131058769"></p>
<p>因此，我们可以通过观察奇偶性可知，相邻的两个节点的奇偶性一定是不相同的，分别对应到两个不同的点集$X$和$Y$中。那么当存在奇圈时，则说明相邻的这两个节点奇偶性一定是相同的，这与二分图的性质矛盾。</p>
<hr>
<h3 id="染色法判定二分图-1"><a href="#染色法判定二分图-1" class="headerlink" title="染色法判定二分图"></a>染色法判定二分图</h3><p>二分图染色算法的实现是通过判断一个图中是否存在奇圈从而确定它是否是二分图。    </p>
<p>染色法的算法步骤如下：</p>
<ul>
<li><p>设染色只有2种颜色，$color$为1和2</p>
</li>
<li><p>选择当前还没有被染色的节点作为当前节点$u$，给它染上颜色1，即$color[u]=1$</p>
</li>
<li>遍历该节点的所有邻接点$v$，并给这些邻接点染色，即$color[v]=3-color[u]$</li>
<li>重复上面两个步骤，直到全部染色完毕</li>
<li>如果染色过程种发生了矛盾，即相邻两个节点的颜色相同，则说明不满足二分图的奇偶性，因此可以判定出该图不是二分图；否则说明全部都成功无矛盾染色，该图是二分图</li>
</ul>
<p>注意：由于二分图可能是一个非连通图，所以不是只访问一个结点就能遍历到所有结点的，需要对所有结点都进行一次遍历。</p>
<p>染色法可以用dfs和bfs实现，算法思路其实都是一样的</p>
<blockquote>
<p>问题：如何理解dfs染色法中的下列代码呢？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(color[j]==c)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>如上图，假设当前节点是$u$，设$u=4$，设当前节点$u$的被染上的颜色为$c$。我们来看它的邻接点$j=2$。我们发现，其实在前面的时候，节点$1$就已经把节点$2$染过色了，染的颜色为$color[j]$。那么当节点$u$遍历到节点$j$时，发现节点$j$已经被染过色了，那么我们就只需要判断节点$j$的颜色是否与当前节点$u$的颜色相同。如果相同，则不符合二分图的奇偶性，则该图不是二分图；</p>
</blockquote>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><strong>dfs染色法：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//dfs染色法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, M = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="keyword">int</span> color[N];<span class="comment">//给图的每个顶点染色的数组</span></span><br><span class="line"><span class="comment">//构造无向图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//dfs函数是用来判定染色过程中是否出现了矛盾，如果出现了矛盾，则返回false</span></span><br><span class="line"><span class="comment">//如果没有出现矛盾，就返回true</span></span><br><span class="line"><span class="comment">//这里假设染了两种颜色1 和 2</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    color[u] = c;<span class="comment">//u这个顶点染上c的颜色</span></span><br><span class="line">    <span class="comment">//拓展u这个顶点的邻接表，去寻找邻接点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="comment">//如果j顶点还没有被染过色</span></span><br><span class="line">        <span class="keyword">if</span> (!color[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果当这个j顶点染上色之后，就出现了矛盾，那么让flag为false</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(j, <span class="number">3</span> - c))<span class="comment">//3 - c表示所染的颜色一定是在1和2之间</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里说明j之前已经被染过色了 那么判断一下当前节点u的颜色和它的邻接点j的颜色是否相同</span></span><br><span class="line">        <span class="comment">//如果相同则说明一条边的两个顶点都是染相同的颜色,则不满足二分图的奇偶性</span></span><br><span class="line">        <span class="comment">//那么就会出现染色矛盾</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (color[j] == c)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//染色成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="built_in">add</span>(a, b);</span><br><span class="line">        <span class="built_in">add</span>(b, a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;<span class="comment">//flag用来判断染色是否有矛盾，如果出现矛盾,则为false,否则就是true</span></span><br><span class="line">    <span class="comment">//对1号顶点到n号顶点分别染色</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果当前i这个顶点还没有被染色的话  !color[i]表示当前i顶点还没有被染色</span></span><br><span class="line">        <span class="keyword">if</span> (!color[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果当这个i顶点染上色之后，就出现了矛盾，那么让flag为false，然后break退出for循环</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(i, <span class="number">1</span>))<span class="comment">//有两种颜色  颜色1和颜色2</span></span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果染色过程中没有出现矛盾，成功给每个顶点染色了，输出Yes</span></span><br><span class="line">    <span class="keyword">if</span> (flag)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="comment">//否则如果染色过程中出现了矛盾，则输出No</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bfs染色法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//bfs染色法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, M = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="keyword">int</span> color[N];<span class="comment">//给图的每个顶点染色的数组</span></span><br><span class="line"><span class="comment">//bfs的队列</span></span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line"><span class="comment">//构造无向图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//bfs染色法 c是颜色  0 表示还没有染色 1表示染了一种颜色  2表示染了另一种颜色</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    color[u]=c;     <span class="comment">//给u这个节点染上颜色c</span></span><br><span class="line">    q.<span class="built_in">push</span>(u);      <span class="comment">//将u这个节点加入队列q中</span></span><br><span class="line">    <span class="comment">//当队列不为空时</span></span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//取出队头元素</span></span><br><span class="line">        <span class="keyword">int</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();    <span class="comment">//队头元素已经出队了,弹掉队头元素</span></span><br><span class="line">        <span class="comment">//遍历队头元素t的所有邻接点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//队头元素t的邻接点j</span></span><br><span class="line">            <span class="keyword">int</span> j=e[i];</span><br><span class="line">            <span class="comment">//如果j还没有被染色</span></span><br><span class="line">            <span class="keyword">if</span>(!color[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//由于j是t的邻接点 所以它俩奇偶性不同 染色不一样</span></span><br><span class="line">                color[j]=<span class="number">3</span>-color[t];</span><br><span class="line">                <span class="comment">//将j加入队列q中</span></span><br><span class="line">                q.<span class="built_in">push</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//否则说明j已经被染过色了 但是它的颜色与邻接点t的颜色相同 则不满足奇偶性</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(color[j]==color[t])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a,b);</span><br><span class="line">        <span class="built_in">add</span>(b,a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!color[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">bfs</span>(i,<span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                flag=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>二分图</category>
      </categories>
      <tags>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title>捉迷藏</title>
    <url>/2021/07/20/Algorithm-Improvement/Chapter3---Gragh-Theory/%E4%BA%8C%E5%88%86%E5%9B%BE/%E6%8D%89%E8%BF%B7%E8%97%8F/</url>
    <content><![CDATA[<h1 id="捉迷藏"><a href="#捉迷藏" class="headerlink" title="捉迷藏"></a>捉迷藏</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210720123116.png" alt="image-20210720123116058"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>最小路径点覆盖：选择一些路径，覆盖所有点，并且各个路径的节点之间不能有交集，要求路径数最少</p>
<p>最小路径重复点覆盖：选择一些路径，覆盖所有点，但是各个路径的节点之间允许有交集，要求路径数最少</p>
<p>求解最小路径点覆盖的方法：</p>
<p><strong>结论：DAG的最小路径点覆盖=原图节点数-拆点后形成的二分图的最大匹配数</strong></p>
<p>证明：</p>
<p>这里使用的技巧是拆点。假设原图有$n$个节点，将每个节点都复制一份放到右边，假设节点$i$复制后的点为$i’$，我们将原图中的边$(i,j)$转变为新图中的$(i,j’)$。新图必然是一个二分图。</p>
<p>如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210720123914.png" alt="image-20210720123914525"></p>
<p>考虑原图中的任意一条路径转化到新图中是啥样的呢？</p>
<ul>
<li>每条路径转化到新图中一定对应新图的一个匹配，即每个点只会在一条边中。反之也成立</li>
<li>我们可以看到原图中每条路径的终点，对应到新图中的话就是出点没有引出一条出边，即它是新图中左部的非匹配点，例如上图中的节点3。同理左部的每一个非匹配点都对应着原图中的路径。即使是孤立节点也可以看成一个终点，符合要求。我们想要让路径数最少，那么就是让左部的非匹配点数目最少，由于$n=$左部非匹配点数+左部匹配点数，因此必须让左部匹配点数最大，那么也就是找最大匹配，设最大匹配为$m$，因此左部的非匹配点最少为$n-m$，即路径数最少为$n-m$。因此最小路径点覆盖=原图节点数-拆点后形成的二分图的最大匹配数</li>
</ul>
<p>求解最小路径重复点覆盖的方法：</p>
<ul>
<li>对原图$G$求一次传递闭包，得到一张图$G’$</li>
<li>求原图的最小路径重复点覆盖$\iff$ 求新图的最小路径点覆盖</li>
</ul>
<p>证明：</p>
<ol>
<li>充分性：依次考虑原图的每一条符合条件的路径，当我们考察第$i$条路径时，如果路径上的点和前$i-1$条边上的点是重复的，那么直接跳过即可，新图中加了很多边，可以跳过。另外第$i$条路径上的点不可能全部和前$i-1$条边上的点重复，否则第$i$条路径就没有存在的必要了。</li>
<li>必要性：将新图中间接转移过去的边展开成原来的边即可得到原图中的路径。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210720145120.png" alt="image-20210720145120840"></p>
<p>现在我们来理清一下题意：题目中说到 “如果从房子$A$沿着路走下去能够到达$B$，那么在 $A$和 $B$ 里的人是能够相互望见的。”这说明了一条路径中最多只能选择一个点作为藏身点，因为如果选择两个藏身点的话，那么就可以互相看见了。 “cl2 要求这$K$个藏身点的任意两个之间都没有路径相连。”其实就是要求：给定一定DAG图，让我们选择尽可能多的点，使得这些点任意两个点之间都不能相互到达。</p>
<p>题目要求尽可能多的藏身点组成集合，使得任意两点之间都没有边。那这与最小重复点路径覆盖有啥关系嘛？这不应该是最大独立集的含义嘛？但是要注意最大独立集只针对无向图，对于有向图是不适用的。但是题目中说到视线是可以沿着路径无限延展的，似乎在引导我们往传递闭包上面想，而说到传递闭包，那么不就是要求最重复路径点覆盖嘛？</p>
<p>或者我们可以根据下面的这个定理来理清题意：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210720130243.png" alt="image-20210720130243580"></p>
<p>要求尽可能多的藏身点组成集合，使得任意两点之间都没有边这正与最长反链长度相同，而最长反链长度=最小链覆盖。</p>
<p>我们设答案为$K$，最小重复路径点覆盖为cnt：</p>
<ul>
<li>先证明$K\leq cnt$。由于这cnt条路径把所有节点都已经覆盖了，所以选择$K$个点从这cnt条路径上选了，每条路径上最多只能选择一个点，因此必然有$K\leq cnt$。</li>
<li>再证明$K=cnt$。可以采用构造法：我们把这cnt条路径中每条路径的终点都放入这个顶点集合$V$中。设集合<code>next(V)</code>表示：从点集合$V$中的每个点出发可以到达的所有顶点的集合。<ul>
<li>如果$V\cap next(V)=\empty$，那么意味着从$V$中所有节点出发，都不能到达$V$集合内部的顶点。即$V$内部的任意两个节点之间是不能相互到达的。而这个含义正好与我们题意想要求的是一致的。因此，而$V$里面就有cnt个点，因此我们就构造出了包含cnt个点的方案。此时$V$就是合法的答案。</li>
<li>如果$V\cap next(V)\notin \empty$，那么我们从$V$中挑选出任意一个点$v_i$（某条路径的终点），让$v_i$沿着有向边往回走（往起点方向走），走到某个点$v_i’$不属于$next(V)$为止。对于$V$集合中的每一个点$v_i$都进行这样的操作，每个$v_i$都走到$v_i’$不属于$next(V)$为止。那么最终直到$V$和$next(V)$没有交集为止。那么如何证明最终一定可以做到$V$和$next(V)$没有交集呢？如何证明最多走到起点时就能保证$V\cap next(V)=\empty$呢？ 这里采用反证法：假设一直往回走，一直回退到起点，都不能保证某个点$v_i’$不属于$next(V)$，也就是说，走到起点了仍然有某个点$v_i’\in next(V)$，由于$next(V)$表示从多条路径的终点出发所能到达的所有顶点的集合，那么这说明$v_i’$所在的这条路径$e$的起点都是可以被这些路径所到达的，那么这条路径$e$其实就没有存在的价值了。因为我们可以把这条路径$e$接到$next(V)$中某条路径的后面，那么当前路径$e$上的每一个点都可以被覆盖，由于把这条路径接到了某一条路径的后面，因此路径数目少1，这与cnt为最小重复路径点覆盖矛盾。因此，我们就证明了$v_i$它走到某个点就一定会停止，也就是说最终仍然会有$V\cap next(V)=\empty$。因此，我们就证明了$K=cnt$。</li>
</ul>
</li>
</ul>
<p>由于我们证明了$K\leq cnt$并且$K=cnt$，那么最终$K=cnt$。</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">210</span>,M=<span class="number">30010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="comment">//邻接矩阵 g[i][j]=1表示从i节点到j节点连一条有向边</span></span><br><span class="line"><span class="comment">//g[i][j]=0表示从i节点到j节点没没有引出有向边</span></span><br><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line"><span class="keyword">int</span> match[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="comment">//寻找男生x的配对女生</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//遍历x能够联系的所有这n个女生</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//g[x][i]==1表示男生x和女生i之间连了一条有向边  可以联系</span></span><br><span class="line">        <span class="comment">//!st[i]表示男生x之前还没有访问过这个女生i</span></span><br><span class="line">        <span class="keyword">if</span>(g[x][i]&amp;&amp;!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            st[i]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(match[i]==<span class="number">-1</span>||<span class="built_in">find</span>(match[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                match[i]=x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(match,<span class="number">-1</span>,<span class="keyword">sizeof</span> match);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        g[a][b]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对原图G求一遍传递闭包,得到一个新图G&#x27;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                g[i][j]|=g[i][k]&amp;g[k][j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//对这个新图G&#x27;求二分图的最大匹配</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(st,<span class="number">0</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(i))</span><br><span class="line">        res++;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">//最小路径重复点覆盖=总点数-新图G&#x27;的最大匹配      </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,n-res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>二分图</category>
      </categories>
      <tags>
        <tag>最小可重复点覆盖</tag>
      </tags>
  </entry>
  <entry>
    <title>棋盘覆盖</title>
    <url>/2021/07/19/Algorithm-Improvement/Chapter3---Gragh-Theory/%E4%BA%8C%E5%88%86%E5%9B%BE/%E6%A3%8B%E7%9B%98%E8%A6%86%E7%9B%96/</url>
    <content><![CDATA[<h1 id="棋盘覆盖"><a href="#棋盘覆盖" class="headerlink" title="棋盘覆盖"></a>棋盘覆盖</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210719133614.png" alt="image-20210719133614274"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>在状态压缩DP的例题“蒙德里安的梦想”中，我们解决了用$1\times2$的长方形铺满$N\times M$网格的方案数问题。而这里与之不同的是，本题中的棋盘有禁止放置的格子，并且只需要求出能放置的$1\times2$骨牌的最大数量即可。当$N,M$较小时，仍然可以使用状态压缩DP来求解，这里更高效的方法则是构建出二分图匹配的模型。</p>
<p>二分图匹配的模型需要两个基本要素：</p>
<ul>
<li>节点能分成两个独立的集合，每个集合内部有$0$条边</li>
<li>每个节点只能与$1$条匹配边相连</li>
</ul>
<p>我们称为“0要素”和“1要素”。在把实际问题抽象成二分图匹配时，我们就要寻找题目中具有这种“0”和“1”性质的对象，从而发现模型构建的突破口。</p>
<p>在本题中，任意两张骨牌不能重叠，也就是每个格子只能被1张骨牌覆盖。而骨牌的大小为$1\times2$，覆盖$2$个相邻的格子。这恰好与“1要素”相对应。于是，我们可以把棋盘上没有被禁止的格子作为节点，把骨牌作为无向边（两个相邻的格子对应的节点之间连一条无向边）</p>
<p>我们可以发现，对于棋盘来说，相邻的节点它们的横坐标+纵坐标，得到的和 是不同的。因此，我们可以把棋盘黑白染色（行号+列号为偶数的格子被染成白色，行号+列号为奇数的格子被染成黑色），把白色格子都放进一个点集合$V_1$中，把黑色格子都放进另一个点集合$V_2$中。那么两个相同颜色的格子不可能被同一个骨牌覆盖，也就是说同色格子之间没有边相连，即点集合$V_1$内部没有边相连，点集合$V_2$内部没有边相连。这恰好与“0要素”对应。</p>
<p>于是，刚才建立的无向图就是一张二分图。可以把白色格子作为左部节点，黑色格子作为右部节点。如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210719135004.png" alt="image-20210719135004377"></p>
<p>要让骨牌不重叠的情况下尽量多放，就是求上述构建好的二分图的最大匹配。</p>
<p>这里因为涉及到二维坐标问题，那么我们建图时，可以使用二维的邻接矩阵<code>g[N][N]</code>，当$g[i][j]=1$表示这个格子不能放置，当$g[i][j]=0$表示这个格子可以放置。</p>
<p>对于二分图来说，虽然是无向图。但是求二分图的最大匹配时，使用匈牙利算法，是从男生集合出发的，因此只需要当初有向边即可。那么这里我们把白色格子组成的点集合看作是男生集合，把黑色格子组成的点集合看作是女生集合。那么做匈牙利算法时，从$(i+j)\%2==0$这个男生集合出发即可。</p>
<p>由于是使用邻接矩阵建图，因此不像邻接表那样的建图方式（邻接表需要add这个建图函数)</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">110</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;PII;</span><br><span class="line"><span class="keyword">int</span> n,t;</span><br><span class="line"><span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line"><span class="comment">//存储女生配对的男友的编号 比如match[i][j]=&#123;2,3&#125; 表示(i,j)这个格子所对应的那个女生她的现配男友的编号为&#123;2,3&#125;这个格子</span></span><br><span class="line">PII match[N][N];</span><br><span class="line"><span class="keyword">bool</span> st[N][N];</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="comment">//匈牙利算法</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//遍历点(x,y)的四个方向</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a=x+dx[i];</span><br><span class="line">        <span class="keyword">int</span> b=y+dy[i];</span><br><span class="line">        <span class="keyword">if</span>(a&gt;=<span class="number">1</span>&amp;&amp;a&lt;=n&amp;&amp;b&gt;=<span class="number">1</span>&amp;&amp;b&lt;=n&amp;&amp;!g[a][b]&amp;&amp;!st[a][b])</span><br><span class="line">        &#123;</span><br><span class="line">            st[a][b]=<span class="literal">true</span>;</span><br><span class="line">            PII t=match[a][b];</span><br><span class="line">            <span class="keyword">if</span>(t.first==<span class="number">-1</span>||<span class="built_in">find</span>(t.first,t.second))</span><br><span class="line">            &#123;</span><br><span class="line">                match[a][b]=&#123;x,y&#125;;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        <span class="comment">//如果不能放置 则g设为1</span></span><br><span class="line">        g[x][y]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(match,<span class="number">-1</span>,<span class="keyword">sizeof</span> match);</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;  <span class="comment">//匹配数量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//(i+j)%2==0表示男生集合  g[i][j]==0表示这个点可以放置</span></span><br><span class="line">            <span class="keyword">if</span>((i+j)%<span class="number">2</span>==<span class="number">0</span>&amp;&amp;g[i][j]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//每一轮男生(i,j)匹配时  都要清空上一个男生进行匹配操作时所遗留下的状态</span></span><br><span class="line">                <span class="built_in">memset</span>(st,<span class="number">0</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">                <span class="comment">//(i,j)这个男生找到了女朋友  匹配数量+1</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">find</span>(i,j))</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>二分图</category>
      </categories>
      <tags>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP</title>
    <url>/2021/07/11/Algorithm-Improvement/Chapter3---Gragh-Theory/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/KMP/</url>
    <content><![CDATA[<h1 id="KMP算法详解"><a href="#KMP算法详解" class="headerlink" title="KMP算法详解"></a>KMP算法详解</h1><hr>
<p>求解<code>next[]</code>数组之前要先明白以下数组的概念：</p>
<ul>
<li>前缀：包含首位字符但是不包含末位字符的子串</li>
<li>后缀：包含末位字符但是不包含首位字符的子串</li>
<li><code>next[]</code>数组的含义：当主串S与模式串P的某一位字符不匹配时，模式串P应该回退的位置（数组下标）</li>
<li>$next[i]=j$的含义：即模式串P的前i个字符(包括i)组成的字符串中，最长公共前后缀子串的长度为$j$</li>
</ul>
<p><strong>注意：我们的算法中，字符串的下标都是从1开始，不用下标0，下标为0可以表示空字符。</strong></p>
<p>如下图所示，来看看什么是最长公共前后缀：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210711105744.png" alt="image-20210711105734389"></p>
<ol>
<li>当i=0时，空字符，最长公共前后缀为0</li>
<li>当i=1时，对于单个字符来说，不存在前缀和后缀，因此最长公共前后缀为0</li>
<li>当i=2时，字符串为“AB”，前缀为A，后缀为B，前缀与后缀并不相同，因此最长公共前后缀为0</li>
<li>当i=3时，字符串为“ABC”，前缀为A，AB；后缀为C，BC，前缀与后缀并不相同，因此最长公共前后缀为0</li>
<li>当i=4时，字符串为“ABCA”，前缀为<strong>A</strong>，AB，ABC；后缀为<strong>A</strong>，CA，BCA；有最长的相同的前后缀A，因此最长公共前后缀为1</li>
<li>当i=5时，字符串为“ABCAB”，前缀为A，<strong>AB</strong>，ABC，ABCA；后缀为B，<strong>AB</strong>，CAB，BCAB；有最长的相同的前后缀AB，因此最长公共前后缀为2</li>
<li>当i=6时，字符串“ABCABD”，前缀为A，AB，ABC，ABCA，ABCAB；后缀为D，BD，ABD，CABD，BCABD，前缀与后缀并不相同，因此有相同的前后缀，因此最长公共前后缀为0</li>
</ol>
<p>该栗子中，<code>next[]</code>数组元素的值分别为：</p>
<p>一般来说，我们都可以预定义$next[0]$和$next[1]$都为0</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">next[<span class="number">0</span>]=<span class="number">0</span>;	<span class="comment">//空字符  弃用</span></span><br><span class="line">next[<span class="number">1</span>]=<span class="number">0</span>;	<span class="comment">//单个字符,不存在前缀和后缀,因此next[1]固定为0</span></span><br><span class="line">next[<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">next[<span class="number">3</span>]=<span class="number">0</span>;</span><br><span class="line">next[<span class="number">4</span>]=<span class="number">1</span>;</span><br><span class="line">next[<span class="number">5</span>]=<span class="number">2</span>;</span><br><span class="line">next[<span class="number">6</span>]=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>我们用图示来形象地理解<code>next[]</code>的含义：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210711111510.png" alt="image-20210711111454805"></p>
<p>如上图所示，对于由$i$个字符组成的字符串来说，前面的绿色部分和后面的绿色部分就表示该字符串相同的前缀和后缀，值为$next[i]$</p>
<hr>
<p>那么，我们怎么求解<code>next[]</code>数组呢？</p>
<p>根据<code>next[]</code>数组的含义，可以分为两种情况讨论，找到规律：</p>
<ul>
<li>如果新加入的字符与前一个最长公共前后缀子串的后面一个字符相同时，即$p[j+1]==p[i]$</li>
<li>如果新加入的字符与前一个最长公共前后缀子串的后面一个字符不同时，即$p[j+1]\neq p[i]$</li>
</ul>
<p><strong>讨论第一种情况：如果新加入的字符与前一个最长公共前后缀子串的后面一个字符相同时</strong></p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(p[i]==p[j+<span class="number">1</span>])</span><br><span class="line">    j++;</span><br><span class="line"><span class="comment">//用此时j的值来填充i所指向的这个字符的next数组的内容</span></span><br><span class="line">ne[i]=j;</span><br></pre></td></tr></table></figure>
<p>如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210711112121.png" alt="image-20210711112121418"></p>
<p>新加入的字符为$p[i]$，前一个最长公共前后缀子串的后一个字符是$p[j+1]$，可以发现，$p[j+1]==p[i]$，那么绿色部分就可以扩展一格，那么就是$next[i]=next[i-1]+1$，其实也就是$j=j+1$嘛，因为之前$j=next[i-1]$，然后由于$p[j+1]==p[i]$，那么$next[i]=next[i-1]+1$，就等效于此时$j=j+1$，即$j$++</p>
<p>注意：绿色部分是可以为0的，那么含义就是：最长公共前后缀为0，即不存在相同的前缀和后缀。也就是说此时$j$回退到0，指向了那个空字符</p>
<p><strong>讨论第二种情况：如果新加入的字符与前一个最长公共前后缀子串的后面一个字符不相同时</strong></p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当j没有回退到下标0所在的那个空字符,并且绿色部分内部一直都没有相同的前缀和后缀</span></span><br><span class="line"><span class="keyword">while</span>(j&amp;&amp;p[i]!=p[j+<span class="number">1</span>])</span><br><span class="line">    j=ne[j];</span><br><span class="line"><span class="comment">//用此时j的值来填充i所指向的这个字符的next数组的内容</span></span><br><span class="line">ne[i]=j;</span><br></pre></td></tr></table></figure>
<p>当出现这种情况时，在KMP算法中，就会执行$j=next[j]$，但是很难理解为什么要这么做。</p>
<p>下面我们看这张图：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210711121243.png" alt="image-20210711121242198"></p>
<p>那么蓝色的部分该怎么求解呢？在KMP中，就是用$j=next[j]$，这是回退操作</p>
<p>这个蓝色部分，首先要内容都完全相同，其次还要位于绿色部分的开头和结尾，那么这不就是绿色部分的最长公共前后缀的子串嘛？</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210711122308.png" alt="image-20210711122239056"></p>
<p>更新$j=next[j]$后，又回到原来的问题了，接着判断$p[j+1]$是否与$p[i]$相同就行了</p>
<p>至此，我们弄明白了那个令人费解的回退操作到底是什么意思了，其实就是在当前的这个最长公共前后缀已经不能使用时，那么就继续去寻找这个最长公共前后缀，看看它内部是否也存在最长公共前后缀，就这样一直迭代去寻找，一直尝试到成功或者是最长公共前后缀的长的为0时，就停止迭代循环</p>
<hr>
<p>下面给出求出<code>next[]</code>数组的完整代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ne[<span class="number">0</span>]=<span class="number">0</span>;	<span class="comment">//空字符的最长公共前后缀长度为0</span></span><br><span class="line">ne[<span class="number">1</span>]=<span class="number">0</span>;	<span class="comment">//单个字符不存在前缀和后缀，那么最长公共前后缀长度也为0</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(j&amp;&amp;p[i]!=p[j+<span class="number">1</span>])</span><br><span class="line">        j=ne[j];</span><br><span class="line">    <span class="keyword">if</span>(p[i]==p[j+<span class="number">1</span>])</span><br><span class="line">        j++;</span><br><span class="line">    ne[i]=j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>上面我们求出了<code>next[]</code>数组，那么如何进行主串和模式串的匹配呢？</p>
<p>其实进行主串和模式串的匹配，与求解<code>next[]</code>数组是一样的。</p>
<p>主循环中，$i$是用来遍历主串S的，$j$是用来遍历模式串p的。初始时$i$指向主串的第一个字符，即$i=1$，$j$指向模式串的空字符，即$j=0$。要注意：主串的$i$是不会回退的，它是一直往前遍历，但是模式串的$j$会进行回退操作，即会执行$j=next[j]$。</p>
<p><strong>讨论第一种情况：如果新加入的字符与前一个最长公共前后缀子串的后面一个字符相同时</strong></p>
<p>这里新加入的字符是指主串中的$S[i]$，前一个最长公共前后缀子串的后一个字符是指模式串中的$p[j+1]$，也就是说$S[i]==p[j+1]$，那么此时主串的下标$i$往前移动一位，模式串的下标$j$也往前移动一位</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(s[i]==p[j+<span class="number">1</span>])</span><br><span class="line">    j++;</span><br></pre></td></tr></table></figure>
<p><strong>讨论第二种情况：如果新加入的字符与前一个最长公共前后缀子串的后面一个字符不相同时</strong></p>
<p>这里新加入的字符是指主串中的$S[i]$，前一个最长公共前后缀子串的后一个字符是指模式串中的$p[j+1]$，也就是说$S[i]\neq p[j+1]$，那么此时模式串的$j$就要执行回退操作了，即$j=next[j]$</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(j&amp;&amp;s[i]!=p[j+<span class="number">1</span>])</span><br><span class="line">    j=ne[j];</span><br></pre></td></tr></table></figure>
<p>可以发现，其实进行主串与模式串的匹配时，与求解<code>next[]</code>数组是如出一辙的</p>
<hr>
<h1 id="KMP字符串"><a href="#KMP字符串" class="headerlink" title="KMP字符串"></a>KMP字符串</h1><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210711125013.png" alt="image-20210711125013111"></p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="comment">//n是模式串P的长度  m是主串S的长度</span></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">char</span> p[N];  <span class="comment">//模式串</span></span><br><span class="line"><span class="keyword">char</span> s[M];  <span class="comment">//主串</span></span><br><span class="line"><span class="comment">//next数组</span></span><br><span class="line"><span class="keyword">int</span> ne[N];</span><br><span class="line"><span class="comment">//求解出模式串P的next数组   next数组是对于模式串来说的,主串并不存在next数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ne[<span class="number">0</span>]=<span class="number">0</span>,ne[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;p[i]!=p[j+<span class="number">1</span>])</span><br><span class="line">        j=ne[j];</span><br><span class="line">        <span class="keyword">if</span>(p[i]==p[j+<span class="number">1</span>])</span><br><span class="line">        j++;</span><br><span class="line">        <span class="comment">//用此时j的值来填充i所指向当前这个字符的ne数组的内容</span></span><br><span class="line">        <span class="comment">//next[i] = j 表示下标以i-j为起点，i为终点的后缀和下标以1为起点，j为终点的前缀相等</span></span><br><span class="line">        <span class="comment">//且此字符串的长度最长。用符号表示为p[1~j] == p[i-j~i]</span></span><br><span class="line">        ne[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进行主串S和模式串P的匹配操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//主循环，遍历主串字符 i是用来遍历主串的，j是用来遍历模式串的</span></span><br><span class="line">    <span class="comment">//初始时i指向主串的第一个字符，j指向空字符</span></span><br><span class="line">    <span class="comment">//主串数组和模式串数组都是舍去数组下标0不用，从数组下标1开始存入字符</span></span><br><span class="line">    <span class="comment">//主串的i是不会回溯的，只有模式串的j才能回溯</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;s[i]!=p[j+<span class="number">1</span>])</span><br><span class="line">        j=ne[j];</span><br><span class="line">        <span class="keyword">if</span>(s[i]==p[j+<span class="number">1</span>])</span><br><span class="line">        j++;</span><br><span class="line">        <span class="comment">//如果j能走到n,那么一定是成功匹配了,因为如果不匹配的话,那么进行回退操作</span></span><br><span class="line">        <span class="comment">//j就不会到达n</span></span><br><span class="line">        <span class="keyword">if</span>(j==n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i-n);</span><br><span class="line">            <span class="comment">//这一句可以不用</span></span><br><span class="line">            j=ne[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//模式串和主串的下标都是从1开始</span></span><br><span class="line">    cin &gt;&gt;n&gt;&gt;p+<span class="number">1</span>&gt;&gt;m&gt;&gt;s+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//求解next数组</span></span><br><span class="line">    <span class="built_in">getNext</span>();</span><br><span class="line">    <span class="comment">//进行模式串和主串匹配操作</span></span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>区间</title>
    <url>/2021/07/08/Algorithm-Improvement/Chapter3---Gragh-Theory/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/%E5%8C%BA%E9%97%B4/</url>
    <content><![CDATA[<h1 id="区间"><a href="#区间" class="headerlink" title="区间"></a>区间</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210710143855.png" alt="image-20210710143855592"></p>
<hr>
<h3 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h3><ul>
<li>【1】给定区间<code>[a,b]</code>为$[3,7]$，那么$3\leq x\leq 7$，所以$x$的可选范围为{3，4，5，6，7}，其中要求选出来的$x$的个数必须不少于$c=3$个</li>
<li>【2】给定区间<code>[a,b]</code>为$[8,10]$，那么$8\leq x\leq 10$，所以$x$的可选范围为{8，9，10}，其中要求选出来的$x$的个数必须不少于$c=3$个</li>
<li>【3】给定区间<code>[a,b]</code>为$[6,8]$，那么$6\leq x\leq 8$，所以$x$的可选范围为{6，7，8}，其中要求选出来的$x$的个数必须不少于$c=1$个</li>
<li>【4】给定区间<code>[a,b]</code>为$[1,3]$，那么$1\leq x\leq 3$，所以$x$的可选范围为{1，2，3}，其中要求选出来的$x$的个数必须不少于$c=1$个</li>
<li>【5】给定区间<code>[a,b]</code>为$[10,11]$，那么$10\leq x\leq 11$，所以$x$的可选范围为{10，11}，其中要求选出来的$x$的个数必须不少于$c=1$个</li>
</ul>
<p>题目是意思是说想让我们从【1】、【2】、【3】、【4】、【5】中挑出$x$，组成一个整数集合$Z$，使得集合$Z$中元素的个数最少。那么给我们的启发就是，从【1】到【5】中跳出的这些数$x$应该尽可能的有交集，这样，才能使得选出最少的个数来组成集合$Z$。</p>
<ul>
<li>我们先看【1】和【4】，可以发现有交集元素3，由于【4】要求至少$c=1$，因此从【4】中我们挑出$x=3$就行了；</li>
<li>再来看【1】和【3】，可以发现有交集元素6，7，由于【1】中要求至少$c=3$，因此从【1】中挑选出$x=3,x=7,x=6,x=7$</li>
<li>再来看【2】和【3】，可以发现有交集元素8，由于【3】要求至少选出$c=1$，因此从【3】中我们挑出$x=8$</li>
<li>再来看【2】和【5】，有交集元素10，由于【5】要求至少选出$c=1$，因此从【5】中我们挑出$x=10$，由于【2】要求选出来的$x$的个数必须不少于$c=3$个，因此从【2】中挑出$x=8,9,10$</li>
<li>综上，我们选出来的$x$有<code>[3,6,7,8,9,10]</code>，也就是最少选出6个数，就可以构成一个整数集合$Z$，此时可以满足题目给出的五个限制条件</li>
</ul>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>这题我们需要用到差分约束来求解，同时还需要用到前缀和（这点比较难想）</p>
<p>我们设<code>S[i]</code>来表示从区间$[1,i]$中选出的$x$的个数。这里$0\leq a_i,b_i\leq 50000$，但是呢，由于前缀和需要用到$S[0]$，由定义可知$S[0]=0$，那么我们可以让$a_i,b_i$都+1，即向右平移一个单位，空出0这个位置来表达前缀和$S[0]$，平移之和并不影响最终结果。因此，此时$1\leq a_i,b_i\leq 50001$。</p>
<p>那么题目的意思也就是让我们从区间<code>[1,50001]</code>从选出最少的$x$的个数，来构成整数$Z$的集合。这道题肯定是会有解的，因为最坏情况下，我们把区间$[1,50001]$中的所有数都选择了，那么此时集合$Z$就有50001个元素，因此一定是有解的。那么这个解该怎么表示呢？由于我们不知道具体要选出多少个数，但是我们知道范围上限是50001，也就是$S[50001]$表示的是从区间$[1,50001]$中选出的$x$的最少的个数。因此，我们真正要求解的就是$S[50001]_{min}$</p>
<p>那么这题该怎么用差分约束呢？我们需要根据思路和题目描述自己来找出差分约束的条件：</p>
<ul>
<li>$S_i\geq S_{i-1}，1\leq i\leq 50001$，为什么呢？因为$S_i$表示从区间$[1,i]$中选出的$x$的个数，而$S_{i-1}$表示从区间$[1,i-1]$中选出的$x$的个数，因此$S_i$必定是要$\geq S_{i-1}$的，由定义出发就可以知道</li>
<li>$S_i-S_{i-1}\leq 1$，为什么呢？因为$S_i$表示从区间$[1,i]$中选出的$x$的个数，而$S_{i-1}$表示从区间$[1,i-1]$中选出的$x$的个数，那么$S_i-S_{i-1}$就表示第$i$个数，即整数$i$它被选的个数，由于整数$i$要么没有，如果有的话则最多只会有一个，因此由含义就可以知道选出来的第$i$个数，它被选的个数最多为1</li>
<li>由题目描述”区间$[a,b]$中最少要有$c$个数，可推知：$S_b-S_{a-1}\geq c$</li>
</ul>
<p>由于想要求的是变量$S[50001]$的最小值，运用差分约束，那么就需要跑最长路。将上面三个限制条件重新整理一下：</p>
<ul>
<li>$S_i\geq S_{i-1}+0$，那么就是从节点$S_{i-1}$向节点$S_i$连一条权值为0的边</li>
<li>$S_{i-1}\geq S_i-1$，那么就是从节点$S_{i}$向节点$S_{i-1}$连一条权值为-1的边</li>
<li>$S_b\geq S_{a-1}+c$，那么就是从节点$S_{a-1}$向节点$S_b$连一条权值为$c$的边</li>
</ul>
<p>但是呢，我们还需要思考一下，是否满足差分约束的条件：<strong>从源点出发，是否一定可以走到所有的边</strong>，这是差分约束正确性的前提条件。根据第一个约束条件可知，从$S_{i-1}$节点可以走到节点$S_i$，因此可以从$S_0$走到$S_1$，$S_1$走到$S_2$，$\cdots$，从$S_{50000}$走到$S_{50001}$，因此，从源点出发，是可以走到所有的边的</p>
<blockquote>
<p>问题：为什么这里的边数要开3倍呢？</p>
<p>由第一、二个约束条件可知，$S_{i-1}$和$S_{i}$之间都有边，即双向边，由第三个约束条件可知，则还会连出一条边，因此会有3条边。</p>
</blockquote>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">50010</span>,M=<span class="number">150010</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],w[M],idx;</span><br><span class="line"><span class="comment">//dist[i]表示从起点到节点i的最长距离</span></span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="comment">//循环队列</span></span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"><span class="comment">//判断一个节点是否已经入队了</span></span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    w[idx]=c;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里一定有解，因此并不需要判断是否存在负环了</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//求最长路,则初始化为负无穷</span></span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">-0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">1</span>;</span><br><span class="line">    dist[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    st[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(hh!=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//取出队头元素</span></span><br><span class="line">        <span class="keyword">int</span> t=q[hh++];</span><br><span class="line">        <span class="comment">//循环队列满了</span></span><br><span class="line">        <span class="keyword">if</span>(hh==N)</span><br><span class="line">            hh=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//节点t出队</span></span><br><span class="line">        st[t]=<span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//遍历节点t的所有邻接点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];<span class="comment">//t的邻接点编号j</span></span><br><span class="line">            <span class="keyword">if</span>(dist[j]&lt;dist[t]+w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//通过节点t来更新节点j到起到的最长距离</span></span><br><span class="line">                dist[j]=dist[t]+w[i];</span><br><span class="line">                <span class="comment">//如果节点j还没有入队</span></span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q[tt++]=j;<span class="comment">//节点j入队</span></span><br><span class="line">                    <span class="comment">//队尾指针走到了末尾,则重新回到队头</span></span><br><span class="line">                    <span class="keyword">if</span>(tt==N)</span><br><span class="line">                        tt=<span class="number">0</span>;</span><br><span class="line">                    <span class="comment">//标记节点j已经入队了</span></span><br><span class="line">                    st[j]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化表头为-1</span></span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//给第一、二个约束条件建图</span></span><br><span class="line">        <span class="built_in">add</span>(i<span class="number">-1</span>,i,<span class="number">0</span>);   </span><br><span class="line">        <span class="built_in">add</span>(i,i<span class="number">-1</span>,<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        <span class="comment">//记得向右平移一位</span></span><br><span class="line">        a++,b++;</span><br><span class="line">        <span class="built_in">add</span>(a<span class="number">-1</span>,b,c);   <span class="comment">//给第三个约束条件建图</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//跑以便spfa求出每个节点到起点的最长路</span></span><br><span class="line">    <span class="built_in">spfa</span>();</span><br><span class="line">    <span class="comment">//dist[50001]表示节点S(50001)到起点的最长距离,也就是题目中想要求的最小值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dist[<span class="number">50001</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title>差分约束算法</title>
    <url>/2021/07/11/Algorithm-Improvement/Chapter3---Gragh-Theory/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="差分约束系统"><a href="#差分约束系统" class="headerlink" title="差分约束系统"></a>差分约束系统</h1><hr>
<p>差分约束系统是一种特殊的$N$元一次不等式组。它包含$N$个变量$X_1$~$X_N$以及$M$个约束条件，每个约束条件都是由两个变量做差构成的，形如$X_i-X_j\leq c_k$，其中$c_k$是常数（可以是非负数，也可以是负数），$1\leq i,j\leq N,1\leq k\leq M$。我们要解决的问题就是：求一组解$X_1=a_1,X_2=a_2,\cdots,X_N=a_N$，即解$X=(a_1,a_2,\cdots,a_N)$使得所有约束条件都能得到满足。</p>
<p>差分约束系统的每个约束条件$X_i-X_j\leq c_k$可以变形为$X_i\leq X_j+c_k$，这与单源最短路径问题中的三角不等式$dist[y]\leq dist[x]+z$非常相似，注意这个式子是更新过后的。因此，我们可以把每个变量$X_i$看作是有向图中的一个节点$i$，对于每个约束条件$X_i-X_j\leq c_k$，从节点$j$向节点$i$连一条长度为$c_k$的有向边。</p>
<p><strong>引理：</strong></p>
<p>设$X=(x_1,x_2,\cdots,x_n)$是一个差分约束系统的一个解，$d$为任意常数，那么$X+d=(x_1+d,x_2+d,\cdots,x_n+d)$也是该系统的解。</p>
<p>证明：对于每个$x_i$和$x_j$，有$(x_j+d)-(x_i+d)=x_j-x_i$。因此，若$X$是这个差分约束系统的一个解，那么$X+d$也是这个系统的解</p>
<p>例如：</p>
<ul>
<li>$x_1-x_2\leq 0$</li>
<li>$x_1-x_5\leq -1$</li>
<li>$x_2-x_5\leq 1$</li>
<li>$x_3-x_1\leq 5$</li>
<li>$x_4-x_1\leq 4$</li>
<li>$x_4-x_3\leq -1$</li>
<li>$x_5-x_3\leq -3$</li>
<li>$x_5-x_4\leq -3$</li>
</ul>
<p>该问题的一个解为$X=(-5,-3,0,-1,-4)$，令一个解为$X’=(0,2,5,4,1)$，这两个解是有联系的，$X’$中的每个元素比$X$中的相应元素大5</p>
<p>这也正说明了，如果$X$是一个差分约束系统的解，那么$X+d$也是这个系统的解</p>
<p>假设$\forall i,X_i\leq c$，然后再增加一个超级源点0号节点，令$X_0=0$，令$d=-X_0$，等式两边同时加上$d$，可得$X_i-X_0\leq c-X_0$，即$X_i-X_0\leq c$。这样一来，就多了$N$个形如$X_i-X_0\leq 0$的约束条件，应该从节点0向每个节点$i$连一条长度为0的有向边。</p>
<hr>
<h3 id="约束图"><a href="#约束图" class="headerlink" title="约束图"></a>约束图</h3><p>对于$n$个变量，$m$个约束条件来说，其实就是对应于图论中的$n$个节点，$m$条边。对于$i=1,2,\cdots,n$，图中的每一个顶点$v_i$对应着$n$个未知量中的一个$x_i$，图中的每个有向边对应着关于两个未知量的$m$个不等式的其中一个。</p>
<p>对于一个差分约束系统来说，相应的约束图是一个带权有向图$G=(V,E)$，其中$V=${$v_0,v_1,\cdots,v_n$}，而且$E=${$(v_i,v_j):x_j-x_i\leq b_k$}$\bigcup$ {$(v_0,v_1),(v_0,v_2),\cdots,(v_0,v_n)$}</p>
<p>这里引入超级源点$v_0$是为了保证其他每个顶点$v_1,v_2,\cdots,v_n$均从$v_0$可达。因此，顶点集合$V$由对应于每个未知量$x_i$的顶点$v_i$和附加的顶点$v_0$所组成。边的集合$E$由对应于每个差分约束条件的边与对应于每个未知量$x_i$的边$(v_0,v_i)$所构成。如果$x_j-x_i\leq b_k$是一个差分约束，则边$(v_i,v_j)$的权$w(v_i,v_j)=b_k$。从超级源点$v_0$出发的每条边的权值均为0。</p>
<p>约束图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210707093851.png" alt="image-20210707093808678"></p>
<hr>
<h3 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h3><p>给定一个差分约束系统，设$G=(V,E)$为其相应的约束图。如果$G$不包含负权回路(即负环)，那么</p>
<p>$X=(\delta (v_0,v_1),\delta (v_0,v_2),\delta (v_0,v_3),\cdots,\delta (v_0,v_n))$</p>
<p>是此系统的一个可行解。当且仅当$G$中存在负环时，该系统不存在可行解。</p>
<p>上式中$\delta(v_0,v_1)$表示超级源点$v_0$到节点$v_1$的真实的最短距离，其他同理。跑一边最短路算法后得到的$dist[v_1]$其实就是$\delta(v_0,v_1)$</p>
<p><strong>证明：</strong></p>
<ul>
<li><p>首先来证明，如果$G$中不存在负环时，那么可以求出一个可行解。考察任意边$(v_i,v_j)\in E$，由三角不等式$\delta (v_0,v_j)\leq \delta (v_0,v_i)+w(v_i,v_j)$，即$\delta (v_0,v_j)-\delta (v_0,v_i)\leq w(v_i,v_j)$。因此，设$x_i=\delta (v_0,v_i),x_j=\delta(v_0,v_j)$，带入上式子可知满足对应边$(v_i,v_j)$的差分约束$x_j-x_i\leq w(v_i,v_j)$</p>
</li>
<li><p>接下来再来证明，如果$G$中存在负环，那么差分约束系统不存在可行解。设负权回路为$c=$&lt;$v_1,v_2,\cdots,v_k$&gt;，其中$v_1=v_k$（因为节点$v_0$没有入边，所以它不可能再回路$c$上）。回路$c$对应着如下的差分约束：</p>
<ul>
<li>$x_2-x_1\leq w(v_1,v_2)$</li>
<li>$x_3-x_2\leq w(v_2,v_3)$</li>
<li>$\cdots $</li>
<li>$x_k-x_{k-1}\leq w(v_{k-1},v_k)$</li>
<li>$x_1-x_k\leq w(v_k,v_1)$</li>
</ul>
<p>假设存在满足$k$个不等式的一个解$X$，那么也满足上述$k$个不等式相加所得到的不等式。如果把这些不等式相加，就会发现每个变量$x_i$的正负项相互抵消了，结果左边项和为0，而右边项和为$w(c)$，因此有$0\leq w(c)$。但是由于$c$是一个负权回路，因此有$w(c)&lt;0$，因此得到矛盾$0\leq w(c)&lt;0$，由此得证</p>
</li>
</ul>
<hr>
<p>求不等式组的可行解：</p>
<p>源点需要满足的条件：<strong>从源点出发，一定可以走到所有边</strong></p>
<p>步骤：</p>
<ul>
<li>先将每个不等式$x_i\leq x_j+c_k$，转化为一条从$x_j$走到$x_i$，长度为$c_k$的一条边</li>
<li>找到一个超级源点，使得该源点一定可以遍历到所有边</li>
<li>从源点求一边单源最短路<ul>
<li>如果存在负环，则原不等式组一定无解</li>
<li>如果不存在负环，则$X=(dist[v_1],dist[v_2],\cdots,dist[v_n])$的一个可行解</li>
</ul>
</li>
</ul>
<p>在某些题目中，约束条件形如$X_i-X_j\geq c_k$，我们仍然可以从$j$到$i$连一条长度为$c_k$的有向边，只不过现在应该要计算单源最长路，若图中存在正环则无解。当然，我们也可以把约束条件转换为$X_j-X_i\leq -c_k$，再按照单源最短路进行计算</p>
<hr>
<h3 id="变量的最大值和最小值"><a href="#变量的最大值和最小值" class="headerlink" title="变量的最大值和最小值"></a>变量的最大值和最小值</h3><p>对于给定的一组不等式关系，如何求出每个变量的最大值或者最小值呢？</p>
<blockquote>
<p>什么是最大值或最小值？</p>
<p>这里的意思是说，比如你求出了一个解$X=(x_1,x_2,\cdots,x_n)$，那么$X’=(x_1+d,x_2+d,\cdots,x_n+d)$也是一个解，$X’’=(x_1+2d,x_2+2d,\cdots,x_3+3d)$也是一个解，那么我想知道某个变量$x_i$的最大值，那么到底是取$x_i$还是$x_i+d$还是$x_i+2d$呢？同理，求某个变量$x_i$的最小值也是一样的含义。</p>
</blockquote>
<p>结论：</p>
<ul>
<li>如果求的是最小值，那么应该求单源最长路</li>
<li>如果求的是最大值，那么应该求单源最短路</li>
</ul>
<p><strong>证明：</strong></p>
<p>以求$x_i$的最大值为例：</p>
<p>求所有从$x_i$出发，构成的多个形如如下的不等式链：</p>
<p>$x_i\leq x_j+c_m\leq x_k+c_m+c_n\leq \cdots \leq x_0+c_0+c_4+\cdots +c_n+c_m$，其中$x_0=0,c_0=0$，令$F=$$x_0+c_0+c_4+\cdots +c_n+c_m$</p>
<p>那么$x_i$的最大值，要注意$F$可能多很多个，因此，我们取$F$中最小的那个值，就是$x_i$的最大值</p>
<p>例如$x_i\leq 5,x_i\leq 7,x_i\leq 9$，那么$x_i$的最大值为5。假设$x_i$取最大值为9，那么就不满足$x_i\leq 5$和$x_i\leq 7$了。</p>
<p>把上述转换成图论的问题，其实就是求$dist[i]$的最小值（因为$F$表示的是从起点出发，到达某个点的距离。那么求$F$的最小值，其实就是求单源最短路），那么就可以用最短路来求解。</p>
<p>以求$x_i$的最小值为例：</p>
<p>求所有从$x_i$出发，构成的多个形如如下的不等式链：</p>
<p>$x_i\geq x_j+c_m\geq x_k+c_m+c_n\geq \cdots \geq x_0+c_0+c_4+\cdots +c_n+c_m$，其中$x_0=0,c_0=0$，令$F=$$x_0+c_0+c_4+\cdots +c_n+c_m$</p>
<p>那么$x_i$的最小值，要注意$F$可能多很多个，因此，我们取$F$中最大的那个值，就是$x_i$的最小值</p>
<p>例如$x_i\geq 5,x_i\geq 7,x_i\geq 9$，那么$x_i$的最大值为9。假设$x_i$取最小值为5，那么就不满足$x_i\geq 7$和$x_i\geq 9$了。</p>
<p>下面举个图例：</p>
<ul>
<li>$x_2-x_1\leq c_1$</li>
<li>$x_3-x_2\leq c_2$</li>
<li>$x_3-x_1\leq c_3$</li>
</ul>
<p>那么，我们可以求出这样的：</p>
<ul>
<li>$x_3\leq x_1+c_3$</li>
<li>$x_3\leq x_1+c_1+c_2$</li>
</ul>
<p>可以看出，约束变量$x_3$的有两个条件，如果画到图中，就对应于有2条路径。那么当我们要求$x_3$的最大值时，取的肯定是$x_1+c_3$和$x_1+c_1+c_2$中的最小值，这样才能保证满足这两个约束条件，进而满足题目给定的所有原始的约束条件。</p>
<p>我们添加超级源点$s$即$v_0$，那么有$x_1-x_0\leq c_0$，因此有如下：</p>
<ul>
<li>$x_3\leq x_0+c_0+c_3$</li>
<li>$x_3\leq x_0+c_0+c_1+c_2$</li>
</ul>
<p>其中$x_0=0,c_0=0$</p>
<p>解释一样$x_0+c_0+c_3$的含义：它表示从源点$v_0$到达节点$v_3$所走过的路径上的权值之和。$x_0+c_0+c_1+c_2$也是一样的含义。</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210707094207.png" alt=""></p>
<p>对应有两条路径：</p>
<ul>
<li>$v_0\implies v_1\implies v_3$，从源点$v_0$走到节点$v_3$，所走过的路径之和为$c_0+c_3$</li>
<li>$v_0\implies v_1\implies v_2\implies v_3$，从源点$v_0$走到节点$v_3$，所走过的路径之和为$c_0+c_1+c_2$</li>
<li>可以发现，既然我们知道了等式右边的式子含义，其实就是求从源点出发到达某个节点的距离，由于可能存在多条路径，因此有多个值，那么我们只需要根据单源最短路径算法，就可以求出最小的那个值了，设为$F_{min}$。因此，如果想要求某个变量$x_i$的最大值，那么就要满足$Max(x_i)\leq F_{min}$。这也就是说，求变量$x_i$的最大值，等价于跑一下单源最短路，求出最短路径的权值之和</li>
</ul>
<p>因此，相应的就可以知道，要求$x_i$的最小值，其实就是跑一下单源最长路，求出最长路径的权值之和。</p>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>$x_i\geq x_j+c$，则从节点$j$向节点$i$连一条长度为$c$的边，要求变量$x_i$的最小值，则跑一下最长路即可</li>
<li>$x_i\leq x_j+c$，则从节点$j$向节点$i$连一条长度为$c$的边，要求变量$x_i$的最大值，则跑一下最短路即可</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title>排队布局</title>
    <url>/2021/07/10/Algorithm-Improvement/Chapter3---Gragh-Theory/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/%E6%8E%92%E9%98%9F%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h1 id="排队布局"><a href="#排队布局" class="headerlink" title="排队布局"></a>排队布局</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210710145142.png" alt="image-20210710145142511"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>这题是需要用到差分约束。对于差分约束，我们最主要的是根据题目描述，找出题目中的所有不等式关系，我们设$x_i$表示第$i$头牛的位置：</p>
<ul>
<li>根据“一些奶牛相互间存有好感，它们希望两者之间的距离不超过一个给定的数 L”，可以得到奶牛$a$和奶牛$b$之间至多相隔距离$L$，即有$x_b-x_a\leq L$</li>
<li>根据“一些奶牛相互间非常反感，它们希望两者间的距离不小于一个给定的数 D”，可以得到奶牛$a$和奶牛$b$之间至少相隔距离$D$，即有$x_b-x_a\geq D$</li>
<li>根据“奶牛排在队伍中的顺序和它们的编号是相同的，且同一位置上可以站多头牛”，可以得到$x_{i+1}\geq x_i$</li>
</ul>
<p>那么，我们再来观察题目要求的是$1$号奶牛和$N$号奶牛之间的最大距离，即要求变量$x_n$的最大值。那么，由差分约束可知，需要跑单源最短路，求出最短距离。</p>
<p>但是，我们要考虑，是否满足 <strong>从源点出发，可以到达所有边</strong>这个条件。由于从上面的三个不等式中，并不能看出，从某个点出发，一定能走完所有边。因此，我们就需要添加一个虚拟源点了，所以我们添加超级源点$x_0$，然后从它出发，就可以到达所有边了，那么就可以使用差分约束的方法了。</p>
<p>需要找一个超级源点（记超级源点为$x_0$），发现这里求的距离都是牛之间的相对距离，所以联想到令$x_0=0$，又因为求的是形如$x_i\leq x_j+c$的不等式，所以将所有点放在超级源点$0$号点的左侧就可以得出 $x_i\leq x_0+0$的不等式,这样从源点出发可以遍历所有的点，那么就可以遍历到所有的边。</p>
<p>因此，我们重新整理一下，上面的三个式子，统一写成$\leq$的形式（因为这是差分约束中求变量最大值的写法）：</p>
<ul>
<li>$x_b\leq x_a+L$，则从节点$x_a$向节点$x_b$连一条长度为$L$的边</li>
<li>$x_a\leq x_b-D$，则从节点$x_b$向节点$x_a$连一条长度为$-D$的边</li>
<li>$x_{i}\leq x_{i+1}+0$，则从节点$x_{i+1}$向节点$x_i$连一条长度为0的边</li>
</ul>
<p>对于建立虚拟源点问题，有两种方法：</p>
<ul>
<li>真正开辟一个超级源点0号点，那么此时建立好图后，就有$n+1$个节点</li>
<li>并不需要真正开辟一个虚拟源点，我们只需要刚开始的时候就把所有节点都放入队列中就行了，这种情况就等效于建立一个超级源点了（注意此时仍是$n$个节点，因为并没有把超级源点0号节点建立出来）。如何理解呢？<ul>
<li>我们这么想：对于spfa算法来说，假设我们真正设立了一个超级源点，这个源点连向其余的$n$个节点。那么第一次扩展时，就会把超级源点的所有邻接点都加入队列q中，然后更新这$n$个节点到超级源点的距离为0。也就是说，如果我们真的建立了一个超级源点，那么第一次扩展时，就会把它的所有邻接点（$n$个顶点）都更新最短距离为0。那么这不就等效于 《我们不用真的开辟一个超级源点，而是一开始就把这$n$个顶点都放入spfa算法的队列q中，然后初始化这$n$个点的距离为$0$》嘛？只不过这里并不需要第一次扩展而已啦，想法都是一样的，只不过实现方法有所不同而已</li>
</ul>
</li>
</ul>
<p>下面使用两种方法来分别实现以上的两种想法</p>
<p>然后这一题，有三个问题：</p>
<ul>
<li>对于第一个问题，我们可以跑一遍spfa算法求负环，如果存在负环，那么在说明不存在满足要求的方案，输出-1即可</li>
<li>对于第二个问题，想要求的是“1号牛和n号牛的最小距离是多少？即求$x_n-x_1$”，因此我们可以让1号节点称为起点，即设$x_1=0$，然后用spfa算法求出1号节点到其他各点的最短距离，最终求出$dist[n]$，如果$dist[n]\geq INF$则说明1号奶牛到$n$号奶牛之间不存在约束关系，距离可以无限远，输出-2。</li>
<li>对于第三个问题，如果求出的$dist[n]&lt;INF$，那么就直接输出此时的$dist[n]$即可</li>
</ul>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><strong>算法一：真正开辟一个超级源点0号节点</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>,M=<span class="number">3e4</span>+<span class="number">10</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n,m1,m2;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],w[M],idx;</span><br><span class="line"><span class="comment">//记录每个点到起点的最短距离</span></span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="comment">//spfa算法的循环队列</span></span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"><span class="comment">//记录每个点到起点一共经过了多少条边,用来判断负环</span></span><br><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line"><span class="comment">//用来判断某个节点是否已经放进q队列中</span></span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="comment">//建图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    w[idx]=c;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//spfa算法进行 判断负环和求出最短距离</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span> cnt);</span><br><span class="line">    <span class="built_in">memset</span>(st,<span class="number">0</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">1</span>;</span><br><span class="line">    dist[s]=<span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>]=s;</span><br><span class="line">    st[s]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(hh!=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//取出队头元素</span></span><br><span class="line">        <span class="keyword">int</span> t=q[hh++];</span><br><span class="line">        <span class="comment">//队满</span></span><br><span class="line">        <span class="keyword">if</span>(hh==N)</span><br><span class="line">        hh=<span class="number">0</span>;</span><br><span class="line">        st[t]=<span class="literal">false</span>;<span class="comment">//队头元素出队</span></span><br><span class="line">        <span class="comment">//遍历t的所有邻接点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];<span class="comment">//取出t的邻接点j</span></span><br><span class="line">            <span class="comment">//松弛</span></span><br><span class="line">            <span class="keyword">if</span>(dist[j]&gt;dist[t]+w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j]=dist[t]+w[i];</span><br><span class="line">                <span class="comment">//记录j到起点所走过的边数</span></span><br><span class="line">                cnt[j]=cnt[t]+<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//有n个点,如果此时节点j到起点所经历的边数&gt;=n,则说明有n+1个顶点,则有负环</span></span><br><span class="line">                <span class="keyword">if</span>(cnt[j]&gt;=n)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//如果j还没有放入队列q中</span></span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q[tt++]=j;  <span class="comment">//把j放入队列q中</span></span><br><span class="line">                    <span class="comment">//如果走到队尾</span></span><br><span class="line">                    <span class="keyword">if</span>(tt==N)</span><br><span class="line">                    tt=<span class="number">0</span>;</span><br><span class="line">                    st[j]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//说明不存在负环</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化表头</span></span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m1,&amp;m2);</span><br><span class="line">    <span class="comment">//建立了一个真正的超级源点,因此需要从超级源点0号点到其他n个节点连一条长度为0的边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="built_in">add</span>(<span class="number">0</span>,i,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//第一个约束条件,节点i+1向节点i连一条长度为0的边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    <span class="built_in">add</span>(i+<span class="number">1</span>,i,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(m1--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,L;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;L);</span><br><span class="line">        <span class="comment">//保证b要&gt;=a</span></span><br><span class="line">        <span class="keyword">if</span>(a&gt;b)</span><br><span class="line">        <span class="built_in">swap</span>(a,b);</span><br><span class="line">        <span class="comment">//第二个约束条件,节点a向节点b连一条长度为L的边</span></span><br><span class="line">        <span class="built_in">add</span>(a,b,L);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m2--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,D;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;D);</span><br><span class="line">        <span class="comment">//保证b要&gt;=a</span></span><br><span class="line">        <span class="keyword">if</span>(a&gt;b)</span><br><span class="line">        <span class="built_in">swap</span>(a,b);</span><br><span class="line">        <span class="comment">//第三个约束条件,节点b向节点a连一条长度为-D的边</span></span><br><span class="line">        <span class="built_in">add</span>(b,a,-D);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//存在负环</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">spfa</span>(<span class="number">0</span>))</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把1号节点当作起点</span></span><br><span class="line">        <span class="built_in">spfa</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//说明1号奶牛到N号奶牛的距离可以任意大</span></span><br><span class="line">        <span class="keyword">if</span>(dist[n]==INF)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;-2&quot;</span>);</span><br><span class="line">        <span class="comment">//否则就输出1号奶牛到N号奶牛的最短距离</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dist[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>算法二：不需要开辟一个超级源点0号节点</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>,M=<span class="number">3e4</span>+<span class="number">10</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n,m1,m2;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],w[M],idx;</span><br><span class="line"><span class="comment">//记录每个点到起点的最短距离</span></span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="comment">//spfa算法的循环队列</span></span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"><span class="comment">//记录每个点到起点一共经过了多少条边,用来判断负环</span></span><br><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line"><span class="comment">//用来判断某个节点是否已经放进q队列中</span></span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="comment">//建图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    w[idx]=c;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//spfa算法进行 判断负环和求出最短距离</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span> cnt);</span><br><span class="line">    <span class="built_in">memset</span>(st,<span class="number">0</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//将这num个节点都加入队列中,并且每个节点的最短距离初始化为0,标记每个节点都放入q队列中了</span></span><br><span class="line">    <span class="comment">//那么就等效于开辟了一个超级源点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        q[tt++]=i;</span><br><span class="line">        dist[i]=<span class="number">0</span>;</span><br><span class="line">        st[i]=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(hh!=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//取出队头元素</span></span><br><span class="line">        <span class="keyword">int</span> t=q[hh++];</span><br><span class="line">        <span class="comment">//队满</span></span><br><span class="line">        <span class="keyword">if</span>(hh==N)</span><br><span class="line">        hh=<span class="number">0</span>;</span><br><span class="line">        st[t]=<span class="literal">false</span>;<span class="comment">//队头元素出队</span></span><br><span class="line">        <span class="comment">//遍历t的所有邻接点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];<span class="comment">//取出t的邻接点j</span></span><br><span class="line">            <span class="comment">//松弛</span></span><br><span class="line">            <span class="keyword">if</span>(dist[j]&gt;dist[t]+w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j]=dist[t]+w[i];</span><br><span class="line">                <span class="comment">//记录j到起点所走过的边数</span></span><br><span class="line">                cnt[j]=cnt[t]+<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//有n个点,如果此时节点j到起点所经历的边数&gt;=n,则说明有n+1个顶点,则有负环</span></span><br><span class="line">                <span class="keyword">if</span>(cnt[j]&gt;=n)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//如果j还没有放入队列q中</span></span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q[tt++]=j;  <span class="comment">//把j放入队列q中</span></span><br><span class="line">                    <span class="comment">//如果走到队尾</span></span><br><span class="line">                    <span class="keyword">if</span>(tt==N)</span><br><span class="line">                    tt=<span class="number">0</span>;</span><br><span class="line">                    st[j]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//说明不存在负环</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化表头</span></span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m1,&amp;m2);</span><br><span class="line">    <span class="comment">//第一个约束条件,节点i+1向节点i连一条长度为0的边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    <span class="built_in">add</span>(i+<span class="number">1</span>,i,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(m1--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,L;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;L);</span><br><span class="line">        <span class="comment">//保证b要&gt;=a</span></span><br><span class="line">        <span class="keyword">if</span>(a&gt;b)</span><br><span class="line">        <span class="built_in">swap</span>(a,b);</span><br><span class="line">        <span class="comment">//第二个约束条件,节点a向节点b连一条长度为L的边</span></span><br><span class="line">        <span class="built_in">add</span>(a,b,L);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m2--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,D;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;D);</span><br><span class="line">        <span class="comment">//保证b要&gt;=a</span></span><br><span class="line">        <span class="keyword">if</span>(a&gt;b)</span><br><span class="line">        <span class="built_in">swap</span>(a,b);</span><br><span class="line">        <span class="comment">//第三个约束条件,节点b向节点a连一条长度为-D的边</span></span><br><span class="line">        <span class="built_in">add</span>(b,a,-D);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//存在负环</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">spfa</span>(n))</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把1号节点当作起点</span></span><br><span class="line">        <span class="built_in">spfa</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//说明1号奶牛到N号奶牛的距离可以任意大</span></span><br><span class="line">        <span class="keyword">if</span>(dist[n]==INF)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;-2&quot;</span>);</span><br><span class="line">        <span class="comment">//否则就输出1号奶牛到N号奶牛的最短距离</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dist[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title>糖果</title>
    <url>/2021/07/09/Algorithm-Improvement/Chapter3---Gragh-Theory/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/%E7%B3%96%E6%9E%9C/</url>
    <content><![CDATA[<h1 id="糖果"><a href="#糖果" class="headerlink" title="糖果"></a>糖果</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://gitee.com/linmacos/blog-image/raw/master/img/20210709201853.png" alt="image-20210709201852949"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>从题目描述中可知，这道题主要是要运用差分约束来求解。求至少需要准备多少个糖果，也就是求变量$a_i$的最小值，那么也就是需要跑最长路。</p>
<ul>
<li><p>根据题目描述如果$X=1$，则$A=B$，即有$A\geq B+0$，$B\geq A+0$ 。因此需要从节点$B$向节点$A$连一条权值为0的边，从节点$A$向节点$B$连一条权值为0的边</p>
</li>
<li><p>根据题目描述如果$X=2$，则$B\geq A+1$，因此从节点$A$向节点$B$连一条权值为1的边</p>
</li>
<li><p>根据题目描述如果$X=3$，则$A\geq B+0$，因此从节点$B$向节点$A$连一条权值为0的边</p>
</li>
<li><p>根据题目描述如果$X=4$，则$A\geq B+1$，因此从节点$B$向节点$A$连一条权值为1的边</p>
</li>
<li><p>根据题目描述如果$X=5$，则$B\geq A+0$，因此从节点$A$向节点$B$连一条权值为0的边</p>
</li>
<li><p>同时，由题干”要求每个小朋友都要分到苹果“，因此可以知道$a_i&gt;0$，即$a_i\geq 1$，那么可以添加一个超级源点$a_0$，$a_0$为0。那么$a_i+a_0\geq a_0+1$，即$a_i\geq a_0+1$，因此从超级源点$a_0$向节点$a_i$连一条权值为1的边</p>
</li>
</ul>
<p>注意，当我们用差分约束时，要考虑是否满足“<strong>从源点出发，能够到达所有边</strong>”这个条件。从$a_i\geq a_0+1$可知，可以从源点$0$号节点到达任意的节点$i$，既然可以从源点出发，到达任意节点$i$，那么也就是说，可以到达所有边，因此满足了前提条件。但是要注意，如果知道了从源点出发能够到达所有边，那么则不一定能推出可以到达所有节点，可以有可能某个节点它是孤立的，而剩余的所有节点（含有源点）是连通的。</p>
<ul>
<li>一般来说，如果已知$a_i\geq a_0+c$，那么就说明需要额外建立一个超级源点，并且从超级源点出发能够到达所有边</li>
<li>但是如果已知$a_i\geq a_{i-1}+c$，则不能说明从源点出发能到达所有边。因此也是需要添加超级源点。这样才能使得从超级源点出发能够到达所有边</li>
</ul>
<blockquote>
<p>问题：这里为什么是用栈而不是用循环队列呢？</p>
<p>对于spfa判负环，一般是对STL中的queue或者是手写循环队列。但是这一题比较玄学，用栈竟然是一种优化…</p>
<p>因为队列下标是递增的，进队次数可能会很多，所以访问到的下标可能很大。但栈不管插入多少次，最多只会用前n个位置。</p>
<p>这个优化不太稳定，比较玄学。优化大致上基于如下想法：如果存在一个环，那么用栈来搜索时，会按照深度优先的顺序，那么很快就会沿着环找到起点。</p>
</blockquote>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//这里的边的数目要开3倍,是因为比如点A-&gt;点B,点B-&gt;点A,同时还有超级源点0-&gt;点B</span></span><br><span class="line"><span class="comment">//因此对于点B来说,就有3条边</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],w[M],idx;</span><br><span class="line"><span class="comment">//注意数据范围可能会爆int</span></span><br><span class="line">LL dist[N];</span><br><span class="line"><span class="comment">//数组模拟栈,用来存储spfa算法中入栈的节点</span></span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"><span class="comment">//用来记录从起点到某个点所经过的边的个数</span></span><br><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line"><span class="comment">//判断某个点是否入栈</span></span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    w[idx]=c;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//spfa判负环</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//最长路,因此需要设置为负无穷大</span></span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">-0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="comment">//超级源点到自身距离为0</span></span><br><span class="line">    dist[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//超级源点0号节点入栈</span></span><br><span class="line">    q[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//标记超级源点0号节点入栈</span></span><br><span class="line">    st[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(hh!=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//取出栈顶元素</span></span><br><span class="line">        <span class="keyword">int</span> t=q[--tt];</span><br><span class="line">        <span class="comment">//标记栈顶元素这个节点已经出栈</span></span><br><span class="line">        st[t]=<span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//遍历栈顶元素t的所有邻接点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];<span class="comment">//取出邻接节点j</span></span><br><span class="line">            <span class="comment">//最长路的松弛条件：dist[j]&lt;dist[t]+w[i]</span></span><br><span class="line">            <span class="keyword">if</span>(dist[j]&lt;dist[t]+w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//更新节点j的最短距离</span></span><br><span class="line">                dist[j]=dist[t]+w[i];</span><br><span class="line">                <span class="comment">//从起点到节点j经过了cnt[t]+1条边</span></span><br><span class="line">                cnt[j]=cnt[t]+<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//由于我们建立的图中有超级源点0号节点+n个点=n+1个节点</span></span><br><span class="line">                <span class="comment">//但是如果但cnt[j]&gt;=n+1时,即从起点到节点j经过了n+1条边,则说明有(n+1)+1=n+2个节点</span></span><br><span class="line">                <span class="comment">//这与图中的n+1个节点相矛盾,因此由抽屉原理,知必存在负环</span></span><br><span class="line">                <span class="keyword">if</span>(cnt[j]&gt;=n+<span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//如果j这个节点还没有入栈</span></span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q[tt++]=j;<span class="comment">//将节点j入栈</span></span><br><span class="line">                    st[j]=<span class="literal">true</span>;<span class="comment">//标记节点j已经入栈了</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则,说明不存在负环</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//表头初始化为-1</span></span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x,a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;a,&amp;b);</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">add</span>(b,a,<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">add</span>(a,b,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">2</span>)</span><br><span class="line">            <span class="built_in">add</span>(a,b,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">3</span>)</span><br><span class="line">            <span class="built_in">add</span>(b,a,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">4</span>)</span><br><span class="line">            <span class="built_in">add</span>(b,a,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">add</span>(a,b,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//由于我们添加了超级源点0,因此从0号节点到其他的各个节点i都要建一条边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">add</span>(<span class="number">0</span>,i,<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//存在负环,则差分约束系统无解</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">spfa</span>())</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="comment">//不存在负环,则差分约束系统有解</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        LL res=<span class="number">0</span>;   <span class="comment">//记录最终答案</span></span><br><span class="line">        <span class="comment">//dist[i]表示从超级源点到节点i的最长路,也就是题目中每个小朋友应该在限制要求下分得的糖果</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            res+=dist[i];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title>雇佣收银员</title>
    <url>/2021/07/10/Algorithm-Improvement/Chapter3---Gragh-Theory/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/%E9%9B%87%E4%BD%A3%E6%94%B6%E9%93%B6%E5%91%98/</url>
    <content><![CDATA[<h1 id="雇佣收银员"><a href="#雇佣收银员" class="headerlink" title="雇佣收银员"></a>雇佣收银员</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210710201724.png" alt="image-20210710201724728"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>这题需要用差分约束来求解，具体思路如下：</p>
<p>我们定义以下变量的含义：</p>
<ul>
<li><code>num[i]</code>表示在$t_i$时刻来应聘的人数</li>
<li><code>x[i]</code>表示在$t_i$时刻公司选择雇佣的人数</li>
<li><code>R[i]</code>表示在$t_i$时刻需要的员工的最小需求量</li>
<li><code>S[i]</code>表示满足能在$t_i$时刻上岗工作的公司已经聘用的员工总数。比如当$t_i=24h$时，$S_i=100$，则说明这100个人，它们的工作服务时间段是包括$t_i$的，即在$t_i$时刻他们在岗工作</li>
</ul>
<p>根据以上定义，我们再来梳理一下不等式的关系：</p>
<ul>
<li><p>$0\leq x_i\leq num[i]$，因为聘用的人数不可能大于来应该的人数，因此有$x_i\leq num[i]$，而且公司选择聘用的人数不可能为-1，要么都不聘用，因此有$x_i\geq 0$</p>
</li>
<li><p>$x_{i-7}+x_{i-6}+x_{i-5}+x_{i-4}+x_{i-3}+x_{i-2}+x_{i-1}+x_i\geq R_i$，即公司聘用的能够在$t_i$时刻处于工作服务状态的员工总数，应该$\geq$在$t_i$时刻最小需要的员工总数</p>
<blockquote>
<p> <strong>问题：如何理解$x_{i-7}+x_{i-6}+x_{i-5}+x_{i-4}+x_{i-3}+x_{i-2}+x_{i-1}+x_i$这个式子呢？</strong></p>
<p>由于题目说了，员工一定会连续工作8个小时，即每个员工的工作服务时常为$8h$。那么我们就想，哪些员工他们的工作服务时间段是包括$t_i$这个时刻的呢？如果包括，则说明他们在$t_i$这个时刻，一定可以上岗工作服务。因此$x_{i-7}+x_{i-6}+x_{i-5}+x_{i-4}+x_{i-3}+x_{i-2}+x_{i-1}+x_i$就表示能在$t_i$时刻上岗工作服务的员工总数，那么这个总数就应该要$\geq t_i$时刻需要的员工的最小需求量$R_i$。</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210710211018.png" alt="image-20210710211017955"></p>
</blockquote>
</li>
</ul>
<p>$x_{i-7}+x_{i-6}+x_{i-5}+x_{i-4}+x_{i-3}+x_{i-2}+x_{i-1}+x_i$这个是连加的形式，那么很容易想到用前缀和来表示，即用$S[i]$来表示，其中$1\leq i\leq 24$。由于前缀和需要用到$S[0]$，因此我们需要把时间都向右平移一个单位，即现在时间为$1,2,\cdots,24$而不是再是原来的$0,1,2,\cdots,23$了。</p>
<p>那么则会由如下的不等式关系：</p>
<ul>
<li>$0\leq x_i\leq num[i]$，用前缀和来代替，那么就是$0\leq S_i-S_{i-1}\leq num[i]$</li>
<li>$S_i\geq R_i$</li>
</ul>
<p>由于题目要求的是变量的最小值，那么就需要跑单源最长路，求出最长距离。因此把不等式关系都改写为$x_i\geq x_j+c$的形式：</p>
<ul>
<li>$S_i\geq S_{i-1}+0$</li>
<li>$S_{i-1}\geq S_i-num[i]$</li>
</ul>
<p>对于$S_i\geq R_i$要分类讨论，因为时间它是循环的，当到了24之后就会变为0，又重新开始了。</p>
<ul>
<li><p>当$i\geq 8$时，则有$S_i-S_{i-8}\geq R_i$，分析如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210710213044.png" alt="image-20210710213044097"></p>
</li>
<li><p>当$0&lt;i\leq 7$时，则要分为两部分了。一部分是$1$到$7$这个时间段，由于不足8h，因此说明需要向$24$(包括它)之前的借一些时间，这主要就是因为时间是循环的。那么会得到$S_i+(S_{24}-S_{i+16})\geq R[i]$分析如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210710214154.png" alt="image-20210710214002246"></p>
</li>
</ul>
<p>进一步梳理不等式关系：</p>
<ul>
<li>$S_i\geq S_{i-1}+0$</li>
<li>$S_{i-1}\geq S_i-num[i]$</li>
<li>当$i\geq 8$时，$S_i\geq S_{i-8}+R[i]$</li>
<li>当$0&lt;i\leq 7$时，$S_i\geq S_{i+16}-S_{24}+R[i]$</li>
</ul>
<p>但是我们发现第四个约束条件中，有三个变量，平时我们都是遇到两个变量。其实，我们可以把$S_{24}$当作常量。那么如何把它作为常量呢？由于题目说要求最少需要雇佣多少名收银员，那么其实也就是说要求出$S_{24}$是多少。由于题目说了$0\leq N\leq 1000$，因此最坏情况下是至少聘用了$1000$个人。那么我们可以依次从0开始枚举到1000，我们把枚举的这个值$i$其实就是$S_{24}$，每次枚举一个$i$，都去跑一下spfa，当第一次枚举到某个值时，它满足所有的约束条件，那么这个值就是我们要求的最小的$S_{24}$，找到第一个就直接break。</p>
<p>注意这里当我们枚举到某个$S_{24}=c$时，也要把它写成差分约束的形式，即$S_{24}\geq c$和$S_{24}\leq c$，建立一个超级源点$S_0$（为0），那么有$S_{24}\geq S_0+c$和$S_{0}\geq S_{24}-c$</p>
<p>因此，总结一下，总共有以下的约束条件：</p>
<ul>
<li>$S_i\geq S_{i-1}+0$</li>
<li>$S_{i-1}\geq S_i-num[i]$</li>
<li>当$i\geq 8$时，$S_i\geq S_{i-8}+R[i]$</li>
<li>当$0&lt;i\leq 7$时，$S_i\geq S_{i+16}-S_{24}+R[i]$</li>
<li>$S_{24}\geq S_0+c$</li>
<li>$S_{0}\geq S_{24}-c$</li>
</ul>
<p>由第一个约束条件$S_i\geq S_{i-1}+0$可知，设立一个超级源点0号节点，则可以从超级源点出发，0-&gt;1-&gt;2-&gt;$\cdots$-&gt;$24$，因此可以到达所有节点，那么一定可以到达所有边。所以，这里满足了 “<strong>从源点出发，能遍历到所有边</strong>”这个条件，因此可以用差分约束。</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">30</span>,M=<span class="number">100</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],w[M],idx;</span><br><span class="line"><span class="comment">//R[i]表示i时刻公司需要雇佣的最小的员工的需求量</span></span><br><span class="line"><span class="comment">//num[i]表示i时刻来应聘的员工的数量</span></span><br><span class="line"><span class="keyword">int</span> R[N],num[N];</span><br><span class="line"><span class="comment">//dist[i]表示i节点到起点的最长距离</span></span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="comment">//循环队列q来存储入队节点</span></span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"><span class="comment">//cnt[i]表示从起点到达节点i一共经过了多少条边</span></span><br><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line"><span class="comment">//判断某个节点是否已经加入了q队列中</span></span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="comment">//建图函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    w[idx]=c;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将约束条件建成图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化表头</span></span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    idx=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//S[24]=c,写成了两个约束条件</span></span><br><span class="line">    <span class="built_in">add</span>(<span class="number">0</span>,<span class="number">24</span>,c);</span><br><span class="line">    <span class="built_in">add</span>(<span class="number">24</span>,<span class="number">0</span>,-c);</span><br><span class="line">    <span class="comment">//当0&lt;i&lt;=7时,给这个约束条件建图</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">7</span>;i++)</span><br><span class="line">    <span class="built_in">add</span>(i+<span class="number">16</span>,i,R[i]-c);</span><br><span class="line">    <span class="comment">//当i&gt;=8时,给这个约束条件建图</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">8</span>;i&lt;=<span class="number">24</span>;i++)</span><br><span class="line">    <span class="built_in">add</span>(i<span class="number">-8</span>,i,R[i]);</span><br><span class="line">    <span class="comment">//给S[i]&gt;=S[i-1]+0和S[i-1]&gt;=S[i]-num[i]建图</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">24</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">add</span>(i<span class="number">-1</span>,i,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">add</span>(i,i<span class="number">-1</span>,-num[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//spfa算法用来  判断是否存在正环  和 求出最长距离</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//对于枚举的每一个S[24]都去建图</span></span><br><span class="line">    <span class="built_in">build</span>(c);</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">-0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">memset</span>(st,<span class="number">0</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span> cnt);</span><br><span class="line">    <span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//由于真正地建立了超级源点S[0]</span></span><br><span class="line">    dist[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    st[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(hh!=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=q[hh++];</span><br><span class="line">        <span class="keyword">if</span>(hh==N)</span><br><span class="line">        hh=<span class="number">0</span>;</span><br><span class="line">        st[t]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j]&lt;dist[t]+w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j]=dist[t]+w[i];</span><br><span class="line">                cnt[j]=cnt[t]+<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//本来1~24共有24个节点,但是建立了1个超级源点,因此总共25个节点</span></span><br><span class="line">                <span class="comment">//cnt[j]&gt;=25说明从超级源点到节点j经过了25条边,那么则有26个节点</span></span><br><span class="line">                <span class="comment">//这与实际的25个节点不符合,因此存在正环</span></span><br><span class="line">                <span class="keyword">if</span>(cnt[j]&gt;=<span class="number">25</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q[tt++]=j;</span><br><span class="line">                    <span class="keyword">if</span>(tt==N)</span><br><span class="line">                    tt=<span class="number">0</span>;</span><br><span class="line">                    st[j]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//说明不存在正环  且找到了最小的满足所有约束条件的S[24]</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">24</span>;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;R[i]);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="keyword">sizeof</span> num);</span><br><span class="line">        <span class="keyword">while</span>(n--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">            <span class="comment">//由于前缀和S[0]占用0这个位置,因此我们让时间都向右平移一位</span></span><br><span class="line">            t++;</span><br><span class="line">            num[t]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//用来判断是否有解</span></span><br><span class="line">        <span class="keyword">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">1000</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//枚举找到最小的满足所有约束条件的S[24]</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">spfa</span>(i))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">                flag=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//说明无解</span></span><br><span class="line">        <span class="keyword">if</span>(!flag)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;No Solution&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title>局域网</title>
    <url>/2021/07/24/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/%E5%B1%80%E5%9F%9F%E7%BD%91/</url>
    <content><![CDATA[<h1 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210724120055.png" alt="image-20210724120055096"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>题意：给定一张有$n$个点，$k$条边的无向有环图，要求删掉其中部分边，且不改变图的连通性的情况下，使得最终的图仍然是连通的不存在环，并且删除的边权之和最大，输出最大的所删边边权权和。从题意我们可以发现：</p>
<p>删边权和最大$\implies$ 剩下边权和最小 $\implies$ 求最小生成树</p>
<p>但是题中并没有说图一定连通，这让这道题恶心了很多。也就是说，图中可能存在多棵树，这些树并不在同一个连通块中。假设有$A_1$，$A_2$，$A_3$这三颗树，它们都是独立的连通块，那么我们需要求出每树的最小生成树，不妨设为$x_1,x_2,x_3$，设这三棵树边权总和为$sum$，那么最终删除的边权之和最大为$sum-(x_1+x_2+x_3)$。</p>
<p>说到连通块，我们很容易想到Kruskal算法，它也是利用连通块思想来求解最小生成树。因此，这题我们可以采用Kruskal算法来求解，对于一棵树来说，如果两个点不在同一个集合中，则说明它是最小生成树中的边，那么就可以累加边权。如果两个点已经在一个集合中了，根据Kruskal算法思想，则不需要累加边权了。</p>
<p>当然这题也是可以用prim算法的。</p>
<p>下面给出一个有多棵树的栗子：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210724122230.png" alt="image-20210724122230651"></p>
<p>如图所示：</p>
<p>将所有边权从小到大排好序，初始化每个节点都是独立集合（独立的连通块），设$ans=0$</p>
<ul>
<li>对于树$A$，节点$1$和节点$2$起初都是独立的集合，那么可以使用并查集进行合并，因此需要累加边权，即$ans+=w$，也就是$ans=0+10=10$，此时树$A$就已经是一个连通块了</li>
<li>对于树$B$，由于$(3,4)$边权小，所有选择这条边，节点$3,4$起初都是独立的集合，那么可以使用并查集进行合并，更新节点$4$的祖宗节点为$3$，因此需要累加边权，即$ans+=w$，也就是$ans=10+11=21$，此时节点$3$和节点$4$就属于同一个连通块了。接着由于$(4,5)$边权小，所以选择这条边，经过上一步的操作后，此时$(3,4)$属于一个连通块，而$5$是独立的一个集合，因此$5$属于另一个连通块，那么可以使用并查集进行合并，更新节点$5$的祖宗节点为$3$，因此需要累加边权，即$ans+=w$，也就是$ans=21+12=33$，此时$(3,4,5)$已经在同一个连通块中了。最后选择$(3,5)$这条边，但是由于$(3,4,5)$已经在同一个连通块中了，所以此时$(3,5)$这条边并不需要累加权值。也就是说$(3,5)$这条边并不是最小生成树上的边。所以$ans$仍为$33$，树$B$的最小生成树的边有$(3,4)$和$(4,5)$</li>
<li>对于树$C$，由于$(7,6)$边权小，所以选择这条边，节点$7,6$起初都是独立的集合，那么可以使用并查集进行合并，更新节点$7$的祖宗节点为$6$，因此需要累加边权，即$ans+=w$，也就是$ans=33+14=47$，那么此时节点$7$和节点$6$就已经在同一个连通块中了。接着考虑$(6,7)$这条边，由于$(6,7)$已经在同一个连通块中了，所以这条边并不需要累加权值。也就是说$(6,7)$这条边并不是最小生成树上的边。所以$ans$仍为$47$，树$C$的最小生成树的边有$(7,6)$</li>
<li>由于这三颗树的边权总和为$sum=75$，而我们已经求出了这三棵树的最小生成树之和为$47$，那么需要删除的边的最大权值为$sum-res=75-47=28$，也就是图中的红色边</li>
</ul>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>写法1：Kruskal算法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">110</span>,M=<span class="number">210</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a,b,w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge&amp; W)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w&lt;W.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x!=p[x])</span><br><span class="line">        p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(edges,edges+m);    <span class="comment">//将边权从小到大排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   <span class="comment">//初始化每个点都是独立的集合</span></span><br><span class="line">        p[i]=i;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;      <span class="comment">//最小生成树的权值</span></span><br><span class="line">    <span class="comment">//由于边已经排好序了  所以这里是优先选择小的边</span></span><br><span class="line">    <span class="comment">//要注意这些边并不都是连通的  (存在多个非连通块)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="built_in">find</span>(edges[i].a);</span><br><span class="line">        <span class="keyword">int</span> b=<span class="built_in">find</span>(edges[i].b);</span><br><span class="line">        <span class="keyword">int</span> w=edges[i].w;</span><br><span class="line">        <span class="comment">//对于每个连通块来说,我们都只会在当两个节点的集合号不同时 才累加权值</span></span><br><span class="line">        <span class="comment">//因为Kruskal算法就是当合并两个集合时,才累加了边权,而如果已经在同一个连通块中了,那么就不会累加</span></span><br><span class="line">        <span class="keyword">if</span>(a!=b)</span><br><span class="line">        &#123;</span><br><span class="line">            p[a]=b;</span><br><span class="line">            <span class="comment">//只有不在同一集合时,才累加权值</span></span><br><span class="line">            res+=w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回最小生成树的权值</span></span><br><span class="line">    <span class="keyword">return</span> res;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;w);</span><br><span class="line">        edges[i]=&#123;a,b,w&#125;;</span><br><span class="line">        <span class="comment">//计算全部边权的总和</span></span><br><span class="line">        sum+=w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t=<span class="built_in">Kruskal</span>();</span><br><span class="line">    <span class="comment">//总和减去最小生成树,那么剩下的其实就是被除去网线的最大值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum-t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写法2：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">110</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="comment">//prim算法需要用到邻接矩阵</span></span><br><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="comment">//dist[i]表示节点i到集合S的距离</span></span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="comment">//st[i]=true表示节点i已经被加入了集合S中</span></span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="comment">//prim算法求解最小生成树</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span>(!st[j]&amp;&amp;(t==<span class="number">-1</span>||dist[t]&gt;dist[j]))</span><br><span class="line">                t=j;</span><br><span class="line">        <span class="keyword">if</span>(i&amp;&amp;dist[t]==INF)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(i)</span><br><span class="line">            res+=dist[t];</span><br><span class="line">        st[t]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">            dist[k]=<span class="built_in">min</span>(dist[k],g[t][k]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(g,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> g);    <span class="comment">//初始化邻接矩阵为正无穷</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">int</span> total;  <span class="comment">//记录输入的所有子树的权值总和</span></span><br><span class="line">    <span class="keyword">while</span>(k--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        <span class="comment">//防止重边和自环</span></span><br><span class="line">        g[a][b]=g[b][a]=<span class="built_in">min</span>(g[a][b],c);</span><br><span class="line">        <span class="comment">//算出整个森林的边权总和</span></span><br><span class="line">        total+=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//由于题目给定的树不一定都是连通的,也就是说可能存在多个互不连通的树,即存在多个连通块</span></span><br><span class="line">    <span class="comment">//依次求解每颗树中的最小生成树</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果还没有处理节点i所在的树,则去求解i所在的这颗树的最小生成树</span></span><br><span class="line">        <span class="keyword">if</span>(!st[i])</span><br><span class="line">            total-=<span class="built_in">prim</span>();  <span class="comment">//用总和减去每一颗树的最小生成树</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,total);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>最小生成树</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>可达性统计</title>
    <url>/2021/07/20/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/%E5%8F%AF%E8%BE%BE%E6%80%A7%E7%BB%9F%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="可达性统计"><a href="#可达性统计" class="headerlink" title="可达性统计"></a>可达性统计</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210720213337.png" alt="image-20210720213336979"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>设从点$x$出发能到达的所有点的集合为<code>f(x)</code>，设$x$连接的所有边为$y_1,y_2,\cdots,y_k$，则有如下式子：</p>
<p>$f(x)=x$ $\cup$ $(\bigcup \limits _{1\leq i\leq k}f(y_i))$</p>
<p>即：从点$x$出发能到达的所有点就是从它连接的所有点出发能到达的所有点加上$x$本身</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210720215025.png" alt="image-20210720215025122"></p>
<p>考虑拓扑排序。在一张图的拓扑序中，对每条边$(x,y)$总有：$x$在$y$之前。根据上述的这个式子，我们发现要想求出$f(x)$，必须要先求出$f(y_i)$，而由于$y_i$是$x$之后的节点，因此我们可以按照拓扑排序的倒序来进行计算。</p>
<p>我们考虑将每个点$f(x)$记作一个$N$位二进制数，其中第$i$位为1，表示可以到达$i$；第$i$位为0，表示不可以到达$i$。那么$f(x)$中1的数量就是从$x$出发能到达的所有点的数量。</p>
<p>我们来考虑一下数据规模，在最坏情况下，拓扑排序是一条链，对于第一个节点，$f(1)=n$，对于第二个节点，$f(2)=n-1$，$\cdots$，对于第$n$个节点，$f(n)=1$。那么总数为$f(1)+f(2)+\cdots+f(n)=n+(n-1)+\cdots+1=\dfrac {n(n-1)}{2}$，$n$最大取到$30000$，所以最坏的总数约为$4.5$亿，如果用二维数组来存储的话，那么内存空间就会爆炸。因此需要把$N$位的二进制数压缩到一个int中，这需要借助STL中的bitset。这样空间复杂度将减少为原来的$\dfrac {1}{32}$，此时变为$14,062,500$是可以接受的。</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210720215049.png" alt="image-20210720215048996"></p>
<p><code>bitset&lt;N&gt;f</code>这里的$f$其实是一维数组；</p>
<p><code>bitset&lt;N&gt;f[N]</code>，这里的$f$其实是二维数组</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">30010</span>,M=<span class="number">30010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="keyword">int</span> d[N];   <span class="comment">//记录每个点的入队</span></span><br><span class="line"><span class="keyword">int</span> q[N];   <span class="comment">//记录拓扑序列</span></span><br><span class="line">bitset&lt;N&gt;f[N];</span><br><span class="line"><span class="comment">//从点a向点b连一条有向边</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!d[i])</span><br><span class="line">        &#123;</span><br><span class="line">            q[++tt]=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(hh&lt;=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=q[hh++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(--d[j]==<span class="number">0</span>)</span><br><span class="line">                q[++tt]=j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a,b);</span><br><span class="line">        d[b]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//求出拓扑序列</span></span><br><span class="line">    <span class="built_in">topsort</span>();</span><br><span class="line">    <span class="comment">//对拓扑序列进行倒序遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x=q[i];</span><br><span class="line">        <span class="comment">//从x这个点出发可以到达x自身  因此f[x][x]=1</span></span><br><span class="line">        f[x][x]=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//遍历x的所有邻接点</span></span><br><span class="line">        <span class="comment">//f[x]|=f(yi)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=h[x];~j;j=ne[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> y=e[j]; <span class="comment">//取出x邻接点的编号y</span></span><br><span class="line">            f[x]|=f[y];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//f[i].count()表示f[i]中1的个数</span></span><br><span class="line">    <span class="comment">//其实也就是从i出发能到达的所有点的数量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[i].<span class="built_in">count</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>拓扑排序</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>最短网络</title>
    <url>/2021/07/24/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/%E6%9C%80%E7%9F%AD%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="最短网络"><a href="#最短网络" class="headerlink" title="最短网络"></a>最短网络</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210724102626.png" alt="image-20210724102626788"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>从题意可知，农夫想要连接所有农场并且想要所使用的光纤最短。这其实就是想要求最小生成树，因为最小生成树一定包含所有节点（即所有农场），而且是连通的（连接所有农场），并且边权之和是最小的（所使用的光纤最短）。因此就是一道裸的最小生成树算法。</p>
<p>求解最小生成树有两种算法：prim算法和Kruskal算法。</p>
<ul>
<li>prim算法一般适用于稠密图，用邻接矩阵存储。而题目又说了对称矩阵，所以这题就可以用prim算法来求解</li>
<li>Kruskal算法一般适用于稀疏图，我们一般用结构体来存储</li>
</ul>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>写法1：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">110</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="comment">//prim算法比较适用于稠密图  稠密图可以用邻居矩阵来存储</span></span><br><span class="line"><span class="comment">//这里采用prim算法  所以用了邻居矩阵</span></span><br><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line"><span class="comment">//dist[i]表示节点i距离S集合的距离</span></span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="comment">//st[i]=true表示节点i已经被加入了S集合</span></span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="comment">//prim算法求最小生成树</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;  <span class="comment">//最小生成树的权值总和</span></span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);  <span class="comment">//距离初始化为无穷大</span></span><br><span class="line">    <span class="comment">//起点1号节点到自身距离为0</span></span><br><span class="line">    dist[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//最终得到的最小生成树中一定有n个节点</span></span><br><span class="line">    <span class="comment">//因此需要循环n次  每个把一个节点加入S集合中</span></span><br><span class="line">    <span class="comment">//最终都会把这n个节点加入S集合中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=<span class="number">-1</span>;   <span class="comment">//寻找不在S集合中,但是距离S集合最近的一个节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span>(!st[j]&amp;&amp;(t==<span class="number">-1</span>||dist[t]&gt;dist[j]))</span><br><span class="line">                t=j;</span><br><span class="line">        <span class="keyword">if</span>(dist[t]==INF)</span><br><span class="line">            <span class="keyword">return</span> INF;</span><br><span class="line">        res+=dist[t];   <span class="comment">//累加最小生成树的权值和</span></span><br><span class="line">        st[t]=<span class="literal">true</span>;   <span class="comment">//标记节点t已经被加入了S集合</span></span><br><span class="line">        <span class="comment">//遍历节点t的所有邻接点  通过t来更新这些邻接点到起点的距离</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">            <span class="keyword">if</span>(!st[k])</span><br><span class="line">                dist[k]=<span class="built_in">min</span>(dist[k],g[t][k]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="comment">//读入邻接矩阵</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;g[i][j]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">prim</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写法2：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">110</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span>(!st[j]&amp;&amp;(t==<span class="number">-1</span>||dist[t]&gt;dist[j]))</span><br><span class="line">                t=j;</span><br><span class="line">        <span class="keyword">if</span>(i&amp;&amp;dist[t]==INF)</span><br><span class="line">            <span class="keyword">return</span> INF;</span><br><span class="line">        <span class="keyword">if</span>(i)</span><br><span class="line">            res+=dist[t];</span><br><span class="line">        st[t]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">            dist[k]=<span class="built_in">min</span>(dist[k],g[t][k]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;g[i][j]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">prim</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>最小生成树</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>家谱树</title>
    <url>/2021/07/21/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/%E5%AE%B6%E8%B0%B1%E6%A0%91/</url>
    <content><![CDATA[<h1 id="家谱树"><a href="#家谱树" class="headerlink" title="家谱树"></a>家谱树</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210721101434.png" alt="image-20210721101434566"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>这是一道很裸的拓扑排序，直接套拓扑排序模版即可。</p>
<blockquote>
<p>问题：如何输出字典序最小的拓扑排序？</p>
<p>将队列换成优先队列，优先队列取出的元素是当前字典序最小的编号，在出队的时候记录出队的编号即为当前字典序最小的拓扑序，此方法的时间复杂度是$O(logn*(n+m))$</p>
</blockquote>
<p>由于是有向无环图，对于第1个节点来说，最多与后面的$n-1$个节点有边；对于第2个节点来说，最多与后面的$n-2$个节点有边；$\cdots$；对于第$n$个节点来说，有0个连边。因此最多有$\dfrac {n(n-1)}{2}$条边。由于点的个数最多是$N$，所以边的个数最多是$\dfrac {N(N-1)}{2}$</p>
<p>由于这道题目中肯定不会存在环（家庭伦理问题…），因此一定可以得到拓扑序列。</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>手写队列：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">110</span>,M=N*N/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="keyword">int</span> d[N];</span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(!d[i])</span><br><span class="line">            q[++tt]=i;</span><br><span class="line">    <span class="keyword">while</span>(hh&lt;=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=q[hh++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(--d[j]==<span class="number">0</span>)</span><br><span class="line">                q[++tt]=j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> son;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;son),son)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//从i向son连一条有向边</span></span><br><span class="line">            <span class="built_in">add</span>(i,son);</span><br><span class="line">            d[son]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进行一遍拓扑排序</span></span><br><span class="line">    <span class="built_in">topsort</span>();</span><br><span class="line">    <span class="comment">//输出得到的拓扑序列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,q[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运用STL中的队列</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">110</span>,M=N*N/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="keyword">int</span> d[N];</span><br><span class="line"><span class="comment">//seq数组用来存储得到的拓扑序列,cnt是这个数组的下标</span></span><br><span class="line"><span class="keyword">int</span> seq[N],cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt;q;    <span class="comment">//运用STL中的队列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!d[i])</span><br><span class="line">        &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">        <span class="comment">//记录此时的拓扑序列的节点是t</span></span><br><span class="line">        seq[cnt++]=t;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(--d[j]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> son;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;son),son)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">add</span>(i,son);</span><br><span class="line">            d[son]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">topsort</span>();</span><br><span class="line">    <span class="comment">//输出得到的拓扑序列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,seq[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>拓扑排序</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>奖金</title>
    <url>/2021/07/21/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/%E5%A5%96%E9%87%91/</url>
    <content><![CDATA[<h1 id="奖金"><a href="#奖金" class="headerlink" title="奖金"></a>奖金</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210721120429.png" alt="image-20210721120429310"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>实际上是一道差分约束的题，要求变量的最小值，也就是取所有下界的最大值，用最长路求解即可。但是呢，如果用差分约束spfa的时间复杂度为$O(km)$~$O(nm)$，可能会被卡。</p>
<p>因为本题中所有的权值都是正值，因此我们可以不用差分约束就求这个最长路。</p>
<p>我们直接拓扑排序得到一张有向无环图DAG$\implies $每一个状态都没有循环依赖 $\implies$没有后效性$\implies$就可以用DP递推求最长路</p>
<p>题目中说到”员工$a$的奖金比员工$b$的奖金高“，因此可以得出$a\geq b+1$，那么我们可以从节点$b$向节点$a$连一条边权为1的边。</p>
<p>由于”每位员工奖金最少为$100$元“，因此就可以看作是建立了一个虚拟源点，该源点到其他各点的距离都为$100$。</p>
<p>这题有两种写法：</p>
<ul>
<li>在拓扑排序中就求出了最长路</li>
<li>先进行拓扑排序得到一张有向无环图DAG，然后在这个DAG上跑一下最长路即可。</li>
</ul>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>在拓扑排序中就求出了最长路</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">10010</span>,M=<span class="number">20010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="keyword">int</span> d[N];       <span class="comment">//存储每个点的入度</span></span><br><span class="line"><span class="keyword">int</span> q[N];       <span class="comment">//存储拓扑序列</span></span><br><span class="line"><span class="keyword">int</span> dist[N];    <span class="comment">//存储最长路</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在进行拓扑排序的同时求出了dist[]</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//求最长路 因此初始化为负无穷</span></span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">-0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!d[i])</span><br><span class="line">        &#123;</span><br><span class="line">            q[++tt]=i;</span><br><span class="line">            <span class="comment">//相当于建立了一个虚拟源点 该虚拟源点到这n个点的距离为100</span></span><br><span class="line">            dist[i]=<span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(hh&lt;=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=q[hh++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(--d[j]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                q[++tt]=j;</span><br><span class="line">                <span class="comment">//j是t的邻接点   t经过边权为1的边后就可以走到了j</span></span><br><span class="line">                dist[j]=dist[t]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tt==n<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="comment">//从b向a连一条边权为1的有向边 </span></span><br><span class="line">        <span class="comment">//由于边权都是1  因此没必要用一个数组w[i]来存储了  直接用1就好了</span></span><br><span class="line">        <span class="built_in">add</span>(b,a);</span><br><span class="line">        d[a]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//说明存在环 则无解</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">topsort</span>())</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Poor Xed&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//计算最长路</span></span><br><span class="line">            res+=dist[i];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);         </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先进行拓扑排序得到一张有向无环图DAG，然后在这个DAG上跑一下最长路</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">10010</span>,M=<span class="number">20010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="keyword">int</span> d[N],q[N],dist[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(!d[i])</span><br><span class="line">            q[++tt]=i;</span><br><span class="line">    <span class="keyword">while</span>(hh&lt;=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=q[hh++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(--d[j]==<span class="number">0</span>)</span><br><span class="line">                q[++tt]=j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;       </span><br><span class="line">    <span class="keyword">return</span> tt==n<span class="number">-1</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="built_in">add</span>(b,a);</span><br><span class="line">        d[a]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">topsort</span>())</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Poor Xed&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//相当于建立了一个虚拟源点 该虚拟源点到这n个点的距离为100</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            dist[i]=<span class="number">100</span>;</span><br><span class="line">        <span class="comment">//对得到的这个拓扑图DAG跑一下最长路</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t=q[i]; <span class="comment">//取出拓扑序列中的节点t</span></span><br><span class="line">            <span class="comment">//遍历t的所有邻接点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=h[t];~k;k=ne[k])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> j=e[k]; <span class="comment">//取出t的邻接点j</span></span><br><span class="line">                <span class="comment">//由于得到的是DAG图,没有后效性,因此可以用dp思想</span></span><br><span class="line">                <span class="comment">//状态转移方程</span></span><br><span class="line">                dist[j]=<span class="built_in">max</span>(dist[j],dist[t]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            res+=dist[i];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>拓扑排序</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>车站分级</title>
    <url>/2021/07/21/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/%E8%BD%A6%E7%AB%99%E5%88%86%E7%BA%A7/</url>
    <content><![CDATA[<h1 id="车站分级"><a href="#车站分级" class="headerlink" title="车站分级"></a>车站分级</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210721151841.png" alt="image-20210721151841388"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>题目中描述的”如果这趟车次停靠了火车站x，则始发站、终点站之间所有级别大于等于火车站x的都必须停靠“，这句话翻译过来就是<strong>停靠过的车站的等级一定严格大于没有停靠过的车站的等级</strong></p>
<p>因此车站的等级均有严格的大小关系，则不存在环，因此可以用拓扑排序每个车站在图中的大小关系。</p>
<p>有些车站会停车，这些车站的集合设为$A$；有些车站不会停车，这些车站的集合设为$B$。由于A中所有车站的级别都严格大于B中车站的级别，因此有$a_i\geq b_i+1$，$a_i\in A$，$b_i\in B$。另外，由于题目说了车站等级最低是$1$，因此有$a_i\geq 1$。</p>
<ul>
<li>对于$a_i\geq b_i+1$，在差分约束中，其实就是$b_i$向$a_i$连一条权值为1的有向边</li>
<li>对于$a_i\geq 1$，其实就是$a_i\geq X_0+1$，其中$X_0=0$，是超级源点。在差分约束中，其实是$X_0$向$a_i$连一条权值为1的有向边</li>
</ul>
<p>由于本题中的所有点的权值都是大于0，并且一定满足要求=&gt;=&gt;所有车站都等级森严=&gt;=&gt;不存在环=&gt;=&gt;可以拓扑排序得到拓扑图使用递推求解差分约束问题。</p>
<p><strong>整体思路：</strong></p>
<ul>
<li>进行拓扑排序得到一张拓扑图</li>
<li>”至少“$\implies$求变量的最小值$\implies$所有条件的下界中取最大值$\implies$跑最长路。因此我们，根据拓扑序跑最长路递推即可</li>
<li>我们求完最长路之后，会得到$n$个<code>dist[i]</code>。取最大的那个$dist[i]$，那么它就是最高等级，而这个最高等级的等级数就是整张图的级数。为什么呢？因为题目要求”$n$个火车站最少划分的级别数“。假设dist有{2，4，5，8}。说明有四个车站，最高等级是8，说明这四个车站最少划分的等级数是8。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210721155006.png" alt="image-20210721155006523"></p>
<p>我们来考虑如何建边：最坏情况下是有1000趟火车，最多存在1000个火车站，每趟上限最多会有500个停靠站（具体原因下述），那么则有$1000-500=500$个不停靠站，不停站的点都向停站的点连有向边，那么对于一趟车次来说，就会建立$500\times500=250000$条边。有1000趟车次，因此总共有$250000\times1000=2.5\times10^{8}$条边，那么则会超过内存。如果用邻接矩阵存储，需要遍历所有的边，遍历的次数也是$2.5\times10^8$，那么则会超时。</p>
<blockquote>
<p>问题：为什么每趟上限最多会有500个停靠站呢？</p>
<p>停靠过的车站的等级一定严格大于为停靠过的车站的等级，不停站的点都向停站的点连有向边，最坏情况下有1000个点，假设停靠站有$x$个，那么不停站就有$1000-x$个。那么需要总共需要建立的总边数就是$y=x(1000-x)$，从这个二元一次方程中可以看出，当$x=500$时，$y$取到最大值。因此，每趟上限最多会有500个停靠站。</p>
</blockquote>
<p>那么有什么技巧能够减少建立的边数呢？一般对于这种把点分成两部分，从一个点集合向另一个点集合引出边，如果最终边数很多的话。那么是可以使用技巧来优化的：</p>
<p>设左边点集合都是不停靠站，右边点集合都是停靠站，那么我们可以在这两个点集合之间建立<strong>辅助节点</strong>（可以看作是连通两个点集合的交通枢纽）。</p>
<p>如下图所示：</p>
<p>可以发现，优化前，左边点集合为$n=4$，右边点集合为$m=4$，那么总边数为$n\times m=16$。优化后，左边点集合为$n=4$，右边点集合为$m=4$，那么总边数为$n+m=8$。因此，边数减少了。当点数特别多时，那么边数就可以大大减少，从而降低了空间复杂度。</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210721162850.png" alt="image-20210721162850371"></p>
<p>对于这种优化后的建图方式来说，每趟车次需要建边$500+500=1000$条边，有1000趟车次，因此总共需要建立边数为$1000\times1000=1e6$，空间复杂度明显降低了。</p>
<p>也就是说，我们可以在中间建一个辅助节点，左边（非停靠站）向辅助节点连一条权值为0的有向边，辅助节点向右边（停靠站）连一条权值为1的有向边，而这就等价于优化前左边直接向右边连一条权值为1的有向边。</p>
<p>注意本题一共有$m$条线路，每条线路都需要一个辅助节点来连通，而原来就已经有了$n$个节点了，因此总的节点数就是$n+m$。</p>
<p>举个栗子：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210721163916.png" alt="image-20210721163916543"></p>
<p><code>dist[i]</code>表示在拓扑图中，点$i$离起点的最长距离。</p>
<p>由于题目保证所有的火车都满足要求，故该图必定是一张有向无环图，在该图上做一遍拓扑排序求出拓扑序之后，从前往后遍历，求一遍最长路，级别的最大值就是最终的答案</p>
<p>注意，假设图中有$n$个点，我们用$1$到$n$表示原来的点，代码实现中，使用$n+i$表示第$i$个辅助节点（$i$从1开始）</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>写法1：求完拓扑排序后得到一张拓扑图，对这张拓扑图求最长路</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2010</span>,M=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],w[M],idx;</span><br><span class="line"><span class="keyword">int</span> d[N],q[N],dist[N];</span><br><span class="line"><span class="comment">//用来距离哪个车站是停靠站  如果st[i]=true表示第i个车站是停靠站</span></span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="comment">//从a向b连一条权值为c的有向边</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    w[idx]=c;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">    d[b]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进行拓扑排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+m;i++)<span class="comment">//一共有n+m个点</span></span><br><span class="line">        <span class="keyword">if</span>(!d[i])</span><br><span class="line">            q[++tt]=i;</span><br><span class="line">    <span class="keyword">while</span>(hh&lt;=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=q[hh++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(--d[j]==<span class="number">0</span>)</span><br><span class="line">                q[++tt]=j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="comment">//输入m趟车次的信息</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//每次都要情况上一趟车次的停靠站信息</span></span><br><span class="line">        <span class="built_in">memset</span>(st,<span class="number">0</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">        <span class="comment">//起始站和终点站</span></span><br><span class="line">        <span class="keyword">int</span> start=n,end=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;cnt);</span><br><span class="line">        <span class="comment">//读入cnt个停靠站的信息</span></span><br><span class="line">        <span class="keyword">while</span>(cnt--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> stop;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;stop);</span><br><span class="line">            start=<span class="built_in">min</span>(start,stop);</span><br><span class="line">            end=<span class="built_in">max</span>(end,stop);</span><br><span class="line">            <span class="comment">//标记stop这个车站是停靠站</span></span><br><span class="line">            st[stop]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//辅助节点的编号</span></span><br><span class="line">        <span class="keyword">int</span> ver=n+i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=start;j&lt;=end;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果是非停靠站  那么从非停靠站j向辅助节点ver连一条长度为0的有向边</span></span><br><span class="line">            <span class="keyword">if</span>(!st[j])</span><br><span class="line">                <span class="built_in">add</span>(j,ver,<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//如果是停靠站  那么从辅助节点ver向停靠站j连一条长度为1的有向边    </span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">add</span>(ver,j,<span class="number">1</span>);    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进行拓扑排序  得到一张拓扑图</span></span><br><span class="line">    <span class="built_in">topsort</span>();</span><br><span class="line">    <span class="comment">//由于车站等级最低为1级 由差分约束可知 这里是相当于建立了一个超级源点</span></span><br><span class="line">    <span class="comment">//这个超级源点到其他n个节点的距离为1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    dist[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//这张拓扑图中有n+m个节点    求最长路</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n+m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//取出拓扑图中的某个节点t</span></span><br><span class="line">        <span class="keyword">int</span> t=q[i];</span><br><span class="line">        <span class="comment">//遍历t的所有邻接点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//j是t的邻接点</span></span><br><span class="line">            <span class="keyword">int</span> j=e[i];</span><br><span class="line">            <span class="comment">//求出最长路</span></span><br><span class="line">            dist[j]=<span class="built_in">max</span>(dist[j],dist[t]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//找到等级最高的那个dist   那么就是整张图的级数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    res=<span class="built_in">max</span>(res,dist[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>写法2：直接在拓扑排序里求dist</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2010</span> , M = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line"><span class="keyword">int</span> e[M] , ne[M] , w[M] , h[N] , idx;</span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="keyword">int</span> q[N] , d[N];</span><br><span class="line"><span class="keyword">int</span> res;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a , <span class="keyword">int</span> b , <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b , ne[idx] = h[a] , w[idx] = c , h[a] = idx++;</span><br><span class="line">    d[b]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span> , tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n + m ; i++)<span class="comment">//因为加入了辅助节点，所以点数是n+m</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!d[i])</span><br><span class="line">        &#123;</span><br><span class="line">            q[++tt] = i;</span><br><span class="line">            <span class="keyword">if</span>(i &lt;= n) </span><br><span class="line">                dist[i] = <span class="number">1</span>;<span class="comment">//普通节点的初始等级是1，辅助节点的初始等级是0.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = q[hh++];</span><br><span class="line">        <span class="keyword">int</span> temp = (t &gt; n);<span class="comment">//如果是辅助节点连向普通点边权是1，普通节点连向辅助节点边权是0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = h[t] ; ~i ; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(--d[j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + temp;</span><br><span class="line">                q[++tt] = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(h , <span class="number">-1</span> , <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(st , <span class="number">0</span> , <span class="keyword">sizeof</span> st);</span><br><span class="line">        <span class="keyword">int</span> cnt;</span><br><span class="line">        cin &gt;&gt; cnt;</span><br><span class="line">        <span class="keyword">int</span> start = n , end = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(cnt--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> stop;</span><br><span class="line">            cin &gt;&gt; stop;</span><br><span class="line">            start = <span class="built_in">min</span>(start , stop);</span><br><span class="line">            end = <span class="built_in">max</span>(end , stop);</span><br><span class="line">            st[stop] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ver = i + n;<span class="comment">//建立辅助节点</span></span><br><span class="line">        <span class="comment">//遍历从始发站到终点站的信息</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = start ; j &lt;= end;  j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果是非停靠站  那么从非停靠站j向辅助节点ver连一条长度为0的有向边</span></span><br><span class="line">            <span class="keyword">if</span>(!st[j])</span><br><span class="line">                <span class="built_in">add</span>(j,ver,<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//如果是停靠站  那么从辅助节点ver向停靠站j连一条长度为1的有向边    </span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">add</span>(ver,j,<span class="number">1</span>);    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">topsort</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++) </span><br><span class="line">        res = <span class="built_in">max</span>(res , dist[i]);</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>写法3：</p>
<p>看到如此鲜明的层级关系，就是拓扑排序了，从未停靠站向停靠站连一条有向边。</p>
<p>此题的要点在于如何计算等级：</p>
<p>利用$dep[son]=dep[father]+1$递推出每一个点在图中是第几层，进而推出了它的等级，然后在计算完一个$dep[i]$时，都用$max$取最大值，最终那个最高等级的等级数就是整张图的级数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>,M=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="comment">//a数组用来记录停靠站的信息  dep数组用来记录拓扑序中的每个节点都处于哪一层,即属于什么等级</span></span><br><span class="line"><span class="keyword">int</span> a[N],dep[N],d[N];</span><br><span class="line"><span class="comment">//st[i]=true表示第i个车站是停靠站</span></span><br><span class="line"><span class="comment">//vst[j][a[p]]表示从非停靠站j向停靠站a[p]连一条有向边</span></span><br><span class="line"><span class="keyword">bool</span> st[N],vst[N][N];</span><br><span class="line"><span class="keyword">int</span> ans;    <span class="comment">//答案</span></span><br><span class="line"><span class="comment">//快读</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> Sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> F=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(c&gt;<span class="string">&#x27;9&#x27;</span> || c&lt;<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            F=<span class="number">-1</span>;</span><br><span class="line">        c=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(c&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; c&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Sum=Sum*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        c=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Sum*F;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">    d[b]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!d[i])</span><br><span class="line">        &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">            <span class="comment">//由于车站等级最低是1级</span></span><br><span class="line">            <span class="comment">//因此那些刚开始时 对于这张图中所有入度为0的节点都是处于同一层</span></span><br><span class="line">            <span class="comment">//即这些入度为0的车站都是相同等级,处于第一层</span></span><br><span class="line">            dep[i]=<span class="number">1</span>;        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">//遍历t的所有邻接点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//j是t的邻接点</span></span><br><span class="line">            <span class="keyword">int</span> j=e[i]; </span><br><span class="line">            <span class="comment">//所有t的邻接点都是处于t的下一层</span></span><br><span class="line">            <span class="comment">//即t的所有邻接点都比节点t的等级多1</span></span><br><span class="line">            dep[j]=dep[t]+<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//找到等级最高的那个就是整张图的级数</span></span><br><span class="line">            ans=<span class="built_in">max</span>(ans,dep[j]);</span><br><span class="line">            <span class="keyword">if</span>(--d[j]==<span class="number">0</span>)</span><br><span class="line">            q.<span class="built_in">push</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span> a);</span><br><span class="line">        <span class="built_in">memset</span>(st,<span class="number">0</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">        <span class="keyword">int</span> start=n,end=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt;</span><br><span class="line">        cin&gt;&gt;cnt;</span><br><span class="line">        <span class="comment">//输入这cnt个停靠站的信息</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=cnt;k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> stop;</span><br><span class="line">            cin &gt;&gt;stop;</span><br><span class="line">            a[k]=stop;</span><br><span class="line">            start=<span class="built_in">min</span>(start,stop);</span><br><span class="line">            end=<span class="built_in">max</span>(end,stop);</span><br><span class="line">            st[stop]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从起始站到终点站</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=start;j&lt;=end;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果j不是停靠站</span></span><br><span class="line">            <span class="keyword">if</span>(!st[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">1</span>;p&lt;=cnt;p++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//如果非停靠站j还没有向停靠站a[p]连过一条有向边</span></span><br><span class="line">                    <span class="keyword">if</span>(!vst[j][a[p]])</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//从非停靠站j向停靠站a[p]连一条有向边</span></span><br><span class="line">                        <span class="built_in">add</span>(j,a[p]);</span><br><span class="line">                        vst[j][a[p]]=<span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">topsort</span>();</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>拓扑排序</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>祖孙询问</title>
    <url>/2021/07/21/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/%E7%A5%96%E5%AD%99%E8%AF%A2%E9%97%AE/</url>
    <content><![CDATA[<h1 id="祖孙询问"><a href="#祖孙询问" class="headerlink" title="祖孙询问"></a>祖孙询问</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210721211507.png" alt="image-20210721211507323"></p>
<hr>
<h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p>最近公共祖先（LCA）是指有根树中距离两个节点最近的公共祖先。祖先是指从当前节点到树根路径上的所有节点。</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210721211850.png" alt="image-20210721211850774"></p>
<p>$u$和$v$的公共祖先是指一个节点它既是$u$的祖先，又是$v$的祖先。$u$和$v$的最近公共祖先是指距离$u$和$v$最近的祖先。如果$v$是$u$的祖先，那么$u$和$v$的最近公共祖先就是$v$。</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210721212059.png" alt="image-20210721212059201"></p>
<p>我们可以使用LCA来求解树上任意两点之间的距离。求$u$和$v$这两个之间的距离时，设为$L$，如果$u$和$v$的最近公共祖先为lca，则$u$和$v$之间的距离为$u$到树根的距离$dist[u]$加上$v$到树根的距离$dist[v]$再减去2倍的lca到树根的距离$2\times dist[lca]$。即有：$L=dist[u]+dist[v]-2\times dist[lca]$。</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210721212512.png" alt="image-20210721212511915"></p>
<p>从图中可以看出$u$到lca的距离加上$v$到lca的距离，设为$L_1$，其实就是我们想要求的$u$和$v$之间的距离，设为$L_2$。可知：$dist[u]=L_1+dist[lca]$，所以$L_1=dist[u]-dist[lca]$；$dist[v]=L_2+dist[lca]$，所以$L_2=dist[v]-dist[lca]$。所以$L=L_1+L_2=dist[u]-dist[lca]+dist[v]-dist[lca]=dist[u]+dist[v]-2\times dist[lca]$。</p>
<h4 id="树上倍增法"><a href="#树上倍增法" class="headerlink" title="树上倍增法"></a>树上倍增法</h4><p><code>F[i,j]</code>表示$i$的$2^j$辈祖先，即$i$节点向根节点走$2^j$步所到达的那个节点。</p>
<p>$u$节点向上走$2^0$步，则为$u$的父节点$x$，$F[u,0]=x$；$u$节点向上走$2^1$步，到达节点$y$，$F[u,1]=y$；$u$节点向上走$2^2$步，到达节点$z$，$F[u,2]=z$；$u$节点向上走$2^3$步，节点不存在，$F[u,3]=0$；</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210721213504.png" alt="image-20210721213503867"></p>
<p><code>F[i,j]</code>表示$i$的$2^j$辈祖先，即$i$节点向根节点走$2^j$步所到达的那个节点。那么该如何走到$F[i,j]$这个节点呢？可以分为两个步骤：</p>
<ul>
<li>$i$节点先向根节点走$2^{j-1}$步得到$F[i,j-1]$</li>
<li>然后再从$F[i,j-1]$这个节点出发向根节点走$2^{j-1}$步，得到<code>F[F[i,j-1],j-1]</code>，那么此时走到的节点即为$F[i,j-1]$</li>
</ul>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210721213844.png" alt="image-20210721213844186"></p>
<p>递推公式：<code>F[i,j]=F[F[i][j-1],j-1]</code>，$i=1,2,\cdots,n$，$j=0,,1,2,\cdots,k$，$2^k\leq n$，$k=logn$</p>
<p><strong>树上倍增法的两个关键步骤</strong>：</p>
<ol>
<li>先将两个点跳到同一层</li>
<li>让两个点同时向上跳，一直跳到它们的<strong>最近公共祖先的下一层</strong>为止</li>
</ol>
<p>也就是说先让深度大的$y$向上走到与$x$处于同一深度，然后$x,y$一起向上走。但是这里是按照倍增思想走的，而不是一步一步往上走的，因此速度比较快。</p>
<p>现在来思考两个问题：</p>
<ul>
<li>怎么让深度大的$y$向上走与$x$处于同一深度呢？</li>
<li>$x$和$y$一起向上走，怎么找到最近的公共祖先呢？</li>
</ul>
<p>先来解决第一个问题：怎么让深度大的$y$向上走与$x$处于同一深度呢？</p>
<p>假设$y$的深度比$x$的深度大，需要$y$向上走到与$x$处于同一深度，$k=3$，则求解过程如下：</p>
<ul>
<li>$y$向上走$2^3$步，如果此时到达节点的深度比$x$的深度小（说明跳的太远了，跳到了$x$的上面了），那么什么也不做</li>
<li>减小增量，$y$向上走$2^2$步，如果此时到达节点的深度比$x$的深度大（说明此时还处于$x$的下面），则$y$向上移动，令$y=F[y][2]$</li>
<li>减小增量，$y$向上走$2^1$步，如果此时到达节点的深度比$x$的深度相等（说明此时它俩处于同一深度），则$y$向上移动，令$y=F[y][2]$</li>
<li>减小增量，$y$向上走$2^0$步，如果此时到达节点的深度比$x$的深度小，那么什么也不做。由于上一次$y$已经与$x$处于同一深度了，而这次啥也没做，因此$y$仍然与$x$处于同一深度。</li>
</ul>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210721215346.png" alt="image-20210721215345942"></p>
<p>总结：</p>
<p>按照增量递减的方式，如果到达节点的深度比$x$的深度还要小，则什么也不做；如果到达节点的深度$\geq x$的深度时，则$y$向上移动，令$y=F[y][2]$，一直循环到增量为0，那么最后一定会有$x$和$y$处于同一深度。</p>
<p>再来解决第二个问题：$x$和$y$一起向上走，怎么找到最近的公共祖先呢？</p>
<p>假设$x,y$已经处于同一深度了，现在一起向上走，$k=3$，则其求解过程如下：</p>
<ul>
<li>$x$和$y$同时向上走$2^3$步，如果到达的节点相同，说明是公共祖先节点，但是不能保证是最近公共祖先，于是什么也不做</li>
<li>减少增量，$x,y$同时向上走$2^2$步，如果此时到达的节点不相同，则说明肯定不是最近公共祖先节点，那么此时$x,y$都要向上移动，令$x=F[x][2]$，$y=F[y][2]$</li>
<li><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210721220405.png" alt="image-20210721220404938"></li>
<li>减少增量，$x,y$同时向上走$2^1$步，如果此时到达的节点不同，那么此时$x,y$都要向上移动，令$x=F[x][1]$，$y=F[y][1]$</li>
<li>减少增量，$x$和$y$同时向上走$2^0$步，如果到达的节点相同，什么也不做</li>
<li>因此经过这么做，那么最终我们一定让$x,y$都处于它俩的最近公共祖先的下一层了。此时$x,y$的父节点就是最近公共祖先节点了，那么最终只需要$x$或者$y$向上走一步就可以到达最近公共祖先了。即最终的$F[x][0]$或者$F[y][0]$就是答案</li>
<li><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210721220600.png" alt="image-20210721220600144"></li>
</ul>
<p>完整的求解过程如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210721220655.png" alt="image-20210721220655472"></p>
<p>总结：按照增量递减的方式，如果到达的节点相同时，说明是公共祖先，但是不能保证就是最近公共祖先节点，所以什么也不做；如果到达的节点不相同，那么$x,y$同时往上走，一直到增量为0。此时$x,y$的父节点就是最近公共祖先节点了。</p>
<blockquote>
<p>问题：为什么碰到$F[x][k]==F[y][k]$时什么都不做，而且为什么此时就是公共祖先而不能是最近公共祖先呢？</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210722134122.png" alt="image-20210722134122538"></p>
<p>增量从大到小逐渐递减，设$k=2$，那么$F[x][2]=F[y][2]=0$，但是很明显，此时的$0$号节点只是它俩的公共祖先而已，此时我们啥也不做，也就是说$x$和$y$仍然原地踏步，并没有发生跳跃；然后$k$—，此时$k=1$，那么$F[x][1]=F[y][1]=2$，但是很明显，此时的$2$号节点只是它俩的公共祖先而已，此时我们啥也不做，也就是说$x$和$y$仍然原地踏步，并没有发生跳跃；然后$k$—，此时$k=0$，那么$F[x][0]=F[y][0]=4$，注意此时我们可以直观地看出来$4$是它俩的最近公共祖先，但是由于$F[x][0]=F[y][0]$，因此我们也是什么也不做，也就是说$x$和$y$仍然原地踏步，并没有发生跳跃；然后$k$—，此时$k$为-1，退出循环了。那么，我们发现$x$和$y$确实就是在最近公共祖先的下一层！所以最后$x$或者$y$再向上跳一步就到了最近公共祖先节点了，即$F[x][0]$或者$F[y][0]$就是答案了。</p>
</blockquote>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>主要就是利用树上倍增法来求解$LCA$，</p>
<p>这里最多有$N=40000$个节点，那么$2^k\leq40000$，所以$k\leq16$。也就是说我们要给这个<code>F[N][]</code>数组的第二维开的大小应该是$16$，即有$16$位二进制。</p>
<p>还有就是我们用$depth[0]=0$来当作哨兵，它有什么用处呢？假设从$i$开始跳$2^j$步，那么有可能此时已经跳出了整棵树的根节点，那么<code>fa[fa[j][k-1]][k-1]=0</code>，那么到达的那个虚无节点$fa[i][j]=0$，于是$depth[fa[i][j]]=depth[0]=0$。</p>
<blockquote>
<p>如何理解处理超过根节点呢？</p>
<p>举个栗子：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210722140317.png" alt="image-20210722140317627"></p>
<p>因为我们没有对根节点$fa[1][0]$赋值，所以它使用的是全局变量，于是$fa[1][0]=0$。可以知道，$fa[2][0]=1$。假设从$2$节点跳了$2^1$步，那么就会跳出根节点，此时的处理是这样的：$fa[2][1]=fa[fa[2][0]][0]=fa[1][0]=0$，那么$depth[fa[1][0]=depth[0]$，但是此时$depth[0]$还没有定义，那么我们可以给它定义为0，此时就可以表示跳出了根节点了。</p>
</blockquote>
<p>还有个细节要注意，我们是让深度更大的先往上跳到与深度较小的节点处于同一层。我们不妨假设$a$是深度较大的，$b$是深度较小的，那么如果$depth(a)&lt;depth(b)$，则交换，也就是说必须保证$a$的深度是$\geq b$的深度，然后对$a$往上跳。</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//对于树来说 有n个顶点 则有n-1条边  </span></span><br><span class="line"><span class="comment">//由于题目说了是无向边,所以最多有2(n-1)条边</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">40010</span>,M=N*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="comment">//记录每个节点的在树中的深度</span></span><br><span class="line"><span class="keyword">int</span> depth[N];</span><br><span class="line"><span class="comment">//fa[i][j]表示从i节点出发跳2^j步后所到达的节点</span></span><br><span class="line"><span class="keyword">int</span> fa[N][<span class="number">16</span>];</span><br><span class="line"><span class="comment">//宽搜的队列</span></span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//采用bfs,在构建这棵有根树的过程中,预处理出fa[i][j],预处理的时间复杂度是nlogn</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化深度为无穷大</span></span><br><span class="line">    <span class="built_in">memset</span>(depth,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> depth);</span><br><span class="line">    <span class="comment">//由于已知了q[0]是根节点  所以这里直接让tt=0了</span></span><br><span class="line">    <span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>]=root;</span><br><span class="line">    <span class="comment">//哨兵 如果跳超过了根节点,那么就设那些超过根节点的虚无节点的深度为0</span></span><br><span class="line">    depth[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//根节点的深度为1</span></span><br><span class="line">    depth[root]=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//进行宽搜</span></span><br><span class="line">    <span class="keyword">while</span>(hh&lt;=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=q[hh++];<span class="comment">//取出队头元素</span></span><br><span class="line">        <span class="comment">//遍历t的所有邻接点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];<span class="comment">//取出t的邻接点j</span></span><br><span class="line">            <span class="comment">//说明j还没有倍搜索过</span></span><br><span class="line">            <span class="keyword">if</span>(depth[j]&gt;depth[t]+<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//更新顶点j的深度</span></span><br><span class="line">                depth[j]=depth[t]+<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//将j加入队列中</span></span><br><span class="line">                q[++tt]=j;</span><br><span class="line">                <span class="comment">//由于赋值后depth[j]=depth[t]+1 说明j的深度大于t的深度</span></span><br><span class="line">                <span class="comment">//那么从j出发跳2^0步后,到达的节点就是t</span></span><br><span class="line">                fa[j][<span class="number">0</span>]=t;</span><br><span class="line">                <span class="comment">//上面已经处理了从j出发跳2^0步了</span></span><br><span class="line">                <span class="comment">//这里是处理从j出发跳2^1,2^2,...,2^15步所能到达的节点</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">15</span>;k++)</span><br><span class="line">                    fa[j][k]=fa[fa[j][k<span class="number">-1</span>]][k<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树上倍增法求出顶点a和顶点b的最近公共祖先</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//约定顶点a的深度必须&gt;=顶点b的深度,否则就要交换</span></span><br><span class="line">    <span class="keyword">if</span>(depth[a]&lt;depth[b])</span><br><span class="line">        <span class="built_in">swap</span>(a,b);</span><br><span class="line">    <span class="comment">//让深度较大的顶点a先往上跳到与深度较小的顶点b处于同一层(有可能a跳到了b身上)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">15</span>;k&gt;=<span class="number">0</span>;k--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=fa[a][k];</span><br><span class="line">        <span class="comment">//此时跳到了tmp这个节点 如果这节点的深度&gt;=顶点b的深度</span></span><br><span class="line">        <span class="comment">//说明tmp这个节点还没有跳超过顶点b这一层   那么则让a跳到tmp这个节点</span></span><br><span class="line">        <span class="keyword">if</span>(depth[tmp]&gt;=depth[b])</span><br><span class="line">            a=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里说明a跳到了b身上 此时两个重合 最近公共祖先就是a或者b</span></span><br><span class="line">    <span class="keyword">if</span>(a==b)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="comment">//如果能到这里,就说明a跳到了与b处于同一层</span></span><br><span class="line">    <span class="comment">//那么此时让a和b同时往上跳</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">15</span>;k&gt;=<span class="number">0</span>;k--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//说明它俩跳到的顶点不相同,那么不是公共祖先,则必然不可能是LCA</span></span><br><span class="line">        <span class="keyword">if</span>(fa[a][k]!=fa[b][k])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//让a跳到fa[a][k]这个顶点</span></span><br><span class="line">            a=fa[a][k];</span><br><span class="line">            <span class="comment">//让b跳到fa[b][k]这个顶点</span></span><br><span class="line">            b=fa[b][k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//退出循环后,a和b一定是跳到了它俩的最近公共祖先节点的下一层</span></span><br><span class="line">    <span class="comment">//那么此时它俩再向上跳2^0=1步就可以找到LCA了</span></span><br><span class="line">    <span class="comment">//因此最终返回 fa[a][0] 或者 fa[b][0]  都是可以的</span></span><br><span class="line">    <span class="keyword">return</span> fa[a][<span class="number">0</span>];      </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="comment">//整棵树的根节点</span></span><br><span class="line">    <span class="keyword">int</span> root=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="comment">//根据题目意思,如果b为-1,那么a就是整棵树的根节点</span></span><br><span class="line">        <span class="keyword">if</span>(b==<span class="number">-1</span>)</span><br><span class="line">            root=a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//建立无向边</span></span><br><span class="line">            <span class="built_in">add</span>(a,b);</span><br><span class="line">            <span class="built_in">add</span>(b,a);</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在构建这棵有根树的过程中,预处理出fa[i][j]</span></span><br><span class="line">    <span class="built_in">bfs</span>(root);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">    <span class="comment">//处理m个询问</span></span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="comment">//找到顶点a和顶点b的最近公共祖先</span></span><br><span class="line">        <span class="keyword">int</span> p=<span class="built_in">LCA</span>(a,b);</span><br><span class="line">        <span class="comment">//如果a是它俩的最近公共祖先</span></span><br><span class="line">        <span class="keyword">if</span>(p==a)</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="comment">//如果b是它俩的最近公共祖先    </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p==b)</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>最近公共祖先</category>
      </categories>
      <tags>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title>距离</title>
    <url>/2021/07/22/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/%E8%B7%9D%E7%A6%BB/</url>
    <content><![CDATA[<h1 id="距离"><a href="#距离" class="headerlink" title="距离"></a>距离</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210722165410.png" alt="image-20210722165410424"></p>
<hr>
<h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><h4 id="tarjan算法"><a href="#tarjan算法" class="headerlink" title="tarjan算法"></a>tarjan算法</h4><p>由于tarjan发明了很多算法，特别是在图论领域，因此很多算法都直接被称为了tarjan算法，需要注意区分的是，这里的tarjan算法是用来解决LCA问题的离线算法。</p>
<p>所谓的<strong>在线做法</strong>和<strong>离线做法</strong>都是针对有<strong>询问</strong>这种类型的题目。</p>
<ul>
<li>在线算法：每读入一个询问，都需要运行一次程序立即得到本次查询的答案。若一次查询需要$O(logn)$，则$m$次查询需要$O(mlogn)$</li>
<li>离线算法：读入所有询问，然后运行一次程序就可以得到所有查询的答案。</li>
</ul>
<p>tarjan算法利用并查集优越的时空复杂性，可以在$O(n+m)$时间内解决LCA问题。</p>
<blockquote>
<p>问题：为什么tarjan算法利用并查集就可以求出LCA呢？</p>
<p>如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210722170818.png" alt="image-20210722170818667"></p>
<p>从图中可以看出，节点$u$与子树$A$中的节点，它俩的最近公共祖先是根节点$root$，而且我们发现一个很强的性质就是：子树$A$中的每个节点的祖宗节点刚好就是$root$；节点$u$与子树$B$中的每个节点，它俩最近公共祖先是那个被涂色的节点，而这个节点LCA刚好就是节点子树$B$中每个节点的祖宗节点，也就是说$v$节点的祖宗节点是那个被涂色节点，而 从图中易知$u$和$v$的最近公共祖先恰好就是那个被涂色的节点。</p>
<p>因此，当我们遍历完$u$时，查询有关$u$的询问，比如$v$，然后使用并查集找到节点$v$的集合号，那么就是$u$和$v$的最近公共祖先LCA了。</p>
</blockquote>
<p>下面是tarjan算法求解LCA的过程：</p>
<ul>
<li>初始化集合号数组和访问数组，即<code>fa[i]=i</code>，<code>vis[i]=0</code>，这里$vis[i]=0$表示$i$这个节点还没有被访问过，$vis[i]=1$表示$i$这个节点已经被访问过了</li>
<li>从节点$u$出发进行深度优先遍历，标记$vis[u]=1$，深搜$u$所有还未被访问的邻接点，在遍历的过程中更新距离，回退时更新节点的集合号（祖宗节点）</li>
<li>当节点$u$的所有邻接点全部遍历完毕时，检查关于$u$的所有询问，若存在一个查询$u,v$，并且$vis[v]=1$，那么就利用并查集查找节点$v$的集合号，找到它的祖宗节点，那么这个祖宗节点就是$u$和$v$的最近公共祖先节点。</li>
</ul>
<p>举个栗子：</p>
<p>在树中求$5、6$的最近公共祖先，求解过程如下：</p>
<p>【1】初始化所有节点的集合号等于自己，访问数组都设置为还没有被访问过，即$fa[i]=i$，$vis[i]=0$</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210722180943.png" alt="image-20210722180942823"></p>
<p>【2】随意选择一个节点进行深搜，这里选择从根节点开始深度优先遍历，在遍历的过程中，将访问过的节点都设置为$vis[i]=1$</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210722181052.png" alt="image-20210722181051956"></p>
<p>【3】$8$号节点的所有邻接点都已经访问完毕了，没有与$8$相关的查询，则回退到$6$，更新$fa[8]=6$</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210722181120.png" alt="image-20210722181120440"></p>
<p>【4】遍历$6$号节点的下一个邻接点$9$，标记$vis[9]=1$，$9$号节点的所有邻接点都已经访问完毕了，没有与$9$相关的查询，则回退到$6$，更新$fa[9]=6$</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210722181141.png" alt="image-20210722181141114"></p>
<p>【5】$6$号节点的所有邻接点都已经访问完毕了，有与$6$相关的查询（查询$5$和$6$），但是由于此时$vis[6]\neq1$，并不满足$vis[u]=1$并且$vis[v]=1$（这里$u=5,v=6$），所以啥也不做，然后回退到$4$，更新$fa[6]=4$</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210722181335.png" alt="image-20210722181334949"></p>
<p>【6】$4$号节点的所有邻接点都已经访问完毕了，没有与$4$相关的查询，回退到$2$，更新$fa[4]=2$</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210722181412.png" alt="image-20210722181412378"></p>
<p>【7】遍历$2$号节点的下一个邻接点$5$，标记$vis[5]=1$，继续深度优先遍历到$7$，标记$vis[7]=1$，$7$号节点的所有邻接点都已经访问完毕了，没有与$7$相关的查询，回退到$5$，更新$fa[7]=5$</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210722181422.png" alt="image-20210722181421905"></p>
<p>【8】$5$号节点的所有邻接点都已经访问完毕了，有与$5$相关的查询（查询$5$和$6$），并且$vis[6]=1$，满足$vis[u]=1$并且$vis[v]=1$（这里$u=5,v=6$），那么就需要执行并查集，找到节点$v$的集合号。回退到$2$，更新$fa[5]=2$。设找到节点$v$的祖宗为$x$，那么$x$就是节点$u$和节点$v$的最近公共祖先</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210722181530.png" alt="image-20210722181530072"></p>
<p>【9】从$6$号节点开始利用并查集查找祖宗的过程如下：首先判断$6$的集合号$fa[6]=4$，找到$4$的集合号$fa[4]=2$，找到$2$的集合号$fa[2]=2$，所以找到祖宗（集合号为其自身）后返回，在回溯过程中更新祖宗到当前节点路径上所有节点的集合号，即更新$6、4$的父节点为$fa[4]=2$，$fa[6]=2$。那么此时$fa[6]=2$，即$2$号节点就是$5$号节点和$6$号节点的最近公共祖先</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210722181540.png" alt="image-20210722181540652"></p>
<p><strong>总结：</strong></p>
<p>在当前节点$u$的所有邻接点都已经访问完毕时，检查与$u$相关的查询$v$，注意此时$vis[u]$已经是1了，如果$vis[v]\neq1$，那么什么也不做；如果$vis[v]=1$，则利用并查集查找$v$的祖宗节点。最终$LCA(u,v)=fa[v]$。实际上，$u$的祖宗就是$u$向上查找第1个邻接点未访问完的节点，因为它的$fa[]$还没有更新，仍满足$fa[i]=i$，它就是$v$的祖宗。</p>
<p><strong>算法实现：</strong></p>
<p>并查集算法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x!=p[x])</span><br><span class="line">        p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tarjan算法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];~i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j=e[i];</span><br><span class="line">        <span class="keyword">if</span>(vis[j])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        dist[j]=dist[u]+w[i];</span><br><span class="line">        fa[j]=u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;query[u].<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//query[u][i]存储的是第i次询问时,与u相关的查询号  将其赋值给v</span></span><br><span class="line">        <span class="keyword">int</span> v=query[u][i];</span><br><span class="line">        <span class="comment">//query_id[u][i]存储的是第i次查询</span></span><br><span class="line">        <span class="keyword">int</span> id=query_id[u][i];</span><br><span class="line">        <span class="keyword">if</span>(vis[v])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> lca=<span class="built_in">find</span>(v);</span><br><span class="line">            ans[id]=dist[u]+dist[v]<span class="number">-2</span>*dist[lca];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>这道题就直接利用上面所讲述的方法，使用tarjan+并查集算法来解决LCA的离线算法。</p>
<p>树上任意两点之间的距离公式：$L=dist[u]+divt[v]-2\times dist[lca]$</p>
<p>$dist[u]$表示节点$u$到整棵树的根节点的距离；</p>
<p>$dist[v]$表示节点$v$到整棵树的根节点的距离；</p>
<p>$dist[lca]$，其中$lca$是节点$u$和节点$v$的最近公共祖先，表示节点$lca$到整棵树的根节点的距离；</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//这是一棵树  有N个节点 则有N-1条边 由于是无向边  所以要开2倍</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">10010</span>,M=<span class="number">2</span>*N;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;PII;</span><br><span class="line"><span class="keyword">int</span> n,m;    <span class="comment">//n是点数  m是询问次数</span></span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],w[M],idx;</span><br><span class="line"><span class="keyword">int</span> dist[N];    <span class="comment">//距离</span></span><br><span class="line"><span class="keyword">int</span> p[N];       <span class="comment">//并查集的集合号数组</span></span><br><span class="line"><span class="keyword">int</span> res[M];     <span class="comment">//存储询问的结果</span></span><br><span class="line"><span class="keyword">int</span> st[N];      <span class="comment">//标记当前节点是否已经被访问过  st[i]=1表示i节点被访问过了</span></span><br><span class="line"><span class="comment">//query[u]是存放关于节点u的查询信息</span></span><br><span class="line"><span class="comment">//query[u].first存放的是与u相关的那个查询是啥(比如说查询5 6  那么u就是5  query[5].first就是6)</span></span><br><span class="line"><span class="comment">//query[u].second存放的就是这次询问是第几次</span></span><br><span class="line">vector&lt;PII&gt;query[N]; <span class="comment">//存放查询数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//并查集查找x的祖宗节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x!=p[x])</span><br><span class="line">        p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建边</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    w[idx]=c;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//tarjan算法解决LCA的离线查询</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//标记节点u已经被访问过了</span></span><br><span class="line">    st[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//遍历节点u的所有邻接点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];~i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//j是u的邻接节点</span></span><br><span class="line">        <span class="keyword">int</span> j=e[i];</span><br><span class="line">        <span class="comment">//如果节点j还没有被访问过</span></span><br><span class="line">        <span class="keyword">if</span>(!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//更新顶点j的距离</span></span><br><span class="line">            dist[j]=dist[u]+w[i];</span><br><span class="line">            <span class="comment">//以下两句不能调换  因为调换后 经过find函数会进行路径压缩 更新了节点  导致错误</span></span><br><span class="line">            <span class="comment">//然后对顶点j进行深度优先遍历</span></span><br><span class="line">            <span class="built_in">tarjan</span>(j);</span><br><span class="line">            <span class="comment">//回退时更新顶点j的父节点为u</span></span><br><span class="line">            p[j]=u;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果有查询的话</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> item:query[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v=item.first;   <span class="comment">//取出与u相关的查询v</span></span><br><span class="line">        <span class="keyword">int</span> id=item.second; <span class="comment">//这是第几次查询</span></span><br><span class="line">        <span class="comment">//如果节点v之前已经遍历过了  </span></span><br><span class="line">        <span class="comment">//那么满足st[u]=1并且st[v]=1</span></span><br><span class="line">        <span class="keyword">if</span>(st[v])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//对节点v进行并查集操作  找到它的祖宗节点</span></span><br><span class="line">            <span class="comment">//那么这个祖宗节点就是节点u和节点v的最近公共祖先</span></span><br><span class="line">            <span class="keyword">int</span> lca=<span class="built_in">find</span>(v);</span><br><span class="line">            <span class="comment">//记录这次查询的结果 也就是树上节点u和节点v之间的距离</span></span><br><span class="line">            res[id]=dist[u]+dist[v]<span class="number">-2</span>*dist[lca];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="comment">//读入n-1个数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        <span class="comment">//建立无向边</span></span><br><span class="line">        <span class="built_in">add</span>(a,b,c);</span><br><span class="line">        <span class="built_in">add</span>(b,a,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读入m次询问</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="comment">//如果a==b 即查询自身到自身的距离 那肯定是0  那就直接使用全局res数组的0就好了</span></span><br><span class="line">        <span class="comment">//因此当a!=b时  才记录</span></span><br><span class="line">        <span class="keyword">if</span>(a!=b)</span><br><span class="line">        &#123;</span><br><span class="line">            query[a].<span class="built_in">push_back</span>(&#123;b,i&#125;);</span><br><span class="line">            query[b].<span class="built_in">push_back</span>(&#123;a,i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化每个点都是独立的集合</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        p[i]=i;</span><br><span class="line">    <span class="comment">//这里选择从根节点1进行深度优先遍历,进行tarjan算法</span></span><br><span class="line">    <span class="built_in">tarjan</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//输出这m次查询的结果</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>最近公共祖先</category>
      </categories>
      <tags>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title>食物链</title>
    <url>/2021/07/15/Algorithm-Improvement/Chapter4---Advanced%20Data%20Structure/%E5%B9%B6%E6%9F%A5%E9%9B%86/%E9%A3%9F%E7%89%A9%E9%93%BE/</url>
    <content><![CDATA[<h1 id="食物链"><a href="#食物链" class="headerlink" title="食物链"></a>食物链</h1><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210715205916.png" alt="image-20210715205849019"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>这题刚开始看的时候，都想不到会用到并查集。那么，我们就来分析一下，为什么需要用到并查集呢？</p>
<p>题目中提到，只有三类动物，但是每类动物中可能有很多个，每个动物都会有各自的编号。并且$A$吃$B$，$B$吃$C$，$C$吃$A$，这三类动物的食物链构成了有趣的环形。我们设如果$x$吃了$y$，则记录表示为$y\to x$。那么$A$吃$B$，$B$吃$C$，$C$吃$A$，可以表达为$B\to A,C\to B,A\to C$，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210715230906.png" alt="image-20210715230906789"></p>
<p>题目会给出一些信息，那么我们如何根据这些信息来判断各个动物之间的关系呢？是同类呢还是天敌关系呢？</p>
<p>我们把这些动物看成是军人，假设有$100$个军人，我们想知道每个军人是什么等级。</p>
<ul>
<li>如果我们是两两比较军人的关系，那么需要$O(n^2)$才能知道每个军人是什么等级</li>
<li>但是如果我们知道编号为$1$的军人它是司令，然后知道了剩下的$99$个军人与司令的关系，那么就可以在$O(n)$内知道每个军人是什么等级了。比如$2$号说：我比司令低一级，那么$2$号军人的等级就是军长，$5$号军人说：我比司令低两级，那么$5$号军人的等级就是师长。如果$90$号军人说：我比司令低一级，那么$90$号军人的等级就是军长。那么$2$号和$90$就是同类，处于同一个等级。不要被编号迷惑了，可以理解为$2$号成为军长的时间较早，$90$号成为军长较晚，但是他俩都是军长，是同类，处于同一个等级。</li>
</ul>
<p>因此，我们可以把司令看作是一个根节点，那么我们怎么知道每个点与司令这个根节点的关系呢？这其实就需要用到并查集呢！想要知道每个点与司令这个根节点的关系，其实就类似于并查集中的路径压缩。因此，我们可以使用并查集来查询和合并食物链中动物之间的关系。</p>
<p>这里给出<code>d[]</code>数组的解释：</p>
<p><code>d[i]</code>的含义：表示第$i$个动物在食物链中的深度，其实也就是第$i$个动物到它父节点的距离。</p>
<p>设根节点的深度为0，我们有以下定义：</p>
<ul>
<li>如果某类动物，它到根节点距离为0，则表明该类动物与根节点这类动物是同一类动物</li>
<li>如果某类动物，它到根节点距离为1，则表明根节点被该类动物吃</li>
<li>如果某类动物，它到根节点距离为2，则表明该类动物可以吃上一种情况的动物，而且该类动物被根节点吃（因为三类动物形成环）</li>
</ul>
<p>在本题中，我们可以用深度来表达动物在食物链中的关系。由于本题只有三种类型的动物，这三类动物的食物链构成了有趣的环形。$A$吃$B$，$B$吃$C$，$C$吃$A$，那么深度也只有$0,1,2$，因此当深度$\geq3$时，则可以通过模$3$运算，将其转换成$0,1,2$中的某一个。</p>
<p>现在来思考一个问题，我们 <strong>在查找时如何更新深度</strong>？</p>
<p>首先，通过并查集的查询操作，找到祖宗节点，当集合号等于自身时回溯，在回溯过程中需要更新集合号为祖宗的集合号，并且要更新当前节点的深度累加其父节点的深度。当深度$\geq3$时，则可以通过模$3$运算即可。即$d[x]=(d[x]+d[f_x])\%3$</p>
<blockquote>
<p>如何理解$d[x]=(d[x]+d[f_x])\%3$这个式子呢？</p>
<p>如图：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210718000800.png" alt="image-20210718000753778"></p>
</blockquote>
<p>当输入1吃2、2吃3、3吃4时，并查集如下左图所示。当查询1的集合号时，首先找到祖宗节点4，回溯时更新3号节点的深度为1，集合号为4；更新2号节点的深度为2，集合号为4；更新1号节点的深度为0，集合号为4，如下右图所示：</p>
<ul>
<li>对于3号节点来说，路径压缩前，它的父节点是4，距离为1，所以$d[x]=d[3]=1$；路径压缩后，找到集合的根节点是4号节点，那么3号节点的父节点就是4，距离为1，所以$d[x]=d[3]=1$，其父节点的深度其实就是4号节点到4号节点的深度，所以$d[f_x]=0$；所以路径压缩后，3号节点的深度为$d[3]=(d[x]+d[f_x])\%3=(1+0)\%3=1$</li>
<li>对于2号节点来说，路径压缩前，它的父节点是3，距离为1，所以$d[x]=d[2]=1$；路径压缩后，找到集合的根节点是4号节点，那么路径压缩后2号节点的父节点就是4，其父节点的深度其实就是3号节点到4号节点的深度，所以$d[f_x]=1$；所以路径压缩后，2号节点的深度为$d[2]=(d[x]+d[f_x])\%3=(1+1)\%3=2$</li>
<li>对于1号节点来说，路径压缩前，它的父节点是2，距离为1，所以$d[x]=d[2]=1$；路径压缩后，找到集合的根节点是4号节点，那么路径压缩后1号节点的父节点就是4，其父节点的深度其实就是2号节点到4号节点的深度，所以$d[f_x]=2$；所以路径压缩后，1号节点的深度为$d[1]=(d[x]+d[f_x])\%3=(1+2)\%3=0$</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210718002228.png" alt="image-20210718002227975"></p>
<p>再来考虑一个问题：<strong>合并时如何更新深度呢</strong>？</p>
<p>假设节点$x$的集合号为$a$，节点$y$的集合号为$b$，如果$a\neq b$，则合并集合号$p[a]=b$，更新$a$的深度为$d[a]=(d[y]-d[x]+c-1)\%3$。如何理解这个式子呢？</p>
<p>路径压缩后，节点$x$到祖宗节点$a$的距离为$d[x]$，节点$y$到祖宗节点$b$的距离为$d[y]$，那么如果合并集合号$p[a]=b$后？那么如何求节点$a$到它的祖宗节点$b$的距离呢？</p>
<p>由于$a\neq b$，说明$x$和$y$不在同一个集合中，所以才需要用到合并操作。</p>
<ul>
<li><p>当$x$和$y$是同类时，根据<code>d[]</code>的定义可知，同类的深度差为0。即$d[x]+?$与$dy$是相等的。因此有如下式子推导：</p>
<p>$dx+?=dy$$\iff$</p>
<p>$dx+?=dy+0$$\iff$</p>
<p>$?=dy-dx+0$$\iff$</p>
<p>$?=(dy-dx+3+0)\%3$       由于$x$和$y$是同类， 根据题意，此时$c=1$，我们可以发现式子中的0其实就是$c-1=1-1=0$。因此用$c-1$代替0即可</p>
<p>$\iff ?=(dy-dx+3+c-1)\%3$   这里$dy-dx+3$之所以要加3是因为有可能$dy-dx$是负数，导致最终结果是负数，负数不能取模，所以需要转换为正数。模3是因为该食物链为环形</p>
</li>
<li><p>当$x$和$y$是异类时，不妨假设$x$吃$y$，根据<code>d[]</code>的定义可知，合并集合后，$x$到祖宗节点的距离 比 $y$到祖宗节点的距离 多1。即$d[x]+?$与$dy+1$是相等的。因此有如下式子推导：</p>
<p>$dx+?=dy+1$$\iff$</p>
<p>$?=(dy-dx+1)$$\iff$</p>
<p>$?=(dy-dx+3+1)\%3$     由于$x$和$y$是异类，$x$吃$y$， 根据题意，此时$c=2$，我们可以发现式子中的1其实就是$c-1=2-1=1$。因此用$c-1$代替1即可</p>
<p>$\iff ?=(dy-dx+3+c-1)\%3$  这里$dy-dx+3$之所以要加3是因为有可能$dy-dx$是负数，导致最终结果是负数，负数不能取模，所以需要转换为正数。模3是因为该食物链为环形</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210718094601.png" alt="image-20210718094601633">      </p>
</li>
</ul>
<p>举个栗子：</p>
<p>输入6吃2，两个节点属于不同的集合，其中6号节点属于4号集合，6号节点属于7号集合，执行合并，那么$p[7]=4$，更新7号节点的深度为$d[7]=(d[2]-d[6]+3+2-1)\%3=2$，合并更新图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210718210130.png" alt="image-20210718210130274"></p>
<p>当下次查询6号节点的集合号时，找到它的祖宗节点4，回溯时同时更新6号节点的深度为$d[6]=(d[6]+d[7])\%3=0$，查询更新图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210718210557.png" alt="image-20210718210557278"></p>
<p>因此，我们来总结以下就是，如果$x$的集合号$a$与$y$的集合号$b$不相同，则说明它俩不在同一个集合中，这是才需要用到并查集的合并操作。根据以上分析推导可知，最终合并时更新深度其实就只有一个式子：$?=(dy-dx+3+c-1)\%3$ </p>
<p>最后再来看一个问题，<strong>深度满足什么关系是真话</strong>？</p>
<p>这里判断是否为真话或假话，是在$x$和$y$属于同一个集合中讨论的，因为属于同一个集合的话，则不需要合并操作，那么就没有未知变量$d[a]$，不需要求未知变量，而且在这里的全部变量都是已知的，因此我们可以用这些已知变量推导出一些式子，然后我们判断这些式子是否正确就可以判断是否为真话还是假话了。因此可以在这里讨论真假话：</p>
<ul>
<li><p>如果$x$和$y$是同类，那么深度差为0，那么有如下式子推导：</p>
<p>$dx=dy\iff$</p>
<p>$dx=dy+0\iff$</p>
<p>$dx-dy=0\iff$</p>
<p>$(dx-dy+3)\%3=0$    由于$x$和$y$是同类， 根据题意，此时$c=1$，我们可以发现式子中的0其实就是$c-1=1-1=0$。因此用$c-1$代替0即可</p>
<p>$\iff (dx-dy+3)\%3=c-1$   也就是说当$x$和$y$在同一个集合，然后$x$和$y$是同类时，如果满足$(dx-dy+3)\%3$与$c-1$相等，则说明是真话，否则就是假话</p>
</li>
<li><p>如果$x$和$y$是异类，假设$x$吃$y$，那么深度差为$d[x]-d[y]=1$或者$d[x]-d[y]=-2$。如上图所示，1吃2，那么深度差为$d[1]-d[2]=0-2=-2$；2吃3，那么深度差为$d[2]-d[3]=2-1=1$，对于深度差为-2的话，我们可以先加上3，然后就会变为1了，接着在模3即可，对于深度差为1的话，我们先加上3，然后就会变为4，接着再模3即可。那么有如下式子推导：</p>
<p>$dx=dy+1\iff$</p>
<p>$dx-dy=1\iff$</p>
<p>$(dx-dy+3)\%3=1\iff $    由于$x$和$y$是异类，$x$吃$y$，根据题意，此时$c=2$，我们可以发现式子中的1其实就是$c-1=2-1=1$。因此用$c-1$代替1即可</p>
<p>$(dx-dy+3)\%3=c-1$   也就是说当$x$和$y$在同一个集合，然后$x$和$y$是异类时，如果满足$(dx-dy+3)\%3$与$c-1$相等，则说明是真话，否则就是假话</p>
<p>因此，从上面分析可知，在同一个集合中，不论是同类还是被吃关系，公式统一为$(dx-dy+3)\%3=c-1$，如果不满足此等式，则为假话</p>
</li>
</ul>
<p>  <strong>算法设计</strong>：</p>
<ol>
<li>若$x$或$y$大于$n$，或者$c=2$并且$x==y$，则为假话</li>
<li><p>执行c x y指令时，首先查询$x$和$y$的集合号。查询集合号回归时，更新这条路径上每个节点的深度，$d[x]=(d[x]+d[f_x])\%3$。设$x$的集合号为$a$，$y$的集合号为$b$，则分以下两种情况讨论：</p>
<ul>
<li>当$a\neq b$时，说明$x$和$y$不在同一个集合中，那么需要合并$p[a]=b$，更新$a$的深度为$d[a]=(d[y]-d[x]+3+c-1)\%3$</li>
<li>当$a=b$时，说明$x$和$y$在同一个集合中，如果$(d[x]-d[y]+3)\%3!=c-1$，则为假话</li>
</ul>
<p><strong>算法实现：</strong></p>
<p>（1）初始化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    p[i]=i;</span><br><span class="line">      d[i]=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>（2）查找集合号。查询$x,y$的集合号，在返回过程中，除了要统一路径上每个节点的集合号外，还要更新$d[x]$的值（将当前节点的$d$值($d[x]$)累加其父节点的$d$值$d[f_x]$模3）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x!=p[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u=<span class="built_in">find</span>(p[x]);</span><br><span class="line">        d[x]=(d[x]+d[p[x]])%<span class="number">3</span>;</span><br><span class="line">        p[x]=u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>  （3）判断假话数量。对输入的每一条指令，如果$x$或$y$大于$n$，或者$c=2$并且$x==y$，则为假话，$total$++；否则查询集合号，设$x$的集合号为$a$，$y$的集合号为$b$，当$a\neq b$时，合并集合号$p[a]=b$，更新$a$的深度为$d[a]=(d[y]-d[x]+3+c-1)\%3$，当$a=b$时，说明$x$和$y$在同一个集合中，如果$(d[x]-d[y]+3)\%3!=c-1$，则为假话，$total++$。</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(k--)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;c,&amp;x,&amp;y);</span><br><span class="line">    <span class="keyword">if</span>(x&gt;n||y&gt;n||(c==<span class="number">2</span>&amp;&amp;x==y))</span><br><span class="line">        total++;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="built_in">find</span>(x);</span><br><span class="line">        <span class="keyword">int</span> b=<span class="built_in">find</span>(y);</span><br><span class="line">        <span class="keyword">if</span>(a==b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((dx-dy+<span class="number">3</span>)%<span class="number">3</span>!=c<span class="number">-1</span>)</span><br><span class="line">                total++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p[a]=b;</span><br><span class="line">            d[a]=(d[y]-d[x]+<span class="number">3</span>+c<span class="number">-1</span>)%<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 50010</span></span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="keyword">int</span> total;</span><br><span class="line"><span class="keyword">int</span> p[N],d[N];</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">//每个点都是独立的集合  集合号为它自身</span></span><br><span class="line">		p[i]=i;</span><br><span class="line">        <span class="comment">//每个节点到它自身的距离为0  即自身深度为0</span></span><br><span class="line">		d[i]=<span class="number">0</span>;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在查询点x的祖宗节点过程中  更新d[x]的新值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x!=p[x])</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">//寻找节点x的父节点</span></span><br><span class="line">		<span class="keyword">int</span> u=<span class="built_in">find</span>(p[x]);</span><br><span class="line">        <span class="comment">//更新d[x]的值</span></span><br><span class="line">		d[x]=(d[x]+d[p[x]])%<span class="number">3</span>;</span><br><span class="line">        <span class="comment">//回溯时进行了路径压缩,记录每个节点x的祖宗节点为u</span></span><br><span class="line">        p[x]=u;</span><br><span class="line">	&#125; 	</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="comment">//先进行初始化操作</span></span><br><span class="line">	<span class="built_in">init</span>();</span><br><span class="line">	<span class="keyword">while</span>(k--)</span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="keyword">int</span> c,x,y;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;c,&amp;x,&amp;y);</span><br><span class="line">        <span class="comment">//x或y大于n,或者是x吃y,并且x==y,即同类吃同类  则为假话</span></span><br><span class="line">		<span class="keyword">if</span>(x&gt;n||y&gt;n||(c==<span class="number">2</span>&amp;&amp;x==y))</span><br><span class="line">			total++;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> a=<span class="built_in">find</span>(x);  <span class="comment">//查询节点x的集合号(祖宗节点)</span></span><br><span class="line">			<span class="keyword">int</span> b=<span class="built_in">find</span>(y);  <span class="comment">//查询节点y的集合号(祖宗节点)</span></span><br><span class="line">            <span class="comment">//如果集合号相同,说明x和y在同一个集合中,那么不需要合并</span></span><br><span class="line">			<span class="keyword">if</span>(a==b)</span><br><span class="line">			&#123;</span><br><span class="line">                <span class="comment">//如果d[x]-d[y]+3)%3不等于c-1,则为假话</span></span><br><span class="line">				<span class="keyword">if</span>((d[x]-d[y]+<span class="number">3</span>)%<span class="number">3</span>!=c<span class="number">-1</span>)</span><br><span class="line">					total++;</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">//否则说明集合号不同,说明x和y不在同一个集合中,那么就需要进行合并操作了</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				p[a]=b; <span class="comment">//a的父节点是b</span></span><br><span class="line">                <span class="comment">//更新节点a到父节点的距离d[a]</span></span><br><span class="line">				d[a]=(d[y]-d[x]+<span class="number">3</span>+c<span class="number">-1</span>)%<span class="number">3</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,total);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
</search>
