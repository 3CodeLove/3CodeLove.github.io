<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>木棒</title>
    <url>/2021/09/03/Algorithm-Improvement/Chapter2---Search/DFS%E4%B9%8B%E5%89%AA%E6%9E%9D%E4%BC%98%E5%8C%96/%E6%9C%A8%E6%A3%92/</url>
    <content><![CDATA[<h1 id="木棒"><a href="#木棒" class="headerlink" title="木棒"></a>木棒</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210903230523.png" alt="image-20210903230523463"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>首先明确一下概念：<strong>木棒</strong>指原来为被砍断的，<strong>木棍</strong>指砍断后的。</p>
<p>我们可以从小到大枚举原始木棒的长度的长度<code>length</code>(也就是枚举答案)。假设有$cnt$根原始木棒，设所有小木棍的长度之和为$sum$，那么有$cnt\times length=sum$，也就是说必然有<code>length</code>是<code>sum</code>的约数。</p>
<p>对于枚举的每个原始木棒的长度<code>length</code>，我们可以依次搜索每根原始木棒由哪些小木棍组成。搜索所面对的状态包括：</p>
<ul>
<li>已经拼好的原始木棒的个数$u$（其实也就是当前在模拟第$u$根原始木棒的拼凑）</li>
<li>正在拼凑的这根原始木棒中的那些小木棍的长度之和$cur$</li>
<li>这根原始木棒中的拼凑的起始小木棍的编号$start$</li>
</ul>
<p>在每个状态下，我们从尚未使用的小木棍中选择一个，尝试放入当前的这根原始木棒中，然后递归到新的状态。递归边界就是成功拼好这$cnt$根原始木棒，或者因为无法继续拼接而宣告失败。</p>
<p>考虑剪枝优化：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210903231414.png" alt="image-20210903231414145"></p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210903231452.png" alt="image-20210903231452641"></p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210903231530.png" alt="image-20210903231516460"></p>
<p>这里的（3）和（4）剪枝特别难理解….</p>
<hr>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">70</span>;</span><br><span class="line"><span class="keyword">int</span> w[N];   <span class="comment">//存储小木棍的长度</span></span><br><span class="line"><span class="keyword">bool</span> st[N]; <span class="comment">//标记某根小木棍是否已经被使用过了</span></span><br><span class="line"><span class="comment">//sum是所有小木棍的长度总和  length是枚举的原始木棒的长度</span></span><br><span class="line"><span class="keyword">int</span> n,sum,length;</span><br><span class="line"></span><br><span class="line"><span class="comment">//u表示当前枚举的是第u根原始木棒</span></span><br><span class="line"><span class="comment">//cur表示当前枚举的第u根原始木棒时,这个木棒里面的那些已经拼凑好的木棍长度之和是cur</span></span><br><span class="line"><span class="comment">//start表示枚举第u根原始木棒时 这个木棒中拼凑的起始木棍编号</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> cur,<span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//已经模拟完了u根原始木棒 发现它们的长度之和已经等于sum了 则是合法解</span></span><br><span class="line">    <span class="keyword">if</span>(u*length==sum)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//如果当前原始木棒中那些已经拼凑好的木棍长度之和已经是这根原始木棒的长度</span></span><br><span class="line">    <span class="comment">//那么我们就继续去模拟下一根原始木棒 讨论看看下一根原始木棒该怎么拼凑出来</span></span><br><span class="line">    <span class="keyword">if</span>(cur==length)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(u+<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);    <span class="comment">//u+1表示下一个原始木棒</span></span><br><span class="line">    <span class="comment">//对于模拟的这跟原始木棒 它组内的木棍编号的从大到小的</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果i这根小木棍已经被用过了 则跳过</span></span><br><span class="line">        <span class="keyword">if</span>(st[i])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//如果把i这根小木棍放进这个组内 使得长度之和大于这根原始木棒的长度 则不把i放进来 跳过</span></span><br><span class="line">        <span class="keyword">if</span>(cur+w[i]&gt;length)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        st[i]=<span class="literal">true</span>; <span class="comment">//标记i这根小木棍已经被用过了</span></span><br><span class="line">        <span class="comment">//如果把i这根小木棍放进该组内 可以满足条件 则返回true</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">dfs</span>(u,cur+w[i],i+<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//恢复现场</span></span><br><span class="line">        st[i]=<span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//cur==0表示拼凑第一根小木棍就失败了</span></span><br><span class="line">        <span class="comment">//cur+w[i]==length表示拼凑最后一根小木棍失败了</span></span><br><span class="line">        <span class="keyword">if</span>(cur==<span class="number">0</span>||cur+w[i]==length)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> j=i;</span><br><span class="line">        <span class="comment">//如果把i这根小木棍放进这个模拟的原始木棒中不合法  那么就跳过所有木棍长度与i相等的木棍</span></span><br><span class="line">        <span class="keyword">while</span>(j&lt;n&amp;&amp;w[j]==w[i])</span><br><span class="line">            j++;</span><br><span class="line">        <span class="comment">//这里要记得让i=j-1 因为我们最后还要执行for中的i++</span></span><br><span class="line">        <span class="comment">//比如 5 5 5 6  结束while循环j指向6 执行i=j-1后 i指向最后一个5</span></span><br><span class="line">        <span class="comment">//最后再执行i++  那么i就指向6了</span></span><br><span class="line">        i=j<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//枚举完了还没有成功,就返回失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt;n,n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(st,<span class="number">0</span>,<span class="keyword">sizeof</span> st); <span class="comment">//清空上一次的状态</span></span><br><span class="line">        sum=<span class="number">0</span>;  <span class="comment">//清空上一次的状态</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w[i]);</span><br><span class="line">            sum+=w[i];  <span class="comment">//计算这些木棍的总和</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(w,w+n);    <span class="comment">//排序</span></span><br><span class="line">        <span class="built_in">reverse</span>(w,w+n); <span class="comment">//将木棍从大到小排序</span></span><br><span class="line">        <span class="comment">//对于枚举原始的这些等长木棒  我们从小到大开始</span></span><br><span class="line">        <span class="comment">//这样当找到第一个满足条件的木棒的长度时  它一定是最小的原始木棒长度</span></span><br><span class="line">        length=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//小木棍的总长度是sum 而这些小木棍组成了那些等长的原始木棒</span></span><br><span class="line">            <span class="comment">//因此那些原始木棒的长度之和也是sum 假设有cnt根原始木棒 而每根原始木棒的长度为length</span></span><br><span class="line">            <span class="comment">//那么一定有cnt*length=sum  因此sum一定可以除尽length</span></span><br><span class="line">            <span class="comment">//u=0其实就是枚举第一根原始木棒</span></span><br><span class="line">            <span class="comment">//cur=0表示枚举的第一根原始木棒中那些小木棍的长度之和为0</span></span><br><span class="line">            <span class="comment">//start=0表示枚举的第一根原始木棒中所,第一个小木棍的编号为0</span></span><br><span class="line">            <span class="keyword">if</span>(sum%length==<span class="number">0</span>&amp;&amp;<span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,length);</span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">//找到第一个满足条件的原始木棒的长度  直接break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//尝试让原始木棒长度增大</span></span><br><span class="line">            length++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>DFS</category>
      </categories>
      <tags>
        <tag>DFS剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title>回转游戏</title>
    <url>/2021/09/04/Algorithm-Improvement/Chapter2---Search/IDA%20Star/%E5%9B%9E%E8%BD%AC%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h1 id="回转游戏"><a href="#回转游戏" class="headerlink" title="回转游戏"></a>回转游戏</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210904122300.png" alt="image-20210904122300032"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>本题采用 IDA<em> 算法，即迭代加深的 A</em> 算法。</p>
<p>估价函数：</p>
<ul>
<li>统计中间8个方格中出现次数最多的数出现了多少次，记为出现了$k$次</li>
<li>每次操作会从中间8个方格中移出一个数，再移入一个数，所以最多会减少一个不同的数。</li>
<li>我们把中间8个方格中的那些数都转变为出现次数最多的那个数，则需要$8-k$次移动。因此估价函数可以设为$8-k$</li>
</ul>
<p>剪枝：记录上一次的操作，本次操作避免枚举上一次的逆操作。比如执行A操作，然后再执行F操作，那么相当于没有移动。</p>
<p>如何保证答案的字典序最小？由于最短操作步数是一定的，因此每一步枚举时先枚举字典序小的操作即可。</p>
<p>假设答案最少需要$k$步，每次需要枚举7种不同操作（除了上一步的逆操作），因此最坏情况下需要枚举$7^k$种方案。但加入启发函数后，实际枚举到的状态数很少。</p>
<p>如下图，我们给图形中的每个方格都给一个标号，并且把A到H这8种操作都给一个0到7的编号：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210904122724.png" alt="image-20210904122724046"></p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">30</span>;</span><br><span class="line"><span class="comment">//给图形中的每个方格一个标号</span></span><br><span class="line"><span class="keyword">int</span> op[<span class="number">8</span>][<span class="number">7</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">22</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">17</span>, <span class="number">21</span>, <span class="number">23</span>&#125;,</span><br><span class="line">    &#123;<span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>&#125;,</span><br><span class="line">    &#123;<span class="number">19</span>, <span class="number">18</span>, <span class="number">17</span>, <span class="number">16</span>, <span class="number">15</span>, <span class="number">14</span>, <span class="number">13</span>&#125;,</span><br><span class="line">    &#123;<span class="number">23</span>, <span class="number">21</span>, <span class="number">17</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">22</span>, <span class="number">20</span>, <span class="number">15</span>, <span class="number">11</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//将A到H的操作都编号为0到7</span></span><br><span class="line"><span class="comment">//opposite[0]=5 表示0的相反操作是5</span></span><br><span class="line"><span class="keyword">int</span> opposite[<span class="number">8</span>] = &#123;<span class="number">5</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="comment">//中间8个格子的编号</span></span><br><span class="line"><span class="keyword">int</span> center[<span class="number">8</span>] = &#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> q[N];       <span class="comment">//记录题目中输入的数字</span></span><br><span class="line"><span class="keyword">int</span> path[<span class="number">100</span>];  <span class="comment">//记录方案</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//计算估价函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum[<span class="number">4</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x=center[i];</span><br><span class="line">        sum[q[x]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;    <span class="comment">//找到中间8个方格中出现次数最多的那个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)<span class="comment">//方格中的数字只能是1 2 3</span></span><br><span class="line">        k=<span class="built_in">max</span>(k,sum[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">8</span>-k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环移动的操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operate</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t=q[op[x][<span class="number">0</span>]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">        q[op[x][i]]=q[op[x][i+<span class="number">1</span>]];</span><br><span class="line">    q[op[x][<span class="number">6</span>]]=t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代加深  depth是当前搜索层   max_depth是深度限制 last是上一次的操作</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> depth,<span class="keyword">int</span> max_depth,<span class="keyword">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(depth+<span class="built_in">f</span>()&gt;max_depth)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">f</span>()==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//依次按照字典序枚举A到H这8种操作</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(opposite[i]!=last)<span class="comment">//当前i这个操作的逆向操作不等于上一次的操作</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">operate</span>(i); <span class="comment">//执行i操作</span></span><br><span class="line">            path[depth]=i;  <span class="comment">//记录当前层的操作是i</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">dfs</span>(depth+<span class="number">1</span>,max_depth,i))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//恢复现场</span></span><br><span class="line">            path[depth]=<span class="number">0</span>;</span><br><span class="line">            <span class="built_in">operate</span>(opposite[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt;q[<span class="number">0</span>],q[<span class="number">0</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">24</span>;i++)   <span class="comment">//读入方格中的数字</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q[i]);</span><br><span class="line">        <span class="keyword">int</span> depth=<span class="number">0</span>;    <span class="comment">//最大深度限制</span></span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">dfs</span>(<span class="number">0</span>,depth,<span class="number">-1</span>))</span><br><span class="line">            depth++;</span><br><span class="line">        <span class="keyword">if</span>(!depth)  <span class="comment">//深度为0  不需要移动</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;No moves needed&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;depth;i++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,<span class="string">&#x27;A&#x27;</span>+path[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最中间的8个格子最终都是相同的 编号是从6开始  那么输出q[6]即可</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n%d\n&quot;</span>,q[<span class="number">6</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>IDA*</tag>
      </tags>
  </entry>
  <entry>
    <title>虫洞</title>
    <url>/2021/07/11/Algorithm-Improvement/Chapter3---Gragh-Theory/Negative-Circle/%E8%99%AB%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="虫洞"><a href="#虫洞" class="headerlink" title="虫洞"></a>虫洞</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210711231829.png" alt="image-20210711231829264"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>这题主要是要读懂题目，刚开始读不懂，后来再理解这题其实就是一个裸的求负环。</p>
<p>虫洞它是单向边，路径是双向边，因此建图时，图中就会既有单项边，又有双向边。”通过虫洞，它可以回到过去的某个时刻“这句话的意思其实就是说明虫洞的单向边是负值</p>
<p>读懂题目的意思后，用spfa求负环就好了</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//边数=路径的双向边2500*2+虫洞的单向边200=5200</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">510</span>,M=<span class="number">5210</span>;</span><br><span class="line"><span class="comment">//n表示田地的数量  m1表示路径的数量  m2表示虫洞单向边的数量</span></span><br><span class="line"><span class="keyword">int</span> n,m1,m2;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],w[M],idx;</span><br><span class="line"><span class="keyword">int</span> q[N],cnt[N],dist[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="comment">//建图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    w[idx]=c;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//spfa求负环</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//有多组测试数据 要初始化</span></span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);  <span class="comment">//求负环时  对于dist数组没有任何要求,不用初始化都可以</span></span><br><span class="line">    <span class="built_in">memset</span>(st,<span class="number">0</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span> cnt);</span><br><span class="line">    <span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//在新图中添加一个虚拟源点就等效于 一开始将原图中的所有节点都加入循环队列q中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        q[tt++]=i;</span><br><span class="line">        <span class="comment">//这里从初始化为0 其实含义就是：在新图中,虚拟源点到其他n个节点连一条长度为0的边</span></span><br><span class="line">        dist[i]=<span class="number">0</span>;</span><br><span class="line">        st[i]=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(hh!=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=q[hh++];</span><br><span class="line">        <span class="keyword">if</span>(hh==N)</span><br><span class="line">        hh=<span class="number">0</span>;</span><br><span class="line">        st[t]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j]&gt;dist[t]+w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j]=dist[t]+w[i];</span><br><span class="line">                cnt[j]=cnt[t]+<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//存在负环  那么他可以回到过去</span></span><br><span class="line">                <span class="keyword">if</span>(cnt[j]&gt;=n) </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q[tt++]=j;</span><br><span class="line">                    <span class="keyword">if</span>(tt==N)</span><br><span class="line">                    tt=<span class="number">0</span>;</span><br><span class="line">                    st[j]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//说明不存在负环  那么他不可用回到过去</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">        idx=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m1,&amp;m2);</span><br><span class="line">        <span class="comment">//给路径的双向边建图</span></span><br><span class="line">        <span class="keyword">while</span>(m1--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a,b,c;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">            <span class="built_in">add</span>(a,b,c);</span><br><span class="line">            <span class="built_in">add</span>(b,a,c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//给虫洞的单向边建图</span></span><br><span class="line">        <span class="keyword">while</span>(m2--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a,b,c;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">            <span class="comment">//注意边的权值是-c</span></span><br><span class="line">            <span class="built_in">add</span>(a,b,-c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//存在负环 则可以回到过去</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">spfa</span>())</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">        <span class="comment">//不存在负环 则不可以回到过去</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>负环</category>
      </categories>
      <tags>
        <tag>负环</tag>
      </tags>
  </entry>
  <entry>
    <title>单词环</title>
    <url>/2021/07/12/Algorithm-Improvement/Chapter3---Gragh-Theory/Negative-Circle/%E5%8D%95%E8%AF%8D%E7%8E%AF/</url>
    <content><![CDATA[<h1 id="单词环"><a href="#单词环" class="headerlink" title="单词环"></a>单词环</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210712192242.png" alt="image-20210712192242017"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>这题主要是要用到spfa判断正环+01分数规划+spfa玄学优化</p>
<p>我们先来思考一下该怎么建图呢？</p>
<p>如果按照常规思路，我们把一个字符串看作一个节点，那么题目最多有$10^5$个节点，那么会最多会有多少条边呢？我们来考虑最坏情况，这$10^5$个字符串都是相同的，以3个完全相同的字符串为栗子，比如：</p>
<ul>
<li>【1】$aaaaa$</li>
<li>【2】$aaaaa$</li>
<li>【3】$aaaaa$</li>
</ul>
<p>可以发现对于【1】来说，它可以接到【2】和【3】上，那么有$3-1=2$种可能，也就是说要从【1】引出两条有向边，分别指向【2】和【3】。同理分析可知，如果$10^5$个字符串都相同，则对于每个字符串来说，都会引出$10^5-1$条边，为了方便起见，就看作是引出$10^5$条边。有$10^5$个节点，每个节点会引出$10^5$条有向边，因此总共有$10^5\times 10^5=10^{10}$条有向边。很明显，点数为$10^5$，边数为$10^{10}$，存储空间要爆炸。因此，我们需要思考该怎么建图呢？</p>
<p>从题目描述中，我们可以知道，一个字符串除了前面的2个字符和后面的2个字符有用之外，字符串中间的其他所有字符都没有用，因此，我们可以这样建图：</p>
<p>直接hash前面的两个字符和后面的两个字符作为节点，该字符串的长度作为这两个节点之间的边的权值。对于一个字符串来说，它后面的两个字符，每个字符都有26种可能，因此这两个字符产生了$26\times26=676$种可能，也就是最多会有$676$个节点。例如题目中的第一个字符串$ababc$，它后面的$bc$就确定了图中的一个顶点，第二个字符串$bckjaca$，它后面的$ca$就确定了图中的一个顶点，第三个字符串$caahoynaab$，它后面的$ab$就确定了图中的一个顶点。也就是说对于后面两个字符所确定的一种可能，都会对应地确定了图中的一个顶点。那么有$26\times 26$种可能，也就是确定了图中最多会有$676$个顶点。由之前分析可知，每个节点最多很引出$10^5$条有向边。因此这种建图方式最多会引出$676\times 10^5=6.76\times 10^7$条有向边，空间还算好一些。</p>
<p>如下图解释题目中的栗子：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210712194716.png" alt="image-20210712194716858"></p>
<p>知道了该怎么建图后，我们再来思考题目要求的是什么？题目想要求的是形成环的这个串它的平均长度最大，转换到我们建好的图中，意思就是：边权之和/节点个数 最大。即$\dfrac {\sum w_i}{\sum 1}$要最大</p>
<p>要求这个值最大，满足单调性，很明显这就是一个01分数规划问题，那么就可以使用二分算法来二分答案了。我们设某一时刻二分出来的答案为$mid$（但不保证这就是最终正确想要的最大的那个答案），如果当前这个答案$mid$不够大，则说明还可以更大，即</p>
<p>$\dfrac {\sum w_i}{\sum 1}&gt;mid$</p>
<p>$\iff$ $\sum w_i&gt;mid*\sum 1$</p>
<p>$\iff$ $\sum w_i-mid*\sum 1&gt;0$</p>
<p>$\iff$$\sum w_i-\sum mid*1&gt;0$</p>
<p>$\iff$ $\sum (w_i-mid*1)$</p>
<p>那么也就是说，对于每一条边，给它赋权值为$w_i-mid*1$，如果存在正环，也就意味着有一个环的权值和大于0，也就是$\sum (w_i-mid\times 1)&gt;0$，就意味着$mid$需要更大，由于是单调递增的，那么此时就应该执行$L=mid$，否则就是执行$R=mid$。</p>
<p>这里还要思考一下二分的区间是啥？由于$\sum w_i$和$\sum 1$都是正数，因此相除的话一定是大于0的，注意这里是浮点数相除哦！因此左范围一定大于0。由$\dfrac {\sum w_i}{\sum 1}$式子可知，要想取最大，则分子要最大，分子要最小，由于最多有$10^5$条边，每条边的权值最大是$1000$，所以$\sum w_i$最大是$1000\times 10^5$。由于最多有$10^5$条边，所以至少有$10^5$个节点，所以$\sum 1$最小为$10^5$，于是$\dfrac {\sum w_i}{\sum 1}=\dfrac {1000\times 10^5}{10^5}$最大为$1000$。因此答案区间就是$(0,1000]$。</p>
<p>题目说了不一定存在环串，那么我们该怎么知道呢？从$w_i-mid\times1$可知，这是一个递减的线性函数，当$mid$取0时，有最大值，因此我们可以先尝试$mid=0$，如果$w_i-mid\times 1\leq 0$，那么$\sum w_i-mid\times 1\leq0$，因此对于剩下的所有节点，必定是$\sum w_i-mid\times 1\leq0$，但是这个式子显然与$\sum (w_i-mid\times 1)&gt;0$这个存在正环的式子不矛盾。因此，只要带入$mid=0$，验证一下看看这个式子$\sum (w_i-mid*1)$是否满足正环，如果不满足，那么全部都不满足，输出无解，否则说明可以求解。</p>
<p>一般来说，如果题目要求保留$k$位小数，那么我们一般把精度多控制两位，即精度位$eps=1e^{-(k+2)}$</p>
<blockquote>
<p>问题：如何理解一下代码呢？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> left=(s[<span class="number">0</span>]-<span class="string">&#x27;a&#x27;</span>)*<span class="number">26</span>+(s[<span class="number">1</span>]-<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">int</span> right=(s[len<span class="number">-2</span>]-<span class="string">&#x27;a&#x27;</span>)*<span class="number">26</span>+s[len<span class="number">-1</span>]-<span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>我们这里是以字符串的前面两个字符和后面两个字符来作为节点，那么这个节点该怎么编号呢？其实我们可以利用字符串hash的思想，把这两个字符hash成对应的一个整数值。比如字符串$ababc$前面的两个字符$ab$其实就是$(‘a’-‘a’)\times 26^1+(‘b’-‘a’)\times 26^0=1$，所以字符$ab$这个节点的编号就是1；比如字符$ababc$后面的两个字符$bc$其实就是$(‘b’-‘a’)\times 26^1+(‘c’-‘a’)\times 26^0=28$，所以字符$bc$这个节点的编号就是28</p>
</blockquote>
<p>这里还有一个spfa判环的玄学优化（不太常用）：</p>
<p>当图中所有顶点的更新次数（入队次数)<code>count</code>大于图中顶点的个数的2倍时，则认为存在环。如果2倍不行，那就长度3倍、4倍…  这玩意很玄学</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">700</span>, M = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps=<span class="number">1e-4</span>;  <span class="comment">//控制精度</span></span><br><span class="line"><span class="keyword">int</span> h[N], e[M], w[M], ne[M], idx;</span><br><span class="line"><span class="keyword">double</span> dist[N];</span><br><span class="line"><span class="keyword">int</span> q[N], cnt[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="comment">//建图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    w[idx] = c;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//spfa判正环</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">double</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">-0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> cnt);</span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//图中最多有676个顶点,一开始就把原图中的所有顶点都放入队列q中</span></span><br><span class="line">    <span class="comment">//就等效于建立了一个虚拟源点和其他676个节点的新图</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">676</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        q[tt ++ ] = i;</span><br><span class="line">        <span class="comment">//初始化该虚拟源点到其他676个节点的权值为0</span></span><br><span class="line">        dist[i]=<span class="number">0</span>;</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;  <span class="comment">//统计图中所有节点的更新次数即所有节点的入队次数</span></span><br><span class="line">    <span class="keyword">while</span> (hh != tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = q[hh ++ ];</span><br><span class="line">        <span class="keyword">if</span> (hh == N) </span><br><span class="line">        hh = <span class="number">0</span>;</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &lt; dist[t] + w[i] - mid)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i] - mid;</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">                count++;    <span class="comment">//更新次数+1  即入队次数+1</span></span><br><span class="line">                <span class="comment">//一般经验上来说是count &gt;2N 但是这里点数少,边数实在太多了 </span></span><br><span class="line">                <span class="comment">//那么就3N,4N...一直尝试吧</span></span><br><span class="line">                <span class="keyword">if</span> (count&gt; <span class="number">10</span>*N) </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 经验上的trick</span></span><br><span class="line">                <span class="comment">//说明存在正环</span></span><br><span class="line">                <span class="keyword">if</span> (cnt[j] &gt;= N) </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q[tt ++ ] = j;</span><br><span class="line">                    <span class="keyword">if</span> (tt == N) tt = <span class="number">0</span>;</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//说明不存在正环</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">1010</span>]; <span class="comment">//字符串</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T), T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//初始化表头</span></span><br><span class="line">        <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//T个字符串</span></span><br><span class="line">        <span class="keyword">while</span>(T--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">            <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">            <span class="keyword">if</span> (len &gt;= <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//该字符串的前面两个字符  hash 成一个整数值 作为 一个节点的编号</span></span><br><span class="line">                <span class="keyword">int</span> left = (str[<span class="number">0</span>] - <span class="string">&#x27;a&#x27;</span>) * <span class="number">26</span> + str[<span class="number">1</span>] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="comment">//该字符串的后面两个字符  hash 成一个整数值 作为 一个节点的编号</span></span><br><span class="line">                <span class="keyword">int</span> right = (str[len - <span class="number">2</span>] - <span class="string">&#x27;a&#x27;</span>) * <span class="number">26</span> + str[len - <span class="number">1</span>] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="comment">//从left节点想right节点连一条长度为len的有向边</span></span><br><span class="line">                <span class="built_in">add</span>(left, right, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果把0带进去计算都不能得到正环的话,那么1,2,...,1000就不可能得到正环</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">check</span>(<span class="number">0</span>)) </span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;No solution&quot;</span>);</span><br><span class="line">        <span class="comment">//说明还是可以得到正环的</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">double</span> l = <span class="number">0</span>, r = <span class="number">1000</span>;</span><br><span class="line">            <span class="comment">//二分答案</span></span><br><span class="line">            <span class="keyword">while</span> (l+eps&lt;r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">                <span class="comment">//由于答案是单调递增的 </span></span><br><span class="line">                <span class="comment">//所以当满足性质时  往右侧收缩 寻找答案</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) </span><br><span class="line">                l = mid;</span><br><span class="line">                <span class="comment">//否则不满足性质  往左侧收缩 寻找答案</span></span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//输出最终的答案</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>负环</category>
      </categories>
      <tags>
        <tag>负环</tag>
      </tags>
  </entry>
  <entry>
    <title>二分图最大匹配的应用</title>
    <url>/2021/07/14/Algorithm-Improvement/Chapter3---Gragh-Theory/%E4%BA%8C%E5%88%86%E5%9B%BE/%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h1 id="二分图最大匹配的应用"><a href="#二分图最大匹配的应用" class="headerlink" title="二分图最大匹配的应用"></a>二分图最大匹配的应用</h1><hr>
<p>对于二分图最大匹配来说，更重要的是对一些实质问题的转化，比如通过求解二分图最大匹配，我们可以得到一个二分图的最小顶点覆盖，最小边覆盖，最大独立集、最大完全子图、最小路径覆盖 等等。</p>
<p><strong>引理：</strong></p>
<p>在二分图最大匹配中，每条匹配边连接的两个顶点$(u,v)$最多只有一个与非匹配点有连边。</p>
<p><strong>证明：</strong></p>
<p>假设存在一条匹配边连接的两个顶点$(u,v)$，分别存在非匹配边$(u,x)$和$(v,y)$，且$x$和$y$都是匹配点，可以让$(u,v)$断开，从而成为失配边，那么 $(u,x)$和$(v,y)$变成匹配边。因此此时匹配数目相对之前增加了1个，这与最大匹配矛盾。故得证</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210714082435.png" alt="image-20210714082435281"></p>
<p>假设我们已经找到了二分图最大匹配，并且$(1,6)$是匹配边，$(1,8)$和$(3,6)$是非匹配边，其中$3$和$8$是非匹配点，那么可以将$(1,8)$和$(6,3)$变成匹配边，$(1,6)$变成非匹配边，那么就会使得匹配数量+1，因此这与最大匹配矛盾了。</p>
<hr>
<h3 id="最小顶点覆盖"><a href="#最小顶点覆盖" class="headerlink" title="最小顶点覆盖"></a>最小顶点覆盖</h3><p><code>点覆盖</code>的含义：一个点集合$S\subseteq V$，使得每一条边中至少有一个端点是在点集合$S$中</p>
<p><code>最小顶点覆盖</code>的含义：选择最少的点来覆盖所有的边</p>
<p>如下图，最小顶点覆盖是$(2,4,6)$三个点组成的点集。因为顶点2覆盖的边有$(2,5)$和$(2,8)$，顶点4覆盖的边有$(4,7)$和$(4,6)$，顶点6覆盖的边有$(1,6)$和$(3,6)$，可以发现这个顶点集合就已经完全覆盖了图中所有的边，而且它也已经是最小点集了。</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210714084437.png" alt="image-20210714084437304"></p>
<p><strong>结论：二分图最小顶点覆盖 = 二分图最大匹配</strong></p>
<p>要想证明$=$，那么可以先证明$\geq$，然后再证明$\leq$，由夹逼定理可知，就可以证明出$=$了</p>
<p>证明如下：</p>
<p>对于二分图$G$，设匹配图为$M$，最大匹配数为$m$：</p>
<ul>
<li>先来证明二分图的最小顶点覆盖$\geq $二分图的最大匹配。我们可以构造一个点集，这个点集是从最大匹配$M$里面取出来的，对于每一条匹配边，选择那个与非匹配点有连边的点（根据引理，这个点最多只有一个）加入点集$S$；如果不存在非匹配点，也就是说这个二分图其实就是最大匹配，即$M$就是$G$，那么匹配边的两侧端点都是匹配点，因此我们只需要从这一条匹配边中随便选择一个点即可，那么有$m$条匹配边，因此就需要选择$m$个点来覆盖。如上图所示：三条匹配边$(1,6)、(2,5)、(4,7)$，点集$S$构造的时候，$(1,6)$这条边选择$6$这个顶点，$(2,5)$这条边选择$2$这个点，$(4,7)$这条边选择$4$这个点。因此这种对于存在非匹配点的二分图来说，对于这$m$条匹配边，就需要$m$个点来覆盖，还存在非匹配边，那么可能还需要用一些点来覆盖这些匹配边，因此最小顶点集$S$肯定是$\geq m$的，即<strong>二分图的最小顶点覆盖$\geq $二分图的最大匹配</strong>。</li>
<li>再来证明二分图的最小顶点覆盖$\leq $二分图的最大匹配。如果$G$中的边除了$M$中匹配边以外没有其它非匹配边，那么最小顶点覆盖就是$m$。否则，还存在非匹配边，如果这条非匹配边的两个端点都在非匹配点上，那么可以构成一条新的匹配边，从而和最大匹配矛盾；所以这些非匹配边一定是其中一个端点在匹配点上，另一个端点在非匹配点上；令一条非匹配边上的一个端点为$u$，且$u$在非匹配点上，那么如果存在一条边$(u,v)$，点$v$必定是在我们构造出来的点集 $S$中的，于是边$(u,v)$一定可以被这个点集覆盖。所以<strong>二分图的最小顶点覆盖$\leq$二分图的最大匹配</strong>。</li>
</ul>
<p>简单理解为：</p>
<ul>
<li>$m$个点是必须的，即二分图的最小顶点覆盖$\geq $二分图的最大匹配。匹配的这$m$条边，它们的端点各不相同，因此要覆盖这$m$条匹配边，就需至少需要$m$个点。</li>
<li>$m$个点是足够的，即二分图的最小顶点覆盖$\leq $二分图的最大匹配。假设最小顶点覆盖为$n$，那么一定可以构造出$n$条匹配边，又由于我们已经知道了二分图的最大匹配是$m$，也就是说最大匹配边是$m$，因此必定有$n\leq m$。即假设覆盖完这$m$条匹配边后，如果还有某条边$e$还没有被覆盖，那么把$e$加入后会使得匹配数量+1，那么就会大于给定的最大匹配数目$m$，这与二分图最大匹配矛盾。</li>
</ul>
<hr>
<h3 id="最小边覆盖"><a href="#最小边覆盖" class="headerlink" title="最小边覆盖"></a>最小边覆盖</h3><p><code>边覆盖</code>的含义：选一条边就相当于覆盖了它的两个端点。</p>
<p><code>最小边覆盖</code>的含义：选择最少的边集，覆盖所有的点集</p>
<p>如下图所示，最小边覆盖为$E=${$(2,9),(3,8),(5,10),(4,9),(3,11)$}，答案是5。注意：<strong>孤立节点不需要用边来覆盖！</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210714093506.png" alt="image-20210714093506209"></p>
<p><strong>结论：二分图的最小边覆盖 = 顶点总数 - 孤立点数 - 二分图最大匹配</strong></p>
<p>证明：</p>
<p>为了使边数最少，又因为一条边最多能干掉两个点，所以尽量用边干掉两个点。也就是选择有匹配的那些边，因为它们一次能干掉两个节点，而且我们希望有匹配的边越多越好，那么就是最大匹配了，因为最大匹配才会有最多的匹配边。我们设左侧节点数目为$L$，右侧节点数目为$R$，孤立节点数目为$A$，设二分图最大匹配数目为$M$，节点总数就是$V=L+R$。由于孤立节点不需要边覆盖，因此需要考虑的点有$V-A$。</p>
<p>我们先用最大匹配边去干掉两侧的节点，那么就可以干掉$2\times M$个节点，剩下的就是要解决那些没有被匹配的点，那么这些没有被匹配的点的数目为$(V-A)-2\times M$，那么这些没有被匹配的点就需要用边去覆盖，因此还需要$(V-A)-2\times M$条边。因此总的需要最少的边数=$M+(V-A-2\times M)=V-A-M$，即二分图的最小边覆盖=顶点总数-孤立点数-二分图最大匹配。</p>
<p>如上图所示，绿色边表示匹配边，黑色边表示非匹配边。那么匹配边有3条，干掉了$2,3,5,8,9,10$节点，那么还剩下$4,11$没有被干掉，覆盖这两个点还需要2条边，因此最小边覆盖为$3+2=5$，这正好就是$12-4-3=5$</p>
<hr>
<h3 id="最大独立集"><a href="#最大独立集" class="headerlink" title="最大独立集"></a>最大独立集</h3><p><code>最大独立集合含义</code>：选取最多的点，使得图中任意两点都没有关系</p>
<p>如下图所示，最大独立集合为$A=${$1,3,5,7,8$}</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210714095317.png" alt="image-20210714095317247"></p>
<p><strong>结论：二分图的最大独立集 = 顶点总数 - 最小顶点覆盖</strong></p>
<p>证明：</p>
<p>首先，由最小顶点覆盖的含义可知，它已经覆盖了图中的所有边，因此我们把最小顶点集$S$中的顶点都从图中去掉，那么所有的边也就消失了，那么还剩下$V-S$个顶点，这些节点两两之间都不相邻了（因为没有边相连，不存在关联），那么这些剩余的节点就构成了一个独立集（为$A=V-S)$。由这个式子可以知道，因为$V$是定值，要想$A$最大，那么需要$S$最小。又由于最小顶点覆盖已经是最少的能够覆盖图中所有边的点集了，不能再少了，因此当取到最小顶点覆盖时，$S$达到最小，那么剩下的节点就是最大的。因此二分图的最大独立集 = 顶点总数 - 最小顶点覆盖</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210714101105.png" alt="image-20210714101105273"></p>
<hr>
<h3 id="最大完全子图（最大团）"><a href="#最大完全子图（最大团）" class="headerlink" title="最大完全子图（最大团）"></a>最大完全子图（最大团）</h3><p><code>完全图</code>的含义：任意两点都恰有一条边相连的图(任意两点都相邻)</p>
<p><code>完全子图</code>的含义：满足任意两点都恰有一条边相连的<strong>子图</strong>，也叫<strong>团</strong></p>
<p><code>最大完全子图</code>的含义：所有完全子图中<strong>顶点数最大的团</strong>，即<strong>最大团</strong>。最大指的是点数最多。即选取最多的点，使得图中任意两点都有关系</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210714102723.png" alt="image-20210714102723336"></p>
<p>图中{$a,b,d$}，${a,e}$，${c,f,g}$等都是完全子图，但是最大完全子图是${a,b,d,e}$</p>
<p><code>补图</code>的含义：一个$n$阶完全图中去掉原图$G$上的所有边，剩下的所有边所构成的一个图就是该图$G$的补图$G’$</p>
<p>如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210714104214.png" alt="image-20210714104214360"></p>
<p><strong>结论：二分图的最大团 = 补图的最大独立集</strong></p>
<p>证明：</p>
<p>对比最大团的含义和最大独立集的含义，我们知道它俩是相反的，那么我们就可以知道其实二分图的最大独立集的相反就是二分图的最大团。那么我们该怎么表达最大独立集的相反呢？这里就需要用到补图了。设原图为$G$，那么原图的相反其实就是原图的补图$G’$。因此我们想要求出原图$G$的最大团，那么就是要求出补图$G’$的最大独立集。</p>
<p>求最大完全子图的问题，如果不是二分图，这将是一个 NP 问题，但如果是个二分图，我们可以用上面的方法求解</p>
<hr>
<h3 id="有向无环图的最小路径覆盖"><a href="#有向无环图的最小路径覆盖" class="headerlink" title="有向无环图的最小路径覆盖"></a>有向无环图的最小路径覆盖</h3><h4 id="不相交的情况"><a href="#不相交的情况" class="headerlink" title="不相交的情况"></a>不相交的情况</h4><p>定义：选择一些路径，覆盖所有的点集，且各路径的点集之间不允许有交集，要求路径数最少。</p>
<p>如下图所示，得到的路径是：$(1\to2\to4\to5)$，$(6\to7)$，$(3)$。最小（不相交）路径覆盖为3</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210714105315.png" alt="image-20210714105315325"></p>
<p><strong>结论：有向无环图的最小(不相交)路径覆盖 = 原图结点数 - 拆点后二分图最大匹配数</strong></p>
<p>证明：</p>
<ul>
<li><p>初始状态，所有顶点都是一条路径，那么总共有$n$条路径</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210714111347.png" alt="image-20210714111347242"></p>
</li>
<li><p>每当增加一对匹配时，对应到原图中就是用一条边连接了两个节点，并且这两个结点一定不在同一个连通块（下文会证明），那么总的连通块数目减一（比如连接节点1和节点2，那么此时它俩处于同一个连通块，但它俩原来都是独立的连通块），也就是路径数目减一（二分图里找一条匹配边就相当于把两条路径合成了一条路径）；所以找到了几条匹配边，路径数就减少了多少。那么要想使得路径数最少，那么应该有更多的匹配边，因此想到应该是二分图的最大匹配。所以有最小路径覆盖=原图的结点数-拆点后新图的最大匹配数。</p>
</li>
<li><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210714111920.png" alt="image-20210714111920874"></p>
</li>
</ul>
<p>证明：每增加一条匹配边，在原图中的两个点必然不在一个连通块内</p>
<ul>
<li><p>每增加一对匹配边：$u_l\to v_r$，对应原图中就是增加了一条$u\to v$的边，反证法：假设$u$和$v$在同一个连通块内，那么会有如下的四种情况（橙色边为原本的连接情况，红色边为当前增加匹配后增加的新边）：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210714112425.png" alt="image-20210714112425763"></p>
</li>
<li><p>(a)如上图，对于节点$u$来说，它有两条出边，对于节点$v$来说，它有两条入边，但是对于二分图匹配来说，两个节点之间应该是只有一条出边和一条入边，因此这与 二分图匹配的 定义矛盾，因此，这种情况是不合法的</p>
</li>
<li><p>(b)如上图，节点$u,v$产生了圈，形成了环，这与 二分图匹配的 定义矛盾，因此，这种情况是不合法的</p>
</li>
<li><p>(c)如上图，对于节点$u$来说，它有两条出边，分别连向两点不同的节点，这对应到二分图和两个点进行了匹配，但在二分图匹配中，是一夫一妻制，而不能一夫多妻，因此这与 二分图匹配的 定义矛盾，因此，这种情况是不合法的</p>
</li>
<li><p>(d)如上图，对于节点$v$来说，它有两条入边，分别有两个不同的节点指向它，这对应到二分图和两个点进行了匹配，但在二分图匹配中，是一妻一夫制，而不是一妻多夫，因此这与 二分图匹配的 定义矛盾，因此，这种情况是不合法的</p>
</li>
<li><p>基于以上四种情况都不合法，所以每增加一条匹配边，在原图中的两个点必然不在一个连通块内，得证</p>
</li>
</ul>
<p>举个栗子：</p>
<p>首先将每个节点$u$拆成两个节点$u_l$和$u_r$，如果原图存在边$u\to v$，则在拆点后的图上建立边：$u_l\to v_r$。由于原图是有向无环图，所以拆点后的图是一个二分图。如图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210714141226.png" alt="image-20210714141226353"></p>
<p>对拆点后的图求一次二分图最大匹配，得到：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210714141427.png" alt="image-20210714141427393"></p>
<p>那么有向无环图的最小(不相交)路径覆盖 = 原图结点数 -  拆点后二分图最大匹配数=$7-4=3$</p>
<h4 id="相交的情况"><a href="#相交的情况" class="headerlink" title="相交的情况"></a>相交的情况</h4><p>定义：选择一些路径，覆盖所有的点集，且各路径的点集之间允许有交集，要求路径数最少。</p>
<p>举个栗子：</p>
<p>如下图所示，得到的路径为：$(1\to 2\to 4\to 5)$，$(3\to 4\to 6\to 7)$，最小（相交）路径覆盖为2</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210714142307.png" alt="image-20210714142307071"></p>
<p><strong>结论：首先对原图求一次传递闭包得到一个新图，有向无环图的最小(相交)路径覆盖 = 新图结点数 - 拆点后二分图最大匹配数</strong>。</p>
<p>证明：</p>
<p>因为路径之间是允许相交的，所以对于 2 条路径$x\to p\to y$和$a\to p\to b$，那么多建立两条边$(x\to y)$和$(a\to b)$，那么我们发现$x\to y$其实是 $x\to p$，$p\to y$求传递闭包得到的，同理分析$a\to b$也是求传递闭包得到的。对图中所有的这样的边都这样操作一次，相当于求了一个传递闭包。然后再求拆点二分图的最大匹配，就可以当成求最小不相交路径覆盖的情况来求解了。</p>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>二分图最小顶点覆盖 = 二分图最大匹配</li>
<li>二分图的最小边覆盖 = 顶点总数 - 孤立点数 - 二分图最大匹配</li>
<li>二分图的最大独立集 = 顶点总数 - 最小顶点覆盖</li>
<li>有向无环图的最小(不相交)路径覆盖 = 原图结点数 - 拆点后二分图最大匹配数</li>
<li>首先对原图求一次传递闭包得到一个新图，有向无环图的最小(相交)路径覆盖 = 新图结点数 - 拆点后二分图最大匹配数</li>
</ol>
<hr>
]]></content>
      <categories>
        <category>二分图</category>
      </categories>
      <tags>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title>排书</title>
    <url>/2021/09/04/Algorithm-Improvement/Chapter2---Search/IDA%20Star/%E6%8E%92%E4%B9%A6/</url>
    <content><![CDATA[<h1 id="排书"><a href="#排书" class="headerlink" title="排书"></a>排书</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210904105207.png" alt="image-20210904105207440"></p>
<hr>
<h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p>IDA Star一种将估价函数和迭代加深DFS算法相结合的算法。我们设计一个估价函数，估算从每个状态到目标状态需要的步数。当然，与A Star算法一样，估价函数需要遵守”估计值不大于未来实际步数”的准则。然后，以迭代加深DFS的搜索框架为基础，把原来简单的深度限制加强为：<strong>若当前深度+未来估计步数&gt;深度限制，则立即从当前分支回溯</strong>。</p>
<p>假设<code>f()</code>表示估价函数，如果<code>f()=0</code>，而我们知道估价函数的定义就是：从当前状态到目标状态需要的步数。由于$f()=0$，因此说明从当前状态到目标状态需要的步数为0，那么也就是说，当前状态就是目标状态了。那么此时就找到了解</p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>先考虑每一步的决策数量：</p>
<p>当抽取长度为$i$的一段时，有$n-i+1$种抽法，对于每一种抽法，都有$n-i$种放法。比如3 5 1 4 2，总长度$n=5$，设抽取长度为$i=2$的一段，那么可以抽取{3,5}或者{5,1}或者{1,4}或者{4,2}，有4种抽法，而$n-i+1=5-2+1=4$，因此有$n-i+1$种抽法。假设我们抽取了{1,4}，此时还剩下 3 5 2 ，有四个空位，但是由于原来{1,4}已经是在5的后面了，因此5后面的这个空位就不算了，因此此时只有3个空位了。那么我们可以将{1,4}插入这三个空位中，也就是有3种放法，而$n-i=5-2=3$，因此对于每一种抽法，都有都有$n-i$种放法。</p>
<p>另外，将某一段向前移动，等价于将跳过的那段向后移动，因此每种移动方式被算了两遍，所以每个状态总共的分支数量是：$\sum \limits _{i=1}^{n}(n-i)\times(n-i+1)/2=(15\times 14+14\times 13+\cdots+2\times 1)/2=560$</p>
<p>考虑在四步以内解决，最多有$560^4$个状态，那么会超时。我们可以考虑使用IDA*来优化。</p>
<p>我们的最终状态是$1,2,\cdots,i-1,i,i+1,\cdots,n$。在目标状态下，第$i$本书后面应该是第$i+1$本书，我们称$i+1$是$i$的正确后继。</p>
<p>对于任意状态，考虑整个排列中书的错误后继的个数，记为$tot$，可以发现每一次操作最多只会更改3本书的后继。例如3 5 1 4 2，我们把{5,1}放到4的后面，得到<strong>3</strong> <strong>4</strong> 5 <strong>1</strong> 2。它影响了3，4，1的后继。原来3的后继是5，4的后继的2，1的后继是4，但是现在3的后继是4，4的后记是5，1的后继是2。因此每一次操作最多只会把3本书的错误后继修改为正确的后继。那么消除所有错误后继所需要的操作次数至少需要$\lceil \dfrac {tot}{3}\rceil$</p>
<p>因此我们把一个状态s的估价函数设计为$f(s)=$$\lceil \dfrac {tot}{3}\rceil$，其中$tot$表示在状态s下书的错误后继总数。</p>
<p>我们采用迭代加深的方法，从1~4依次限制搜索的深度，然后从起始状态出发进行DFS。在DFS时，在每个状态下直接枚举抽取哪一段、移动到更靠后的哪个位置，沿着该分支深入即可。注意在进入任何状态s后，我们先进行判断，如果当前操作次数加深$f(s)$已经大于深度限制，则直接从当前分支回溯。</p>
<p>理论上最多搜索$560^4$个状态，使用IDA*后实际搜索的状态数量很少。</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> q[N];   <span class="comment">//书的排列</span></span><br><span class="line"><span class="keyword">int</span> w[<span class="number">5</span>][N];    <span class="comment">//4步以内书的排列</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="comment">//估价函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;  <span class="comment">//错误后继的数量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(q[i+<span class="number">1</span>]!=q[i]+<span class="number">1</span>)</span><br><span class="line">            cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cnt/3向上取整的 写法  是(cnt+2)/3</span></span><br><span class="line">    <span class="keyword">return</span> (cnt+<span class="number">2</span>)/<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代加深  depth是当前层   max_depth是深度限制</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> depth,<span class="keyword">int</span> max_depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//超过最大深度限制  则立即回溯</span></span><br><span class="line">    <span class="keyword">if</span>(depth+<span class="built_in">f</span>()&gt;max_depth)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//估价函数为0 则到达了目标状态</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">f</span>()==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//这里有点类似于区间DP</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">1</span>;len&lt;=n;len++) <span class="comment">//枚举抽取其中连续的一段的长度</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>;l+len<span class="number">-1</span>&lt;n;l++)<span class="comment">//枚举抽取的这段书的左端点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> r=l+len<span class="number">-1</span>;      <span class="comment">//r是抽取的这段书的右端点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=r+<span class="number">1</span>;j&lt;n;j++)  <span class="comment">//枚举抽取的这段书应该插入到r后面的哪个位置</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">memcpy</span>(w[depth],q,<span class="keyword">sizeof</span> q);    <span class="comment">//先记录之前的状态</span></span><br><span class="line">                <span class="keyword">int</span> k=l;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> x=r+<span class="number">1</span>;x&lt;=j;x++)</span><br><span class="line">                    q[k++]=w[depth][x];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> x=l;x&lt;=r;x++)</span><br><span class="line">                    q[k++]=w[depth][x];</span><br><span class="line">                <span class="comment">//向下一层递归</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">dfs</span>(depth+<span class="number">1</span>,max_depth))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">memcpy</span>(q,w[depth],<span class="keyword">sizeof</span> q);    <span class="comment">//恢复之前的状态  恢复现场</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//搜完全部都搜不到 无解</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q[i]);</span><br><span class="line">        <span class="keyword">int</span> depth=<span class="number">0</span>;    <span class="comment">//最大深度限制</span></span><br><span class="line">        <span class="keyword">while</span>(depth&lt;<span class="number">5</span>&amp;&amp;!<span class="built_in">dfs</span>(<span class="number">0</span>,depth))</span><br><span class="line">            depth++;</span><br><span class="line">        <span class="keyword">if</span>(depth&gt;=<span class="number">5</span>)</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;5 or more&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,depth);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>IDA*</tag>
      </tags>
  </entry>
  <entry>
    <title>二分图的最大匹配</title>
    <url>/2021/07/13/Algorithm-Improvement/Chapter3---Gragh-Theory/%E4%BA%8C%E5%88%86%E5%9B%BE/%E4%BA%8C%E5%88%86%E5%9B%BE%E7%9A%84%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h1 id="二分图的最大匹配"><a href="#二分图的最大匹配" class="headerlink" title="二分图的最大匹配"></a>二分图的最大匹配</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210713135825.png" alt="image-20210713135825492"></p>
<hr>
<h3 id="二分图的最大匹配-1"><a href="#二分图的最大匹配-1" class="headerlink" title="二分图的最大匹配"></a>二分图的最大匹配</h3><p>从题目中给出的二分图匹配的定义可知，匹配其实也是一张图，并且图中的点数是边数的2倍。</p>
<p>如下图所示：二分图的匹配</p>
<p>红色边组成的 4 个结点、2条边就是这个二分图的一个匹配了；</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210713140235.png" alt="image-20210713140235437"></p>
<p><strong>二分图最大匹配定义</strong>：最大匹配就是找到一个子图，满足是匹配，并且边数（点数）最多。</p>
<p>如下图所示：二分图的最大匹配</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210713140350.png" alt="image-20210713140350842"></p>
<hr>
<h3 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h3><p>匈牙利算法可以用来求解二分图的最大匹配问题。匈牙利算法也被戏称为“相亲算法”，它的大致过程是这样的：</p>
<ul>
<li><p>有两个点集，分别是男生和女生，$X$点集中全部都是男生，$Y$点集中全部都是女生</p>
</li>
<li><p>然后男生取追求女生，如果男生$X_a$对女生$Y_b$有好感，并且女生$Y_b$也有男生$X_a$有好感，那么男生$X_a$就有很大机会可以追到女生$Y_b$，否则如果女生$Y_b$不喜欢男生$X_a$，那么男生$X_a$就不会再追求女生$Y_b$，而是继续去寻找其他女生  （不想当<del>舔狗</del>)</p>
</li>
<li><p>作为一个男人，要主动出击。因此约定都是男生追女生，即开始先从点集$X$出发</p>
</li>
<li><p>每个男生可以选遍所有他喜欢的女生：如果某位女生还是单身并且没有其他男生追求她，那么 女人 拿来吧你，恭喜你，直接配对；如果特别喜欢的这个女生已经有男朋友了，则这个女生会让她男朋友再去找其他女生（爱情就是这么<del>不堪一击</del>)，又转化成了另一个男生去寻找女生的过程，继续递归找；</p>
</li>
<li><p>那么最终的结果就有两种情况：</p>
<ul>
<li><p>由于这个男生的插足，导致最后可能有一个男生被抛弃，这是不道德的行为，所以不能干这种事情！（如下图，结局好惨）</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210713142754.png" alt="image-20210713142754572"></p>
</li>
<li><p>由于这个男人的插足，导致所有的男女关系都进行了一次轮换，但是匹配的对数多了一对；（成功<del>横刀夺爱</del>）</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210713143031.png" alt="image-20210713143030993"></p>
</li>
</ul>
</li>
</ul>
<p>以上就是匈牙利算法的相亲过程，算法很简单也很有趣，教会了<del>恋爱丛林法则</del></p>
<hr>
<h3 id="匈牙利算法实现"><a href="#匈牙利算法实现" class="headerlink" title="匈牙利算法实现"></a>匈牙利算法实现</h3><p>先来给出以下变量的定义：</p>
<ul>
<li><code>st[j]</code>这个是个bool类型数组，用来表示某个女生有没有被男生访问联系过，如果$st[j]=true$，表示$j$这个女生已经某个男生联系过了</li>
<li><code>match[j]</code>是个int类型的数组，用来表示$j$这个女生她现任男友的编号，如果$match[j]=a$，表示$j$这个女生她现任男友的编号为$a$</li>
</ul>
<p>算法流程：</p>
<ul>
<li>将男生和女生分成点集$X$和$Y$</li>
<li>由于是男生掌握主动权，所以只需要建立有向图，从男生节点向女生节点引出有向边即可</li>
<li>从男生点集$X$出发，假设某个男生$u$，遍历$u$这个节点所有的邻接点$v$（即他喜欢的所有女生）<ul>
<li>如果这个女生$v$处于单身状态，$v$还没有匹配，那么此时$(u,v)$就是一组成功的匹配（在一起了），所以匹配的数量+1</li>
<li>如果这个女生$v$虽然有男朋友了，但是她可能对这个男生$u$有点意思，所以让她现任男友$c$去寻找其他女生，假设男生$c$是个<del>海王</del>（本来就是），他确实有很多青青草原，然后他找到了后宫中的女生$d$，最终女生$d$答应了他，于是他俩就在一起了，那么此时女生$v$就处于单身状态，于是男生$u$就成功和她在一起了，可以发现此时又成功匹配了一对情侣，所以匹配数目+1；但是如果后宫中的女生$d$知道男生$c$是海王，拒绝了他，那么男生$c$和她女友$v$说 我还是只爱你一人，因此他俩还是继续在一起，那么很可惜男生$u$还是<del>单身狗</del>。因此这次$u$的匹配失败。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>, M = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n1, n2, m;<span class="comment">//n1表示左侧男生的个数  n2表示右侧女生的个数</span></span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="comment">//match[j]=a,表示女孩j的现有配对男友是a</span></span><br><span class="line"><span class="keyword">int</span> match[N];<span class="comment">//右边女生所对应的左边男孩,即女生现在和哪个男生的在一起</span></span><br><span class="line"><span class="keyword">bool</span> st[N];<span class="comment">//临时预定数组，st[j]=a表示一轮模拟匹配中，女孩j被男孩a预定了。 避免重复搜索女孩</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断x这个男生能不能找到匹配的女生</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//依次遍历自己喜欢的女孩</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];<span class="comment">//获取女孩在图中的顶点的编号</span></span><br><span class="line">        <span class="comment">//如果j这个女孩之前还没有被考虑过，在这一轮模拟匹配中,这个女孩尚未被预定</span></span><br><span class="line">        <span class="keyword">if</span> (!st[j])<span class="comment">//j这个女孩还没有被男生x访问过</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//标记j这个女孩被男生x访问过了</span></span><br><span class="line">            st[j] = <span class="literal">true</span>;<span class="comment">//表示j这个女孩已经被x男孩看上了，被考虑过啦，x男孩已经预定了j这个女孩</span></span><br><span class="line">            <span class="comment">//match[j]==0表示j这个女孩还没有匹配任何男孩，即j女孩还没有男朋友 j目前没有任何可以匹配的节点</span></span><br><span class="line">            <span class="comment">//find(match[j])=true表示j这个女孩虽然已经匹配了某个男孩,但是她匹配的这个男孩是个海王</span></span><br><span class="line">            <span class="comment">//留有后手随时可以找到其他女孩来代替她，那么此时j女孩被甩处于单身状态,j告诉x说我们在一起吧</span></span><br><span class="line">            <span class="comment">//那么执着追j女孩的这个x男子就击败了j女孩的所有暗恋者，有机会了</span></span><br><span class="line">            <span class="comment">//也就是说j有和它匹配的点(现任男友),但是呢这个点(现任男友)能够通过一些办法来找到新的匹配</span></span><br><span class="line">            <span class="keyword">if</span> (match[j] == <span class="number">0</span> || <span class="built_in">find</span>(match[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                match[j] = x;<span class="comment">//表示j女孩已经匹配成功了，现有配对男友是x</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//返回true表示配对成功</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果遍历过x男子所喜欢的女生中，都没能找到合适的，自己中意的全部都被预定了。</span></span><br><span class="line">    <span class="comment">//配对失败。即没有配对成功，则返回false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n1, &amp;n2, &amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a, b);<span class="comment">//虽然是无向图，但是因为是左侧男生去找女朋友，单向追求，所以用“有向图”就行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;<span class="comment">//res表示匹配的数量</span></span><br><span class="line">    <span class="comment">//依次枚举左半部分的男生该去找哪个女孩</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//要保证每个女孩只被考虑一遍</span></span><br><span class="line">        <span class="comment">//因为每次模拟匹配的预定情况都是不一样的所以每轮模拟都要初始化</span></span><br><span class="line">        <span class="comment">//如果不初始化则当男生i进行匹配操作后会修改st的内容  那么会保留这个内容</span></span><br><span class="line">        <span class="comment">//当下一个男生i+1进行匹配操作时 就会用到上一个男生i保留的st的内容  就会出错</span></span><br><span class="line">        <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);<span class="comment">//把每个女孩的匹配状态清空，表示这些女孩还没有被考虑过</span></span><br><span class="line">        <span class="comment">//如果i这个男子成功的找到了匹配的妹子  那么匹配个数+1</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find</span>(i))</span><br><span class="line">            res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>二分图</category>
      </categories>
      <tags>
        <tag>匈牙利算法</tag>
      </tags>
  </entry>
  <entry>
    <title>关押罪犯</title>
    <url>/2021/07/14/Algorithm-Improvement/Chapter3---Gragh-Theory/%E4%BA%8C%E5%88%86%E5%9B%BE/%E5%85%B3%E6%8A%BC%E7%BD%AA%E7%8A%AF/</url>
    <content><![CDATA[<h1 id="关押罪犯"><a href="#关押罪犯" class="headerlink" title="关押罪犯"></a>关押罪犯</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210714161314.png" alt="image-20210714161314811"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>从题干中，警察局长会把怒气值从大到小排序送给市长看，而市长只会看第一个最大的那个怒气值，如果这个最大的怒气值达到某种程度，则警察局长会被撤职。题目想让我们求的就是：有没有一个分配囚犯的方案，使得那个最大的怒气值，能够达到最小。</p>
<p>一般求 最大值最小 或者 最小值最大，都可以考虑用二分算法。 这里是想求最大值最小，因此，我们可以考虑一下使用二分算法。那么该如何进行二分呢？</p>
<p>考虑这样一个判定问题：是否存在一种分配罪犯的方案，使得$Z$市长看到的那个冲突事件的影响力不超过$mid$。对于当$mid$满足要求时，那么所有大于$mid$也是满足要求的。也就是说题目的答案是具有单调性的，一旦具有单调性，那么一定可以用二分算法。</p>
<blockquote>
<p>问题：为什么对于当$mid$满足要求时，那么所有大于$mid$也是满足要求的呢？</p>
<p>设当前二分的值为$mid$，那么对于那些怒气值大于$mid$的囚犯应该关在不同的监狱。假设它俩关在同一所监狱，那么他们会产生更大的影响力（设其值为$a$)，这个影响力会大于现优解$mid$，即$a&gt;mid$，那么$a$就要在排行榜上当第一了，又由于市长只看第一，因此市长看到更大的$a$就会撤换警察局长，相对来说如果让$mid$在排行榜上当第一，那么影响力会更小一些。</p>
<p>举个栗子，假设当前$mid=50$，如果有两个囚犯，他们之间的怒气值为$100$，假设它俩关在同一个监狱$A$，那么监狱$A$就会产生影响力$100$，但是如果我们让它俩关在不同的监狱$A$和$B$，那么此时监狱$A$产生的影响力为0。因此，我们发现，当怒气值大于$mid$时，我们就更应该把它俩放到不同的监狱，这样会使得同一个监狱内的怒气值相对降低。但是如果他们之间的怒气值小于$mid$，那么就算把他俩放到不同监狱，此时排行榜上第一仍然是$mid$，并没有让第一的值减小，反而还浪费了一次分配机，这导致后面如果有大于$mid$的囚犯本应该被分配到两个不同的监狱却因为位置不够而被迫关在同一个监狱，导致这个监狱内的怒气值大于$mid$，排行榜上第一的值增大，这与我们想要的结果事与愿违。</p>
<p>这也就证明了 当$mid$满足要求时，那些怒气值大于$mid$就更能满足要求了，而那些怒气值$\leq mid$的就不满足条件了。</p>
</blockquote>
<p>二分答案，设当前二分的值为$mid$。此时，任意两个仇恨程度大于$mid$的囚犯都必须被安排在不同的监狱。我们把每个囚犯都看作是一个节点，如果两个囚犯之间的仇恨程度大于$mid$，那么我们就在这两个囚犯之间连一条无向边，这样最终就会得到一张无向图。由于两个囚犯被分配到两个不同的监狱，因此这两个节点属于不同的点集合，也就是说这张无向图需要被分成两个点集合。由于我们把怒气值大于$mid$的两个囚犯分别关到两个不同的监狱中了，那么此时同一个监狱内的囚犯之间的怒气值必然是$\leq mid$。而我们定义了当怒气值大于$mid$才连边，所以对于怒气值$\leq mid$都不需要连边。也就是说每个集合内部都没有边（同一个监狱内没有仇恨程度大于$mid$的罪犯）。我们发现，这种把节点划分成两种点集合，并且只能从一个点集合向另一个点集合连边，这种做法不正是二分图的定义嘛？</p>
<p>刚开始，我们对输入的数据都进行无向图$T$，然后再这张图中，如果边权怒气值$\leq mid$，那么我们就不看这些边（可以认为是从原图$G$中删除这些边），然后如果边权怒气值$&gt;mid$，则保留，那么最终全部保留下来的这个子图也就是一张无向图，设为$G$。然后我们对这个无向图$G$判定是否为二分图。</p>
<p>因此总的算法思路如下：</p>
<ul>
<li>先二分一个答案$mid$，此时$mid$其实就是对应一种分配罪犯的方案。</li>
<li>对每一个$ mid$，都使用染色法来check一下，来判定这个无向图$G$是否为二分图<ul>
<li>如果$check(mid)$成功，则说明是二分图，点$mid$位于右侧绿色满足性质的区间，那么对于所有大于$mid$的分配方案都是合理的，即$mid$右侧都满足，为了求最小，我们让$r=mid$，往左侧收缩，找到最小值</li>
<li>如果$check(mid)$失败，则说明不是二分图，点$mid$位于左侧红色不满足性质的区间，那么此时应该让左侧边界跳到$mid$的下一个位置，即$l=mid+1$，这样才能满足性质</li>
</ul>
</li>
</ul>
<p>那么该如何确定二分的边界呢？由于题目说了$0\leq c\leq 1e9$，因此答案最小值为$0$，最大值为$1e9$，因此二分的区间为<code>[0,1e9]</code>。</p>
<p>题目要求“如果本年内监狱中未发生任何冲突事件，请输出 $0$”，这个我们并不需要特殊处理，因为我们二分的答案区间中就包含了$0$。因此我们的算法一定可以考虑到这种情况。</p>
<p>设二分的性质为 <strong>当同一个监狱的两个囚犯之间的怒气值很大，则分配到两个不同的监狱中</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210714170229.png" alt="image-20210714170229547"></p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//题目给的边数为1e5 但是由于是二分图 它是无向图 所以边数要开2倍</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>,M=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],w[M],idx;</span><br><span class="line"><span class="keyword">int</span> color[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    w[idx]=c;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//染色法判定二分图</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> c,<span class="keyword">int</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    color[u]=c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];~i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j=e[i];</span><br><span class="line">        <span class="comment">//在mid左侧的都在红色不满足性质的区间</span></span><br><span class="line">        <span class="keyword">if</span>(w[i]&lt;=mid)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//如果j还没有被染色</span></span><br><span class="line">        <span class="keyword">if</span>(!color[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">dfs</span>(j,<span class="number">3</span>-c,mid))<span class="comment">//染色有矛盾</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//j被染过色了,但是它的颜色与相邻节点的颜色都是相同的 染色有矛盾</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(color[j]==c)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//说明染色无矛盾  是二分图</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(color,<span class="number">0</span>,<span class="keyword">sizeof</span> color);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!color[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">dfs</span>(i,<span class="number">1</span>,mid))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        <span class="comment">//建图</span></span><br><span class="line">        <span class="built_in">add</span>(a,b,c);</span><br><span class="line">        <span class="built_in">add</span>(b,a,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>,r=<span class="number">1e9</span>;</span><br><span class="line">    <span class="comment">//二分答案</span></span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//判断mid是否在绿色满足性质的区间 如果在则说明是二分图</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid))</span><br><span class="line">        r=mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>二分图</category>
      </categories>
      <tags>
        <tag>二分算法+二分图</tag>
      </tags>
  </entry>
  <entry>
    <title>染色法判定二分图</title>
    <url>/2021/07/13/Algorithm-Improvement/Chapter3---Gragh-Theory/%E4%BA%8C%E5%88%86%E5%9B%BE/%E6%9F%93%E8%89%B2%E6%B3%95%E5%88%A4%E5%AE%9A%E4%BA%8C%E5%88%86%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="染色法判定二分图"><a href="#染色法判定二分图" class="headerlink" title="染色法判定二分图"></a>染色法判定二分图</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210713124859.png" alt="image-20210713124859893"></p>
<hr>
<h3 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h3><p>二分图的含义：二分图是有两组点集$X$和$Y$组成的无向图，其中点集$X$中的点之间互相没有关联，点集$Y$中的点之间互相没有关联，但是点集$X$中的点和点集$Y$中的点之间可能存在关联，用一条无向边来表示这种关联。</p>
<p>如下图所示：</p>
<p>橙色节点都属于点集$X$，互相之间没有边相连；蓝色节点都属于点集$Y$，互相之间没有边相连。绿色代表无向边，用来连接点集$X$和点集$Y$中的节点。</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210713125403.png" alt="image-20210713125403160"></p>
<hr>
<h3 id="二分图的判定"><a href="#二分图的判定" class="headerlink" title="二分图的判定"></a>二分图的判定</h3><h4 id="圈的定义"><a href="#圈的定义" class="headerlink" title="圈的定义"></a>圈的定义</h4><p>图论中圈的定义是：任选一个顶点为起点，沿着不重复的边，经过不重复的顶点，之后又回到起点的闭合路径。</p>
<p>如下图所示：</p>
<p>$1-&gt;2-&gt;4-&gt;3-&gt;1$就是一个圈</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210713130025.png" alt="image-20210713130025270"></p>
<ul>
<li>偶数圈就是经过路径中的顶点数为偶数的圈，如上图，$1-&gt;2-&gt;4-&gt;3-&gt;1$</li>
<li>奇数圈就是经过路径中的顶点数为奇数的圈，如下图，$1-&gt;2-&gt;4-&gt;5-&gt;3-&gt;1$</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210713131614.png" alt="image-20210713131614073"></p>
<h4 id="二分图的判定性质"><a href="#二分图的判定性质" class="headerlink" title="二分图的判定性质"></a>二分图的判定性质</h4><p><strong>判定性质：判断一个图是不是二分图，其实就是判断这个图有没有奇圈</strong></p>
<p>如下图所示：</p>
<p>我们把这个图划分成了两个点集$X$和$Y$</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210713130951.png" alt="image-20210713130951633"></p>
<p>但是如果存在奇圈的话，就会变成如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210713131058.png" alt="image-20210713131058769"></p>
<p>因此，我们可以通过观察奇偶性可知，相邻的两个节点的奇偶性一定是不相同的，分别对应到两个不同的点集$X$和$Y$中。那么当存在奇圈时，则说明相邻的这两个节点奇偶性一定是相同的，这与二分图的性质矛盾。</p>
<hr>
<h3 id="染色法判定二分图-1"><a href="#染色法判定二分图-1" class="headerlink" title="染色法判定二分图"></a>染色法判定二分图</h3><p>二分图染色算法的实现是通过判断一个图中是否存在奇圈从而确定它是否是二分图。    </p>
<p>染色法的算法步骤如下：</p>
<ul>
<li><p>设染色只有2种颜色，$color$为1和2</p>
</li>
<li><p>选择当前还没有被染色的节点作为当前节点$u$，给它染上颜色1，即$color[u]=1$</p>
</li>
<li>遍历该节点的所有邻接点$v$，并给这些邻接点染色，即$color[v]=3-color[u]$</li>
<li>重复上面两个步骤，直到全部染色完毕</li>
<li>如果染色过程种发生了矛盾，即相邻两个节点的颜色相同，则说明不满足二分图的奇偶性，因此可以判定出该图不是二分图；否则说明全部都成功无矛盾染色，该图是二分图</li>
</ul>
<p>注意：由于二分图可能是一个非连通图，所以不是只访问一个结点就能遍历到所有结点的，需要对所有结点都进行一次遍历。</p>
<p>染色法可以用dfs和bfs实现，算法思路其实都是一样的</p>
<blockquote>
<p>问题：如何理解dfs染色法中的下列代码呢？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(color[j]==c)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>如上图，假设当前节点是$u$，设$u=4$，设当前节点$u$的被染上的颜色为$c$。我们来看它的邻接点$j=2$。我们发现，其实在前面的时候，节点$1$就已经把节点$2$染过色了，染的颜色为$color[j]$。那么当节点$u$遍历到节点$j$时，发现节点$j$已经被染过色了，那么我们就只需要判断节点$j$的颜色是否与当前节点$u$的颜色相同。如果相同，则不符合二分图的奇偶性，则该图不是二分图；</p>
</blockquote>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><strong>dfs染色法：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//dfs染色法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, M = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="keyword">int</span> color[N];<span class="comment">//给图的每个顶点染色的数组</span></span><br><span class="line"><span class="comment">//构造无向图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//dfs函数是用来判定染色过程中是否出现了矛盾，如果出现了矛盾，则返回false</span></span><br><span class="line"><span class="comment">//如果没有出现矛盾，就返回true</span></span><br><span class="line"><span class="comment">//这里假设染了两种颜色1 和 2</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    color[u] = c;<span class="comment">//u这个顶点染上c的颜色</span></span><br><span class="line">    <span class="comment">//拓展u这个顶点的邻接表，去寻找邻接点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="comment">//如果j顶点还没有被染过色</span></span><br><span class="line">        <span class="keyword">if</span> (!color[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果当这个j顶点染上色之后，就出现了矛盾，那么让flag为false</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(j, <span class="number">3</span> - c))<span class="comment">//3 - c表示所染的颜色一定是在1和2之间</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里说明j之前已经被染过色了 那么判断一下当前节点u的颜色和它的邻接点j的颜色是否相同</span></span><br><span class="line">        <span class="comment">//如果相同则说明一条边的两个顶点都是染相同的颜色,则不满足二分图的奇偶性</span></span><br><span class="line">        <span class="comment">//那么就会出现染色矛盾</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (color[j] == c)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//染色成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="built_in">add</span>(a, b);</span><br><span class="line">        <span class="built_in">add</span>(b, a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;<span class="comment">//flag用来判断染色是否有矛盾，如果出现矛盾,则为false,否则就是true</span></span><br><span class="line">    <span class="comment">//对1号顶点到n号顶点分别染色</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果当前i这个顶点还没有被染色的话  !color[i]表示当前i顶点还没有被染色</span></span><br><span class="line">        <span class="keyword">if</span> (!color[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果当这个i顶点染上色之后，就出现了矛盾，那么让flag为false，然后break退出for循环</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(i, <span class="number">1</span>))<span class="comment">//有两种颜色  颜色1和颜色2</span></span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果染色过程中没有出现矛盾，成功给每个顶点染色了，输出Yes</span></span><br><span class="line">    <span class="keyword">if</span> (flag)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="comment">//否则如果染色过程中出现了矛盾，则输出No</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bfs染色法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//bfs染色法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, M = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="keyword">int</span> color[N];<span class="comment">//给图的每个顶点染色的数组</span></span><br><span class="line"><span class="comment">//bfs的队列</span></span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line"><span class="comment">//构造无向图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//bfs染色法 c是颜色  0 表示还没有染色 1表示染了一种颜色  2表示染了另一种颜色</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    color[u]=c;     <span class="comment">//给u这个节点染上颜色c</span></span><br><span class="line">    q.<span class="built_in">push</span>(u);      <span class="comment">//将u这个节点加入队列q中</span></span><br><span class="line">    <span class="comment">//当队列不为空时</span></span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//取出队头元素</span></span><br><span class="line">        <span class="keyword">int</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();    <span class="comment">//队头元素已经出队了,弹掉队头元素</span></span><br><span class="line">        <span class="comment">//遍历队头元素t的所有邻接点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//队头元素t的邻接点j</span></span><br><span class="line">            <span class="keyword">int</span> j=e[i];</span><br><span class="line">            <span class="comment">//如果j还没有被染色</span></span><br><span class="line">            <span class="keyword">if</span>(!color[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//由于j是t的邻接点 所以它俩奇偶性不同 染色不一样</span></span><br><span class="line">                color[j]=<span class="number">3</span>-color[t];</span><br><span class="line">                <span class="comment">//将j加入队列q中</span></span><br><span class="line">                q.<span class="built_in">push</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//否则说明j已经被染过色了 但是它的颜色与邻接点t的颜色相同 则不满足奇偶性</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(color[j]==color[t])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a,b);</span><br><span class="line">        <span class="built_in">add</span>(b,a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!color[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">bfs</span>(i,<span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                flag=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>二分图</category>
      </categories>
      <tags>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title>棋盘覆盖</title>
    <url>/2021/07/19/Algorithm-Improvement/Chapter3---Gragh-Theory/%E4%BA%8C%E5%88%86%E5%9B%BE/%E6%A3%8B%E7%9B%98%E8%A6%86%E7%9B%96/</url>
    <content><![CDATA[<h1 id="棋盘覆盖"><a href="#棋盘覆盖" class="headerlink" title="棋盘覆盖"></a>棋盘覆盖</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210719133614.png" alt="image-20210719133614274"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>在状态压缩DP的例题“蒙德里安的梦想”中，我们解决了用$1\times2$的长方形铺满$N\times M$网格的方案数问题。而这里与之不同的是，本题中的棋盘有禁止放置的格子，并且只需要求出能放置的$1\times2$骨牌的最大数量即可。当$N,M$较小时，仍然可以使用状态压缩DP来求解，这里更高效的方法则是构建出二分图匹配的模型。</p>
<p>二分图匹配的模型需要两个基本要素：</p>
<ul>
<li>节点能分成两个独立的集合，每个集合内部有$0$条边</li>
<li>每个节点只能与$1$条匹配边相连</li>
</ul>
<p>我们称为“0要素”和“1要素”。在把实际问题抽象成二分图匹配时，我们就要寻找题目中具有这种“0”和“1”性质的对象，从而发现模型构建的突破口。</p>
<p>在本题中，任意两张骨牌不能重叠，也就是每个格子只能被1张骨牌覆盖。而骨牌的大小为$1\times2$，覆盖$2$个相邻的格子。这恰好与“1要素”相对应。于是，我们可以把棋盘上没有被禁止的格子作为节点，把骨牌作为无向边（两个相邻的格子对应的节点之间连一条无向边）</p>
<p>我们可以发现，对于棋盘来说，相邻的节点它们的横坐标+纵坐标，得到的和 是不同的。因此，我们可以把棋盘黑白染色（行号+列号为偶数的格子被染成白色，行号+列号为奇数的格子被染成黑色），把白色格子都放进一个点集合$V_1$中，把黑色格子都放进另一个点集合$V_2$中。那么两个相同颜色的格子不可能被同一个骨牌覆盖，也就是说同色格子之间没有边相连，即点集合$V_1$内部没有边相连，点集合$V_2$内部没有边相连。这恰好与“0要素”对应。</p>
<p>于是，刚才建立的无向图就是一张二分图。可以把白色格子作为左部节点，黑色格子作为右部节点。如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210719135004.png" alt="image-20210719135004377"></p>
<p>要让骨牌不重叠的情况下尽量多放，就是求上述构建好的二分图的最大匹配。</p>
<p>这里因为涉及到二维坐标问题，那么我们建图时，可以使用二维的邻接矩阵<code>g[N][N]</code>，当$g[i][j]=1$表示这个格子不能放置，当$g[i][j]=0$表示这个格子可以放置。</p>
<p>对于二分图来说，虽然是无向图。但是求二分图的最大匹配时，使用匈牙利算法，是从男生集合出发的，因此只需要当初有向边即可。那么这里我们把白色格子组成的点集合看作是男生集合，把黑色格子组成的点集合看作是女生集合。那么做匈牙利算法时，从$(i+j)\%2==0$这个男生集合出发即可。</p>
<p>由于是使用邻接矩阵建图，因此不像邻接表那样的建图方式（邻接表需要add这个建图函数)</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">110</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;PII;</span><br><span class="line"><span class="keyword">int</span> n,t;</span><br><span class="line"><span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line"><span class="comment">//存储女生配对的男友的编号 比如match[i][j]=&#123;2,3&#125; 表示(i,j)这个格子所对应的那个女生她的现配男友的编号为&#123;2,3&#125;这个格子</span></span><br><span class="line">PII match[N][N];</span><br><span class="line"><span class="keyword">bool</span> st[N][N];</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="comment">//匈牙利算法</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//遍历点(x,y)的四个方向</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a=x+dx[i];</span><br><span class="line">        <span class="keyword">int</span> b=y+dy[i];</span><br><span class="line">        <span class="keyword">if</span>(a&gt;=<span class="number">1</span>&amp;&amp;a&lt;=n&amp;&amp;b&gt;=<span class="number">1</span>&amp;&amp;b&lt;=n&amp;&amp;!g[a][b]&amp;&amp;!st[a][b])</span><br><span class="line">        &#123;</span><br><span class="line">            st[a][b]=<span class="literal">true</span>;</span><br><span class="line">            PII t=match[a][b];</span><br><span class="line">            <span class="keyword">if</span>(t.first==<span class="number">-1</span>||<span class="built_in">find</span>(t.first,t.second))</span><br><span class="line">            &#123;</span><br><span class="line">                match[a][b]=&#123;x,y&#125;;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        <span class="comment">//如果不能放置 则g设为1</span></span><br><span class="line">        g[x][y]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(match,<span class="number">-1</span>,<span class="keyword">sizeof</span> match);</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;  <span class="comment">//匹配数量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//(i+j)%2==0表示男生集合  g[i][j]==0表示这个点可以放置</span></span><br><span class="line">            <span class="keyword">if</span>((i+j)%<span class="number">2</span>==<span class="number">0</span>&amp;&amp;g[i][j]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//每一轮男生(i,j)匹配时  都要清空上一个男生进行匹配操作时所遗留下的状态</span></span><br><span class="line">                <span class="built_in">memset</span>(st,<span class="number">0</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">                <span class="comment">//(i,j)这个男生找到了女朋友  匹配数量+1</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">find</span>(i,j))</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>二分图</category>
      </categories>
      <tags>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title>机器任务</title>
    <url>/2021/07/19/Algorithm-Improvement/Chapter3---Gragh-Theory/%E4%BA%8C%E5%88%86%E5%9B%BE/%E6%9C%BA%E5%99%A8%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="机器任务"><a href="#机器任务" class="headerlink" title="机器任务"></a>机器任务</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210719155448.png" alt="image-20210719155448461"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>这一题其实是二分图最大匹配的应用。</p>
<p>结论：<strong>二分图的最小顶点覆盖=二分图的最大匹配</strong></p>
<p>最小顶点覆盖：用最少的顶点来覆盖图中所有的边</p>
<p>二分图最小顶点覆盖的模型特点是：<strong>每条边有2个端点，二者至少选择一个</strong>。我们称之为“2要素”。如果一个题目具有“2要素”的特点，那么就可以尝试抽象成二分图最小顶点覆盖模型来求解</p>
<p>在这道题目中，每个任务要么在机器$A$上以模式$a[i]$执行，要么在机器$B$上以模式$b[i]$执行，二者必选其一。因此，我们可以把机器$A$的$N$种模式作为$N$个顶点放在左部点集合中，把机器$B$的$M$种模式作为$M$个顶点放在右部点集合中，每个任务当作是一条无向边，连接左边的$a[i]$模式（第$a[i]$个节点）和右边的$b[i]$模式（第$b[i]$个节点）。</p>
<p>由于每台机器转换一次模式就需要重启一次，要想使得重启次数最少，那么就需要某种模式它能处理多种任务，即一个节点能够连接多个无向边。那么要使重启次数最少，即用最少的顶点来覆盖掉所有的无向边。那么这就是要求二分图的最小顶点覆盖，根据前面的结论可知，只需要求出二分图的最大匹配即可。</p>
<p>这里有个坑点，两台机器一开始的模式都是0，因此每个任务如果可以在模式为0的情况下都可以直接进行，则不需要进行重启，因此建图时碰到$a[i]$或者$b[i]$为0，则直接跳过不考虑把它建立到图中即可。</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="keyword">int</span> match[N];</span><br><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//遍历机器B中的这m个模式   即寻找右边的女生集合</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果x这个男生还没有访问过i这个女生</span></span><br><span class="line">        <span class="comment">//并且 此时并不是处于模式0</span></span><br><span class="line">        <span class="keyword">if</span>(!st[i]&amp;&amp;g[x][i]==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            st[i]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(match[i]==<span class="number">-1</span>||<span class="built_in">find</span>(match[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                match[i]=x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n),n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//有多组测试数据  因此每次都要进行初始化</span></span><br><span class="line">        <span class="built_in">memset</span>(match,<span class="number">-1</span>,<span class="keyword">sizeof</span> match);</span><br><span class="line">        <span class="built_in">memset</span>(g,<span class="number">0</span>,<span class="keyword">sizeof</span> g);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;m,&amp;k);</span><br><span class="line">        <span class="keyword">while</span>(k--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> id,a,b;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;id,&amp;a,&amp;b);</span><br><span class="line">            <span class="comment">//如果机器A处于模式0或者机器B处于模式0 那么g[a][b]=0;否则g[a][b]=1</span></span><br><span class="line">            <span class="keyword">if</span>(a&amp;&amp;b)</span><br><span class="line">            g[a][b]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//机器A的n个模式看成是左边的男生集合  从男生集合出发进行匹配</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memset</span>(st,<span class="number">0</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(i))</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>二分图</category>
      </categories>
      <tags>
        <tag>最小顶点覆盖</tag>
      </tags>
  </entry>
  <entry>
    <title>观光奶牛</title>
    <url>/2021/07/12/Algorithm-Improvement/Chapter3---Gragh-Theory/Negative-Circle/%E8%A7%82%E5%85%89%E5%A5%B6%E7%89%9B/</url>
    <content><![CDATA[<h1 id="观光奶牛"><a href="#观光奶牛" class="headerlink" title="观光奶牛"></a>观光奶牛</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210712160410.png" alt="image-20210712160410274"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>一般来说，求 点权之和/边权之和 的最值问题，都属于01分数规划问题。</p>
<p>图论的01分数规划问题的步骤：</p>
<ul>
<li>确认答案区间，然后用二分算法，判断性质</li>
<li>借助二分出来的中点，推导出性质的公式</li>
<li>套用图论模板</li>
</ul>
<p>本题要求我们求一个环内$\dfrac {\sum f_i}{\sum t_i}$的最大值，而这个答案本身就是具有单调性，因此可以用二分算法，来二分出最终的答案。</p>
<p>首先来确定答案的区间：</p>
<p>我们设$c =\dfrac {\sum f_i}{\sum t_i}$</p>
<ul>
<li>要想求出区间的左范围，那么分子应该最小，分母应该最大，那么分子应该取一个点，该点的点权为1；分母应该取5000条边，边权为1000，那么此时$c=\dfrac {1\times1}{5000\times1000}$，很难明显，这个$c$不为0，肯定是大于0的，注意这里不能理解为C++中的整除会向下取整，这里应该理解为浮点数的除法，因为题目说了要保留两位小数。因此，我们确定了左范围是大于0的</li>
<li>要想求出区间的右范围，那么分子应该最大，分母应该最小，那么分子应该取1000个点，每个点的点权都为1000；由于有了1000个点，那么对于环来说，至少得是1000条边（注意不可能说有1000个点，然后取1条边，这样不能形成环），这1000条边的权值都为1，那么此时$c=\dfrac {1000\times1000}{1000\times1}=1000$。因此，我们确定了右范围是1000</li>
<li>所以，答案区间就是<code>(0,1000]</code></li>
</ul>
<p>由于我们发现答案区间是单调递增的，也就是说具有单调性，那么就可以用二分算法，来快速地求出$c$。我们设$L=0,R=1000$，假设某个时刻，我们设中点为$mid$，那么：</p>
<p>$\dfrac {\sum f_i}{\sum t_i}&gt;mid$</p>
<p>$\iff$ $\sum f_i&gt;mid*\sum t_i$</p>
<p>$\iff$ $\sum f_i-mid*\sum t_i&gt;0$</p>
<p>$\iff$ $\sum (f_i-mid*t_i)&gt;0$</p>
<p>根据上述推导的公式可知，对于满足要求的$mid$，就是要满足图中存在一个<code>环</code>，它的$\sum (f_i-mid*t_i)&gt;0$ ，要求一个环，它的权值之和大于0，这不就是想让我们求正环嘛？</p>
<p>因此，原问题就转换为 求图中是否存在一个正环 的问题了</p>
<p>我们每次二分出一个$mid$，然后$check(mid)$，如果它满足上面的这个式子，那么由于答案是单调递增的，我们想要求出最大的$mid$，因此此时左范围$L$应该往右侧收缩，即$L=mid$，不可能让右范围往左收缩吧，即不可能是$R=mid$（如果这样的话，那么更新过后的区间的最大值不就小于$mid$了嘛，这就不可能找到最大值了）。因此一旦二分出的$mid$满足上述式子，那么就往右侧收缩$L=mid$，这样会更快地逼近最大值；如果二分出的这个$mid$不满足上述式子，则说明答案肯定比当前二分的$mid$还小，那么就要往左侧收缩$R=mid$，因为右边已经不可能了。</p>
<p>浮点数的二分比较简单，就是执行$L=mid$或者$R=mid$。</p>
<p>这里还有个问题，就是我们该怎么处理点权和边权呢？我们以前都只是见过有边权的情况。其实，我们可以把节点的点权放到它的出边上，那么此时就只有边权的情况了，不存在点权。为什么可以这么做呢？</p>
<ul>
<li>假设同时存在点权和边权，那么所有点权之和为$\sum f_i$，所有边权之和为$\sum t_i$，因此，总的权值之和为$\sum f_i+\sum t_i$</li>
<li>假设把点权放到出边上，此时只有边权，那么某个出边的权值为$f_i+t_i$，因此，总的权值之和为$\sum (f_i+t_i)$</li>
<li>由于$\sum$是可以分开的，因此$\sum(f_i+t_i)=\sum f_i+\sum t_i$</li>
</ul>
<p>有了上面的处理之和，我们建图就会更加方便了，只需要处理边权就好了。</p>
<p>我们来看这个式子 $\sum(f_i-mid\times t_i)$，那么其实就是$\sum (f_i+(-mid\times t_i))&gt;0=\sum f_i+\sum-mid\times t_i$，也就是说把原来的边权$t_i$换成了$f_i-mid\times t_i$来存储了，把每个点的权值都放入它的出边中。</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>,M=<span class="number">5010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="comment">//点权</span></span><br><span class="line"><span class="keyword">int</span> wf[N];</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],wt[M],idx;  <span class="comment">//wt是边权</span></span><br><span class="line"><span class="keyword">int</span> q[N],cnt[N];</span><br><span class="line"><span class="keyword">double</span> dist[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    wt[idx]=c;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//spfa判断正环</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">double</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">-0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">memset</span>(st,<span class="number">0</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span> cnt);</span><br><span class="line">    <span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//一开始将原图中所有点加入队列q中就  等效于建立了一个带有虚拟源点的新图 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        q[tt++]=i;</span><br><span class="line">        dist[i]=<span class="number">0</span>;</span><br><span class="line">        st[i]=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(hh!=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=q[hh++];</span><br><span class="line">        <span class="keyword">if</span>(hh==N)</span><br><span class="line">        hh=<span class="number">0</span>;</span><br><span class="line">        st[t]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];</span><br><span class="line">            <span class="comment">//wf[t]-mid*wt[i]是将点权放到了边上</span></span><br><span class="line">            <span class="keyword">if</span>(dist[j]&lt;dist[t]+wf[t]-mid*wt[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j]=dist[t]+wf[t]-mid*wt[i];</span><br><span class="line">                cnt[j]=cnt[t]+<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//说明存在正环</span></span><br><span class="line">                <span class="keyword">if</span>(cnt[j]&gt;=n)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q[tt++]=j;</span><br><span class="line">                    <span class="keyword">if</span>(tt==N)</span><br><span class="line">                    tt=<span class="number">0</span>;</span><br><span class="line">                    st[j]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//说明不存在正环</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;wf[i]);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a,b,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> l=<span class="number">0</span>,r=<span class="number">1e4</span>;</span><br><span class="line">    <span class="comment">//二分找到答案</span></span><br><span class="line">    <span class="keyword">while</span>(l+<span class="number">1e-4</span>&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//满足条件 则向右侧收缩</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid))</span><br><span class="line">        l=mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        r=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>,l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>负环</category>
      </categories>
      <tags>
        <tag>负环</tag>
      </tags>
  </entry>
  <entry>
    <title>骑士放置</title>
    <url>/2021/07/19/Algorithm-Improvement/Chapter3---Gragh-Theory/%E4%BA%8C%E5%88%86%E5%9B%BE/%E9%AA%91%E5%A3%AB%E6%94%BE%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="骑士放置"><a href="#骑士放置" class="headerlink" title="骑士放置"></a>骑士放置</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210719171846.png" alt="image-20210719171846826"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>最大独立集：选出最多的点，使得选出的点之间没有边</p>
<p>在二分图中，求最大独立集合$\iff$去掉最少的点，使得将所有边都破坏掉$\iff$ 找到最小顶点覆盖$m$$\iff$ 找到最大匹配$m$</p>
<p>结论：最大独立集=总点数-孤立节点数-最小顶点覆盖数</p>
<p>这个题目和“棋盘覆盖”这个题目是类似的，可以对棋盘进行黑白染色，黑色的格子、白色的格子分别作为二分图的左、右部节点。</p>
<p>如果两个格子是“日”字的对角（能互相攻击到），则在这两个格子之间连一条无向边。这个题目是想要求出最多能放多少个不能互相攻击的骑士，由于我们把有攻击的节点都连边了，因此考虑用最少的点来覆盖这些边，那么就会尽可能的剩下多的节点（骑士）了，因此先求出最小顶点覆盖，然后用总点数减去最小顶点覆盖，再减去孤立节点数即可。因此，抽象题意其实就是要求最大独立集。而且，“日”字的两个对角格子的颜色一定不相同。因此，我们建立的图一定是一张二分图。那么我们用匈牙利算法求出二分图的最大匹配，就可以很容易求出二分图的最大独立集了。</p>
<p>如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210719172823.png" alt="image-20210719172823092"></p>
<p>两个格子的马若能互相攻击，则这两个格子之间能连上一条边。若两只马能够互相攻击，则这两只马的格子一定是两种不同颜色的格子。</p>
<p>这里要注意，题目中说了有一些格子禁止放棋子，因此这些格子都会被认为是孤立节点。计算最大独立集时，要记得减去这些孤立节点。</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">110</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;PII;</span><br><span class="line"><span class="keyword">int</span> n,m,t;</span><br><span class="line"><span class="comment">//邻接矩阵 g[i][j]=1表示(i,j)这个格子可以放置  g[i][j]=0表示(i,j)这个格子不可以放置</span></span><br><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line">PII match[N][N];</span><br><span class="line"><span class="keyword">bool</span> st[N][N];</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">8</span>]=&#123;<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">8</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-2</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="comment">//寻找(x,y)这个男生的女友</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//遍历(x,y)这个格子周围的8个方向 即遍历它周围的女生集合</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a=x+dx[i];</span><br><span class="line">        <span class="keyword">int</span> b=y+dy[i];</span><br><span class="line">        <span class="keyword">if</span>(a&gt;=<span class="number">1</span>&amp;&amp;a&lt;=n&amp;&amp;b&gt;=<span class="number">1</span>&amp;&amp;b&lt;=m&amp;&amp;!st[a][b]&amp;&amp;!g[a][b])</span><br><span class="line">        &#123;</span><br><span class="line">            st[a][b]=<span class="literal">true</span>;</span><br><span class="line">            PII t=match[a][b];</span><br><span class="line">            <span class="keyword">if</span>(t.first==<span class="number">-1</span>||<span class="built_in">find</span>(t.first,t.second))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//(a,b)这个格子的女生她的现配成功男友是(x,y)</span></span><br><span class="line">                match[a][b]=&#123;x,y&#125;;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(match,<span class="number">-1</span>,<span class="keyword">sizeof</span> match);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;t);</span><br><span class="line">    <span class="comment">//输入t个不能放置的格子</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        g[a][b]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//(i+j)%2==0表示男生集合</span></span><br><span class="line">            <span class="comment">//g[i][j]==0表示(i,j)这个格子可以放置</span></span><br><span class="line">            <span class="keyword">if</span>((i+j)%<span class="number">2</span>==<span class="number">0</span>&amp;&amp;g[i][j]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">memset</span>(st,<span class="number">0</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">find</span>(i,j))</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最大独立集=总点数-孤立节点数-最小顶点覆盖</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,n*m-t-res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>二分图</category>
      </categories>
      <tags>
        <tag>最大独立集</tag>
      </tags>
  </entry>
  <entry>
    <title>捉迷藏</title>
    <url>/2021/07/20/Algorithm-Improvement/Chapter3---Gragh-Theory/%E4%BA%8C%E5%88%86%E5%9B%BE/%E6%8D%89%E8%BF%B7%E8%97%8F/</url>
    <content><![CDATA[<h1 id="捉迷藏"><a href="#捉迷藏" class="headerlink" title="捉迷藏"></a>捉迷藏</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210720123116.png" alt="image-20210720123116058"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>最小路径点覆盖：选择一些路径，覆盖所有点，并且各个路径的节点之间不能有交集，要求路径数最少</p>
<p>最小路径重复点覆盖：选择一些路径，覆盖所有点，但是各个路径的节点之间允许有交集，要求路径数最少</p>
<p>求解最小路径点覆盖的方法：</p>
<p><strong>结论：DAG的最小路径点覆盖=原图节点数-拆点后形成的二分图的最大匹配数</strong></p>
<p>证明：</p>
<p>这里使用的技巧是拆点。假设原图有$n$个节点，将每个节点都复制一份放到右边，假设节点$i$复制后的点为$i’$，我们将原图中的边$(i,j)$转变为新图中的$(i,j’)$。新图必然是一个二分图。</p>
<p>如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210720123914.png" alt="image-20210720123914525"></p>
<p>考虑原图中的任意一条路径转化到新图中是啥样的呢？</p>
<ul>
<li>每条路径转化到新图中一定对应新图的一个匹配，即每个点只会在一条边中。反之也成立</li>
<li>我们可以看到原图中每条路径的终点，对应到新图中的话就是出点没有引出一条出边，即它是新图中左部的非匹配点，例如上图中的节点3。同理左部的每一个非匹配点都对应着原图中的路径。即使是孤立节点也可以看成一个终点，符合要求。我们想要让路径数最少，那么就是让左部的非匹配点数目最少，由于$n=$左部非匹配点数+左部匹配点数，因此必须让左部匹配点数最大，那么也就是找最大匹配，设最大匹配为$m$，因此左部的非匹配点最少为$n-m$，即路径数最少为$n-m$。因此最小路径点覆盖=原图节点数-拆点后形成的二分图的最大匹配数</li>
</ul>
<p>求解最小路径重复点覆盖的方法：</p>
<ul>
<li>对原图$G$求一次传递闭包，得到一张图$G’$</li>
<li>求原图的最小路径重复点覆盖$\iff$ 求新图的最小路径点覆盖</li>
</ul>
<p>证明：</p>
<ol>
<li>充分性：依次考虑原图的每一条符合条件的路径，当我们考察第$i$条路径时，如果路径上的点和前$i-1$条边上的点是重复的，那么直接跳过即可，新图中加了很多边，可以跳过。另外第$i$条路径上的点不可能全部和前$i-1$条边上的点重复，否则第$i$条路径就没有存在的必要了。</li>
<li>必要性：将新图中间接转移过去的边展开成原来的边即可得到原图中的路径。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210720145120.png" alt="image-20210720145120840"></p>
<p>现在我们来理清一下题意：题目中说到 “如果从房子$A$沿着路走下去能够到达$B$，那么在 $A$和 $B$ 里的人是能够相互望见的。”这说明了一条路径中最多只能选择一个点作为藏身点，因为如果选择两个藏身点的话，那么就可以互相看见了。 “cl2 要求这$K$个藏身点的任意两个之间都没有路径相连。”其实就是要求：给定一定DAG图，让我们选择尽可能多的点，使得这些点任意两个点之间都不能相互到达。</p>
<p>题目要求尽可能多的藏身点组成集合，使得任意两点之间都没有边。那这与最小重复点路径覆盖有啥关系嘛？这不应该是最大独立集的含义嘛？但是要注意最大独立集只针对无向图，对于有向图是不适用的。但是题目中说到视线是可以沿着路径无限延展的，似乎在引导我们往传递闭包上面想，而说到传递闭包，那么不就是要求最重复路径点覆盖嘛？</p>
<p>或者我们可以根据下面的这个定理来理清题意：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210720130243.png" alt="image-20210720130243580"></p>
<p>要求尽可能多的藏身点组成集合，使得任意两点之间都没有边这正与最长反链长度相同，而最长反链长度=最小链覆盖。</p>
<p>我们设答案为$K$，最小重复路径点覆盖为cnt：</p>
<ul>
<li>先证明$K\leq cnt$。由于这cnt条路径把所有节点都已经覆盖了，所以选择$K$个点从这cnt条路径上选了，每条路径上最多只能选择一个点，因此必然有$K\leq cnt$。</li>
<li>再证明$K=cnt$。可以采用构造法：我们把这cnt条路径中每条路径的终点都放入这个顶点集合$V$中。设集合<code>next(V)</code>表示：从点集合$V$中的每个点出发可以到达的所有顶点的集合。<ul>
<li>如果$V\cap next(V)=\empty$，那么意味着从$V$中所有节点出发，都不能到达$V$集合内部的顶点。即$V$内部的任意两个节点之间是不能相互到达的。而这个含义正好与我们题意想要求的是一致的。因此，而$V$里面就有cnt个点，因此我们就构造出了包含cnt个点的方案。此时$V$就是合法的答案。</li>
<li>如果$V\cap next(V)\notin \empty$，那么我们从$V$中挑选出任意一个点$v_i$（某条路径的终点），让$v_i$沿着有向边往回走（往起点方向走），走到某个点$v_i’$不属于$next(V)$为止。对于$V$集合中的每一个点$v_i$都进行这样的操作，每个$v_i$都走到$v_i’$不属于$next(V)$为止。那么最终直到$V$和$next(V)$没有交集为止。那么如何证明最终一定可以做到$V$和$next(V)$没有交集呢？如何证明最多走到起点时就能保证$V\cap next(V)=\empty$呢？ 这里采用反证法：假设一直往回走，一直回退到起点，都不能保证某个点$v_i’$不属于$next(V)$，也就是说，走到起点了仍然有某个点$v_i’\in next(V)$，由于$next(V)$表示从多条路径的终点出发所能到达的所有顶点的集合，那么这说明$v_i’$所在的这条路径$e$的起点都是可以被这些路径所到达的，那么这条路径$e$其实就没有存在的价值了。因为我们可以把这条路径$e$接到$next(V)$中某条路径的后面，那么当前路径$e$上的每一个点都可以被覆盖，由于把这条路径接到了某一条路径的后面，因此路径数目少1，这与cnt为最小重复路径点覆盖矛盾。因此，我们就证明了$v_i$它走到某个点就一定会停止，也就是说最终仍然会有$V\cap next(V)=\empty$。因此，我们就证明了$K=cnt$。</li>
</ul>
</li>
</ul>
<p>由于我们证明了$K\leq cnt$并且$K=cnt$，那么最终$K=cnt$。</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">210</span>,M=<span class="number">30010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="comment">//邻接矩阵 g[i][j]=1表示从i节点到j节点连一条有向边</span></span><br><span class="line"><span class="comment">//g[i][j]=0表示从i节点到j节点没没有引出有向边</span></span><br><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line"><span class="keyword">int</span> match[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="comment">//寻找男生x的配对女生</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//遍历x能够联系的所有这n个女生</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//g[x][i]==1表示男生x和女生i之间连了一条有向边  可以联系</span></span><br><span class="line">        <span class="comment">//!st[i]表示男生x之前还没有访问过这个女生i</span></span><br><span class="line">        <span class="keyword">if</span>(g[x][i]&amp;&amp;!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            st[i]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(match[i]==<span class="number">-1</span>||<span class="built_in">find</span>(match[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                match[i]=x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(match,<span class="number">-1</span>,<span class="keyword">sizeof</span> match);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        g[a][b]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对原图G求一遍传递闭包,得到一个新图G&#x27;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                g[i][j]|=g[i][k]&amp;g[k][j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//对这个新图G&#x27;求二分图的最大匹配</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(st,<span class="number">0</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(i))</span><br><span class="line">        res++;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">//最小路径重复点覆盖=总点数-新图G&#x27;的最大匹配      </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,n-res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>二分图</category>
      </categories>
      <tags>
        <tag>最小可重复点覆盖</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP</title>
    <url>/2021/07/11/Algorithm-Improvement/Chapter3---Gragh-Theory/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/KMP/</url>
    <content><![CDATA[<h1 id="KMP算法详解"><a href="#KMP算法详解" class="headerlink" title="KMP算法详解"></a>KMP算法详解</h1><hr>
<p>求解<code>next[]</code>数组之前要先明白以下数组的概念：</p>
<ul>
<li>前缀：包含首位字符但是不包含末位字符的子串</li>
<li>后缀：包含末位字符但是不包含首位字符的子串</li>
<li><code>next[]</code>数组的含义：当主串S与模式串P的某一位字符不匹配时，模式串P应该回退的位置（数组下标）</li>
<li>$next[i]=j$的含义：即模式串P的前i个字符(包括i)组成的字符串中，最长公共前后缀子串的长度为$j$</li>
</ul>
<p><strong>注意：我们的算法中，字符串的下标都是从1开始，不用下标0，下标为0可以表示空字符。</strong></p>
<p>如下图所示，来看看什么是最长公共前后缀：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210711105744.png" alt="image-20210711105734389"></p>
<ol>
<li>当i=0时，空字符，最长公共前后缀为0</li>
<li>当i=1时，对于单个字符来说，不存在前缀和后缀，因此最长公共前后缀为0</li>
<li>当i=2时，字符串为“AB”，前缀为A，后缀为B，前缀与后缀并不相同，因此最长公共前后缀为0</li>
<li>当i=3时，字符串为“ABC”，前缀为A，AB；后缀为C，BC，前缀与后缀并不相同，因此最长公共前后缀为0</li>
<li>当i=4时，字符串为“ABCA”，前缀为<strong>A</strong>，AB，ABC；后缀为<strong>A</strong>，CA，BCA；有最长的相同的前后缀A，因此最长公共前后缀为1</li>
<li>当i=5时，字符串为“ABCAB”，前缀为A，<strong>AB</strong>，ABC，ABCA；后缀为B，<strong>AB</strong>，CAB，BCAB；有最长的相同的前后缀AB，因此最长公共前后缀为2</li>
<li>当i=6时，字符串“ABCABD”，前缀为A，AB，ABC，ABCA，ABCAB；后缀为D，BD，ABD，CABD，BCABD，前缀与后缀并不相同，因此有相同的前后缀，因此最长公共前后缀为0</li>
</ol>
<p>该栗子中，<code>next[]</code>数组元素的值分别为：</p>
<p>一般来说，我们都可以预定义$next[0]$和$next[1]$都为0</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">next[<span class="number">0</span>]=<span class="number">0</span>;	<span class="comment">//空字符  弃用</span></span><br><span class="line">next[<span class="number">1</span>]=<span class="number">0</span>;	<span class="comment">//单个字符,不存在前缀和后缀,因此next[1]固定为0</span></span><br><span class="line">next[<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">next[<span class="number">3</span>]=<span class="number">0</span>;</span><br><span class="line">next[<span class="number">4</span>]=<span class="number">1</span>;</span><br><span class="line">next[<span class="number">5</span>]=<span class="number">2</span>;</span><br><span class="line">next[<span class="number">6</span>]=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>我们用图示来形象地理解<code>next[]</code>的含义：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210711111510.png" alt="image-20210711111454805"></p>
<p>如上图所示，对于由$i$个字符组成的字符串来说，前面的绿色部分和后面的绿色部分就表示该字符串相同的前缀和后缀，值为$next[i]$</p>
<hr>
<p>那么，我们怎么求解<code>next[]</code>数组呢？</p>
<p>根据<code>next[]</code>数组的含义，可以分为两种情况讨论，找到规律：</p>
<ul>
<li>如果新加入的字符与前一个最长公共前后缀子串的后面一个字符相同时，即$p[j+1]==p[i]$</li>
<li>如果新加入的字符与前一个最长公共前后缀子串的后面一个字符不同时，即$p[j+1]\neq p[i]$</li>
</ul>
<p><strong>讨论第一种情况：如果新加入的字符与前一个最长公共前后缀子串的后面一个字符相同时</strong></p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(p[i]==p[j+<span class="number">1</span>])</span><br><span class="line">    j++;</span><br><span class="line"><span class="comment">//用此时j的值来填充i所指向的这个字符的next数组的内容</span></span><br><span class="line">ne[i]=j;</span><br></pre></td></tr></table></figure>
<p>如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210711112121.png" alt="image-20210711112121418"></p>
<p>新加入的字符为$p[i]$，前一个最长公共前后缀子串的后一个字符是$p[j+1]$，可以发现，$p[j+1]==p[i]$，那么绿色部分就可以扩展一格，那么就是$next[i]=next[i-1]+1$，其实也就是$j=j+1$嘛，因为之前$j=next[i-1]$，然后由于$p[j+1]==p[i]$，那么$next[i]=next[i-1]+1$，就等效于此时$j=j+1$，即$j$++</p>
<p>注意：绿色部分是可以为0的，那么含义就是：最长公共前后缀为0，即不存在相同的前缀和后缀。也就是说此时$j$回退到0，指向了那个空字符</p>
<p><strong>讨论第二种情况：如果新加入的字符与前一个最长公共前后缀子串的后面一个字符不相同时</strong></p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当j没有回退到下标0所在的那个空字符,并且绿色部分内部一直都没有相同的前缀和后缀</span></span><br><span class="line"><span class="keyword">while</span>(j&amp;&amp;p[i]!=p[j+<span class="number">1</span>])</span><br><span class="line">    j=ne[j];</span><br><span class="line"><span class="comment">//用此时j的值来填充i所指向的这个字符的next数组的内容</span></span><br><span class="line">ne[i]=j;</span><br></pre></td></tr></table></figure>
<p>当出现这种情况时，在KMP算法中，就会执行$j=next[j]$，但是很难理解为什么要这么做。</p>
<p>下面我们看这张图：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210711121243.png" alt="image-20210711121242198"></p>
<p>那么蓝色的部分该怎么求解呢？在KMP中，就是用$j=next[j]$，这是回退操作</p>
<p>这个蓝色部分，首先要内容都完全相同，其次还要位于绿色部分的开头和结尾，那么这不就是绿色部分的最长公共前后缀的子串嘛？</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210711122308.png" alt="image-20210711122239056"></p>
<p>更新$j=next[j]$后，又回到原来的问题了，接着判断$p[j+1]$是否与$p[i]$相同就行了</p>
<p>至此，我们弄明白了那个令人费解的回退操作到底是什么意思了，其实就是在当前的这个最长公共前后缀已经不能使用时，那么就继续去寻找这个最长公共前后缀，看看它内部是否也存在最长公共前后缀，就这样一直迭代去寻找，一直尝试到成功或者是最长公共前后缀的长的为0时，就停止迭代循环</p>
<hr>
<p>下面给出求出<code>next[]</code>数组的完整代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ne[<span class="number">0</span>]=<span class="number">0</span>;	<span class="comment">//空字符的最长公共前后缀长度为0</span></span><br><span class="line">ne[<span class="number">1</span>]=<span class="number">0</span>;	<span class="comment">//单个字符不存在前缀和后缀，那么最长公共前后缀长度也为0</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(j&amp;&amp;p[i]!=p[j+<span class="number">1</span>])</span><br><span class="line">        j=ne[j];</span><br><span class="line">    <span class="keyword">if</span>(p[i]==p[j+<span class="number">1</span>])</span><br><span class="line">        j++;</span><br><span class="line">    ne[i]=j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>上面我们求出了<code>next[]</code>数组，那么如何进行主串和模式串的匹配呢？</p>
<p>其实进行主串和模式串的匹配，与求解<code>next[]</code>数组是一样的。</p>
<p>主循环中，$i$是用来遍历主串S的，$j$是用来遍历模式串p的。初始时$i$指向主串的第一个字符，即$i=1$，$j$指向模式串的空字符，即$j=0$。要注意：主串的$i$是不会回退的，它是一直往前遍历，但是模式串的$j$会进行回退操作，即会执行$j=next[j]$。</p>
<p><strong>讨论第一种情况：如果新加入的字符与前一个最长公共前后缀子串的后面一个字符相同时</strong></p>
<p>这里新加入的字符是指主串中的$S[i]$，前一个最长公共前后缀子串的后一个字符是指模式串中的$p[j+1]$，也就是说$S[i]==p[j+1]$，那么此时主串的下标$i$往前移动一位，模式串的下标$j$也往前移动一位</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(s[i]==p[j+<span class="number">1</span>])</span><br><span class="line">    j++;</span><br></pre></td></tr></table></figure>
<p><strong>讨论第二种情况：如果新加入的字符与前一个最长公共前后缀子串的后面一个字符不相同时</strong></p>
<p>这里新加入的字符是指主串中的$S[i]$，前一个最长公共前后缀子串的后一个字符是指模式串中的$p[j+1]$，也就是说$S[i]\neq p[j+1]$，那么此时模式串的$j$就要执行回退操作了，即$j=next[j]$</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(j&amp;&amp;s[i]!=p[j+<span class="number">1</span>])</span><br><span class="line">    j=ne[j];</span><br></pre></td></tr></table></figure>
<p>可以发现，其实进行主串与模式串的匹配时，与求解<code>next[]</code>数组是如出一辙的</p>
<hr>
<h1 id="KMP字符串"><a href="#KMP字符串" class="headerlink" title="KMP字符串"></a>KMP字符串</h1><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210711125013.png" alt="image-20210711125013111"></p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="comment">//n是模式串P的长度  m是主串S的长度</span></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">char</span> p[N];  <span class="comment">//模式串</span></span><br><span class="line"><span class="keyword">char</span> s[M];  <span class="comment">//主串</span></span><br><span class="line"><span class="comment">//next数组</span></span><br><span class="line"><span class="keyword">int</span> ne[N];</span><br><span class="line"><span class="comment">//求解出模式串P的next数组   next数组是对于模式串来说的,主串并不存在next数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ne[<span class="number">0</span>]=<span class="number">0</span>,ne[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;p[i]!=p[j+<span class="number">1</span>])</span><br><span class="line">        j=ne[j];</span><br><span class="line">        <span class="keyword">if</span>(p[i]==p[j+<span class="number">1</span>])</span><br><span class="line">        j++;</span><br><span class="line">        <span class="comment">//用此时j的值来填充i所指向当前这个字符的ne数组的内容</span></span><br><span class="line">        <span class="comment">//next[i] = j 表示下标以i-j为起点，i为终点的后缀和下标以1为起点，j为终点的前缀相等</span></span><br><span class="line">        <span class="comment">//且此字符串的长度最长。用符号表示为p[1~j] == p[i-j~i]</span></span><br><span class="line">        ne[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进行主串S和模式串P的匹配操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//主循环，遍历主串字符 i是用来遍历主串的，j是用来遍历模式串的</span></span><br><span class="line">    <span class="comment">//初始时i指向主串的第一个字符，j指向空字符</span></span><br><span class="line">    <span class="comment">//主串数组和模式串数组都是舍去数组下标0不用，从数组下标1开始存入字符</span></span><br><span class="line">    <span class="comment">//主串的i是不会回溯的，只有模式串的j才能回溯</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;s[i]!=p[j+<span class="number">1</span>])</span><br><span class="line">        j=ne[j];</span><br><span class="line">        <span class="keyword">if</span>(s[i]==p[j+<span class="number">1</span>])</span><br><span class="line">        j++;</span><br><span class="line">        <span class="comment">//如果j能走到n,那么一定是成功匹配了,因为如果不匹配的话,那么进行回退操作</span></span><br><span class="line">        <span class="comment">//j就不会到达n</span></span><br><span class="line">        <span class="keyword">if</span>(j==n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i-n);</span><br><span class="line">            <span class="comment">//这一句可以不用</span></span><br><span class="line">            j=ne[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//模式串和主串的下标都是从1开始</span></span><br><span class="line">    cin &gt;&gt;n&gt;&gt;p+<span class="number">1</span>&gt;&gt;m&gt;&gt;s+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//求解next数组</span></span><br><span class="line">    <span class="built_in">getNext</span>();</span><br><span class="line">    <span class="comment">//进行模式串和主串匹配操作</span></span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>区间</title>
    <url>/2021/07/08/Algorithm-Improvement/Chapter3---Gragh-Theory/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/%E5%8C%BA%E9%97%B4/</url>
    <content><![CDATA[<h1 id="区间"><a href="#区间" class="headerlink" title="区间"></a>区间</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210710143855.png" alt="image-20210710143855592"></p>
<hr>
<h3 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h3><ul>
<li>【1】给定区间<code>[a,b]</code>为$[3,7]$，那么$3\leq x\leq 7$，所以$x$的可选范围为{3，4，5，6，7}，其中要求选出来的$x$的个数必须不少于$c=3$个</li>
<li>【2】给定区间<code>[a,b]</code>为$[8,10]$，那么$8\leq x\leq 10$，所以$x$的可选范围为{8，9，10}，其中要求选出来的$x$的个数必须不少于$c=3$个</li>
<li>【3】给定区间<code>[a,b]</code>为$[6,8]$，那么$6\leq x\leq 8$，所以$x$的可选范围为{6，7，8}，其中要求选出来的$x$的个数必须不少于$c=1$个</li>
<li>【4】给定区间<code>[a,b]</code>为$[1,3]$，那么$1\leq x\leq 3$，所以$x$的可选范围为{1，2，3}，其中要求选出来的$x$的个数必须不少于$c=1$个</li>
<li>【5】给定区间<code>[a,b]</code>为$[10,11]$，那么$10\leq x\leq 11$，所以$x$的可选范围为{10，11}，其中要求选出来的$x$的个数必须不少于$c=1$个</li>
</ul>
<p>题目是意思是说想让我们从【1】、【2】、【3】、【4】、【5】中挑出$x$，组成一个整数集合$Z$，使得集合$Z$中元素的个数最少。那么给我们的启发就是，从【1】到【5】中跳出的这些数$x$应该尽可能的有交集，这样，才能使得选出最少的个数来组成集合$Z$。</p>
<ul>
<li>我们先看【1】和【4】，可以发现有交集元素3，由于【4】要求至少$c=1$，因此从【4】中我们挑出$x=3$就行了；</li>
<li>再来看【1】和【3】，可以发现有交集元素6，7，由于【1】中要求至少$c=3$，因此从【1】中挑选出$x=3,x=7,x=6,x=7$</li>
<li>再来看【2】和【3】，可以发现有交集元素8，由于【3】要求至少选出$c=1$，因此从【3】中我们挑出$x=8$</li>
<li>再来看【2】和【5】，有交集元素10，由于【5】要求至少选出$c=1$，因此从【5】中我们挑出$x=10$，由于【2】要求选出来的$x$的个数必须不少于$c=3$个，因此从【2】中挑出$x=8,9,10$</li>
<li>综上，我们选出来的$x$有<code>[3,6,7,8,9,10]</code>，也就是最少选出6个数，就可以构成一个整数集合$Z$，此时可以满足题目给出的五个限制条件</li>
</ul>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>这题我们需要用到差分约束来求解，同时还需要用到前缀和（这点比较难想）</p>
<p>我们设<code>S[i]</code>来表示从区间$[1,i]$中选出的$x$的个数。这里$0\leq a_i,b_i\leq 50000$，但是呢，由于前缀和需要用到$S[0]$，由定义可知$S[0]=0$，那么我们可以让$a_i,b_i$都+1，即向右平移一个单位，空出0这个位置来表达前缀和$S[0]$，平移之和并不影响最终结果。因此，此时$1\leq a_i,b_i\leq 50001$。</p>
<p>那么题目的意思也就是让我们从区间<code>[1,50001]</code>从选出最少的$x$的个数，来构成整数$Z$的集合。这道题肯定是会有解的，因为最坏情况下，我们把区间$[1,50001]$中的所有数都选择了，那么此时集合$Z$就有50001个元素，因此一定是有解的。那么这个解该怎么表示呢？由于我们不知道具体要选出多少个数，但是我们知道范围上限是50001，也就是$S[50001]$表示的是从区间$[1,50001]$中选出的$x$的最少的个数。因此，我们真正要求解的就是$S[50001]_{min}$</p>
<p>那么这题该怎么用差分约束呢？我们需要根据思路和题目描述自己来找出差分约束的条件：</p>
<ul>
<li>$S_i\geq S_{i-1}，1\leq i\leq 50001$，为什么呢？因为$S_i$表示从区间$[1,i]$中选出的$x$的个数，而$S_{i-1}$表示从区间$[1,i-1]$中选出的$x$的个数，因此$S_i$必定是要$\geq S_{i-1}$的，由定义出发就可以知道</li>
<li>$S_i-S_{i-1}\leq 1$，为什么呢？因为$S_i$表示从区间$[1,i]$中选出的$x$的个数，而$S_{i-1}$表示从区间$[1,i-1]$中选出的$x$的个数，那么$S_i-S_{i-1}$就表示第$i$个数，即整数$i$它被选的个数，由于整数$i$要么没有，如果有的话则最多只会有一个，因此由含义就可以知道选出来的第$i$个数，它被选的个数最多为1</li>
<li>由题目描述”区间$[a,b]$中最少要有$c$个数，可推知：$S_b-S_{a-1}\geq c$</li>
</ul>
<p>由于想要求的是变量$S[50001]$的最小值，运用差分约束，那么就需要跑最长路。将上面三个限制条件重新整理一下：</p>
<ul>
<li>$S_i\geq S_{i-1}+0$，那么就是从节点$S_{i-1}$向节点$S_i$连一条权值为0的边</li>
<li>$S_{i-1}\geq S_i-1$，那么就是从节点$S_{i}$向节点$S_{i-1}$连一条权值为-1的边</li>
<li>$S_b\geq S_{a-1}+c$，那么就是从节点$S_{a-1}$向节点$S_b$连一条权值为$c$的边</li>
</ul>
<p>但是呢，我们还需要思考一下，是否满足差分约束的条件：<strong>从源点出发，是否一定可以走到所有的边</strong>，这是差分约束正确性的前提条件。根据第一个约束条件可知，从$S_{i-1}$节点可以走到节点$S_i$，因此可以从$S_0$走到$S_1$，$S_1$走到$S_2$，$\cdots$，从$S_{50000}$走到$S_{50001}$，因此，从源点出发，是可以走到所有的边的</p>
<blockquote>
<p>问题：为什么这里的边数要开3倍呢？</p>
<p>由第一、二个约束条件可知，$S_{i-1}$和$S_{i}$之间都有边，即双向边，由第三个约束条件可知，则还会连出一条边，因此会有3条边。</p>
</blockquote>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">50010</span>,M=<span class="number">150010</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],w[M],idx;</span><br><span class="line"><span class="comment">//dist[i]表示从起点到节点i的最长距离</span></span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="comment">//循环队列</span></span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"><span class="comment">//判断一个节点是否已经入队了</span></span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    w[idx]=c;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里一定有解，因此并不需要判断是否存在负环了</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//求最长路,则初始化为负无穷</span></span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">-0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">1</span>;</span><br><span class="line">    dist[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    st[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(hh!=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//取出队头元素</span></span><br><span class="line">        <span class="keyword">int</span> t=q[hh++];</span><br><span class="line">        <span class="comment">//循环队列满了</span></span><br><span class="line">        <span class="keyword">if</span>(hh==N)</span><br><span class="line">            hh=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//节点t出队</span></span><br><span class="line">        st[t]=<span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//遍历节点t的所有邻接点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];<span class="comment">//t的邻接点编号j</span></span><br><span class="line">            <span class="keyword">if</span>(dist[j]&lt;dist[t]+w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//通过节点t来更新节点j到起到的最长距离</span></span><br><span class="line">                dist[j]=dist[t]+w[i];</span><br><span class="line">                <span class="comment">//如果节点j还没有入队</span></span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q[tt++]=j;<span class="comment">//节点j入队</span></span><br><span class="line">                    <span class="comment">//队尾指针走到了末尾,则重新回到队头</span></span><br><span class="line">                    <span class="keyword">if</span>(tt==N)</span><br><span class="line">                        tt=<span class="number">0</span>;</span><br><span class="line">                    <span class="comment">//标记节点j已经入队了</span></span><br><span class="line">                    st[j]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化表头为-1</span></span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//给第一、二个约束条件建图</span></span><br><span class="line">        <span class="built_in">add</span>(i<span class="number">-1</span>,i,<span class="number">0</span>);   </span><br><span class="line">        <span class="built_in">add</span>(i,i<span class="number">-1</span>,<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        <span class="comment">//记得向右平移一位</span></span><br><span class="line">        a++,b++;</span><br><span class="line">        <span class="built_in">add</span>(a<span class="number">-1</span>,b,c);   <span class="comment">//给第三个约束条件建图</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//跑以便spfa求出每个节点到起点的最长路</span></span><br><span class="line">    <span class="built_in">spfa</span>();</span><br><span class="line">    <span class="comment">//dist[50001]表示节点S(50001)到起点的最长距离,也就是题目中想要求的最小值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dist[<span class="number">50001</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title>糖果</title>
    <url>/2021/07/09/Algorithm-Improvement/Chapter3---Gragh-Theory/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/%E7%B3%96%E6%9E%9C/</url>
    <content><![CDATA[<h1 id="糖果"><a href="#糖果" class="headerlink" title="糖果"></a>糖果</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://gitee.com/linmacos/blog-image/raw/master/img/20210709201853.png" alt="image-20210709201852949"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>从题目描述中可知，这道题主要是要运用差分约束来求解。求至少需要准备多少个糖果，也就是求变量$a_i$的最小值，那么也就是需要跑最长路。</p>
<ul>
<li><p>根据题目描述如果$X=1$，则$A=B$，即有$A\geq B+0$，$B\geq A+0$ 。因此需要从节点$B$向节点$A$连一条权值为0的边，从节点$A$向节点$B$连一条权值为0的边</p>
</li>
<li><p>根据题目描述如果$X=2$，则$B\geq A+1$，因此从节点$A$向节点$B$连一条权值为1的边</p>
</li>
<li><p>根据题目描述如果$X=3$，则$A\geq B+0$，因此从节点$B$向节点$A$连一条权值为0的边</p>
</li>
<li><p>根据题目描述如果$X=4$，则$A\geq B+1$，因此从节点$B$向节点$A$连一条权值为1的边</p>
</li>
<li><p>根据题目描述如果$X=5$，则$B\geq A+0$，因此从节点$A$向节点$B$连一条权值为0的边</p>
</li>
<li><p>同时，由题干”要求每个小朋友都要分到苹果“，因此可以知道$a_i&gt;0$，即$a_i\geq 1$，那么可以添加一个超级源点$a_0$，$a_0$为0。那么$a_i+a_0\geq a_0+1$，即$a_i\geq a_0+1$，因此从超级源点$a_0$向节点$a_i$连一条权值为1的边</p>
</li>
</ul>
<p>注意，当我们用差分约束时，要考虑是否满足“<strong>从源点出发，能够到达所有边</strong>”这个条件。从$a_i\geq a_0+1$可知，可以从源点$0$号节点到达任意的节点$i$，既然可以从源点出发，到达任意节点$i$，那么也就是说，可以到达所有边，因此满足了前提条件。但是要注意，如果知道了从源点出发能够到达所有边，那么则不一定能推出可以到达所有节点，可以有可能某个节点它是孤立的，而剩余的所有节点（含有源点）是连通的。</p>
<ul>
<li>一般来说，如果已知$a_i\geq a_0+c$，那么就说明需要额外建立一个超级源点，并且从超级源点出发能够到达所有边</li>
<li>但是如果已知$a_i\geq a_{i-1}+c$，则不能说明从源点出发能到达所有边。因此也是需要添加超级源点。这样才能使得从超级源点出发能够到达所有边</li>
</ul>
<blockquote>
<p>问题：这里为什么是用栈而不是用循环队列呢？</p>
<p>对于spfa判负环，一般是对STL中的queue或者是手写循环队列。但是这一题比较玄学，用栈竟然是一种优化…</p>
<p>因为队列下标是递增的，进队次数可能会很多，所以访问到的下标可能很大。但栈不管插入多少次，最多只会用前n个位置。</p>
<p>这个优化不太稳定，比较玄学。优化大致上基于如下想法：如果存在一个环，那么用栈来搜索时，会按照深度优先的顺序，那么很快就会沿着环找到起点。</p>
</blockquote>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//这里的边的数目要开3倍,是因为比如点A-&gt;点B,点B-&gt;点A,同时还有超级源点0-&gt;点B</span></span><br><span class="line"><span class="comment">//因此对于点B来说,就有3条边</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],w[M],idx;</span><br><span class="line"><span class="comment">//注意数据范围可能会爆int</span></span><br><span class="line">LL dist[N];</span><br><span class="line"><span class="comment">//数组模拟栈,用来存储spfa算法中入栈的节点</span></span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"><span class="comment">//用来记录从起点到某个点所经过的边的个数</span></span><br><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line"><span class="comment">//判断某个点是否入栈</span></span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    w[idx]=c;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//spfa判负环</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//最长路,因此需要设置为负无穷大</span></span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">-0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="comment">//超级源点到自身距离为0</span></span><br><span class="line">    dist[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//超级源点0号节点入栈</span></span><br><span class="line">    q[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//标记超级源点0号节点入栈</span></span><br><span class="line">    st[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(hh!=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//取出栈顶元素</span></span><br><span class="line">        <span class="keyword">int</span> t=q[--tt];</span><br><span class="line">        <span class="comment">//标记栈顶元素这个节点已经出栈</span></span><br><span class="line">        st[t]=<span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//遍历栈顶元素t的所有邻接点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];<span class="comment">//取出邻接节点j</span></span><br><span class="line">            <span class="comment">//最长路的松弛条件：dist[j]&lt;dist[t]+w[i]</span></span><br><span class="line">            <span class="keyword">if</span>(dist[j]&lt;dist[t]+w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//更新节点j的最短距离</span></span><br><span class="line">                dist[j]=dist[t]+w[i];</span><br><span class="line">                <span class="comment">//从起点到节点j经过了cnt[t]+1条边</span></span><br><span class="line">                cnt[j]=cnt[t]+<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//由于我们建立的图中有超级源点0号节点+n个点=n+1个节点</span></span><br><span class="line">                <span class="comment">//但是如果但cnt[j]&gt;=n+1时,即从起点到节点j经过了n+1条边,则说明有(n+1)+1=n+2个节点</span></span><br><span class="line">                <span class="comment">//这与图中的n+1个节点相矛盾,因此由抽屉原理,知必存在负环</span></span><br><span class="line">                <span class="keyword">if</span>(cnt[j]&gt;=n+<span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//如果j这个节点还没有入栈</span></span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q[tt++]=j;<span class="comment">//将节点j入栈</span></span><br><span class="line">                    st[j]=<span class="literal">true</span>;<span class="comment">//标记节点j已经入栈了</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则,说明不存在负环</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//表头初始化为-1</span></span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x,a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;a,&amp;b);</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">add</span>(b,a,<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">add</span>(a,b,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">2</span>)</span><br><span class="line">            <span class="built_in">add</span>(a,b,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">3</span>)</span><br><span class="line">            <span class="built_in">add</span>(b,a,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">4</span>)</span><br><span class="line">            <span class="built_in">add</span>(b,a,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">add</span>(a,b,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//由于我们添加了超级源点0,因此从0号节点到其他的各个节点i都要建一条边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">add</span>(<span class="number">0</span>,i,<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//存在负环,则差分约束系统无解</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">spfa</span>())</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="comment">//不存在负环,则差分约束系统有解</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        LL res=<span class="number">0</span>;   <span class="comment">//记录最终答案</span></span><br><span class="line">        <span class="comment">//dist[i]表示从超级源点到节点i的最长路,也就是题目中每个小朋友应该在限制要求下分得的糖果</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            res+=dist[i];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title>差分约束算法</title>
    <url>/2021/07/11/Algorithm-Improvement/Chapter3---Gragh-Theory/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="差分约束系统"><a href="#差分约束系统" class="headerlink" title="差分约束系统"></a>差分约束系统</h1><hr>
<p>差分约束系统是一种特殊的$N$元一次不等式组。它包含$N$个变量$X_1$~$X_N$以及$M$个约束条件，每个约束条件都是由两个变量做差构成的，形如$X_i-X_j\leq c_k$，其中$c_k$是常数（可以是非负数，也可以是负数），$1\leq i,j\leq N,1\leq k\leq M$。我们要解决的问题就是：求一组解$X_1=a_1,X_2=a_2,\cdots,X_N=a_N$，即解$X=(a_1,a_2,\cdots,a_N)$使得所有约束条件都能得到满足。</p>
<p>差分约束系统的每个约束条件$X_i-X_j\leq c_k$可以变形为$X_i\leq X_j+c_k$，这与单源最短路径问题中的三角不等式$dist[y]\leq dist[x]+z$非常相似，注意这个式子是更新过后的。因此，我们可以把每个变量$X_i$看作是有向图中的一个节点$i$，对于每个约束条件$X_i-X_j\leq c_k$，从节点$j$向节点$i$连一条长度为$c_k$的有向边。</p>
<p><strong>引理：</strong></p>
<p>设$X=(x_1,x_2,\cdots,x_n)$是一个差分约束系统的一个解，$d$为任意常数，那么$X+d=(x_1+d,x_2+d,\cdots,x_n+d)$也是该系统的解。</p>
<p>证明：对于每个$x_i$和$x_j$，有$(x_j+d)-(x_i+d)=x_j-x_i$。因此，若$X$是这个差分约束系统的一个解，那么$X+d$也是这个系统的解</p>
<p>例如：</p>
<ul>
<li>$x_1-x_2\leq 0$</li>
<li>$x_1-x_5\leq -1$</li>
<li>$x_2-x_5\leq 1$</li>
<li>$x_3-x_1\leq 5$</li>
<li>$x_4-x_1\leq 4$</li>
<li>$x_4-x_3\leq -1$</li>
<li>$x_5-x_3\leq -3$</li>
<li>$x_5-x_4\leq -3$</li>
</ul>
<p>该问题的一个解为$X=(-5,-3,0,-1,-4)$，令一个解为$X’=(0,2,5,4,1)$，这两个解是有联系的，$X’$中的每个元素比$X$中的相应元素大5</p>
<p>这也正说明了，如果$X$是一个差分约束系统的解，那么$X+d$也是这个系统的解</p>
<p>假设$\forall i,X_i\leq c$，然后再增加一个超级源点0号节点，令$X_0=0$，令$d=-X_0$，等式两边同时加上$d$，可得$X_i-X_0\leq c-X_0$，即$X_i-X_0\leq c$。这样一来，就多了$N$个形如$X_i-X_0\leq 0$的约束条件，应该从节点0向每个节点$i$连一条长度为0的有向边。</p>
<hr>
<h3 id="约束图"><a href="#约束图" class="headerlink" title="约束图"></a>约束图</h3><p>对于$n$个变量，$m$个约束条件来说，其实就是对应于图论中的$n$个节点，$m$条边。对于$i=1,2,\cdots,n$，图中的每一个顶点$v_i$对应着$n$个未知量中的一个$x_i$，图中的每个有向边对应着关于两个未知量的$m$个不等式的其中一个。</p>
<p>对于一个差分约束系统来说，相应的约束图是一个带权有向图$G=(V,E)$，其中$V=${$v_0,v_1,\cdots,v_n$}，而且$E=${$(v_i,v_j):x_j-x_i\leq b_k$}$\bigcup$ {$(v_0,v_1),(v_0,v_2),\cdots,(v_0,v_n)$}</p>
<p>这里引入超级源点$v_0$是为了保证其他每个顶点$v_1,v_2,\cdots,v_n$均从$v_0$可达。因此，顶点集合$V$由对应于每个未知量$x_i$的顶点$v_i$和附加的顶点$v_0$所组成。边的集合$E$由对应于每个差分约束条件的边与对应于每个未知量$x_i$的边$(v_0,v_i)$所构成。如果$x_j-x_i\leq b_k$是一个差分约束，则边$(v_i,v_j)$的权$w(v_i,v_j)=b_k$。从超级源点$v_0$出发的每条边的权值均为0。</p>
<p>约束图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210707093851.png" alt="image-20210707093808678"></p>
<hr>
<h3 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h3><p>给定一个差分约束系统，设$G=(V,E)$为其相应的约束图。如果$G$不包含负权回路(即负环)，那么</p>
<p>$X=(\delta (v_0,v_1),\delta (v_0,v_2),\delta (v_0,v_3),\cdots,\delta (v_0,v_n))$</p>
<p>是此系统的一个可行解。当且仅当$G$中存在负环时，该系统不存在可行解。</p>
<p>上式中$\delta(v_0,v_1)$表示超级源点$v_0$到节点$v_1$的真实的最短距离，其他同理。跑一边最短路算法后得到的$dist[v_1]$其实就是$\delta(v_0,v_1)$</p>
<p><strong>证明：</strong></p>
<ul>
<li><p>首先来证明，如果$G$中不存在负环时，那么可以求出一个可行解。考察任意边$(v_i,v_j)\in E$，由三角不等式$\delta (v_0,v_j)\leq \delta (v_0,v_i)+w(v_i,v_j)$，即$\delta (v_0,v_j)-\delta (v_0,v_i)\leq w(v_i,v_j)$。因此，设$x_i=\delta (v_0,v_i),x_j=\delta(v_0,v_j)$，带入上式子可知满足对应边$(v_i,v_j)$的差分约束$x_j-x_i\leq w(v_i,v_j)$</p>
</li>
<li><p>接下来再来证明，如果$G$中存在负环，那么差分约束系统不存在可行解。设负权回路为$c=$&lt;$v_1,v_2,\cdots,v_k$&gt;，其中$v_1=v_k$（因为节点$v_0$没有入边，所以它不可能再回路$c$上）。回路$c$对应着如下的差分约束：</p>
<ul>
<li>$x_2-x_1\leq w(v_1,v_2)$</li>
<li>$x_3-x_2\leq w(v_2,v_3)$</li>
<li>$\cdots $</li>
<li>$x_k-x_{k-1}\leq w(v_{k-1},v_k)$</li>
<li>$x_1-x_k\leq w(v_k,v_1)$</li>
</ul>
<p>假设存在满足$k$个不等式的一个解$X$，那么也满足上述$k$个不等式相加所得到的不等式。如果把这些不等式相加，就会发现每个变量$x_i$的正负项相互抵消了，结果左边项和为0，而右边项和为$w(c)$，因此有$0\leq w(c)$。但是由于$c$是一个负权回路，因此有$w(c)&lt;0$，因此得到矛盾$0\leq w(c)&lt;0$，由此得证</p>
</li>
</ul>
<hr>
<p>求不等式组的可行解：</p>
<p>源点需要满足的条件：<strong>从源点出发，一定可以走到所有边</strong></p>
<p>步骤：</p>
<ul>
<li>先将每个不等式$x_i\leq x_j+c_k$，转化为一条从$x_j$走到$x_i$，长度为$c_k$的一条边</li>
<li>找到一个超级源点，使得该源点一定可以遍历到所有边</li>
<li>从源点求一边单源最短路<ul>
<li>如果存在负环，则原不等式组一定无解</li>
<li>如果不存在负环，则$X=(dist[v_1],dist[v_2],\cdots,dist[v_n])$的一个可行解</li>
</ul>
</li>
</ul>
<p>在某些题目中，约束条件形如$X_i-X_j\geq c_k$，我们仍然可以从$j$到$i$连一条长度为$c_k$的有向边，只不过现在应该要计算单源最长路，若图中存在正环则无解。当然，我们也可以把约束条件转换为$X_j-X_i\leq -c_k$，再按照单源最短路进行计算</p>
<hr>
<h3 id="变量的最大值和最小值"><a href="#变量的最大值和最小值" class="headerlink" title="变量的最大值和最小值"></a>变量的最大值和最小值</h3><p>对于给定的一组不等式关系，如何求出每个变量的最大值或者最小值呢？</p>
<blockquote>
<p>什么是最大值或最小值？</p>
<p>这里的意思是说，比如你求出了一个解$X=(x_1,x_2,\cdots,x_n)$，那么$X’=(x_1+d,x_2+d,\cdots,x_n+d)$也是一个解，$X’’=(x_1+2d,x_2+2d,\cdots,x_3+3d)$也是一个解，那么我想知道某个变量$x_i$的最大值，那么到底是取$x_i$还是$x_i+d$还是$x_i+2d$呢？同理，求某个变量$x_i$的最小值也是一样的含义。</p>
</blockquote>
<p>结论：</p>
<ul>
<li>如果求的是最小值，那么应该求单源最长路</li>
<li>如果求的是最大值，那么应该求单源最短路</li>
</ul>
<p><strong>证明：</strong></p>
<p>以求$x_i$的最大值为例：</p>
<p>求所有从$x_i$出发，构成的多个形如如下的不等式链：</p>
<p>$x_i\leq x_j+c_m\leq x_k+c_m+c_n\leq \cdots \leq x_0+c_0+c_4+\cdots +c_n+c_m$，其中$x_0=0,c_0=0$，令$F=$$x_0+c_0+c_4+\cdots +c_n+c_m$</p>
<p>那么$x_i$的最大值，要注意$F$可能多很多个，因此，我们取$F$中最小的那个值，就是$x_i$的最大值</p>
<p>例如$x_i\leq 5,x_i\leq 7,x_i\leq 9$，那么$x_i$的最大值为5。假设$x_i$取最大值为9，那么就不满足$x_i\leq 5$和$x_i\leq 7$了。</p>
<p>把上述转换成图论的问题，其实就是求$dist[i]$的最小值（因为$F$表示的是从起点出发，到达某个点的距离。那么求$F$的最小值，其实就是求单源最短路），那么就可以用最短路来求解。</p>
<p>以求$x_i$的最小值为例：</p>
<p>求所有从$x_i$出发，构成的多个形如如下的不等式链：</p>
<p>$x_i\geq x_j+c_m\geq x_k+c_m+c_n\geq \cdots \geq x_0+c_0+c_4+\cdots +c_n+c_m$，其中$x_0=0,c_0=0$，令$F=$$x_0+c_0+c_4+\cdots +c_n+c_m$</p>
<p>那么$x_i$的最小值，要注意$F$可能多很多个，因此，我们取$F$中最大的那个值，就是$x_i$的最小值</p>
<p>例如$x_i\geq 5,x_i\geq 7,x_i\geq 9$，那么$x_i$的最大值为9。假设$x_i$取最小值为5，那么就不满足$x_i\geq 7$和$x_i\geq 9$了。</p>
<p>下面举个图例：</p>
<ul>
<li>$x_2-x_1\leq c_1$</li>
<li>$x_3-x_2\leq c_2$</li>
<li>$x_3-x_1\leq c_3$</li>
</ul>
<p>那么，我们可以求出这样的：</p>
<ul>
<li>$x_3\leq x_1+c_3$</li>
<li>$x_3\leq x_1+c_1+c_2$</li>
</ul>
<p>可以看出，约束变量$x_3$的有两个条件，如果画到图中，就对应于有2条路径。那么当我们要求$x_3$的最大值时，取的肯定是$x_1+c_3$和$x_1+c_1+c_2$中的最小值，这样才能保证满足这两个约束条件，进而满足题目给定的所有原始的约束条件。</p>
<p>我们添加超级源点$s$即$v_0$，那么有$x_1-x_0\leq c_0$，因此有如下：</p>
<ul>
<li>$x_3\leq x_0+c_0+c_3$</li>
<li>$x_3\leq x_0+c_0+c_1+c_2$</li>
</ul>
<p>其中$x_0=0,c_0=0$</p>
<p>解释一样$x_0+c_0+c_3$的含义：它表示从源点$v_0$到达节点$v_3$所走过的路径上的权值之和。$x_0+c_0+c_1+c_2$也是一样的含义。</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210707094207.png" alt=""></p>
<p>对应有两条路径：</p>
<ul>
<li>$v_0\implies v_1\implies v_3$，从源点$v_0$走到节点$v_3$，所走过的路径之和为$c_0+c_3$</li>
<li>$v_0\implies v_1\implies v_2\implies v_3$，从源点$v_0$走到节点$v_3$，所走过的路径之和为$c_0+c_1+c_2$</li>
<li>可以发现，既然我们知道了等式右边的式子含义，其实就是求从源点出发到达某个节点的距离，由于可能存在多条路径，因此有多个值，那么我们只需要根据单源最短路径算法，就可以求出最小的那个值了，设为$F_{min}$。因此，如果想要求某个变量$x_i$的最大值，那么就要满足$Max(x_i)\leq F_{min}$。这也就是说，求变量$x_i$的最大值，等价于跑一下单源最短路，求出最短路径的权值之和</li>
</ul>
<p>因此，相应的就可以知道，要求$x_i$的最小值，其实就是跑一下单源最长路，求出最长路径的权值之和。</p>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>$x_i\geq x_j+c$，则从节点$j$向节点$i$连一条长度为$c$的边，要求变量$x_i$的最小值，则跑一下最长路即可</li>
<li>$x_i\leq x_j+c$，则从节点$j$向节点$i$连一条长度为$c$的边，要求变量$x_i$的最大值，则跑一下最短路即可</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title>排队布局</title>
    <url>/2021/07/10/Algorithm-Improvement/Chapter3---Gragh-Theory/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/%E6%8E%92%E9%98%9F%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h1 id="排队布局"><a href="#排队布局" class="headerlink" title="排队布局"></a>排队布局</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210710145142.png" alt="image-20210710145142511"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>这题是需要用到差分约束。对于差分约束，我们最主要的是根据题目描述，找出题目中的所有不等式关系，我们设$x_i$表示第$i$头牛的位置：</p>
<ul>
<li>根据“一些奶牛相互间存有好感，它们希望两者之间的距离不超过一个给定的数 L”，可以得到奶牛$a$和奶牛$b$之间至多相隔距离$L$，即有$x_b-x_a\leq L$</li>
<li>根据“一些奶牛相互间非常反感，它们希望两者间的距离不小于一个给定的数 D”，可以得到奶牛$a$和奶牛$b$之间至少相隔距离$D$，即有$x_b-x_a\geq D$</li>
<li>根据“奶牛排在队伍中的顺序和它们的编号是相同的，且同一位置上可以站多头牛”，可以得到$x_{i+1}\geq x_i$</li>
</ul>
<p>那么，我们再来观察题目要求的是$1$号奶牛和$N$号奶牛之间的最大距离，即要求变量$x_n$的最大值。那么，由差分约束可知，需要跑单源最短路，求出最短距离。</p>
<p>但是，我们要考虑，是否满足 <strong>从源点出发，可以到达所有边</strong>这个条件。由于从上面的三个不等式中，并不能看出，从某个点出发，一定能走完所有边。因此，我们就需要添加一个虚拟源点了，所以我们添加超级源点$x_0$，然后从它出发，就可以到达所有边了，那么就可以使用差分约束的方法了。</p>
<p>需要找一个超级源点（记超级源点为$x_0$），发现这里求的距离都是牛之间的相对距离，所以联想到令$x_0=0$，又因为求的是形如$x_i\leq x_j+c$的不等式，所以将所有点放在超级源点$0$号点的左侧就可以得出 $x_i\leq x_0+0$的不等式,这样从源点出发可以遍历所有的点，那么就可以遍历到所有的边。</p>
<p>因此，我们重新整理一下，上面的三个式子，统一写成$\leq$的形式（因为这是差分约束中求变量最大值的写法）：</p>
<ul>
<li>$x_b\leq x_a+L$，则从节点$x_a$向节点$x_b$连一条长度为$L$的边</li>
<li>$x_a\leq x_b-D$，则从节点$x_b$向节点$x_a$连一条长度为$-D$的边</li>
<li>$x_{i}\leq x_{i+1}+0$，则从节点$x_{i+1}$向节点$x_i$连一条长度为0的边</li>
</ul>
<p>对于建立虚拟源点问题，有两种方法：</p>
<ul>
<li>真正开辟一个超级源点0号点，那么此时建立好图后，就有$n+1$个节点</li>
<li>并不需要真正开辟一个虚拟源点，我们只需要刚开始的时候就把所有节点都放入队列中就行了，这种情况就等效于建立一个超级源点了（注意此时仍是$n$个节点，因为并没有把超级源点0号节点建立出来）。如何理解呢？<ul>
<li>我们这么想：对于spfa算法来说，假设我们真正设立了一个超级源点，这个源点连向其余的$n$个节点。那么第一次扩展时，就会把超级源点的所有邻接点都加入队列q中，然后更新这$n$个节点到超级源点的距离为0。也就是说，如果我们真的建立了一个超级源点，那么第一次扩展时，就会把它的所有邻接点（$n$个顶点）都更新最短距离为0。那么这不就等效于 《我们不用真的开辟一个超级源点，而是一开始就把这$n$个顶点都放入spfa算法的队列q中，然后初始化这$n$个点的距离为$0$》嘛？只不过这里并不需要第一次扩展而已啦，想法都是一样的，只不过实现方法有所不同而已</li>
</ul>
</li>
</ul>
<p>下面使用两种方法来分别实现以上的两种想法</p>
<p>然后这一题，有三个问题：</p>
<ul>
<li>对于第一个问题，我们可以跑一遍spfa算法求负环，如果存在负环，那么在说明不存在满足要求的方案，输出-1即可</li>
<li>对于第二个问题，想要求的是“1号牛和n号牛的最小距离是多少？即求$x_n-x_1$”，因此我们可以让1号节点称为起点，即设$x_1=0$，然后用spfa算法求出1号节点到其他各点的最短距离，最终求出$dist[n]$，如果$dist[n]\geq INF$则说明1号奶牛到$n$号奶牛之间不存在约束关系，距离可以无限远，输出-2。</li>
<li>对于第三个问题，如果求出的$dist[n]&lt;INF$，那么就直接输出此时的$dist[n]$即可</li>
</ul>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><strong>算法一：真正开辟一个超级源点0号节点</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>,M=<span class="number">3e4</span>+<span class="number">10</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n,m1,m2;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],w[M],idx;</span><br><span class="line"><span class="comment">//记录每个点到起点的最短距离</span></span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="comment">//spfa算法的循环队列</span></span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"><span class="comment">//记录每个点到起点一共经过了多少条边,用来判断负环</span></span><br><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line"><span class="comment">//用来判断某个节点是否已经放进q队列中</span></span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="comment">//建图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    w[idx]=c;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//spfa算法进行 判断负环和求出最短距离</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span> cnt);</span><br><span class="line">    <span class="built_in">memset</span>(st,<span class="number">0</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">1</span>;</span><br><span class="line">    dist[s]=<span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>]=s;</span><br><span class="line">    st[s]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(hh!=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//取出队头元素</span></span><br><span class="line">        <span class="keyword">int</span> t=q[hh++];</span><br><span class="line">        <span class="comment">//队满</span></span><br><span class="line">        <span class="keyword">if</span>(hh==N)</span><br><span class="line">        hh=<span class="number">0</span>;</span><br><span class="line">        st[t]=<span class="literal">false</span>;<span class="comment">//队头元素出队</span></span><br><span class="line">        <span class="comment">//遍历t的所有邻接点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];<span class="comment">//取出t的邻接点j</span></span><br><span class="line">            <span class="comment">//松弛</span></span><br><span class="line">            <span class="keyword">if</span>(dist[j]&gt;dist[t]+w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j]=dist[t]+w[i];</span><br><span class="line">                <span class="comment">//记录j到起点所走过的边数</span></span><br><span class="line">                cnt[j]=cnt[t]+<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//有n个点,如果此时节点j到起点所经历的边数&gt;=n,则说明有n+1个顶点,则有负环</span></span><br><span class="line">                <span class="keyword">if</span>(cnt[j]&gt;=n)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//如果j还没有放入队列q中</span></span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q[tt++]=j;  <span class="comment">//把j放入队列q中</span></span><br><span class="line">                    <span class="comment">//如果走到队尾</span></span><br><span class="line">                    <span class="keyword">if</span>(tt==N)</span><br><span class="line">                    tt=<span class="number">0</span>;</span><br><span class="line">                    st[j]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//说明不存在负环</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化表头</span></span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m1,&amp;m2);</span><br><span class="line">    <span class="comment">//建立了一个真正的超级源点,因此需要从超级源点0号点到其他n个节点连一条长度为0的边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="built_in">add</span>(<span class="number">0</span>,i,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//第一个约束条件,节点i+1向节点i连一条长度为0的边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    <span class="built_in">add</span>(i+<span class="number">1</span>,i,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(m1--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,L;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;L);</span><br><span class="line">        <span class="comment">//保证b要&gt;=a</span></span><br><span class="line">        <span class="keyword">if</span>(a&gt;b)</span><br><span class="line">        <span class="built_in">swap</span>(a,b);</span><br><span class="line">        <span class="comment">//第二个约束条件,节点a向节点b连一条长度为L的边</span></span><br><span class="line">        <span class="built_in">add</span>(a,b,L);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m2--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,D;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;D);</span><br><span class="line">        <span class="comment">//保证b要&gt;=a</span></span><br><span class="line">        <span class="keyword">if</span>(a&gt;b)</span><br><span class="line">        <span class="built_in">swap</span>(a,b);</span><br><span class="line">        <span class="comment">//第三个约束条件,节点b向节点a连一条长度为-D的边</span></span><br><span class="line">        <span class="built_in">add</span>(b,a,-D);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//存在负环</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">spfa</span>(<span class="number">0</span>))</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把1号节点当作起点</span></span><br><span class="line">        <span class="built_in">spfa</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//说明1号奶牛到N号奶牛的距离可以任意大</span></span><br><span class="line">        <span class="keyword">if</span>(dist[n]==INF)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;-2&quot;</span>);</span><br><span class="line">        <span class="comment">//否则就输出1号奶牛到N号奶牛的最短距离</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dist[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>算法二：不需要开辟一个超级源点0号节点</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>,M=<span class="number">3e4</span>+<span class="number">10</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n,m1,m2;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],w[M],idx;</span><br><span class="line"><span class="comment">//记录每个点到起点的最短距离</span></span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="comment">//spfa算法的循环队列</span></span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"><span class="comment">//记录每个点到起点一共经过了多少条边,用来判断负环</span></span><br><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line"><span class="comment">//用来判断某个节点是否已经放进q队列中</span></span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="comment">//建图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    w[idx]=c;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//spfa算法进行 判断负环和求出最短距离</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span> cnt);</span><br><span class="line">    <span class="built_in">memset</span>(st,<span class="number">0</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//将这num个节点都加入队列中,并且每个节点的最短距离初始化为0,标记每个节点都放入q队列中了</span></span><br><span class="line">    <span class="comment">//那么就等效于开辟了一个超级源点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        q[tt++]=i;</span><br><span class="line">        dist[i]=<span class="number">0</span>;</span><br><span class="line">        st[i]=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(hh!=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//取出队头元素</span></span><br><span class="line">        <span class="keyword">int</span> t=q[hh++];</span><br><span class="line">        <span class="comment">//队满</span></span><br><span class="line">        <span class="keyword">if</span>(hh==N)</span><br><span class="line">        hh=<span class="number">0</span>;</span><br><span class="line">        st[t]=<span class="literal">false</span>;<span class="comment">//队头元素出队</span></span><br><span class="line">        <span class="comment">//遍历t的所有邻接点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];<span class="comment">//取出t的邻接点j</span></span><br><span class="line">            <span class="comment">//松弛</span></span><br><span class="line">            <span class="keyword">if</span>(dist[j]&gt;dist[t]+w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j]=dist[t]+w[i];</span><br><span class="line">                <span class="comment">//记录j到起点所走过的边数</span></span><br><span class="line">                cnt[j]=cnt[t]+<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//有n个点,如果此时节点j到起点所经历的边数&gt;=n,则说明有n+1个顶点,则有负环</span></span><br><span class="line">                <span class="keyword">if</span>(cnt[j]&gt;=n)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//如果j还没有放入队列q中</span></span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q[tt++]=j;  <span class="comment">//把j放入队列q中</span></span><br><span class="line">                    <span class="comment">//如果走到队尾</span></span><br><span class="line">                    <span class="keyword">if</span>(tt==N)</span><br><span class="line">                    tt=<span class="number">0</span>;</span><br><span class="line">                    st[j]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//说明不存在负环</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化表头</span></span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m1,&amp;m2);</span><br><span class="line">    <span class="comment">//第一个约束条件,节点i+1向节点i连一条长度为0的边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    <span class="built_in">add</span>(i+<span class="number">1</span>,i,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(m1--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,L;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;L);</span><br><span class="line">        <span class="comment">//保证b要&gt;=a</span></span><br><span class="line">        <span class="keyword">if</span>(a&gt;b)</span><br><span class="line">        <span class="built_in">swap</span>(a,b);</span><br><span class="line">        <span class="comment">//第二个约束条件,节点a向节点b连一条长度为L的边</span></span><br><span class="line">        <span class="built_in">add</span>(a,b,L);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m2--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,D;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;D);</span><br><span class="line">        <span class="comment">//保证b要&gt;=a</span></span><br><span class="line">        <span class="keyword">if</span>(a&gt;b)</span><br><span class="line">        <span class="built_in">swap</span>(a,b);</span><br><span class="line">        <span class="comment">//第三个约束条件,节点b向节点a连一条长度为-D的边</span></span><br><span class="line">        <span class="built_in">add</span>(b,a,-D);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//存在负环</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">spfa</span>(n))</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把1号节点当作起点</span></span><br><span class="line">        <span class="built_in">spfa</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//说明1号奶牛到N号奶牛的距离可以任意大</span></span><br><span class="line">        <span class="keyword">if</span>(dist[n]==INF)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;-2&quot;</span>);</span><br><span class="line">        <span class="comment">//否则就输出1号奶牛到N号奶牛的最短距离</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dist[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title>雇佣收银员</title>
    <url>/2021/07/10/Algorithm-Improvement/Chapter3---Gragh-Theory/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/%E9%9B%87%E4%BD%A3%E6%94%B6%E9%93%B6%E5%91%98/</url>
    <content><![CDATA[<h1 id="雇佣收银员"><a href="#雇佣收银员" class="headerlink" title="雇佣收银员"></a>雇佣收银员</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210710201724.png" alt="image-20210710201724728"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>这题需要用差分约束来求解，具体思路如下：</p>
<p>我们定义以下变量的含义：</p>
<ul>
<li><code>num[i]</code>表示在$t_i$时刻来应聘的人数</li>
<li><code>x[i]</code>表示在$t_i$时刻公司选择雇佣的人数</li>
<li><code>R[i]</code>表示在$t_i$时刻需要的员工的最小需求量</li>
<li><code>S[i]</code>表示满足能在$t_i$时刻上岗工作的公司已经聘用的员工总数。比如当$t_i=24h$时，$S_i=100$，则说明这100个人，它们的工作服务时间段是包括$t_i$的，即在$t_i$时刻他们在岗工作</li>
</ul>
<p>根据以上定义，我们再来梳理一下不等式的关系：</p>
<ul>
<li><p>$0\leq x_i\leq num[i]$，因为聘用的人数不可能大于来应该的人数，因此有$x_i\leq num[i]$，而且公司选择聘用的人数不可能为-1，要么都不聘用，因此有$x_i\geq 0$</p>
</li>
<li><p>$x_{i-7}+x_{i-6}+x_{i-5}+x_{i-4}+x_{i-3}+x_{i-2}+x_{i-1}+x_i\geq R_i$，即公司聘用的能够在$t_i$时刻处于工作服务状态的员工总数，应该$\geq$在$t_i$时刻最小需要的员工总数</p>
<blockquote>
<p> <strong>问题：如何理解$x_{i-7}+x_{i-6}+x_{i-5}+x_{i-4}+x_{i-3}+x_{i-2}+x_{i-1}+x_i$这个式子呢？</strong></p>
<p>由于题目说了，员工一定会连续工作8个小时，即每个员工的工作服务时常为$8h$。那么我们就想，哪些员工他们的工作服务时间段是包括$t_i$这个时刻的呢？如果包括，则说明他们在$t_i$这个时刻，一定可以上岗工作服务。因此$x_{i-7}+x_{i-6}+x_{i-5}+x_{i-4}+x_{i-3}+x_{i-2}+x_{i-1}+x_i$就表示能在$t_i$时刻上岗工作服务的员工总数，那么这个总数就应该要$\geq t_i$时刻需要的员工的最小需求量$R_i$。</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210710211018.png" alt="image-20210710211017955"></p>
</blockquote>
</li>
</ul>
<p>$x_{i-7}+x_{i-6}+x_{i-5}+x_{i-4}+x_{i-3}+x_{i-2}+x_{i-1}+x_i$这个是连加的形式，那么很容易想到用前缀和来表示，即用$S[i]$来表示，其中$1\leq i\leq 24$。由于前缀和需要用到$S[0]$，因此我们需要把时间都向右平移一个单位，即现在时间为$1,2,\cdots,24$而不是再是原来的$0,1,2,\cdots,23$了。</p>
<p>那么则会由如下的不等式关系：</p>
<ul>
<li>$0\leq x_i\leq num[i]$，用前缀和来代替，那么就是$0\leq S_i-S_{i-1}\leq num[i]$</li>
<li>$S_i\geq R_i$</li>
</ul>
<p>由于题目要求的是变量的最小值，那么就需要跑单源最长路，求出最长距离。因此把不等式关系都改写为$x_i\geq x_j+c$的形式：</p>
<ul>
<li>$S_i\geq S_{i-1}+0$</li>
<li>$S_{i-1}\geq S_i-num[i]$</li>
</ul>
<p>对于$S_i\geq R_i$要分类讨论，因为时间它是循环的，当到了24之后就会变为0，又重新开始了。</p>
<ul>
<li><p>当$i\geq 8$时，则有$S_i-S_{i-8}\geq R_i$，分析如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210710213044.png" alt="image-20210710213044097"></p>
</li>
<li><p>当$0&lt;i\leq 7$时，则要分为两部分了。一部分是$1$到$7$这个时间段，由于不足8h，因此说明需要向$24$(包括它)之前的借一些时间，这主要就是因为时间是循环的。那么会得到$S_i+(S_{24}-S_{i+16})\geq R[i]$分析如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210710214154.png" alt="image-20210710214002246"></p>
</li>
</ul>
<p>进一步梳理不等式关系：</p>
<ul>
<li>$S_i\geq S_{i-1}+0$</li>
<li>$S_{i-1}\geq S_i-num[i]$</li>
<li>当$i\geq 8$时，$S_i\geq S_{i-8}+R[i]$</li>
<li>当$0&lt;i\leq 7$时，$S_i\geq S_{i+16}-S_{24}+R[i]$</li>
</ul>
<p>但是我们发现第四个约束条件中，有三个变量，平时我们都是遇到两个变量。其实，我们可以把$S_{24}$当作常量。那么如何把它作为常量呢？由于题目说要求最少需要雇佣多少名收银员，那么其实也就是说要求出$S_{24}$是多少。由于题目说了$0\leq N\leq 1000$，因此最坏情况下是至少聘用了$1000$个人。那么我们可以依次从0开始枚举到1000，我们把枚举的这个值$i$其实就是$S_{24}$，每次枚举一个$i$，都去跑一下spfa，当第一次枚举到某个值时，它满足所有的约束条件，那么这个值就是我们要求的最小的$S_{24}$，找到第一个就直接break。</p>
<p>注意这里当我们枚举到某个$S_{24}=c$时，也要把它写成差分约束的形式，即$S_{24}\geq c$和$S_{24}\leq c$，建立一个超级源点$S_0$（为0），那么有$S_{24}\geq S_0+c$和$S_{0}\geq S_{24}-c$</p>
<p>因此，总结一下，总共有以下的约束条件：</p>
<ul>
<li>$S_i\geq S_{i-1}+0$</li>
<li>$S_{i-1}\geq S_i-num[i]$</li>
<li>当$i\geq 8$时，$S_i\geq S_{i-8}+R[i]$</li>
<li>当$0&lt;i\leq 7$时，$S_i\geq S_{i+16}-S_{24}+R[i]$</li>
<li>$S_{24}\geq S_0+c$</li>
<li>$S_{0}\geq S_{24}-c$</li>
</ul>
<p>由第一个约束条件$S_i\geq S_{i-1}+0$可知，设立一个超级源点0号节点，则可以从超级源点出发，0-&gt;1-&gt;2-&gt;$\cdots$-&gt;$24$，因此可以到达所有节点，那么一定可以到达所有边。所以，这里满足了 “<strong>从源点出发，能遍历到所有边</strong>”这个条件，因此可以用差分约束。</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">30</span>,M=<span class="number">100</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],w[M],idx;</span><br><span class="line"><span class="comment">//R[i]表示i时刻公司需要雇佣的最小的员工的需求量</span></span><br><span class="line"><span class="comment">//num[i]表示i时刻来应聘的员工的数量</span></span><br><span class="line"><span class="keyword">int</span> R[N],num[N];</span><br><span class="line"><span class="comment">//dist[i]表示i节点到起点的最长距离</span></span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="comment">//循环队列q来存储入队节点</span></span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"><span class="comment">//cnt[i]表示从起点到达节点i一共经过了多少条边</span></span><br><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line"><span class="comment">//判断某个节点是否已经加入了q队列中</span></span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="comment">//建图函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    w[idx]=c;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将约束条件建成图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化表头</span></span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    idx=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//S[24]=c,写成了两个约束条件</span></span><br><span class="line">    <span class="built_in">add</span>(<span class="number">0</span>,<span class="number">24</span>,c);</span><br><span class="line">    <span class="built_in">add</span>(<span class="number">24</span>,<span class="number">0</span>,-c);</span><br><span class="line">    <span class="comment">//当0&lt;i&lt;=7时,给这个约束条件建图</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">7</span>;i++)</span><br><span class="line">    <span class="built_in">add</span>(i+<span class="number">16</span>,i,R[i]-c);</span><br><span class="line">    <span class="comment">//当i&gt;=8时,给这个约束条件建图</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">8</span>;i&lt;=<span class="number">24</span>;i++)</span><br><span class="line">    <span class="built_in">add</span>(i<span class="number">-8</span>,i,R[i]);</span><br><span class="line">    <span class="comment">//给S[i]&gt;=S[i-1]+0和S[i-1]&gt;=S[i]-num[i]建图</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">24</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">add</span>(i<span class="number">-1</span>,i,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">add</span>(i,i<span class="number">-1</span>,-num[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//spfa算法用来  判断是否存在正环  和 求出最长距离</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//对于枚举的每一个S[24]都去建图</span></span><br><span class="line">    <span class="built_in">build</span>(c);</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">-0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">memset</span>(st,<span class="number">0</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span> cnt);</span><br><span class="line">    <span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//由于真正地建立了超级源点S[0]</span></span><br><span class="line">    dist[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    st[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(hh!=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=q[hh++];</span><br><span class="line">        <span class="keyword">if</span>(hh==N)</span><br><span class="line">        hh=<span class="number">0</span>;</span><br><span class="line">        st[t]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j]&lt;dist[t]+w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j]=dist[t]+w[i];</span><br><span class="line">                cnt[j]=cnt[t]+<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//本来1~24共有24个节点,但是建立了1个超级源点,因此总共25个节点</span></span><br><span class="line">                <span class="comment">//cnt[j]&gt;=25说明从超级源点到节点j经过了25条边,那么则有26个节点</span></span><br><span class="line">                <span class="comment">//这与实际的25个节点不符合,因此存在正环</span></span><br><span class="line">                <span class="keyword">if</span>(cnt[j]&gt;=<span class="number">25</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q[tt++]=j;</span><br><span class="line">                    <span class="keyword">if</span>(tt==N)</span><br><span class="line">                    tt=<span class="number">0</span>;</span><br><span class="line">                    st[j]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//说明不存在正环  且找到了最小的满足所有约束条件的S[24]</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">24</span>;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;R[i]);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="keyword">sizeof</span> num);</span><br><span class="line">        <span class="keyword">while</span>(n--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">            <span class="comment">//由于前缀和S[0]占用0这个位置,因此我们让时间都向右平移一位</span></span><br><span class="line">            t++;</span><br><span class="line">            num[t]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//用来判断是否有解</span></span><br><span class="line">        <span class="keyword">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">1000</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//枚举找到最小的满足所有约束条件的S[24]</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">spfa</span>(i))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">                flag=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//说明无解</span></span><br><span class="line">        <span class="keyword">if</span>(!flag)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;No Solution&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title>北极通讯网络</title>
    <url>/2021/07/25/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E6%89%A9%E5%B1%95%E5%BA%94%E7%94%A8/%E5%8C%97%E6%9E%81%E9%80%9A%E8%AE%AF%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="北极通讯网络"><a href="#北极通讯网络" class="headerlink" title="北极通讯网络"></a>北极通讯网络</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210725142226.png" alt="image-20210725142226728"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>抽象一下题意，其实题目是想要求：</p>
<p>找到一个最小的$d$值，使得在删除所有权值大于$d$的边后，所形成的连通块的个数不超过$k$</p>
<p>因为题目中说到“两座村庄之间的距离如果不超过$d$，就可以用该型号的无线电收发机直接通讯”，也就是说，那些距离不超过$d$的节点都是可以直接或者间接连通的，但是那些距离超过$d$的节点之间就不能通过无线电进行通信了，而需要借助卫星设备。</p>
<p>而且，我们发现一个事实：随着$d$值的不断递增，所形成的连通块的个数不断递减。</p>
<p>下面一个图示解释了这个原因：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210725143740.png" alt="image-20210725143740580"></p>
<p>一提到连通块和最小生成树，我们很容易想到Kruskal算法，回顾一下这个算法的流程，其实就是：</p>
<ul>
<li>将边权从小到大排序</li>
<li>依次从小到大扫描每一条边，设这条边的一个端点为$A$，另一个端点为$B$，那么也就是合并$A$所在连通块和$B$所在连通块</li>
</ul>
<p>我们发现第二步本质上就是在维护连通块的个数，而且我们知道Kruskal算法每次选择的边权都是不断递增的，而且随着边权的不断递增，就会不断合并连通块，即<strong>随着边权的递增，所得到的连通块个数不断递减</strong>。而这个性质不正好与我们上面提到的题目事实是完全相同的嘛。</p>
<p>也就是说，题目想要求的最小的距离$d$值，其实就是在Kruskal算法执行过程中的某个时刻，选择了某条边的权值，然后合并这条边后，使得连通块的个数是$k$。即距离$d$值其实就是边权。</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210725144429.png" alt="image-20210725144429219"></p>
<p>因此，我们就直接跑Kruskal算法，然后挑选一条边后，就将这条边的权值赋给$d$，当某一时刻，合并某一条边后，设这条边的权值为$w$，使得所形成的连通块的个数$\leq k$，那么此时的这个$w$就是$d$值的最小值了，直接break即可，不再进行选边操作了。</p>
<p>当然这一题也是可以用二分的，不过需要配合并查集算法：</p>
<p>我们设 性质为：<strong>删除所有边权大于$d$的边后，对所有边权$\leq d$的边进行并查集操作后，所形成的连通块的数量$\leq k$</strong></p>
<p>注意这里是浮点数的二分</p>
<ul>
<li>如果满足这个性质，则$r=mid$</li>
<li>如果不满足这个性质，则$l=mid$</li>
</ul>
<p>如下图解释：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210725155710.png" alt="image-20210725155710521"></p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>写法1：直接用Kruskal算法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//边数M最坏情况下是 无向完全图即n(n-1)/2</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">510</span>,M=N*N/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;PII;</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">double</span> w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge&amp; W)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w&lt;W.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"><span class="comment">//存储每个节点的坐标</span></span><br><span class="line">PII q[M];</span><br><span class="line"><span class="comment">//获取两个点之间的距离  把这个距离当作这两个节点之间的边权</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">get</span><span class="params">(PII A,PII B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dx=A.first-B.first;</span><br><span class="line">    <span class="keyword">int</span> dy=A.second-B.second;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(dx*dx+dy*dy);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x!=p[x])</span><br><span class="line">        p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt=n;  <span class="comment">//起初有n个独立的节点,也就是n个连通块</span></span><br><span class="line">    <span class="built_in">sort</span>(edges,edges+m);</span><br><span class="line">    <span class="comment">//注意这里初始化时是从0开始的 </span></span><br><span class="line">    <span class="comment">//因为我们用到的点是0~n-1而不是1~n</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        p[i]=i;</span><br><span class="line">    <span class="keyword">double</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="built_in">find</span>(edges[i].a);</span><br><span class="line">        <span class="keyword">int</span> b=<span class="built_in">find</span>(edges[i].b);</span><br><span class="line">        <span class="keyword">double</span> w=edges[i].w;</span><br><span class="line">        <span class="keyword">if</span>(a!=b)</span><br><span class="line">        &#123;</span><br><span class="line">            p[a]=b;</span><br><span class="line">            <span class="comment">//记录此时选的那条边的权值</span></span><br><span class="line">            res=w;</span><br><span class="line">            <span class="comment">//合并两个连通块了,因此连通块的数量-1</span></span><br><span class="line">            cnt--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果合并完这条边后,所形成的连通块的个数&lt;=k  那么选中的这条边其实就是最小的d值</span></span><br><span class="line">        <span class="comment">//那么就不需要再 选择后面的边了</span></span><br><span class="line">        <span class="keyword">if</span>(cnt&lt;=k)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="comment">//读入这n个村庄的坐标</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)	<span class="comment">//村庄编号从0到n-1而不是从1到n</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;q[i].first,&amp;q[i].second);</span><br><span class="line">    <span class="comment">//由于是无向边,因此是对称矩阵  那么我们只需要统计下三角的边就行了    </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">double</span> w=<span class="built_in">get</span>(q[i],q[j]);</span><br><span class="line">            edges[m++]=&#123;i,j,w&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> d=<span class="built_in">Kruskal</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>,d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写法2：二分+并查集</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">510</span>,M=N*N/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps=<span class="number">1e-4</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;PII;</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line">PII q[M];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">double</span> w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Edge &amp;W)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w&lt;W.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">get</span><span class="params">(PII A,PII B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dx=A.first-B.first;</span><br><span class="line">    <span class="keyword">int</span> dy=A.second-B.second;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(dx*dx+dy*dy);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x!=p[x])</span><br><span class="line">        p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断mid是否满足该性质：删除所有边权大于d的边后,对所有边权&lt;=d的边进行并查集操作后</span></span><br><span class="line"><span class="comment">//所形成的连通块的数量&lt;=k</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">double</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//注意这里初始化时是从0开始的 </span></span><br><span class="line">    <span class="comment">//因为我们用到的点是0~n-1而不是1~n</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) </span><br><span class="line">        p[i]=i;</span><br><span class="line">    <span class="comment">//idx记录的是第一个大于权值为mid的那条边所对应的数组下标    </span></span><br><span class="line">    <span class="keyword">int</span> idx;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> w=edges[i].w;</span><br><span class="line">        <span class="comment">//浮点数做差会有精度问题  应该需要加入精度比较</span></span><br><span class="line">        <span class="keyword">if</span>(w&gt;mid+eps)</span><br><span class="line">        &#123;</span><br><span class="line">            idx=i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;  <span class="comment">//用多少条边来连接不同的连通块</span></span><br><span class="line">    <span class="comment">//由于第idx条边是首个权值大于mid的边,因此[0,idx-1]这些边都是权值&lt;=mid的边</span></span><br><span class="line">    <span class="comment">//而我们现在就是要对这些权值&lt;=mid的边进行合并 然后求出连通块的个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;idx;i++)<span class="comment">//注意这里是[0,idx)也就是[0,idx-1]</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="built_in">find</span>(edges[i].a);</span><br><span class="line">        <span class="keyword">int</span> b=<span class="built_in">find</span>(edges[i].b);</span><br><span class="line">        <span class="keyword">if</span>(a!=b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//合并两个连通块需要耗费一条边</span></span><br><span class="line">            res++;</span><br><span class="line">            p[a]=b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//连通块的数目=总点数-耗费的连边数量</span></span><br><span class="line">    <span class="comment">//比如有u,v,w三个节点,起初是独立的三个连通块,耗费一条边连接u,v,那么u和v在同一个连通块中了,num=1;</span></span><br><span class="line">    <span class="comment">//耗费一条边连接(u,v),w,那么u,v,w在同一个连通块中了,num=2;最终只有一个连通块</span></span><br><span class="line">    <span class="comment">//因此连通块数量cnt=总点数n-耗费的连边数量num</span></span><br><span class="line">    <span class="keyword">int</span> cnt=n-res;</span><br><span class="line">    <span class="keyword">return</span> cnt&lt;=k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="comment">//读入这n个村庄的坐标</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)    <span class="comment">//村庄编号从0到n-1而不是从1到n</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;q[i].first,&amp;q[i].second);</span><br><span class="line">    <span class="comment">//由于是无向边,因此是对称矩阵  那么我们只需要统计下三角的边就行了    </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">double</span> w=<span class="built_in">get</span>(q[i],q[j]);</span><br><span class="line">            edges[m++]=&#123;i,j,w&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//给所有边按从小到大排序</span></span><br><span class="line">    <span class="built_in">sort</span>(edges,edges+m);</span><br><span class="line">    <span class="comment">// 二分答案 答案区间是读入的边权的最小值和边权的最大值</span></span><br><span class="line">    <span class="keyword">double</span> l=<span class="number">0</span>,r=edges[m<span class="number">-1</span>].w;</span><br><span class="line">    <span class="comment">//进行浮点数二分</span></span><br><span class="line">    <span class="keyword">while</span>(l+eps&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//check是检查当前的mid是否满足删除所有d&gt;mid的边后，对所有&lt;=mid的边进行合并之后所形成的连通块数目&lt;=k</span></span><br><span class="line">        <span class="comment">//设答案为ans,对于d&gt;=ans的d都是满足的,如果满足,为了求出最小的d,则往左侧收缩</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) </span><br><span class="line">            r=mid;  <span class="comment">//往左侧收缩</span></span><br><span class="line">        <span class="comment">//否则不满足该性质  应该往右边去寻找    </span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            l=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2lf&quot;</span>,l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>最小生成树</category>
      </categories>
      <tags>
        <tag>最小生成树的扩展应用</tag>
      </tags>
  </entry>
  <entry>
    <title>冗余路径</title>
    <url>/2021/08/01/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E5%8F%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/%E5%86%97%E4%BD%99%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1 id="冗余路径"><a href="#冗余路径" class="headerlink" title="冗余路径"></a>冗余路径</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210801171848.png" alt="image-20210801171848367"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>从题目描述中的“每一对草场之间都会至少有两条相互分离的路径”和“两条路径相互分离，是指两条路径没有一条重合的道路”，可以知道这其实就是边双连通图的定义。</p>
<p>在同一个边双连通分量中，任意两点都有至少两条独立路径可达，所以同一个边双连通分量里的所有点可以看做同一个点，于是可以把一个边双连通分量进行“缩点”。把所有的边双连通分量都进行缩点后，那么就会形成一棵树。树中的节点就是边双连通分量缩完之后的点，而树中的边其实就是割边。</p>
<p>题目是说要新建一些道路，使得它成为边双连通图。那么转化为：在树中至少添加多少条边能使图变为边双连通图</p>
<p>这里有一个定理：统计出树中度为1的结点的个数，即叶结点的个数，记为 leaf ，则要使树中任意两个节点之间都有两条独立的路径，则需要添加的边数为$\lfloor \dfrac {leaf+1}{2}\rfloor$</p>
<p>证明还不会，但是可以用下面的栗子来解释一下：</p>
<p>当叶子节点的个数$leaf$为偶数时：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210801174550.png" alt="image-20210801174550558"></p>
<p>当叶子节点的个数$leaf$为奇数时：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210801175253.png" alt="image-20210801175253656"></p>
<p>综上，结合$\dfrac {leaf}{2}$和$\dfrac {leaf+1}{2}$答案就是$\dfrac {leaf+1}{2}$向下取整</p>
<p><strong>算法设计：</strong></p>
<ul>
<li>先把原图建立出来</li>
<li>tarjan求割边，同时求出边连通分量，缩点</li>
<li>遍历每一条边，找到割边，设这条割边的两个端点为$x,y$，节点$x$所在的边连通分量为$a=id[x]$，节点$y$所在的边连通分量为$b=id[y]$，分别统计$a,b$的度</li>
<li>遍历这<code>e_dcc</code>个边连通分量，其实也就是缩完之后的<code>e_dcc</code>个点，统计入度为1的顶点个数，最终答案就是$\dfrac {leaf+1}{2}$向下取整</li>
</ul>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5010</span>,M=<span class="number">20010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="keyword">int</span> dfn[N],low[N],num;</span><br><span class="line"><span class="keyword">int</span> stk[N],top;</span><br><span class="line"><span class="keyword">int</span> id[N],e_dcc;    <span class="comment">//e_dcc是边连通分量的个数</span></span><br><span class="line"><span class="keyword">int</span> d[N];           <span class="comment">//统计缩完点之后这棵树中每个顶点(边连通分量)的度</span></span><br><span class="line"><span class="comment">//bridge[i]=bridge[i^1]=true表示节点e[i]与节点e[i^1]之间的这条边是桥</span></span><br><span class="line"><span class="keyword">bool</span> bridge[M];     </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//由于无向图中,从子节点到父节点的这条边是不需要处理的  因此需要记录子节点是父节点从边from走过来的</span></span><br><span class="line"><span class="comment">//目的是为了防止子节点又通过from这条边走回到父节点  这样就不能判定割边了</span></span><br><span class="line"><span class="comment">//from表示 当前节点y是上一个节点x通过边from到达的</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> from)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x]=low[x]=++num;</span><br><span class="line">    stk[++top]=x;</span><br><span class="line">    <span class="comment">//遍历节点x的所有邻接点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[x];~i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y=e[i]; <span class="comment">//y是i的邻接点</span></span><br><span class="line">        <span class="comment">//如果节点y还没有被访问过</span></span><br><span class="line">        <span class="keyword">if</span>(!dfn[y])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(y,i);    <span class="comment">//递归访问y</span></span><br><span class="line">            low[x]=<span class="built_in">min</span>(low[x],low[y]);  <span class="comment">//回溯时更新</span></span><br><span class="line">            <span class="comment">//满足割边判定法则</span></span><br><span class="line">            <span class="keyword">if</span>(low[y]&gt;dfn[x])</span><br><span class="line">                bridge[i]=bridge[i^<span class="number">1</span>]=<span class="literal">true</span>; <span class="comment">//表示节点e[i]与节点e[i^1]之间的这条边是桥</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则说明节点y已经被访问过了 但是有可能节点y可以通过非树边(非父子边)追溯到更早的节点</span></span><br><span class="line">        <span class="comment">//那么也是可以更新的  一条无向边可以看作是两条反向的有向边  </span></span><br><span class="line">        <span class="comment">//x通过from这条边到达y,即x-&gt;y是通过from边,那么y就可以通过from^1这条边到达x,即y-&gt;x是通过from^1边</span></span><br><span class="line">        <span class="comment">//为了防止从子节点y走回到了父节点x 那么此时y就不能走from^1这条边</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i!=(from^<span class="number">1</span>))</span><br><span class="line">            low[x]=<span class="built_in">min</span>(low[x],dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//记录节点分别属于哪些边连通分量</span></span><br><span class="line">    <span class="keyword">if</span>(dfn[x]==low[x])</span><br><span class="line">    &#123;</span><br><span class="line">        e_dcc++;</span><br><span class="line">        <span class="keyword">int</span> y;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            y=stk[top--];</span><br><span class="line">            id[y]=e_dcc;</span><br><span class="line">        &#125;<span class="keyword">while</span>(y!=x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)  <span class="comment">//建立原图</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a,b),<span class="built_in">add</span>(b,a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">tarjan</span>(<span class="number">1</span>,<span class="number">-1</span>);   <span class="comment">//tarjan求桥 然后求边连通分量 缩点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历每一条边,找到割边,给这条割点的两个端点所在的边连通分量的度+1</span></span><br><span class="line">    <span class="comment">//注意这里是统计每个点的度,成对变换时是(0,1)  (2,3)  (4,5)</span></span><br><span class="line">    <span class="comment">//节点0的这个边连通分量的度要+1  同时节点1的这个边连通分量的度也要+1  否则就会出错</span></span><br><span class="line">    <span class="comment">//因为无向边就是两条反向的有向边 因此如果写成i+=2的话  那么其实就只枚举了这个无向边中的正向边</span></span><br><span class="line">    <span class="comment">//那么只会使得一个点的度+1 而另一个点的度不会+1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;idx;i++)  <span class="comment">//总共有idx条边</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(bridge[i])<span class="comment">//如果i这条边是桥</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i]; <span class="comment">//记录这条割边的一个端点j</span></span><br><span class="line">            <span class="keyword">int</span> a=id[j];    <span class="comment">//记录这个端点j所在的边连通分量的编号a</span></span><br><span class="line">            d[a]++; <span class="comment">//缩点后的节点a的度+1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> leaf=<span class="number">0</span>; <span class="comment">//树中节点度为1的个数</span></span><br><span class="line">    <span class="comment">//统计树中节点度为1的节点个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=e_dcc;i++)</span><br><span class="line">        <span class="keyword">if</span>(d[i]==<span class="number">1</span>)</span><br><span class="line">            leaf++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,(leaf+<span class="number">1</span>)/<span class="number">2</span>);  <span class="comment">//答案</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>无向图的双连通分量</category>
      </categories>
      <tags>
        <tag>tarjan求无向图的双连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title>无向图的双连通分量</title>
    <url>/2021/08/01/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E5%8F%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E5%8F%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/</url>
    <content><![CDATA[<h1 id="无向图的双连通分量"><a href="#无向图的双连通分量" class="headerlink" title="无向图的双连通分量"></a>无向图的双连通分量</h1><hr>
<h3 id="割点和割边"><a href="#割点和割边" class="headerlink" title="割点和割边"></a>割点和割边</h3><ul>
<li><p>割点：在无向连通图中，删除一个顶点以及和它相邻的所有边，图中的连通分量个数增加，则该顶点称为割点</p>
</li>
<li><p>割边（桥）：在无向连通图中，删除一条边，图中的连通分量个数增加，则该条边称为割边或者桥</p>
</li>
</ul>
<p>举个栗子：</p>
<p>割点：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210801104523.png" alt="image-20210801104523612"></p>
<p>割边：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210801104542.png" alt="image-20210801104542324"></p>
<hr>
<h3 id="边连通分量和点连通分量"><a href="#边连通分量和点连通分量" class="headerlink" title="边连通分量和点连通分量"></a>边连通分量和点连通分量</h3><ul>
<li>边双连通图：如果在无向图中不存在割边，则称它为边双连通图。在边双连通图中，<strong>任意两个节点之间都存在两条及以上的路径，并且这些路径上的边互不重复</strong>。</li>
<li>点双连通图：如果在无向图中不存在割点，则称它为点双连通图。在点双连通图中，<strong>如果节点数大于2，则在任意两个节点之间都存在两条及以上路径，并且这些路径上的点互不重复</strong>。</li>
<li>边双连通分量：无向图的极大边双连通子图被称为边双连通分量，记作e-DCC。边双连通分量就是删掉桥之后所留下的连通块，连接两个边双连通分量的边就是桥</li>
<li>点双连通分量：无向图的极大点双连通子图被称为点双连通分量，记作v-DCC</li>
</ul>
<p>点双连通分量的性质：</p>
<ul>
<li>点双连通分量之间以割点连接，且两个点双连通分量之间有且只有一个割点</li>
<li>每一个割点可以任意属于多个点双连通分量，因此求点双连通分量时，可能包含重复的点</li>
<li>只有一条边连通的两个点也是点双连通分量</li>
</ul>
<p>一张图无向连通图是“点双连通图”，当且仅当满足以下两个条件之一：</p>
<ul>
<li>图的顶点个数不超过2</li>
<li>图中任意两点都同时包含至少一个简单环，其中“简单环”是指不自交的环，也就是我们通常画出的环。</li>
</ul>
<p>一张无向连通图是“边双连通图”，当且仅当任意一条边都包含在至少一个简单环中。</p>
<p>总结：</p>
<p>对于一个连通图，如果任意两点之间至少存在两条<strong>没有重复节点</strong>的路径，则称这个图为<strong>点双连通</strong>的（简称双连通）；如果任意两点之间至少存在两条<strong>没有重复边</strong>的路径，则称该图为<strong>边双连通</strong>的。点双连通图的定义等价于<strong>任意两条边都同在一个简单环</strong>中，而边双连通图的定义等价于<strong>任意一条边至少在一个简单环中</strong>。对一个无向图，点双连通的<strong>极大子图</strong>称为<strong>点双连通分量</strong>（简称双连通分量），边双连通的极大子图称为<strong>边双连通分量</strong>。在每一个点双连通图中，内部无割点；在每一个边双连通图中，内部无桥。</p>
<p>举个栗子：</p>
<p>边双连通图：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210801115441.png" alt="image-20210801115441663"></p>
<p>边双连通分量：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210801115857.png" alt="image-20210801115857259"></p>
<p>点双连通图：</p>
<p>点双连通分量：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210801124354.png" alt="image-20210801124353958"></p>
<hr>
<h3 id="求解割点和割边"><a href="#求解割点和割边" class="headerlink" title="求解割点和割边"></a>求解割点和割边</h3><p><strong>割点判定法则：</strong></p>
<ul>
<li>如果$x$不是根节点，那么$x$是割点，当且仅当在搜索树上存在$x$的一个子节点$y$，满足$low[y]\geq dfn[x]$</li>
<li>如果$x$是根节点，那么$x$是割点，当且仅当在搜索树上至少存在两个子节点$y_i$，满足$low[y_i]\geq dfn[x]$</li>
</ul>
<p>先来看第一种，分为以下三个式子讨论：</p>
<p>如果$low[y]&gt;dfn[x]$，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210801130607.png" alt="image-20210801130606931"></p>
<p>如果$low[y]=dfn[x]$，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210801131239.png" alt="image-20210801131239787"></p>
<p>如果$low[y]&lt;dfn[x]$，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210801131910.png" alt="image-20210801131910894"></p>
<p>综上可知，当$low[y]\geq dfn[x]$时，才能说明节点$x$的一个割点</p>
<p>接着再来看第二种，分两种情况讨论：</p>
<p>如果$x$是根节点，但是它只有一个子节点：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210801132827.png" alt="image-20210801132827812"></p>
<p>如果$x$是根节点，但是它至少有两个子节点：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210801133324.png" alt="image-20210801133324071"></p>
<p><strong>割边判定法则：</strong></p>
<p>无向边$(x,y)$是桥，当且仅当在搜索树上存在$x$的一个子节点$y$，满足$low[y]&gt;dfn[x]$</p>
<p>分为以下三个式子讨论：</p>
<p>当$low[y]&gt;dfn[x]$时：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210801134658.png" alt="image-20210801134658781"></p>
<p>当$low[y]=dfn[x]$时：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210801135221.png" alt="image-20210801135221403"></p>
<p>当$low[y]&lt;dfn[x]$时：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210801135750.png" alt="image-20210801135750867"></p>
<p>综上，当$low[y]&gt;dfn[x]$时，才能说明边$(x,y)$是一条割边</p>
<p>注意，在无向图中，求割边时，孩子节点到父节点的边是不用处理的：</p>
<p>原因如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210801141800.png" alt="image-20210801141800313"></p>
<hr>
<h3 id="成对变换"><a href="#成对变换" class="headerlink" title="成对变换"></a>成对变换</h3><p>对于非负整数$n$：</p>
<ul>
<li>当$n$是偶数时，$n$ XOR $1$ 等于 $n+1$</li>
<li>当$n$是奇数时，$n$ XOR $1$ 等于$n-1$</li>
</ul>
<p>因此“0与1” “2与3” “4与5”$\cdots$关于XOR $1$ 运算构成了“成对变换”</p>
<p>这一性质经常用于图论邻接表中边集的存储。在具有无向边的图中把一条正反方向的边分别存储在邻接表数组的第$n$与$n+1$位置（其中$n$是偶数），那么就可以通过XOR $1$运算获得与当前边$(x,y)$所反向的边$(y,x)$的存储位置了（存储位置也就是这条边的编号）</p>
<p>如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210801161148.png" alt="image-20210801161148885"></p>
<p>从中我们发现成对变换可以帮助我们在求割边时避免从子节点走回到父节点。</p>
<blockquote>
<p>问题：如何理解割边的代码模板中的i!=(from^1)呢？</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210801161952.png" alt="image-20210801161952786"></p>
</blockquote>
<hr>
<h3 id="点双连通分量"><a href="#点双连通分量" class="headerlink" title="点双连通分量"></a>点双连通分量</h3><p>若某个节点为孤立节点，则它自己单独构成一个v-DCC。除了孤立节点外，点双连通分量的大小至少为2。注意一个割点可能属于多个点双连通分量。</p>
<p>下面的无向图共有2个割点（节点1和节点6），4个点双连通分量，深色部分表示点双连通分量：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210802141908.png" alt="image-20210802141908282"></p>
<p>为了找出“点双连通分量”，需要在tarjan算法的过程中维护一个栈，并按照如下方法维护栈中的元素：</p>
<ul>
<li>当一个节点第一次被访问时，把该节点入栈</li>
<li>当割点判定法则中的条件$low[y]\geq dfn[x]$成立时，无论$x$是否为根，都要：<ul>
<li>从栈顶不断弹出节点，直至节点$y$被弹出（注意不是节点$x$被弹出）</li>
<li>刚才弹出的所有节点与节点$x$一起构成一个点双连通分量</li>
</ul>
</li>
</ul>
<blockquote>
<p>问题：为什么是弹到$y$而不是弹出$x$呢？</p>
<p>因为一个割点可能属于多个点双连通分量，如果在某一个点双连通分量把x这个割点弹出了，然后放进了这个点双连通分量的dcc中，那么其他点双连通分量本来是含有割点x 但是由于x已经弹出栈并且放进了dcc，那么其他的点双连通分量就在栈中找不到$x$了，因此其他的点双连通分量就都缺少了割点$x$，但这与事实不符合。因此必须把割点$x$保存在栈中，而不能被弹出来。</p>
</blockquote>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>割点的代码模板：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>,M=N*N;</span><br><span class="line"><span class="keyword">int</span> n,m,root;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="keyword">int</span> low[N],dfn[N],num;</span><br><span class="line"><span class="keyword">bool</span> cut[N];    <span class="comment">//cut[i]=true表示节点i是割点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    low[x]=dfn[x]=++num;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;    <span class="comment">//统计节点x有多少个子节点</span></span><br><span class="line">    <span class="comment">//遍历节点x的所有邻接点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[x];~i;i=ne[i])  <span class="comment">//i是边</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y=e[i]; <span class="comment">//y是i的邻接点</span></span><br><span class="line">        <span class="comment">//如果节点y还没有被访问过</span></span><br><span class="line">        <span class="keyword">if</span>(!dfn[y])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(y);  <span class="comment">//递归访问y</span></span><br><span class="line">            low[x]=<span class="built_in">min</span>(low[x],low[y]);  <span class="comment">//回溯时更新</span></span><br><span class="line">            <span class="comment">//满足割点判定准则</span></span><br><span class="line">            <span class="keyword">if</span>(low[y]&gt;=dfn[x])</span><br><span class="line">            &#123;</span><br><span class="line">                count++;    <span class="comment">//节点x的子节点个数+1</span></span><br><span class="line">                <span class="comment">//如果x不是根节点 那么如果x满足了割点判定准则,则x必是割点</span></span><br><span class="line">                <span class="comment">//或者x是根节点,但是它至少有2个子节点,并且x满足了割点判定准则,则x必是割点</span></span><br><span class="line">                <span class="keyword">if</span>(x!=root||count&gt;<span class="number">1</span>)</span><br><span class="line">                    cut[x]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则说明节点y已经被访问过了,但是有可能节点y可以通过非树边(非父子边)追溯到更早的节点</span></span><br><span class="line">        <span class="comment">//那么也可以更新</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            low[x]=<span class="built_in">min</span>(low[x],dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);  <span class="comment">//初始化表头</span></span><br><span class="line">    cin &gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)	<span class="comment">//读入m条边</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        cin &gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="keyword">if</span>(a==b)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//建立无向图</span></span><br><span class="line">        <span class="built_in">add</span>(a,b);</span><br><span class="line">        <span class="built_in">add</span>(b,a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i])</span><br><span class="line">        &#123;</span><br><span class="line">            root=i;</span><br><span class="line">            <span class="built_in">tarjan</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   <span class="comment">//输出割点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cut[i])</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;是割点.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>割边的代码模板：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>,M=N*N;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="keyword">int</span> dfn[N],low[N],num;</span><br><span class="line"><span class="comment">//bridge[i]=bridge[i^1]=true表示节点e[i]与节点e[i^1]之间的这条边是桥</span></span><br><span class="line"><span class="keyword">bool</span> bridge[M]; </span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//由于无向图中,从子节点到父节点的这条边是不需要处理的  因此需要记录子节点是父节点从边from走过来的</span></span><br><span class="line"><span class="comment">//目的是为了防止子节点又通过from这条边走回到父节点  这样就不能判定割边了</span></span><br><span class="line"><span class="comment">//from表示 当前节点y是上一个节点x通过边from到达的</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> from)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x]=low[x]=++num;</span><br><span class="line">    <span class="comment">//遍历节点x的所有邻接点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[x];~i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y=e[i]; <span class="comment">//y是i的邻接点</span></span><br><span class="line">        <span class="comment">//如果节点y还没有被访问过</span></span><br><span class="line">        <span class="keyword">if</span>(!dfn[y])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(y,i);    <span class="comment">//递归访问y</span></span><br><span class="line">            low[x]=<span class="built_in">min</span>(low[x],low[y]);  <span class="comment">//回溯时更新</span></span><br><span class="line">            <span class="comment">//满足割边判定法则</span></span><br><span class="line">            <span class="keyword">if</span>(low[y]&gt;dfn[x])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//表示节点e[i]与节点e[i^1]之间的这条边是桥</span></span><br><span class="line">                bridge[i]=bridge[i^<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则说明节点y已经被访问过了 但是有可能节点y可以通过非树边(非父子边)追溯到更早的节点</span></span><br><span class="line">        <span class="comment">//那么也是可以更新的  一条无向边可以看作是两条反向的有向边  </span></span><br><span class="line">        <span class="comment">//x通过from这条边到达y,即x-&gt;y是通过from边,那么y就可以通过from^1这条边到达x,即y-&gt;x是通过from^1边</span></span><br><span class="line">        <span class="comment">//为了防止从子节点y走回到了父节点x 那么此时y就不能走from^1这条边</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i!=(from^<span class="number">1</span>))</span><br><span class="line">            low[x]=<span class="built_in">min</span>(low[x],low[y]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);  <span class="comment">//初始化表头</span></span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)   <span class="comment">//读入m条边</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="comment">//建立无向图</span></span><br><span class="line">        <span class="built_in">add</span>(a,b);</span><br><span class="line">        <span class="built_in">add</span>(b,a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i])    </span><br><span class="line">            <span class="built_in">tarjan</span>(i,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//总共有idx条边  边的编号是从0开始的</span></span><br><span class="line">    <span class="comment">//由于是成对变换,因此编号为0和编号为1就表示一条无向边 编号为2和编号为3就表示另一条无向边</span></span><br><span class="line">    <span class="comment">//所以这里是i+=2 即遍历下一条无向边  如果写成i++则仍然会遍历这条无向边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;idx;i+=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(bridge[i])<span class="comment">//说明编号为i的这条边是桥  那么输出这条割边的两个端点e[i^1],e[i]</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(%d,%d)是一条割边.\n&quot;</span>,e[i^<span class="number">1</span>],e[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>点双连通分量代码模板：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>,M=N*N;</span><br><span class="line"><span class="keyword">int</span> n,m,root;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="keyword">int</span> low[N],dfn[N],num;</span><br><span class="line"><span class="keyword">int</span> stk[N],top;</span><br><span class="line"><span class="keyword">bool</span> cut[N];    <span class="comment">//cut[i]=true表示节点i是割点</span></span><br><span class="line"><span class="comment">//dcc[i]表示存储第i个点双连通分量中的所有节点</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;dcc[N];</span><br><span class="line"><span class="keyword">int</span> cnt;    <span class="comment">//点双连通分量的个数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    low[x]=dfn[x]=++num;</span><br><span class="line">    stk[++top]=x;</span><br><span class="line">    <span class="comment">//特判如果某个节点为孤立节点,则它自己单独构成一个点双连通分量</span></span><br><span class="line">    <span class="comment">//此时这个点双连通分量只有一个节点</span></span><br><span class="line">    <span class="comment">//判定孤立节点:如果它是根节点并且它没有邻边</span></span><br><span class="line">    <span class="keyword">if</span>(x==root&amp;&amp;h[x]==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dcc[++cnt].<span class="built_in">push_back</span>(x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;    <span class="comment">//统计节点x有多少个子节点</span></span><br><span class="line">    <span class="comment">//遍历节点x的所有邻接点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[x];~i;i=ne[i])  <span class="comment">//i是边</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y=e[i]; <span class="comment">//y是i的邻接点</span></span><br><span class="line">        <span class="comment">//如果节点y还没有被访问过</span></span><br><span class="line">        <span class="keyword">if</span>(!dfn[y])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(y);  <span class="comment">//递归访问y</span></span><br><span class="line">            low[x]=<span class="built_in">min</span>(low[x],low[y]);  <span class="comment">//回溯时更新</span></span><br><span class="line">            <span class="comment">//满足割点判定准则</span></span><br><span class="line">            <span class="keyword">if</span>(low[y]&gt;=dfn[x])</span><br><span class="line">            &#123;</span><br><span class="line">                count++;    <span class="comment">//节点x的子节点个数+1</span></span><br><span class="line">                <span class="comment">//如果x不是根节点 那么如果x满足了割点判定准则,则x必是割点</span></span><br><span class="line">                <span class="comment">//或者x是根节点,但是它至少有2个子节点,并且x满足了割点判定准则,则x必是割点</span></span><br><span class="line">                <span class="keyword">if</span>(x!=root||count&gt;<span class="number">1</span>)</span><br><span class="line">                    cut[x]=<span class="literal">true</span>;</span><br><span class="line">                </span><br><span class="line">                cnt++;  <span class="comment">//点双连通分量个数+1</span></span><br><span class="line">                <span class="keyword">int</span> z;</span><br><span class="line">                <span class="comment">//依次弹出这个点双连通分量中的节点  然后放到dcc中</span></span><br><span class="line">                <span class="comment">//注意是弹到y截止  而不是弹到x</span></span><br><span class="line">                <span class="comment">//为什么是弹到y截止而不是弹到x呢？</span></span><br><span class="line">                <span class="comment">//因为一个割点可能属于多个点双连通分量,如果在某一个点双连通分量把x这个</span></span><br><span class="line">                <span class="comment">//割点弹出了然后放进了这个点双连通分量的dcc中</span></span><br><span class="line">                <span class="comment">//那么其他点双连通分量本来是含有割点x 但是由于x已经弹出栈并且放进了dcc</span></span><br><span class="line">                <span class="comment">//那么其他点双连通分量就不能放入割点x了 因此会出错</span></span><br><span class="line">                <span class="keyword">do</span>&#123;</span><br><span class="line">                    z=stk[top--];</span><br><span class="line">                    dcc[cnt].<span class="built_in">push_back</span>(z);</span><br><span class="line">                &#125;<span class="keyword">while</span>(z!=y);</span><br><span class="line">                <span class="comment">//注意这里此时x仍然在栈中,只不过我们把它加入了dcc而已 x并没有弹出栈</span></span><br><span class="line">                <span class="comment">//这样当其他点双连通分量也包含割点x时 由于x仍然在栈中 因此能够找到割点x</span></span><br><span class="line">                dcc[cnt].<span class="built_in">push_back</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则说明节点y已经被访问过了,但是有可能节点y可以通过非树边(非父子边)追溯到更早的节点</span></span><br><span class="line">        <span class="comment">//那么也可以更新</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            low[x]=<span class="built_in">min</span>(low[x],dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);  <span class="comment">//初始化表头</span></span><br><span class="line">    cin &gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)	<span class="comment">//读入m条边</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        cin &gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="keyword">if</span>(a==b)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//建立无向图</span></span><br><span class="line">        <span class="built_in">add</span>(a,b);</span><br><span class="line">        <span class="built_in">add</span>(b,a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i])</span><br><span class="line">        &#123;</span><br><span class="line">            root=i;</span><br><span class="line">            <span class="built_in">tarjan</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出割点和所有的点双连通分量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;v-DCC #%d:&quot;</span>,i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;dcc[i].<span class="built_in">size</span>();j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>,dcc[i][j]);</span><br><span class="line">        cout &lt;&lt;endl;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>无向图的双连通分量</category>
      </categories>
      <tags>
        <tag>tarjan求无向图的双连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title>矿场搭建</title>
    <url>/2021/08/02/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E5%8F%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/%E7%9F%BF%E5%9C%BA%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="矿场搭建"><a href="#矿场搭建" class="headerlink" title="矿场搭建"></a>矿场搭建</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210802143012.png" alt="image-20210802143012333"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>题意：给一个不一定连通的无向图，问最少在几个点设置出口，使得任意一个出口坏掉后,其他所有点都可以和某个出口连通。</p>
<p>假设有$n$个点，只有一个出口，那么当这个点坏了之后，其余的$n-1$个点就没有办法出去了。但是如果至少有两个出口，那么当其中一个出口坏了，仍然可以从另一个出口出去。因此，出口数量必须$\geq2$</p>
<p>设<code>res</code>表示需要设立的最少的出口，初始化为0，<code>path</code>表示不同最少救援出口的设置方案总数，初始化为1</p>
<p>对于一个连通块来说，设这个连通块中点的数量为$n$，如果<strong>它没有割点</strong>，由于一个割点至少连接两个点双连通分量，所以当我们把点双连通分量进行缩点后，缩点后得到的是一棵树，那么这个割点就会连接两个点，那么这两个点就是叶子节点，度为1。但是现在没有割点，则说明这些都是独立的点，因此说明度为0。</p>
<ul>
<li>如果点的数量大于1，即$n&gt;1$，那么只需要设置2个出口就好了，从这$n$个点中随便选择两个点作为出口的方案数就是$C_n^{2}$，即$res+=2$，$path*=C_n^2$</li>
</ul>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210802143643.png" alt="image-20210802143643312"></p>
<ul>
<li>如果点的数量等于1，即$n=1$，说明是一个孤立节点，那么一个孤立节点不可能设立两个出口。因此最终只能在这个孤立节点上设立一个出口，那么$res+=1，path*=1$</li>
</ul>
<p>如果存在割点：</p>
<p>我们先求出所有的点双连通分量，把所有割点都先拿出来，但是要注意一个割点可能属于多个点双连通分量，而且我们计算的这个点双连通分量中是包含割点的。然后我们让拿出来的这个割点和点双连通分量连边，把点双连通分量缩点，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210802144654.png" alt="image-20210802144654261"></p>
<p>如果只有一个割点，由于一个割点至少连接两个点双连通分量，所以当我们把点双连通分量进行缩点后，缩点后得到的是一棵树，那么这个割点就会连接两个点，那么这两个点就是叶子节点，度为1。那么如果我们把出口放在这个割点上，则当割点坏（出口坏了）时，则割点所连接的这两个叶子节点就没有出路了，即这两个点双连通分量中的每个点都没有出口了。因此不能把出口放在割点上。那么我们可以把出口放在这两个叶子节点上，即放在度为1的节点上，也就是说我们可以把一个出口放在这个点双连通分量中的任意一个节点上（但是不能是割点）。设这个点双连通分量中有$x$个点（包括了一个割点），由于出口不能放在割点上，因此出口可以放置在$x-1$个节点上，于是有$x-1$种方案。为什么只放一个出口就行了呢？（下面会解释）。则答案为$res+=1,path*=(x-1)$</p>
<p>如果有两个割点，由于一个割点至少连接两个点双连通分量，所以此时必然是一个割点连接两个点，即这两个点度为2，</p>
<p>现在来解释一下算法的正确性：</p>
<ul>
<li><p>如果割点坏掉时：</p>
<p>由于缩完点之后是一棵树，所有度为1的点都是叶子节点，我们<strong>在所有的度为1的节点都放了一个出口</strong>，因此每一个叶子节点都必然会有一个出口。我们把割点弄成这颗树的根节点，因为一个割点可以连接多个点双连通分量，因此这个根节点就会有很多子树，每个子树都至少有一个叶子节点，因此每个子树中的节点起码会被那个叶子节点救援（叶子节点有出口）</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210802162401.png" alt="image-20210802162401790"></p>
</li>
<li><p>如果是度为1的点双连通分量中的某个点坏时（这个点不是割点，因为这种情况我们上面讨论过了）:</p>
<p>由于它是V-DCC，所以我们把这个坍塌的点删除后，仍然是连通的图，由于它的度为1，因此它会被一个割点连接，同时这个割点还连接其他的V-DCC，所以我们可以把这个割点当作是根，由于在所有的度为1的节点都放了一个出口，因此每一棵子树中的节点都可以被叶子节点救，如果坍塌的这个点刚好就是出口，那么可以顺着割点到达右边，那么也是可以被右边的叶子节点救的：因此对于这个度为1的点来说，只需要在这个点双连通分量内部设立一个出口就好了，因此是$res+=1,path*=(x-1)$</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210802163230.png" alt="image-20210802163230139"></p>
</li>
<li><p>如果是度为2的点双连通分量中的某个点坏时（这个点不是割点，因为这种情况我们上面讨论过了）:</p>
<p>由于度为2，则该点必然连接了两个割点，根据上面的分析，我们知道，每个割点它的子树中一定有了叶子节点存在出口，因此，对于当前的这个点双连通分量来说，就不再需要另外开辟一个出口了，直接使用原来已经设立的出口就好了。</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210802165859.png" alt="image-20210802165859530"></p>
</li>
</ul>
<p>总结：</p>
<ul>
<li>无割点，若这个点双连通分量不是孤立点，则放2个出口，$res+=2,path<em>=C_n^2$，如果这个点双连通分量是孤立点，则$res+=1,path</em>=1$。这里无割点相当于这个点双连通分量度为0</li>
<li>有割点，如果该点双连通分量的度为1，则放1个出口，$res+=1,path*=(x-1)$（不包括割点）</li>
<li>有割点，如果该点双连通分量的度为2，则点双连通分量不再需要新开出口，所以$res+=0,path*=1$</li>
</ul>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>,M=<span class="number">2010</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ULL;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="keyword">int</span> dfn[N],low[N],num;</span><br><span class="line"><span class="keyword">int</span> stk[N],top;</span><br><span class="line"><span class="keyword">bool</span> cut[N];    <span class="comment">//cut[i]=true表示节点i是割点</span></span><br><span class="line"><span class="comment">//dcc[i]表示存储第i个点双连通分量中的所有节点</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;dcc[N];</span><br><span class="line"><span class="comment">//vdcc点双连通分量的个数   root是某个连通块的根</span></span><br><span class="line"><span class="keyword">int</span> vdcc,root;</span><br><span class="line"><span class="comment">//多组测试数据 初始化清空操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=vdcc;i++)</span><br><span class="line">        dcc[i].<span class="built_in">clear</span>();</span><br><span class="line">    idx=num=top=n=vdcc=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">memset</span>(dfn,<span class="number">0</span>,<span class="keyword">sizeof</span> dfn);</span><br><span class="line">    <span class="built_in">memset</span>(cut,<span class="number">0</span>,<span class="keyword">sizeof</span> cut);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x]=low[x]=++num;</span><br><span class="line">    stk[++top]=x;</span><br><span class="line">    <span class="comment">//特判如果某个节点为孤立节点,则它自己单独构成一个点双连通分量</span></span><br><span class="line">    <span class="comment">//此时这个点双连通分量只有一个节点</span></span><br><span class="line">    <span class="comment">//判定孤立节点:如果它是根节点并且它没有邻边</span></span><br><span class="line">    <span class="keyword">if</span>(x==root&amp;&amp;h[x]==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dcc[++vdcc].<span class="built_in">push_back</span>(x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;    <span class="comment">//统计节点x有多少个子节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[x];~i;i=ne[i])   <span class="comment">//i是边</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y=e[i]; <span class="comment">//y是i的邻接点</span></span><br><span class="line">        <span class="comment">//如果节点y还没有被访问过</span></span><br><span class="line">        <span class="keyword">if</span>(!dfn[y])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(y);   <span class="comment">//递归访问y</span></span><br><span class="line">            low[x]=<span class="built_in">min</span>(low[x],low[y]);  <span class="comment">//回溯时更新</span></span><br><span class="line">            <span class="comment">//满足割点判定准则</span></span><br><span class="line">            <span class="keyword">if</span>(low[y]&gt;=dfn[x])</span><br><span class="line">            &#123;</span><br><span class="line">                count++;    <span class="comment">//节点x的子节点个数+1</span></span><br><span class="line">                <span class="comment">//如果x不是根节点 那么如果x满足了割点判定准则,则x必是割点</span></span><br><span class="line">                <span class="comment">//或者x是根节点,但是它至少有2个子节点,并且x满足了割点判定准则,则x必是割点</span></span><br><span class="line">                <span class="keyword">if</span>(x!=root||count&gt;<span class="number">1</span>)</span><br><span class="line">                    cut[x]=<span class="literal">true</span>;</span><br><span class="line">                vdcc++; <span class="comment">//点双连通分量个数+1</span></span><br><span class="line">                <span class="keyword">int</span> z;</span><br><span class="line">                <span class="comment">//依次弹出这个点双连通分量中的节点  然后放到dcc中</span></span><br><span class="line">                <span class="comment">//注意是弹到y截止  而不是弹到x</span></span><br><span class="line">                <span class="comment">//为什么是弹到y截止而不是弹到x呢？</span></span><br><span class="line">                <span class="comment">//因为一个割点可能属于多个点双连通分量,如果在某一个点双连通分量把x这个</span></span><br><span class="line">                <span class="comment">//割点弹出了然后放进了这个点双连通分量的dcc中</span></span><br><span class="line">                <span class="comment">//那么其他点双连通分量本来是含有割点x 但是由于x已经弹出栈并且放进了dcc</span></span><br><span class="line">                <span class="comment">//那么其他点双连通分量就不能放入割点x了 因此会出错</span></span><br><span class="line">                <span class="keyword">do</span>&#123;</span><br><span class="line">                    z=stk[top--];</span><br><span class="line">                    dcc[vdcc].<span class="built_in">push_back</span>(z);</span><br><span class="line">                &#125;<span class="keyword">while</span>(z!=y);</span><br><span class="line">                <span class="comment">//注意这里此时x仍然在栈中,只不过我们把它加入了dcc而已 x并没有弹出栈</span></span><br><span class="line">                <span class="comment">//这样当其他点双连通分量也包含割点x时 由于x仍然在栈中 因此能够找到割点x</span></span><br><span class="line">                dcc[vdcc].<span class="built_in">push_back</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则说明节点y已经被访问过了,但是有可能节点y可以通过非树边(非父子边)追溯到更早的节点</span></span><br><span class="line">        <span class="comment">//那么也可以更新</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            low[x]=<span class="built_in">min</span>(low[x],dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m),m)</span><br><span class="line">    &#123;</span><br><span class="line">        T++;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a,b;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">            <span class="comment">//由于题目没有说明点的最大编号  因此需要记录</span></span><br><span class="line">            n=<span class="built_in">max</span>(n,a),n=<span class="built_in">max</span>(n,b);</span><br><span class="line">            <span class="built_in">add</span>(a,b),<span class="built_in">add</span>(b,a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(root=<span class="number">1</span>;root&lt;=n;root++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!dfn[root])</span><br><span class="line">                <span class="built_in">tarjan</span>(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;  <span class="comment">//至少需要设置几个救援出口</span></span><br><span class="line">        ULL path=<span class="number">1</span>; <span class="comment">//不同最少救援出口的设置方案总数</span></span><br><span class="line">        <span class="comment">//遍历着vdcc个点双连通分量</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=vdcc;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt=<span class="number">0</span>;  <span class="comment">//统计这个点双连通分量中割点的个数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;dcc[i].<span class="built_in">size</span>();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> x=dcc[i][j];</span><br><span class="line">                <span class="keyword">if</span>(cut[x])<span class="comment">//是割点</span></span><br><span class="line">                    cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//无割点</span></span><br><span class="line">            <span class="keyword">if</span>(cnt==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(dcc[i].<span class="built_in">size</span>()&gt;<span class="number">1</span>)<span class="comment">//这个点双连通分量中点的个数&gt;1</span></span><br><span class="line">                &#123;</span><br><span class="line">                    res+=<span class="number">2</span>; <span class="comment">//需要在当前的这个点双连通分量设立两个出口</span></span><br><span class="line">                    <span class="comment">//从这dcc[i].size()个点中随意选择两个作为出口的方案数</span></span><br><span class="line">                    path*=dcc[i].<span class="built_in">size</span>()*(dcc[i].<span class="built_in">size</span>()<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//说明这个点双连通分量只存在1个孤立的节点</span></span><br><span class="line">                <span class="keyword">else</span>    </span><br><span class="line">                    res++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//有一个割点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cnt==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res++;  <span class="comment">//从该点双连通分量中除了割点之外的那dcc[i].size()-1个点中随意选择一个点作为出口</span></span><br><span class="line">                <span class="comment">//从该点双连通分量中除了割点之外的那dcc[i].size()-1个点中随意选择一个点作为出口的方案数</span></span><br><span class="line">                path*=dcc[i].<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;Case %d: %d %llu\n&quot;</span>, T, res, path);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>无向图的双连通分量</category>
      </categories>
      <tags>
        <tag>tarjan求无向图的双连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title>电力</title>
    <url>/2021/08/02/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E5%8F%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/%E7%94%B5%E5%8A%9B/</url>
    <content><![CDATA[<h1 id="电力"><a href="#电力" class="headerlink" title="电力"></a>电力</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210802123118.png" alt="image-20210802123118154"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>题意：“删除一个点，使得连通块个数增加”。</p>
<p>我们知道，如果删除割点，那么得到的连通块个数就会增加。因此，我们需要删除的点应该就是割点。</p>
<p>我们可以使用tarjan算法根据割点判定准则来判断一个点是否为割点，同时统计出连通块的个数，假设有<code>cnt</code>个连通块</p>
<ul>
<li>枚举每个连通块</li>
<li>然后枚举删除这个连通块中的某个点，统计删除该点后，这个连通块能够分裂成多少个连通块，假设为$s$个，然后执行$ans=max(ans,s)$。那么枚举完这个连通块中的所有点之后，就会得到删除这个连通块中的某个点后，得到的局部最优解<code>ans</code></li>
<li>一直枚举完所有的连通块，那么最终就会得到删除某个连通块中的某个点后，得到的全局最优解为<code>ans</code></li>
<li>那么最终的连通块最多为$ans+cnt-1$。其中这里的$ans$表示枚举删除第$i$个连通块中的某个点后得到的连通块个数，$cnt-1$表示除了第$i$个连通块之外的那些连通块个数。</li>
</ul>
<p>根据割点判定法则，如果$low[y]\geq dfn[x]$，$x$是$y$的父节点，$y$是$x$的子节点，那么删除割点$x$后，$y$所在的子树就会成为独立的一个连通块。因此当某个点$y$，满足$low[y]\geq dfn[x]$，则让$s$自增。</p>
<p>比如$x$有$y_1,y_2,y_3$个子节点，它们都满足$low[y]\geq dfn[x]$，那么说明删掉割点$x$后，就会得到3个独立的连通块。但是还有一种情况，如果$x$它不是根节点，那么把它删除后，它上面的父节点所在的子树也会成为一个独立的连通块。因此此时$s$也要自增。</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210802124937.png" alt="image-20210802124937326"></p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">10010</span>,M=<span class="number">30010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="keyword">int</span> dfn[N],low[N],num;</span><br><span class="line"><span class="comment">//ans是删除某个连通块中的某个点后所形成的连通块的最大个数</span></span><br><span class="line"><span class="comment">//root是每个连通块的根</span></span><br><span class="line"><span class="keyword">int</span> ans,root;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多组测试数据 初始化清空操作  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    idx=num=ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dfn,<span class="number">0</span>,<span class="keyword">sizeof</span> dfn);</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x]=low[x]=++num;</span><br><span class="line">    <span class="comment">//s记录的是  枚举删除某个连通块中的某个点后 所形成的连通块的个数</span></span><br><span class="line">    <span class="keyword">int</span> s=<span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[x];~i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y=e[i];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[y])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(y);</span><br><span class="line">            low[x]=<span class="built_in">min</span>(low[x],low[y]);</span><br><span class="line">            <span class="comment">//满足割点判定准则   </span></span><br><span class="line">            <span class="comment">//此时删除割点x后,节点y所在的子树成为一个独立的连通块  因此s++</span></span><br><span class="line">            <span class="keyword">if</span>(low[y]&gt;=dfn[x])</span><br><span class="line">                s++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>    </span><br><span class="line">            low[x]=<span class="built_in">min</span>(low[x],dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//特判 如果割点x不是根节点  那么x的父节点所在的子树也是一个独立的连通块  因此s++</span></span><br><span class="line">    <span class="keyword">if</span>(x!=root)</span><br><span class="line">        s++;</span><br><span class="line">    <span class="comment">//找到这次枚举的这个连通块中删除某个点后所得到的最大的连通块的个数ans</span></span><br><span class="line">    ans=<span class="built_in">max</span>(ans,s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m),n||m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a,b;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">            <span class="built_in">add</span>(a,b),<span class="built_in">add</span>(b,a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;  <span class="comment">//统计原图中有多少个连通块</span></span><br><span class="line">        <span class="keyword">for</span>(root=<span class="number">0</span>;root&lt;n;root++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!dfn[root])</span><br><span class="line">            &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                <span class="built_in">tarjan</span>(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans+cnt<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>无向图的双连通分量</category>
      </categories>
      <tags>
        <tag>tarjan求无向图的双连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title>秘密的牛奶运输</title>
    <url>/2021/07/26/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E6%89%A9%E5%B1%95%E5%BA%94%E7%94%A8/%E7%A7%98%E5%AF%86%E7%9A%84%E7%89%9B%E5%A5%B6%E8%BF%90%E8%BE%93/</url>
    <content><![CDATA[<h1 id="秘密的牛奶运输"><a href="#秘密的牛奶运输" class="headerlink" title="秘密的牛奶运输"></a>秘密的牛奶运输</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210726160105.png" alt="image-20210726160105315"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>通读题目，可知这道题其实想要求的是次小生成树。</p>
<p><code>定理</code>：对于一张无向图，如果存在最小生成树和次小生成树，那么对于任何一棵最小生成树来说，都存在一棵次小生成树，并且最小生成树和次小生成树之间只有一条边不同。</p>
<p>严格证明还不会，但是可以举个形象化的栗子：</p>
<p>给出以下定义：</p>
<p><code>树边</code>：最小生成树中的边</p>
<p><code>非树边</code>：不在最小生成树中的边，但是它是原图中真实存在的边</p>
<p>我们设一条非树边为$a$，一条树边为$b$，我们让这条非树边去代替这条树边，记作：$(+a,-b)$。这称为一次可行变换</p>
<p>通过一次可行变换后得到的仍然是一棵生成树，我们称这棵生成树是最初那棵最小生成树的邻集。</p>
<p>也就是说我们想要证明最小生成树和次小生成树之间只有一条边不同，其实也就是要证明只进行一次可行变换就行了。</p>
<p>如下图所示：</p>
<p>其中$a$和$c$是树边，$b$和$d$是非树边，由Kruskal算法可知，树边$a$把连通块$A$和连通块$B$合并成了一个集合（设为$F$)，树边$c$把集合$F$和连通块$C$合并成了一个大的连通块。</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210726161854.png" alt="image-20210726161854785"></p>
<p>假设我们进行一次可行变换，也就是用非树边$b$去代替树边$a$。由Kruskal算法可知，$a$必定是小于$b$的（这里不讨论等于，因为等于的话则随机选择了$a$或者$b$作为最初最下生成树的树边了），可以用反证法，假设$b<a$，那么由算法的正确性可知，一定会选择$b$作为树边合并连通块$A$和连通块$B$，而不会是$a$，但是最小生成树选择了$a$作为树边，因此矛盾，于是必然有$a<b$。现在我们进行一次可行变换，用非树边$b$去代替树边$a$。设最初最小生成树的权值总和为$sum$，那么增加非树边$b$和删除树边$a$后，所得到的仍然是一棵生成树，权值总和为$sum+b-a$，因为$b-a>0$，也就是说这次可行变换产生了一个增量，设增量$\Delta=b-a$，可以知道$sum+(b-a)&gt;sum$，也就是说进行一次可行变换后得到的这棵生成树的权值总和是大于最初那棵最小生成树的权值总和的。</p>
<p>如下图所示：</p>
<p>设最初的最小生成树为$T_0$，用非树边$b$去代替树边$a$进行一次可行变换得到的生成树为$T_1$：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210726212118.png" alt="image-20210726163600462"></p>
<p>假设我们进行两次可行变换，也就是用非树边$b$去代替树边$a$，用非树边$d$代替树边$c$，同理分析可知$b&gt;a$，$d&gt;c$，那么此时得到的生成树设为$T_2$，权值总和为$sum+(b-a)+(d-c)$，由此可知，$T_0&lt;T_1&lt;T_2$，由于$T_0$是最小生成树，那么$T_1$就是次小生成树。因此我们发现如果替换的边越多，得到的生成树的权值远远大于最小生成树，而且也会大于次小生成树。这就直观地说明了<strong>最小生成树和次小生成树之间只有一条边不同</strong></p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210726164147.png" alt="image-20210726164147506"></p>
<p>从上面的分析我们可以知道，要想求次小生成树，其实就是要从非树边中找出一条边，让这条边去替换已经在最小生成树中的树边。设这条非树边的权值为$w$，设已经在最小生成树中的树边的权值为$w[i]$，那么进行这次可行变换后，得到的生成树的权值总和为$X=sum+w-w[i]$。由这个等式可知，要想$X$尽可能小，那么就需要$w[i]$最大。那么问题就转化为如何求这棵最小生成树中的权值最大的那条边。</p>
<p>但是有个问题，如果$w=w[i]$，那么即使我们进行了这次可行变换，所得到的最小生成树权值总和仍然是不变的，因此这并不是严格的次小生成树。为了考虑这种情况，我们还需要求解出这棵最小生成树中的权值第二大的那条边，称为次大边。我们设最大边为$d_1$，次大边为$d_2$。</p>
<ul>
<li>如果$w&gt;d_1$，那么则说明我们可以直接用这条非树边去替换到原来最小生成树中的那条最大边，这样得到的这棵生成树就是次小的。也就是说如果$w&gt;d_1$，需要执行$d_2=d_1$，$d_1=w$。</li>
<li>如果$w=d_1$，则替换没有任何意义，此时啥也不做</li>
<li>如果$w<d_1$，此时就不能用这条非树边去代替那条树边了（否则会得到更小的最小生成树，矛盾了），但是呢，我们可以考虑是否可以用这条非树边去替换掉次大边，如果此时还有$w>d_2$，那么就可以用这条非树边去代表次大边，这样得到的生成树就是次小的。也就是说如果$w<d1$&&$w>d_2$，则执行$d_2=w$。</li>
<li>如果$w=d_2$，由于次大边肯定是小于最大边的，即$d_1&lt;d2$，因此必有$w&lt;d_2$。既然$w=d_2$，那么用这条非树边去替换次大边$d_2$没有任何意义，此时啥也不做。</li>
<li>那么为什么只需要记录最大边和次大边就行了呢？因为如果$w&gt;d_1$，直接进行可行变换即可；如果$w=d_1$，那么接下来次大值，但是呢有个问题就是次大值并不一定会存在你，啥时候会不存在次大值呢？其实也就是所有边的权值都是一样的，那么就不会分为什么最大边和次大边了，也就不存在次大值了。如果次大值不存在，那么所有的$w_i$都与$d_1$相同，那么这次可行替换没有任何意义。因此只有这两种情况，那么只需要记录最大边和次大边就好了。总的来说就是：<ul>
<li>如果$w&gt;d_1$，直接进行可行变换</li>
<li>如果$w=d_1$，接着考虑次大值：<ul>
<li>如果次大值存在，则说明必有$d_2<d_1$，由于$w=d_1$，因此$w>d_2$</li>
<li>如果次大值不存在，则说明所有边的权值都是一样的，那么这次可行替换没有任何意义</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>于是就有如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(w[i]&gt;td1)</span><br><span class="line">&#123;</span><br><span class="line">    td2=td1;</span><br><span class="line">    td1==w[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(w[i]&lt;td1&amp;&amp;w[i]&gt;td2)</span><br><span class="line">    td2=w[i];</span><br></pre></td></tr></table></figure>
<p>那么我们如何求解一棵树中的最大边和次大边呢？</p>
<p>考虑到这题只有$N=500$个点，数据范围不是很大，可以用暴力求解：</p>
<p>依次遍历这$n$个节点，枚举从$1$号点出发，它到其他各点的路径上所经过的边的最大值；接着枚举从$2$号点出发，它到其他各点的路径上所经过的边的最大值，$\cdots$，最后枚举从$n$号点出发，它到其他各点的路径上所经过的边的最大值。那么最终就可以知道任意两点之间路径上的边权的最大值了。再求解任意两点间的边权最大值时就苦于同时求出了次大边。</p>
<p>我们设<code>dist1[a][b]</code>表示任意两点间的边权最大值，<code>dist2[a][b]</code>表示任意两点间的边权次大值。我们可以在$O(n^2)$内求出一棵树中任意两点间边权的最大值和次大值（当然还有更优化的方法比如LCA）。</p>
<blockquote>
<p>问题：<code>dist[][]</code>不是二维数组嘛？为什么传参进入dfs函数时，就传了一维数组<code>dist[]</code>呢？</p>
<p>其实我们在传参进入dfs函数时，虽然只是传了一维数组<code>dist[]</code>，但是我们还传了是第几行$i$。我们知道$dist1[i][j_1]$表示节点$i$和节点$j_1$之间的边权的最大值，$dist1[i][j_2]$表示节点$i$和节点$j_2$之间的边权的最大值。也就是说，当我们传入行号$i$时，只需要传入一维数组<code>dist[]</code>，但是这个一维数组的含义其实就是：<code>dist[i]</code>存储的是所有从$i$出发，所能到达的节点的之间的边权的最大值，即我们更新时，是把整个第$i$行都更新了，而不是只单单更新某个$dist[i][j]$。</p>
</blockquote>
<p>这里还有一点需要注意，在dfs时，由于树中的边是无向边，假设节点$a$和节点$b$之间有一条无向边，设$a$在前面，$b$在后面。当搜到节点$a$时，就遍历了这条无向边了。通过这条无向边遍历到了邻接点$b$。但是当搜到节点$b$时，我们不能让它往回搜索了，也就是不能让它通过这条无向边又去遍历到邻接点$a$，因为这条无向边已经被搜索过了，为了防止一直在这里死循环，可以设置一个<code>father</code>标志记录上一个节点的编号。假设当前搜到节点$i$，设节点$i$是从节点$father$走过来的，然后遍历到它的邻接点$j$，只有当$j\neq father$时，才能保证不往回搜索。</p>
<p>当然也可以用一个st数组来标记每个节点是否已经被搜索过了，防止往回搜索。</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>写法1：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//M是原图中的所有边</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">510</span>,M=<span class="number">10010</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a,b,w;</span><br><span class="line">    <span class="keyword">bool</span> flag;  <span class="comment">//标记是否为树边  如果为true则说明是树边 如果是false则说明是非树边</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge&amp; W)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w&lt;W.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"><span class="comment">//无向边  树中有n个节点,则有n-1条边,所以边数为2(n-1)</span></span><br><span class="line"><span class="comment">//注意这里邻接表中的边是指对这棵最小生成树建图后的边</span></span><br><span class="line"><span class="comment">//而不是指原图中的所有边</span></span><br><span class="line"><span class="keyword">int</span> h[N],e[<span class="number">2</span>*N],ne[<span class="number">2</span>*N],w[<span class="number">2</span>*N],idx;</span><br><span class="line"><span class="comment">//dist1[i][j]表示从节点i和节点j之间路径上的某条边的权值最大,即最大边</span></span><br><span class="line"><span class="comment">//dist2[i][j]表示从节点i和节点j之间路径上的某条边的权值次大,即次大边</span></span><br><span class="line"><span class="keyword">int</span> dist1[N][N],dist2[N][N];</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    w[idx]=c;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x!=p[x])</span><br><span class="line">        p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Kruskal算法求出最小生成树的权值总和</span></span><br><span class="line"><span class="function">LL <span class="title">Kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(edges,edges+m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        p[i]=i;</span><br><span class="line">    LL res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="built_in">find</span>(edges[i].a);</span><br><span class="line">        <span class="keyword">int</span> b=<span class="built_in">find</span>(edges[i].b);</span><br><span class="line">        <span class="keyword">int</span> w=edges[i].w;</span><br><span class="line">        <span class="keyword">if</span>(a!=b)</span><br><span class="line">        &#123;</span><br><span class="line">            p[a]=b;</span><br><span class="line">            res+=w;</span><br><span class="line">            edges[i].flag=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意：Kruskal算法只是能够求出最小生成树的权值总和,但是并没有把这棵最小生成树建图出来</span></span><br><span class="line"><span class="comment">//因此这里的build函数是把这棵最小生成树用图建立出来</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="comment">//枚举这m条边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果是树边,则说明是最小生成树中的边</span></span><br><span class="line">        <span class="keyword">if</span>(edges[i].flag)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a=edges[i].a;</span><br><span class="line">            <span class="keyword">int</span> b=edges[i].b;</span><br><span class="line">            <span class="keyword">int</span> w=edges[i].w;</span><br><span class="line">            <span class="comment">//最小生成树中的边都是无向边</span></span><br><span class="line">            <span class="built_in">add</span>(a,b,w);</span><br><span class="line">            <span class="built_in">add</span>(b,a,w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//暴力解决任意两个点之间的最大边和次大边</span></span><br><span class="line"><span class="comment">//u表示当前的搜索节点  fa表示节点u的上一个节点  即u是从fa走过来的</span></span><br><span class="line"><span class="comment">//maxd1表示最大边  maxd2表示次大边</span></span><br><span class="line"><span class="comment">//d1[i]记录的是从节点i出发所能到达所有节点的最大边 即d1[i]=&#123;d1[i][0],d1[i][1],...,d1[i][n-1]&#125;</span></span><br><span class="line"><span class="comment">//d2[i]记录的是从节点i出发所能到达所有节点的次大边 即d2[i]=&#123;d2[i][0],d2[i][1],...,d2[i][n-1]&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa,<span class="keyword">int</span> maxd1,<span class="keyword">int</span> maxd2,<span class="keyword">int</span> d1[],<span class="keyword">int</span> d2[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    d1[u]=maxd1;    <span class="comment">//把dist1中第u行的所有列都赋值为maxd1   </span></span><br><span class="line">    d2[u]=maxd2;    <span class="comment">//把dist2中第u行的所有列都赋值为maxd2</span></span><br><span class="line">    <span class="comment">//遍历u的所有邻接点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];~i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j=e[i];</span><br><span class="line">        <span class="comment">//避免往回重复搜索</span></span><br><span class="line">        <span class="keyword">if</span>(j!=fa)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> td1=maxd1;  <span class="comment">//td1是最大边</span></span><br><span class="line">            <span class="keyword">int</span> td2=maxd2;  <span class="comment">//td2是次大边</span></span><br><span class="line">            <span class="comment">//非树边w[i]严格大于最小生成树中的最大边td1,则直接进行可行变换即可</span></span><br><span class="line">            <span class="keyword">if</span>(w[i]&gt;td1)</span><br><span class="line">            &#123;</span><br><span class="line">                td2=td1;    <span class="comment">//先更新次大边</span></span><br><span class="line">                td1=w[i];   <span class="comment">//再更新最大边</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//否则,如果非树边w[i]严格小于最小生成树中的最大边td1,但是严格大于最小生成树中的次大边td2</span></span><br><span class="line">            <span class="comment">//那么可以用这条非树边去代替次大边</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(w[i]&lt;td1&amp;&amp;w[i]&gt;td2)</span><br><span class="line">            &#123;</span><br><span class="line">                td2=w[i];   <span class="comment">//更新次大边</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//接着递归搜索从节点j出发</span></span><br><span class="line">            <span class="built_in">dfs</span>(j,u,td1,td2,d1,d2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="comment">//读入m条边的信息</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;w);</span><br><span class="line">        edges[i]=&#123;a,b,w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用Kruskal算法求出最小生成树的权值总和</span></span><br><span class="line">    LL sum=<span class="built_in">Kruskal</span>();</span><br><span class="line">    <span class="comment">//对这棵最小生成树建图</span></span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    <span class="comment">//依次枚举从节点1~节点n出发,任意两点之间的最大边和次大边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">dfs</span>(i,<span class="number">-1</span>,<span class="number">-1e9</span>,<span class="number">-1e9</span>,dist1[i],dist2[i]);</span><br><span class="line">    LL res=<span class="number">1e18</span>;    <span class="comment">//次小生成树的权值总和</span></span><br><span class="line">    <span class="comment">//枚举每一条非树边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!edges[i].flag)<span class="comment">//非树边</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a=edges[i].a;</span><br><span class="line">            <span class="keyword">int</span> b=edges[i].b;</span><br><span class="line">            <span class="keyword">int</span> w=edges[i].w;</span><br><span class="line">            LL t;   <span class="comment">//次小生成树的权值总和</span></span><br><span class="line">            <span class="comment">//非树边w[i]严格大于最小生成树中的最大边dist1[a][b],则直接进行替换最大边</span></span><br><span class="line">            <span class="keyword">if</span>(w&gt;dist1[a][b])</span><br><span class="line">                t=sum+w-dist1[a][b];</span><br><span class="line">            <span class="comment">//否则,非树边严格大于最小生成树中的次大边dist2[a][b],则直接进行替换次大边</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(w&gt;dist2[a][b])</span><br><span class="line">                t=sum+w-dist2[a][b];</span><br><span class="line">            res=<span class="built_in">min</span>(res,t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写法2：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>, M = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, w;</span><br><span class="line">    <span class="keyword">bool</span> flag;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Edge&amp; t)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; t.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"><span class="keyword">int</span> dist1[N][N], dist2[N][N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="keyword">int</span> h[N], e[N*<span class="number">2</span>], ne[N*<span class="number">2</span>], w[N*<span class="number">2</span>], idx;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x != p[x]) </span><br><span class="line">        p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">Kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(edges,edges+m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        p[i]=i;</span><br><span class="line">    LL res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="built_in">find</span>(edges[i].a);</span><br><span class="line">        <span class="keyword">int</span> b=<span class="built_in">find</span>(edges[i].b);</span><br><span class="line">        <span class="keyword">int</span> w=edges[i].w;</span><br><span class="line">        <span class="keyword">if</span>(a!=b)</span><br><span class="line">        &#123;</span><br><span class="line">            p[a]=b;</span><br><span class="line">            res+=w;</span><br><span class="line">            edges[i].flag=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> u, <span class="keyword">int</span> maxd1, <span class="keyword">int</span> maxd2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dist1[root][u] = maxd1;</span><br><span class="line">    dist2[root][u] = maxd2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (st[j]) </span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        st[j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> td1 = maxd1;</span><br><span class="line">        <span class="keyword">int</span> td2 = maxd2;</span><br><span class="line">        <span class="keyword">if</span> (w[i] &gt; td1) </span><br><span class="line">            td2 = td1, td1 = w[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(w[i]!=td1 &amp;&amp; w[i] &gt; td2) </span><br><span class="line">            td2 = w[i];</span><br><span class="line">        <span class="built_in">dfs</span>(root,j, td1, td2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="comment">//枚举这m条边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果是树边,则说明是最小生成树中的边</span></span><br><span class="line">        <span class="keyword">if</span>(edges[i].flag)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a=edges[i].a;</span><br><span class="line">            <span class="keyword">int</span> b=edges[i].b;</span><br><span class="line">            <span class="keyword">int</span> w=edges[i].w;</span><br><span class="line">            <span class="comment">//最小生成树中的边都是无向边</span></span><br><span class="line">            <span class="built_in">add</span>(a,b,w);</span><br><span class="line">            <span class="built_in">add</span>(b,a,w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        edges[i] = &#123;a, b, c&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    LL sum=<span class="built_in">Kruskal</span>();</span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(i, i, <span class="number">-1e9</span>, <span class="number">-1e9</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    LL res = <span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++ ) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!edges[i].flag)</span><br><span class="line">        &#123;</span><br><span class="line">            LL t;</span><br><span class="line">            <span class="keyword">int</span> a = edges[i].a;</span><br><span class="line">            <span class="keyword">int</span> b = edges[i].b;</span><br><span class="line">            <span class="keyword">int</span> w = edges[i].w;</span><br><span class="line">            <span class="keyword">if</span> (w &gt; dist1[a][b]) </span><br><span class="line">                t = sum - dist1[a][b] + w;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                t = sum - dist2[a][b] + w;</span><br><span class="line">            res = <span class="built_in">min</span>(res, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>最小生成树</category>
      </categories>
      <tags>
        <tag>最小生成树的扩展应用</tag>
      </tags>
  </entry>
  <entry>
    <title>新的开始</title>
    <url>/2021/07/25/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E6%89%A9%E5%B1%95%E5%BA%94%E7%94%A8/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/</url>
    <content><![CDATA[<h1 id="新的开始"><a href="#新的开始" class="headerlink" title="新的开始"></a>新的开始</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210725122343.png" alt="image-20210725122343693"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>这个题目有点特殊，我们把每个矿井都看作图中的一个节点，由于在矿井$i$上建立一个发电站，需要费用$v_i$，也就是说节点上是有权值的。然后题目想要问的是连通所有节点所需要的最小花费，这很明显其实就是想要求最小生成树。</p>
<p>题目中的第一个方法表明了每个节点上是可以有权值的；第二个方法表明了节点之间的边是有权值的。如果只有边权，那么就是我们熟悉的模型，直接求解这个图的最小生成树即可。但是特别之处在于节点也是有权值的，因此我们就不能对这张图直接求解最小生成树了。需要做如下转化：</p>
<p>我们可以建立一个虚拟源点（超级发电站），如果某个矿井$i$上有权值$v_i$，那么我们就转化为虚拟源点到这个节点之间的边权为$v_i$，也就是说我们巧妙地把节点的权值转移到了虚拟源点与该节点之间的边的权值，而且是等效的。那么，我们通过这么做之后，就会得到一张$n+1$个节点的新图，而且这个新图只有边是有权值的，顶点不再带有权值，于是就转化为了我们熟悉的模型，那么就可以对这张新图直接求解最小生成树了。</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210725123841.png" alt="image-20210725123841634"></p>
<p>举个栗子：</p>
<p>拿题目样例解释：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210725124421.png" alt="image-20210725124421133"></p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>写法1：prim算法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">310</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="comment">//prim算法求解最小生成树</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;  <span class="comment">//让所有矿井获得充足电能的最小花费</span></span><br><span class="line">    <span class="comment">//初始化每个节点到S集合的距离为正无穷</span></span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="comment">//初始化虚拟源点到达S集合的距离为0</span></span><br><span class="line">    dist[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//由于最终形成的最小生成树中有n+1个节点</span></span><br><span class="line">    <span class="comment">//每跑一趟循环就能把一个节点加入S集合,有n+1个节点,因此需要跑n+1次循环</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n+<span class="number">1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//t记录的是此时距离S集合最近的点</span></span><br><span class="line">        <span class="keyword">int</span>  t=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span>(!st[j]&amp;&amp;(t==<span class="number">-1</span>||dist[t]&gt;dist[j]))</span><br><span class="line">                t=j;</span><br><span class="line">        <span class="comment">//标记点t已经被加入了S集合</span></span><br><span class="line">        st[t]=<span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//累加最小生成树的权值</span></span><br><span class="line">        res+=dist[t];</span><br><span class="line">        <span class="comment">//枚举节点t的所有邻接点  更新这些点到集合S的距离</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=n;k++)</span><br><span class="line">            dist[k]=<span class="built_in">min</span>(dist[k],g[t][k]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="comment">//将矿井节点上的权值vi转化为虚拟源点与该节点之间的边权</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w);</span><br><span class="line">        <span class="comment">//最小生成树无向图  </span></span><br><span class="line">        g[<span class="number">0</span>][i]=g[i][<span class="number">0</span>]=w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输入矿井i和矿井j之间建立电网的费用</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;g[i][j]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">prim</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写法2：Kruskal算法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">310</span>,M=N*N;</span><br><span class="line"><span class="keyword">int</span> n,cnt;      <span class="comment">//cnt是总共的边数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a,b,w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge&amp; W)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w&lt;W.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x!=p[x])</span><br><span class="line">        p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sort</span>(edges,edges+cnt);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">        p[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="built_in">find</span>(edges[i].a);</span><br><span class="line">        <span class="keyword">int</span> b=<span class="built_in">find</span>(edges[i].b);</span><br><span class="line">        <span class="keyword">int</span> w=edges[i].w;</span><br><span class="line">        <span class="keyword">if</span>(a!=b)</span><br><span class="line">        &#123;</span><br><span class="line">            p[a]=b;</span><br><span class="line">            res+=w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w);</span><br><span class="line">        edges[cnt++]=&#123;<span class="number">0</span>,i,w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> w;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w);</span><br><span class="line">            edges[cnt++]=&#123;i,j,w&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">Kruskal</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>最小生成树</category>
      </categories>
      <tags>
        <tag>最小生成树的扩展应用</tag>
      </tags>
  </entry>
  <entry>
    <title>局域网</title>
    <url>/2021/07/24/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/%E5%B1%80%E5%9F%9F%E7%BD%91/</url>
    <content><![CDATA[<h1 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210724120055.png" alt="image-20210724120055096"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>题意：给定一张有$n$个点，$k$条边的无向有环图，要求删掉其中部分边，且不改变图的连通性的情况下，使得最终的图仍然是连通的不存在环，并且删除的边权之和最大，输出最大的所删边边权权和。从题意我们可以发现：</p>
<p>删边权和最大$\implies$ 剩下边权和最小 $\implies$ 求最小生成树</p>
<p>但是题中并没有说图一定连通，这让这道题恶心了很多。也就是说，图中可能存在多棵树，这些树并不在同一个连通块中。假设有$A_1$，$A_2$，$A_3$这三颗树，它们都是独立的连通块，那么我们需要求出每树的最小生成树，不妨设为$x_1,x_2,x_3$，设这三棵树边权总和为$sum$，那么最终删除的边权之和最大为$sum-(x_1+x_2+x_3)$。</p>
<p>说到连通块，我们很容易想到Kruskal算法，它也是利用连通块思想来求解最小生成树。因此，这题我们可以采用Kruskal算法来求解，对于一棵树来说，如果两个点不在同一个集合中，则说明它是最小生成树中的边，那么就可以累加边权。如果两个点已经在一个集合中了，根据Kruskal算法思想，则不需要累加边权了。</p>
<p>当然这题也是可以用prim算法的。</p>
<p>下面给出一个有多棵树的栗子：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210724122230.png" alt="image-20210724122230651"></p>
<p>如图所示：</p>
<p>将所有边权从小到大排好序，初始化每个节点都是独立集合（独立的连通块），设$ans=0$</p>
<ul>
<li>对于树$A$，节点$1$和节点$2$起初都是独立的集合，那么可以使用并查集进行合并，因此需要累加边权，即$ans+=w$，也就是$ans=0+10=10$，此时树$A$就已经是一个连通块了</li>
<li>对于树$B$，由于$(3,4)$边权小，所有选择这条边，节点$3,4$起初都是独立的集合，那么可以使用并查集进行合并，更新节点$4$的祖宗节点为$3$，因此需要累加边权，即$ans+=w$，也就是$ans=10+11=21$，此时节点$3$和节点$4$就属于同一个连通块了。接着由于$(4,5)$边权小，所以选择这条边，经过上一步的操作后，此时$(3,4)$属于一个连通块，而$5$是独立的一个集合，因此$5$属于另一个连通块，那么可以使用并查集进行合并，更新节点$5$的祖宗节点为$3$，因此需要累加边权，即$ans+=w$，也就是$ans=21+12=33$，此时$(3,4,5)$已经在同一个连通块中了。最后选择$(3,5)$这条边，但是由于$(3,4,5)$已经在同一个连通块中了，所以此时$(3,5)$这条边并不需要累加权值。也就是说$(3,5)$这条边并不是最小生成树上的边。所以$ans$仍为$33$，树$B$的最小生成树的边有$(3,4)$和$(4,5)$</li>
<li>对于树$C$，由于$(7,6)$边权小，所以选择这条边，节点$7,6$起初都是独立的集合，那么可以使用并查集进行合并，更新节点$7$的祖宗节点为$6$，因此需要累加边权，即$ans+=w$，也就是$ans=33+14=47$，那么此时节点$7$和节点$6$就已经在同一个连通块中了。接着考虑$(6,7)$这条边，由于$(6,7)$已经在同一个连通块中了，所以这条边并不需要累加权值。也就是说$(6,7)$这条边并不是最小生成树上的边。所以$ans$仍为$47$，树$C$的最小生成树的边有$(7,6)$</li>
<li>由于这三颗树的边权总和为$sum=75$，而我们已经求出了这三棵树的最小生成树之和为$47$，那么需要删除的边的最大权值为$sum-res=75-47=28$，也就是图中的红色边</li>
</ul>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>写法1：Kruskal算法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">110</span>,M=<span class="number">210</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a,b,w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge&amp; W)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w&lt;W.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x!=p[x])</span><br><span class="line">        p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(edges,edges+m);    <span class="comment">//将边权从小到大排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   <span class="comment">//初始化每个点都是独立的集合</span></span><br><span class="line">        p[i]=i;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;      <span class="comment">//最小生成树的权值</span></span><br><span class="line">    <span class="comment">//由于边已经排好序了  所以这里是优先选择小的边</span></span><br><span class="line">    <span class="comment">//要注意这些边并不都是连通的  (存在多个非连通块)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="built_in">find</span>(edges[i].a);</span><br><span class="line">        <span class="keyword">int</span> b=<span class="built_in">find</span>(edges[i].b);</span><br><span class="line">        <span class="keyword">int</span> w=edges[i].w;</span><br><span class="line">        <span class="comment">//对于每个连通块来说,我们都只会在当两个节点的集合号不同时 才累加权值</span></span><br><span class="line">        <span class="comment">//因为Kruskal算法就是当合并两个集合时,才累加了边权,而如果已经在同一个连通块中了,那么就不会累加</span></span><br><span class="line">        <span class="keyword">if</span>(a!=b)</span><br><span class="line">        &#123;</span><br><span class="line">            p[a]=b;</span><br><span class="line">            <span class="comment">//只有不在同一集合时,才累加权值</span></span><br><span class="line">            res+=w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回最小生成树的权值</span></span><br><span class="line">    <span class="keyword">return</span> res;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;w);</span><br><span class="line">        edges[i]=&#123;a,b,w&#125;;</span><br><span class="line">        <span class="comment">//计算全部边权的总和</span></span><br><span class="line">        sum+=w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t=<span class="built_in">Kruskal</span>();</span><br><span class="line">    <span class="comment">//总和减去最小生成树,那么剩下的其实就是被除去网线的最大值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum-t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写法2：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">110</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="comment">//prim算法需要用到邻接矩阵</span></span><br><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="comment">//dist[i]表示节点i到集合S的距离</span></span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="comment">//st[i]=true表示节点i已经被加入了集合S中</span></span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="comment">//prim算法求解最小生成树</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span>(!st[j]&amp;&amp;(t==<span class="number">-1</span>||dist[t]&gt;dist[j]))</span><br><span class="line">                t=j;</span><br><span class="line">        <span class="keyword">if</span>(i&amp;&amp;dist[t]==INF)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(i)</span><br><span class="line">            res+=dist[t];</span><br><span class="line">        st[t]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">            dist[k]=<span class="built_in">min</span>(dist[k],g[t][k]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(g,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> g);    <span class="comment">//初始化邻接矩阵为正无穷</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">int</span> total;  <span class="comment">//记录输入的所有子树的权值总和</span></span><br><span class="line">    <span class="keyword">while</span>(k--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        <span class="comment">//防止重边和自环</span></span><br><span class="line">        g[a][b]=g[b][a]=<span class="built_in">min</span>(g[a][b],c);</span><br><span class="line">        <span class="comment">//算出整个森林的边权总和</span></span><br><span class="line">        total+=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//由于题目给定的树不一定都是连通的,也就是说可能存在多个互不连通的树,即存在多个连通块</span></span><br><span class="line">    <span class="comment">//依次求解每颗树中的最小生成树</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果还没有处理节点i所在的树,则去求解i所在的这颗树的最小生成树</span></span><br><span class="line">        <span class="keyword">if</span>(!st[i])</span><br><span class="line">            total-=<span class="built_in">prim</span>();  <span class="comment">//用总和减去每一颗树的最小生成树</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,total);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>最小生成树</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>走廊泼水节</title>
    <url>/2021/07/25/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E6%89%A9%E5%B1%95%E5%BA%94%E7%94%A8/%E8%B5%B0%E5%BB%8A%E6%B3%BC%E6%B0%B4%E8%8A%82/</url>
    <content><![CDATA[<h1 id="走廊泼水节"><a href="#走廊泼水节" class="headerlink" title="走廊泼水节"></a>走廊泼水节</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210725210138.png" alt="image-20210725210138528"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>题目的意思是：现在有一张图，已知了这张图的最小生成树了，然后我们需要把这张图变成完全图（任意两个节点之间都有边相连），使得这张完全图中的最小生成树仍然与原图的最小生成树是同一颗。把原图变成完全图，就需要加边，题目想要我们求的是加的这些边的权值总和的最小值。</p>
<p>设当前扫描到边$(x,y)$，其权值为$z$，设$x$所在连通块为$S_x$，$y$所在连通块为$S_y$，此时应该合并$S_x$与$S_y$。合并后的$S_x\cup S_y$构成一棵树的结构。</p>
<p>$\forall u\in S_x$，$v\in S_y$，如果$(u,v)\neq(x,y)$，则在最终的完全图中，我们肯定需要在$(u,v)$之间增加一条边。于是，无向边$(u,v)$、$S_x$中从$u$到$x$的路径、无向边$(x,y)$、$S_y$中从$v$到$y$的路径，就形成了一个环，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210725211301.png" alt="image-20210725211301315"></p>
<p>为了保证$(x,y)$一定在最小生成树中，就必须让$(x,y)$是连接集合$S_x$和集合$S_y$的权值最小的边（否则就可以用边$(u,v)$去代替边$(x,y)$形成一棵最小生成树了，这与已有的最小生成树有矛盾）。因此，为了保证所添加的这些边的权值总和最小，那么可以让所有新添加的这些边的权值都为$z+1$。</p>
<p>设集合$S_x$中有$|S_x|$个节点，集合$S_y$中有$|S_y|$个节点，由于完全图是任意两个节点之间都需要有边相连，因此总共需要$|S_x|\times|S_y|$条边，但是由于边$(x,y)$已经是原图中已有的一条连接$S_x$和$S_y$这两个连通块中的一条边了，因此应该从$|S_x|\times|S_y|$减去这条已有的连接边。也就是说，合并$S_x$和$S_y$这两个连通块，需要边数为$|S_x|\times|S_y|-1$，由于每条边的权值都为$z+1$。因此增加的边的权值总和最小是$(z+1)\times$$(|S_x|\times|S_y|-1)$</p>
<blockquote>
<p>问题：为什么新添加的边权一定是$z+1$，而不能是$z$或者小于$z$呢？如何理解$(z+1)\times$$(|S_x|\times|S_y|-1)$这个式子呢？</p>
<p>如下图所示：可以发现，合并了两个连通块后，所形成的这个连通块就已经是完全图了，以此类推，合并完所有的连通块后，所得到的最终那个连通块就是完全图。</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210725214411.png" alt="image-20210725214411648"></p>
</blockquote>
<p>总结一下就是：</p>
<p>假设有两个连通块$A,B$，要扩展为完全图，那么就需要$A$中的每个节点都与$B$中的每个节点相连。对于一条最小生成树上的边$E$，可以看作$E$连接了$A$和$B$这两个连通块，那么要将$A$和$B$连接成一个完全图需要添加的边数就是$cnt[A]\times cnt[B]-1$，减去1就是减去已经存在的$E$这条边，其中$cnt[A]$表示连通块$A$中的节点数，$cnt[B]$表示连通块$B$中的节点数。设$E$的边权为$z$，由上图的可知，新增加的边权不可能$\leq z$，必须是$&gt;z$的。为了让增加的边权总和最小，则需要让新增加的边权为$z+1$就好了。</p>
<p>那么合并这两个连通块的花费就是$(z+1)\times(cnt[A]\times cnt[B]-1)$。设<code>ans</code>是答案，那么在每次合并连通块时，让$ans$累加上花费就好了。</p>
<p>还有一点，题目要求的是最小的完全图，因此采用贪心的策略：先把树上的边按权值从小到大排序，然后依次枚举即可。</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">6010</span>,M=N;</span><br><span class="line"><span class="comment">//n是点数  m是边数</span></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a,b,w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge&amp; W)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w&lt;W.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"><span class="keyword">int</span> cnt[N];     <span class="comment">//cnt[i]表示第i个连通块中点的数量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x!=p[x])</span><br><span class="line">        p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;  <span class="comment">//增加的边的权值总和最小值</span></span><br><span class="line">    <span class="built_in">sort</span>(edges,edges+m);    <span class="comment">//将边权从小到大排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i]=i;     <span class="comment">//初始化并查集  每个点都是独立的连通块</span></span><br><span class="line">        cnt[i]=<span class="number">1</span>;   <span class="comment">//由于每个点都是独立的连通块  所以每个连通块内只有1个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="built_in">find</span>(edges[i].a);</span><br><span class="line">        <span class="keyword">int</span> b=<span class="built_in">find</span>(edges[i].b);</span><br><span class="line">        <span class="keyword">int</span> w=edges[i].w;</span><br><span class="line">        <span class="keyword">if</span>(a!=b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//每次合并两个连通块都会产生(cnt[a]*cnt[b]-1)*(w+1)的开销</span></span><br><span class="line">            <span class="comment">//所以要让res累加这些开销</span></span><br><span class="line">            res+=(cnt[a]*cnt[b]<span class="number">-1</span>)*(w+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//将a这个连通块中所有点的数量都累加到b这个连通块中</span></span><br><span class="line">            cnt[b]+=cnt[a];</span><br><span class="line">            <span class="comment">//将集合a合并到集合b,现在a的祖宗节点是b</span></span><br><span class="line">            p[a]=b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="comment">//根据题目输入可以知道 有n个点 则有n-1条边</span></span><br><span class="line">        m=n<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//读入m条边的信息</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a,b,w;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;w);</span><br><span class="line">            edges[i]=&#123;a,b,w&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> t=<span class="built_in">Kruskal</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>最小生成树</category>
      </categories>
      <tags>
        <tag>最小生成树的扩展应用</tag>
      </tags>
  </entry>
  <entry>
    <title>繁忙的都市</title>
    <url>/2021/07/24/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/%E7%B9%81%E5%BF%99%E7%9A%84%E9%83%BD%E5%B8%82/</url>
    <content><![CDATA[<h1 id="繁忙的都市"><a href="#繁忙的都市" class="headerlink" title="繁忙的都市"></a>繁忙的都市</h1><hr>
<h3 id="繁忙的都市-1"><a href="#繁忙的都市-1" class="headerlink" title="繁忙的都市"></a>繁忙的都市</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210724132410.png" alt="image-20210724132410163"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>从题目中可以知道，$n$个交叉路口其实就是$n$个顶点，道路是双向的说明是无向边，把所有的交叉路口直接或间接的连通起来也就是说最终这$n$个节点是连通的，改造的那些道路中分值最大值尽量小也就是说选中的那些道路的边权应该尽可能小。从这些信息中可以知道，这不就是与最小生成树的含义类似嘛？其实题目也是想要求最小生成树中的那个最大边。</p>
<p>我们知道，对于Kruskal算法来说，它将所有边权从小到大排序，然后依次从边权小的开始选择，进行合并，形成一个连通块，最终就会得到一个含有$n-1$条边的连通块。由于选择边是从小到大进行选择的，因此最后选择的那条边一定是最小生成树中的最大边（注意原因就是因为Kruskal算法是贪心本质，每次贪心选择边权最小的）</p>
<p>因此，我们只需要跑以下Kruskal算法，然后每次选择边时，使用变量<code>res</code>来记录就好了，即$res=w$，那最后一次选择的那条边其实就是最小生成树中的最大边了。</p>
<p>当然这题也可以用prim算法来求解，也就是每次将节点加入$S$集合时，都进行$res=max(res,w)$，一直到所有节点都被加入了$S$集合中，那么最终得到的$res$就是最大的边。</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>写法1：Kruskal算法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">310</span>,M=<span class="number">8010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a,b,w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge &amp;W)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w&lt;W.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x!=p[x])</span><br><span class="line">        p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(edges,edges+m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        p[i]=i;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="built_in">find</span>(edges[i].a);</span><br><span class="line">        <span class="keyword">int</span> b=<span class="built_in">find</span>(edges[i].b);</span><br><span class="line">        <span class="keyword">int</span> w=edges[i].w;</span><br><span class="line">        <span class="keyword">if</span>(a!=b)</span><br><span class="line">        &#123;</span><br><span class="line">            p[a]=b;</span><br><span class="line">            <span class="comment">//由于Kruskal算法已经把边权从小到大排序了,因此最后选择的那个最小生成树中的边</span></span><br><span class="line">            <span class="comment">//一定是最大的了    当然也可以写成res=max(res,w);</span></span><br><span class="line">            res=w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最小生成树中含有n个点,那么一定有n-1条边 所以一定会选出n-1条边</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,n<span class="number">-1</span>,res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;w);</span><br><span class="line">        edges[i]=&#123;a,b,w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Kruskal</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>prim算法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">310</span>,M=<span class="number">8010</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span>(!st[j]&amp;&amp;(t==<span class="number">-1</span>||dist[t]&gt;dist[j]))</span><br><span class="line">                t=j;</span><br><span class="line">        <span class="comment">// if(i&amp;&amp;dist[t])</span></span><br><span class="line">        <span class="comment">//     return INF;</span></span><br><span class="line">        <span class="keyword">if</span>(i)</span><br><span class="line">            res=<span class="built_in">max</span>(res,dist[t]);</span><br><span class="line">        st[t]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">            dist[k]=<span class="built_in">min</span>(dist[k],g[t][k]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(g,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> g);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        g[a][b]=g[b][a]=<span class="built_in">min</span>(g[a][b],c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t=<span class="built_in">prim</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,n<span class="number">-1</span>,t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>最小生成树</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>连接格点</title>
    <url>/2021/07/24/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/%E8%BF%9E%E6%8E%A5%E6%A0%BC%E7%82%B9/</url>
    <content><![CDATA[<h1 id="连接格点"><a href="#连接格点" class="headerlink" title="连接格点"></a>连接格点</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210724180555.png" alt="image-20210724180555744"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>通过阅读题目，设有$n$行$m$列，那么总共有$n\times m$个点，就相当于图中有$n\times m$个顶点。然后想用一些边，来使得所有顶点都能够连通，并且这些边权之和最小。那么这与最小生成树的含义是相同的。因此，透过题意我们知道其实就是想要求最小生成树。</p>
<p>但是题目还是有点特殊的，一条纵向的连线花费一个单位，一条横向的连线花费两个单位，也就是说边权只能是1或者2，而且某些点之间已经有连线了，也就是说有些顶点已经有边连接起来了。</p>
<p>我们将已有连线的这些点所形成的各个连通块都分别看作是一个个”新的节点”，设有x个”新的节点”，现在需要用 边 来连接这x个”新的节点”，并且使得所用边的权值总和最小。有x个”新的节点”,那么就需要x-1条边才能来连通,因为竖边的花费少,所以就先尽量用竖边,然后剩下的用横边,也就是贪心。</p>
<p>由于有连通块和并查集，因此我们使用Kruskal算法来求解最小生成树。但是我们这里并不对所有边排序。因为：有$n\times(m-1)$条横边，有$m\times(n-1)$条竖边，因此最多有$n\times(m-1)+m\times(n-1)=2nm-n-m$，$n$和$m$最坏取到$1000$，所以最多有$2\times1000\times1000-1000-1000=1998000$，约两百万条边。如果给这两百万条边排序的话，时间其实也是可以的，但是这里提供一种更加优化的方法：</p>
<p>由于Kruskal算法是排序后，优先选择边权小的那些边，然后再选择边权大的那些边。那么我们这里这么做：</p>
<p>优先挑选了边权为1的边作为最小生成树中的边,然后再挑选边权为2的边作为最小生成树中的边，可以发现这种做法中选边也是按边权从小到大进行，这其实就等效于排序了。</p>
<p>因此，我们只需要先尽量选择那些边权为1的竖边来建图，然后再选择那些边权为2的横边来建图，那么就可以不需要排序了，这样就省去了给所有边排序的时间。</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 在求解MST的过程之中，我们首先连好竖向的边，然后再连横向边.我们通过并差集解决这个问题.</span></span><br><span class="line"><span class="comment"> * 我们将已有连线的这些点所形成的各个连通块都分别看作是一个个&quot;新的节点&quot;,设有x个&quot;新的节点&quot;</span></span><br><span class="line"><span class="comment"> * 现在需要用 边 来连接这x个&quot;新的节点&quot;,并且使得所用边的权值总和最小</span></span><br><span class="line"><span class="comment"> * 有x个&quot;新的节点&quot;,那么就需要x-1条边才能来连通,因为竖边的花费少,所以就先尽量用竖边,然后剩下的用横边,也就是贪心</span></span><br><span class="line"><span class="comment"> * 过程分三个阶段:</span></span><br><span class="line"><span class="comment"> *      (1)先将已经连好的边加入并差集</span></span><br><span class="line"><span class="comment"> *      (2)然后是枚举所有竖向相邻的点</span></span><br><span class="line"><span class="comment"> *      (3)最后是横向相连的点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//N是点的数量  M的边的数量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> A=<span class="number">1010</span>,N=A*A,M=<span class="number">2</span>*A*A;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"><span class="comment">//将二维坐标转换成一维编号</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x<span class="number">-1</span>)*m+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x!=p[x])</span><br><span class="line">        p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n*m;i++)</span><br><span class="line">        p[i]=i;</span><br><span class="line">    <span class="keyword">int</span> x1,y1,x2,y2;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="built_in">get</span>(x1,y1);</span><br><span class="line">        <span class="keyword">int</span> b=<span class="built_in">get</span>(x2,y2);</span><br><span class="line">        p[<span class="built_in">find</span>(a)]=<span class="built_in">find</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里进行Kruskal算法时 为什么不需要对边排序呢？</span></span><br><span class="line">    <span class="comment">//因为我们是优先挑选了边权为1的边作为最小生成树中的边,然后再挑选边权为2的边作为最小生成树中的边</span></span><br><span class="line">    <span class="comment">//因此其实就相当于对边权排序了,因为Kruskal算法也是按边权从小到大先选择边权小的边,然后再选择边权大的边</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//先处理边权为1的竖边</span></span><br><span class="line">    <span class="comment">//这里不能写成i&lt;=n   因为我们用到了i+1 因此当i=n时,i+1就是n+1了,就会越界</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//a和b这上下两个点就构成了一条竖边</span></span><br><span class="line">            <span class="keyword">int</span> a=<span class="built_in">get</span>(i,j);</span><br><span class="line">            <span class="keyword">int</span> b=<span class="built_in">get</span>(i+<span class="number">1</span>,j);</span><br><span class="line">            <span class="keyword">int</span> pa=<span class="built_in">find</span>(a);</span><br><span class="line">            <span class="keyword">int</span> pb=<span class="built_in">find</span>(b);</span><br><span class="line">            <span class="keyword">if</span>(pa!=pb)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//累加边权为1的竖边</span></span><br><span class="line">                res+=<span class="number">1</span>;</span><br><span class="line">                p[pa]=pb;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//再处理边权为2的横边</span></span><br><span class="line">    <span class="comment">//这里不能写成j&lt;=m   因为我们用到了j+1 因此当j=m时,j+1就是m+1了,就会越界</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//a和b这左右两个点就构成了一条横边</span></span><br><span class="line">            <span class="keyword">int</span> a=<span class="built_in">get</span>(i,j);</span><br><span class="line">            <span class="keyword">int</span> b=<span class="built_in">get</span>(i,j+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> pa=<span class="built_in">find</span>(a);</span><br><span class="line">            <span class="keyword">int</span> pb=<span class="built_in">find</span>(b);</span><br><span class="line">            <span class="keyword">if</span>(pa!=pb)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//累加边权为2的横边</span></span><br><span class="line">                res+=<span class="number">2</span>;</span><br><span class="line">                p[pa]=pb;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>最小生成树</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>联络员</title>
    <url>/2021/07/24/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/%E8%81%94%E7%BB%9C%E5%91%98/</url>
    <content><![CDATA[<h1 id="联络员"><a href="#联络员" class="headerlink" title="联络员"></a>联络员</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210724150001.png" alt="image-20210724150001282"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>管理员可以看作是节点，所有管理员两两之间需要直接或间接联络 这也就是说明所有顶点都必须连通，通信渠道都是 <strong>双向</strong> 的说明是无向边，题目想要求的是选择权值小的通信渠道，最终连通所有节点。这满足最小生成树的含义，因此可以使用最小生成树。</p>
<p>但是这道题有些特殊，有两种通道，必选与非必选。其实我们可以先处理那些必选边，将那些必选边都弄成连通块，然后把一个连通块看作是”节点“，最后把那些非必选边就看作是这些”节点“之间的连边。</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210724150540.png" alt="image-20210724150540626"></p>
<p>蓝色边表示必须边，绿色边是非必选边。把蓝色边所连通的节点，都看作是一个连通块。那么这该如何实现呢？其实这就是并查集的合并操作嘛，对蓝色边所在的节点都进行并查集操作，找到祖宗节点，然后让这个祖宗节点成为这个连通块的”代表节点“。那么新图就是有”代表节点“和非必选边，那么我们对这个新图求最小生成树即可。</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2010</span>,M=<span class="number">10010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a,b,w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge&amp; W)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w&lt;W.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x!=p[x])</span><br><span class="line">        p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//res表示最小的通信费用</span></span><br><span class="line">    <span class="comment">//k表示新图所含有的边数</span></span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>,k=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        p[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t,a,b,w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;t,&amp;a,&amp;b,&amp;w);</span><br><span class="line">        <span class="comment">//处理必选边</span></span><br><span class="line">        <span class="keyword">if</span>(t==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res+=w; <span class="comment">//累加必选边权值</span></span><br><span class="line">            <span class="comment">//对必选边的节点进行并查集操作  合并到一个集合中,形成连通块</span></span><br><span class="line">            <span class="comment">//祖宗节点当作这个连通块的&quot;代表节点&quot;</span></span><br><span class="line">            <span class="comment">//然后这些&quot;代表节点&quot;和非必选边构成了一个新图</span></span><br><span class="line">            p[<span class="built_in">find</span>(a)]=<span class="built_in">find</span>(b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理非必选边</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            edges[k++]=&#123;a,b,w&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(edges,edges+k);    <span class="comment">//将边权按从小到大排序</span></span><br><span class="line">    <span class="comment">//处理新图中的这k条边  求出最小生成树</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="built_in">find</span>(edges[i].a);</span><br><span class="line">        <span class="keyword">int</span> b=<span class="built_in">find</span>(edges[i].b);</span><br><span class="line">        <span class="keyword">int</span> w=edges[i].w;</span><br><span class="line">        <span class="keyword">if</span>(a!=b)</span><br><span class="line">        &#123;</span><br><span class="line">            p[a]=b;</span><br><span class="line">            res+=w; <span class="comment">//累加最小生成树的权值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>最小生成树</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>可达性统计</title>
    <url>/2021/07/20/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/%E5%8F%AF%E8%BE%BE%E6%80%A7%E7%BB%9F%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="可达性统计"><a href="#可达性统计" class="headerlink" title="可达性统计"></a>可达性统计</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210720213337.png" alt="image-20210720213336979"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>设从点$x$出发能到达的所有点的集合为<code>f(x)</code>，设$x$连接的所有边为$y_1,y_2,\cdots,y_k$，则有如下式子：</p>
<p>$f(x)=x$ $\cup$ $(\bigcup \limits _{1\leq i\leq k}f(y_i))$</p>
<p>即：从点$x$出发能到达的所有点就是从它连接的所有点出发能到达的所有点加上$x$本身</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210720215025.png" alt="image-20210720215025122"></p>
<p>考虑拓扑排序。在一张图的拓扑序中，对每条边$(x,y)$总有：$x$在$y$之前。根据上述的这个式子，我们发现要想求出$f(x)$，必须要先求出$f(y_i)$，而由于$y_i$是$x$之后的节点，因此我们可以按照拓扑排序的倒序来进行计算。</p>
<p>我们考虑将每个点$f(x)$记作一个$N$位二进制数，其中第$i$位为1，表示可以到达$i$；第$i$位为0，表示不可以到达$i$。那么$f(x)$中1的数量就是从$x$出发能到达的所有点的数量。</p>
<p>我们来考虑一下数据规模，在最坏情况下，拓扑排序是一条链，对于第一个节点，$f(1)=n$，对于第二个节点，$f(2)=n-1$，$\cdots$，对于第$n$个节点，$f(n)=1$。那么总数为$f(1)+f(2)+\cdots+f(n)=n+(n-1)+\cdots+1=\dfrac {n(n-1)}{2}$，$n$最大取到$30000$，所以最坏的总数约为$4.5$亿，如果用二维数组来存储的话，那么内存空间就会爆炸。因此需要把$N$位的二进制数压缩到一个int中，这需要借助STL中的bitset。这样空间复杂度将减少为原来的$\dfrac {1}{32}$，此时变为$14,062,500$是可以接受的。</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210720215049.png" alt="image-20210720215048996"></p>
<p><code>bitset&lt;N&gt;f</code>这里的$f$其实是一维数组；</p>
<p><code>bitset&lt;N&gt;f[N]</code>，这里的$f$其实是二维数组</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">30010</span>,M=<span class="number">30010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="keyword">int</span> d[N];   <span class="comment">//记录每个点的入队</span></span><br><span class="line"><span class="keyword">int</span> q[N];   <span class="comment">//记录拓扑序列</span></span><br><span class="line">bitset&lt;N&gt;f[N];</span><br><span class="line"><span class="comment">//从点a向点b连一条有向边</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!d[i])</span><br><span class="line">        &#123;</span><br><span class="line">            q[++tt]=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(hh&lt;=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=q[hh++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(--d[j]==<span class="number">0</span>)</span><br><span class="line">                q[++tt]=j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a,b);</span><br><span class="line">        d[b]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//求出拓扑序列</span></span><br><span class="line">    <span class="built_in">topsort</span>();</span><br><span class="line">    <span class="comment">//对拓扑序列进行倒序遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x=q[i];</span><br><span class="line">        <span class="comment">//从x这个点出发可以到达x自身  因此f[x][x]=1</span></span><br><span class="line">        f[x][x]=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//遍历x的所有邻接点</span></span><br><span class="line">        <span class="comment">//f[x]|=f(yi)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=h[x];~j;j=ne[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> y=e[j]; <span class="comment">//取出x邻接点的编号y</span></span><br><span class="line">            f[x]|=f[y];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//f[i].count()表示f[i]中1的个数</span></span><br><span class="line">    <span class="comment">//其实也就是从i出发能到达的所有点的数量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[i].<span class="built_in">count</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>拓扑排序</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>最短网络</title>
    <url>/2021/07/24/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/%E6%9C%80%E7%9F%AD%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="最短网络"><a href="#最短网络" class="headerlink" title="最短网络"></a>最短网络</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210724102626.png" alt="image-20210724102626788"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>从题意可知，农夫想要连接所有农场并且想要所使用的光纤最短。这其实就是想要求最小生成树，因为最小生成树一定包含所有节点（即所有农场），而且是连通的（连接所有农场），并且边权之和是最小的（所使用的光纤最短）。因此就是一道裸的最小生成树算法。</p>
<p>求解最小生成树有两种算法：prim算法和Kruskal算法。</p>
<ul>
<li>prim算法一般适用于稠密图，用邻接矩阵存储。而题目又说了对称矩阵，所以这题就可以用prim算法来求解</li>
<li>Kruskal算法一般适用于稀疏图，我们一般用结构体来存储</li>
</ul>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>写法1：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">110</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="comment">//prim算法比较适用于稠密图  稠密图可以用邻居矩阵来存储</span></span><br><span class="line"><span class="comment">//这里采用prim算法  所以用了邻居矩阵</span></span><br><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line"><span class="comment">//dist[i]表示节点i距离S集合的距离</span></span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="comment">//st[i]=true表示节点i已经被加入了S集合</span></span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="comment">//prim算法求最小生成树</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;  <span class="comment">//最小生成树的权值总和</span></span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);  <span class="comment">//距离初始化为无穷大</span></span><br><span class="line">    <span class="comment">//起点1号节点到自身距离为0</span></span><br><span class="line">    dist[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//最终得到的最小生成树中一定有n个节点</span></span><br><span class="line">    <span class="comment">//因此需要循环n次  每个把一个节点加入S集合中</span></span><br><span class="line">    <span class="comment">//最终都会把这n个节点加入S集合中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=<span class="number">-1</span>;   <span class="comment">//寻找不在S集合中,但是距离S集合最近的一个节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span>(!st[j]&amp;&amp;(t==<span class="number">-1</span>||dist[t]&gt;dist[j]))</span><br><span class="line">                t=j;</span><br><span class="line">        <span class="keyword">if</span>(dist[t]==INF)</span><br><span class="line">            <span class="keyword">return</span> INF;</span><br><span class="line">        res+=dist[t];   <span class="comment">//累加最小生成树的权值和</span></span><br><span class="line">        st[t]=<span class="literal">true</span>;   <span class="comment">//标记节点t已经被加入了S集合</span></span><br><span class="line">        <span class="comment">//遍历节点t的所有邻接点  通过t来更新这些邻接点到起点的距离</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">            <span class="keyword">if</span>(!st[k])</span><br><span class="line">                dist[k]=<span class="built_in">min</span>(dist[k],g[t][k]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="comment">//读入邻接矩阵</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;g[i][j]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">prim</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写法2：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">110</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span>(!st[j]&amp;&amp;(t==<span class="number">-1</span>||dist[t]&gt;dist[j]))</span><br><span class="line">                t=j;</span><br><span class="line">        <span class="keyword">if</span>(i&amp;&amp;dist[t]==INF)</span><br><span class="line">            <span class="keyword">return</span> INF;</span><br><span class="line">        <span class="keyword">if</span>(i)</span><br><span class="line">            res+=dist[t];</span><br><span class="line">        st[t]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">            dist[k]=<span class="built_in">min</span>(dist[k],g[t][k]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;g[i][j]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">prim</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>最小生成树</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>奖金</title>
    <url>/2021/07/21/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/%E5%A5%96%E9%87%91/</url>
    <content><![CDATA[<h1 id="奖金"><a href="#奖金" class="headerlink" title="奖金"></a>奖金</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210721120429.png" alt="image-20210721120429310"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>实际上是一道差分约束的题，要求变量的最小值，也就是取所有下界的最大值，用最长路求解即可。但是呢，如果用差分约束spfa的时间复杂度为$O(km)$~$O(nm)$，可能会被卡。</p>
<p>因为本题中所有的权值都是正值，因此我们可以不用差分约束就求这个最长路。</p>
<p>我们直接拓扑排序得到一张有向无环图DAG$\implies $每一个状态都没有循环依赖 $\implies$没有后效性$\implies$就可以用DP递推求最长路</p>
<p>题目中说到”员工$a$的奖金比员工$b$的奖金高“，因此可以得出$a\geq b+1$，那么我们可以从节点$b$向节点$a$连一条边权为1的边。</p>
<p>由于”每位员工奖金最少为$100$元“，因此就可以看作是建立了一个虚拟源点，该源点到其他各点的距离都为$100$。</p>
<p>这题有两种写法：</p>
<ul>
<li>在拓扑排序中就求出了最长路</li>
<li>先进行拓扑排序得到一张有向无环图DAG，然后在这个DAG上跑一下最长路即可。</li>
</ul>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>在拓扑排序中就求出了最长路</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">10010</span>,M=<span class="number">20010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="keyword">int</span> d[N];       <span class="comment">//存储每个点的入度</span></span><br><span class="line"><span class="keyword">int</span> q[N];       <span class="comment">//存储拓扑序列</span></span><br><span class="line"><span class="keyword">int</span> dist[N];    <span class="comment">//存储最长路</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在进行拓扑排序的同时求出了dist[]</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//求最长路 因此初始化为负无穷</span></span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">-0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!d[i])</span><br><span class="line">        &#123;</span><br><span class="line">            q[++tt]=i;</span><br><span class="line">            <span class="comment">//相当于建立了一个虚拟源点 该虚拟源点到这n个点的距离为100</span></span><br><span class="line">            dist[i]=<span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(hh&lt;=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=q[hh++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(--d[j]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                q[++tt]=j;</span><br><span class="line">                <span class="comment">//j是t的邻接点   t经过边权为1的边后就可以走到了j</span></span><br><span class="line">                dist[j]=dist[t]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tt==n<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="comment">//从b向a连一条边权为1的有向边 </span></span><br><span class="line">        <span class="comment">//由于边权都是1  因此没必要用一个数组w[i]来存储了  直接用1就好了</span></span><br><span class="line">        <span class="built_in">add</span>(b,a);</span><br><span class="line">        d[a]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//说明存在环 则无解</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">topsort</span>())</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Poor Xed&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//计算最长路</span></span><br><span class="line">            res+=dist[i];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);         </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先进行拓扑排序得到一张有向无环图DAG，然后在这个DAG上跑一下最长路</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">10010</span>,M=<span class="number">20010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="keyword">int</span> d[N],q[N],dist[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(!d[i])</span><br><span class="line">            q[++tt]=i;</span><br><span class="line">    <span class="keyword">while</span>(hh&lt;=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=q[hh++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(--d[j]==<span class="number">0</span>)</span><br><span class="line">                q[++tt]=j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;       </span><br><span class="line">    <span class="keyword">return</span> tt==n<span class="number">-1</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="built_in">add</span>(b,a);</span><br><span class="line">        d[a]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">topsort</span>())</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Poor Xed&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//相当于建立了一个虚拟源点 该虚拟源点到这n个点的距离为100</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            dist[i]=<span class="number">100</span>;</span><br><span class="line">        <span class="comment">//对得到的这个拓扑图DAG跑一下最长路</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t=q[i]; <span class="comment">//取出拓扑序列中的节点t</span></span><br><span class="line">            <span class="comment">//遍历t的所有邻接点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=h[t];~k;k=ne[k])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> j=e[k]; <span class="comment">//取出t的邻接点j</span></span><br><span class="line">                <span class="comment">//由于得到的是DAG图,没有后效性,因此可以用dp思想</span></span><br><span class="line">                <span class="comment">//状态转移方程</span></span><br><span class="line">                dist[j]=<span class="built_in">max</span>(dist[j],dist[t]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            res+=dist[i];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>拓扑排序</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>确定比赛名次</title>
    <url>/2021/07/27/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/%E7%A1%AE%E5%AE%9A%E6%AF%94%E8%B5%9B%E5%90%8D%E6%AC%A1/</url>
    <content><![CDATA[<h1 id="确定比赛名次"><a href="#确定比赛名次" class="headerlink" title="确定比赛名次"></a>确定比赛名次</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=1285">hdu1285</a></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>题意：输出字典序最小的拓扑序列</p>
<p>主要思路：在当前步骤，在所有入度为0的点中输出编号最小的。</p>
<p>考虑用BFS实现拓扑排序：</p>
<p>修改BFS的拓扑排序程序，将普通队列修改成<strong>优先队列Q</strong>，在$Q$中存放入度为0的节点，每次输出编号最小的节点，然后把它的后续节点的入度减1，入度减为0的再放进$Q$中，这样就能输出一个字典序最小的拓扑序列了。</p>
<p>如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210727180249.png" alt="image-20210727175819367"></p>
<p>考虑这题可以使用DFS输出字典序最小的拓扑序列嘛？其实是不行的。上面处理的过程相当于把点按优先级分成了不同的层次，在每个层次都要把这一层入度减为0的点按字典序从小到大输出；而DFS是深度搜索，处理的是上下层之间的关系，不能处理这种同层之间的关系。</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">510</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> g[N][N];    <span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="keyword">int</span> d[N];</span><br><span class="line"><span class="keyword">int</span> seq[N]; <span class="comment">//存储字典序最小的拓扑序列</span></span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//优先队列</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!d[i])</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        seq[cnt++]=t;   <span class="comment">//将t存储拓扑序列中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(g[t][j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(--d[j]==<span class="number">0</span>)</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(g,<span class="number">0</span>,<span class="keyword">sizeof</span> g);</span><br><span class="line">        <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a,b;</span><br><span class="line">            cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">            <span class="keyword">if</span>(!g[a][b])<span class="comment">//防止有重边</span></span><br><span class="line">            &#123;</span><br><span class="line">                g[a][b]=<span class="number">1</span>;</span><br><span class="line">                d[b]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">topsort</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,seq[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,seq[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>拓扑排序</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>家谱树</title>
    <url>/2021/07/21/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/%E5%AE%B6%E8%B0%B1%E6%A0%91/</url>
    <content><![CDATA[<h1 id="家谱树"><a href="#家谱树" class="headerlink" title="家谱树"></a>家谱树</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210721101434.png" alt="image-20210721101434566"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>这是一道很裸的拓扑排序，直接套拓扑排序模版即可。</p>
<blockquote>
<p>问题：如何输出字典序最小的拓扑排序？</p>
<p>将队列换成优先队列，优先队列取出的元素是当前字典序最小的编号，在出队的时候记录出队的编号即为当前字典序最小的拓扑序，此方法的时间复杂度是$O(logn*(n+m))$</p>
</blockquote>
<p>由于是有向无环图，对于第1个节点来说，最多与后面的$n-1$个节点有边；对于第2个节点来说，最多与后面的$n-2$个节点有边；$\cdots$；对于第$n$个节点来说，有0个连边。因此最多有$\dfrac {n(n-1)}{2}$条边。由于点的个数最多是$N$，所以边的个数最多是$\dfrac {N(N-1)}{2}$</p>
<p>由于这道题目中肯定不会存在环（家庭伦理问题…），因此一定可以得到拓扑序列。</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>手写队列：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">110</span>,M=N*N/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="keyword">int</span> d[N];</span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(!d[i])</span><br><span class="line">            q[++tt]=i;</span><br><span class="line">    <span class="keyword">while</span>(hh&lt;=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=q[hh++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(--d[j]==<span class="number">0</span>)</span><br><span class="line">                q[++tt]=j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> son;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;son),son)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//从i向son连一条有向边</span></span><br><span class="line">            <span class="built_in">add</span>(i,son);</span><br><span class="line">            d[son]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进行一遍拓扑排序</span></span><br><span class="line">    <span class="built_in">topsort</span>();</span><br><span class="line">    <span class="comment">//输出得到的拓扑序列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,q[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运用STL中的队列</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">110</span>,M=N*N/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="keyword">int</span> d[N];</span><br><span class="line"><span class="comment">//seq数组用来存储得到的拓扑序列,cnt是这个数组的下标</span></span><br><span class="line"><span class="keyword">int</span> seq[N],cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt;q;    <span class="comment">//运用STL中的队列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!d[i])</span><br><span class="line">        &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">        <span class="comment">//记录此时的拓扑序列的节点是t</span></span><br><span class="line">        seq[cnt++]=t;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(--d[j]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> son;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;son),son)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">add</span>(i,son);</span><br><span class="line">            d[son]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">topsort</span>();</span><br><span class="line">    <span class="comment">//输出得到的拓扑序列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,seq[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>拓扑排序</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>标签球</title>
    <url>/2021/07/27/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/%E6%A0%87%E7%AD%BE%E7%90%83/</url>
    <content><![CDATA[<h1 id="标签球"><a href="#标签球" class="headerlink" title="标签球"></a>标签球</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><a href="http://poj.org/problem?id=3687">POJ3687</a></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>注意，题目中输入的是小球的标签号而不是小球的重量，比如有小球标签$A,B,C,D$，如果$B&gt;C&gt;A&gt;D$，那么小球标签$A,B,C,D$所对应的重量等级为$3,1,2,4$。题目其实是想要输出这些小球的重量等级，而不是输出小球的标签编号。</p>
<p>本题并不是要输出小球的标签，而是按标签输出小球的重量，而且<strong>标签小的球的重量要尽可能的小</strong>。</p>
<p>举个栗子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">4</span>	<span class="comment">//节点数、边数</span></span><br><span class="line"><span class="number">5</span> <span class="number">1</span>	<span class="comment">//标签为5的小球比标签为1的小球轻</span></span><br><span class="line"><span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span>    </span><br></pre></td></tr></table></figure>
<p>由于题目说了$a&lt;b$，那么我们把从$a$向$b$连一条有向边所构建得到的这张图 称为正向图，把从$b$向$a$连一条有向边所构建得到的这张图 称为反向图</p>
<p>这里我们画出上面这个栗子的正向图：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210727131221.png" alt="image-20210727131221802"></p>
<p>分析：根据题目描述，如果$a$比$b$轻，我们构建了一条从$a$指向$b$的有向边，根据重量关系可知，节点$3$是最重的，因此令重量<code>weight[3]=5</code>；节点$1$和节点$2$都比节点$3$轻，因为每个小球的重量都不相同，按照标签小的球其重量小的原则，我们先给标签大的小球分配重量，所以这里先处理节点$2$，因此<code>weight[2]=4</code>；节点$4$比节点$2$轻，所以<code>weight[4]=3</code>；节点$1$比节点$3$轻，所以<code>weight[1]=2</code>；节点$5$比节点$1$轻，因此<code>weight[5]=1</code>。</p>
<p>也就是说，当多个节点$a,b,c$同时指向同一个节点$d$时，如果标签号$a&gt;b&gt;c$，那么我们就先给标签大的分配重量，即$weight[a]&gt;weight[b]&gt;weight[c]$。然后一旦处理了节点$a$，就要把节点$a$所在的关系全部处理了，比如上图中处理了节点$2$，就要处理节点$4$，而不是去处理节点$1$。</p>
<p>再举个栗子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span> <span class="number">5</span>	<span class="comment">//节点数 边数</span></span><br><span class="line"><span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">8</span> <span class="number">1</span></span><br><span class="line"><span class="number">7</span> <span class="number">8</span></span><br><span class="line"><span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">8</span>    </span><br></pre></td></tr></table></figure>
<p>构建正向图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210727132457.png" alt="image-20210727132457512"></p>
<p>分析：按照标签小的球重量小的原则，先给标签大的小球分配重量，因此<code>weight[10]=10</code>，<code>weight[9]=9</code>，<code>weight[6]=8</code>，<code>weight[5]=7</code>，<code>weight[3]=6</code>，<code>weight[1]=5</code>。节点$8$和节点$4$都比节点$1$轻，按照标签小的球重量小的原则，先给标签大的小球分配重量，所以先给节点$8$分配重量，因此<code>weight[8]=4</code>；节点$7$和节点$2$比节点$8$轻，先处理节点$7$，因此<code>weight[7]=3</code>；此时只剩下节点$2$和节点$4$，那么先给节点$4$分配重量，因此<code>weight[4]=2</code>，最后给节点$1$分配重量，因此<code>weight[2]=1</code>。</p>
<p>所以得到标签小球$1$到标签小球$10$的重量等级如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">weight[<span class="number">1</span>]=<span class="number">5</span>;</span><br><span class="line">weight[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">weight[<span class="number">3</span>]=<span class="number">6</span>;</span><br><span class="line">weight[<span class="number">4</span>]=<span class="number">2</span>;</span><br><span class="line">weight[<span class="number">5</span>]=<span class="number">7</span>;</span><br><span class="line">weight[<span class="number">6</span>]=<span class="number">8</span>;</span><br><span class="line">weight[<span class="number">7</span>]=<span class="number">3</span>;</span><br><span class="line">weight[<span class="number">8</span>]=<span class="number">4</span>;</span><br><span class="line">weight[<span class="number">9</span>]=<span class="number">9</span>;</span><br><span class="line">weight[<span class="number">10</span>]=<span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>按照标签$1$到$10$输出其重量：5 1 6 2 7 8 3 4 9 10</p>
<p>注意本题有重复边，需要去重，否则会有环，如果存在环则输出-1。</p>
<p><strong>算法设计：</strong></p>
<p>可以采用以下两种方法来解决：</p>
<ul>
<li>建立正向图。$i=n,n-1,\cdots,1$，$j=n,n-1,\cdots,1$，检查第1个出度为0的节点$t$，给其分配重量<code>weight[t]=i</code>，将有边指向它的那些节点的出度都减1，继续下一个循环。如果没有出度为$0$的节点，则说明有环存在，退出。</li>
<li>建立反向图。$i=n,n-1,\cdots,1$，$j=n,n-1,\cdots,1$，检查第1个入度为0的节点$t$，给其分配重量<code>weight[t]=i</code>，将它所指向的节点的入度都减1，继续下一个循环。如果没有入度为$0$的节点，则说明有环存在，退出。</li>
</ul>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>正向图：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">210</span>,M=<span class="number">40010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="comment">//g[i][j]=1表示节点i向节点j连一条有向边</span></span><br><span class="line"><span class="keyword">int</span> g[N][N];    <span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="keyword">int</span> d[N];       <span class="comment">//记录每个节点的出度</span></span><br><span class="line"><span class="comment">//weight[i]表示i号标签小球的重量</span></span><br><span class="line"><span class="keyword">int</span> weight[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//i是重量等级</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=<span class="number">-1</span>;   <span class="comment">//找到第一个出度为0的节点</span></span><br><span class="line">        <span class="comment">//j枚举的是节点的编号</span></span><br><span class="line">        <span class="comment">//由于是按照&quot;节点大的标签小球分配大的重量&quot;原则</span></span><br><span class="line">        <span class="comment">//所以这里先枚举大的标签小球</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=n;j&gt;<span class="number">0</span>;j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!d[j])<span class="comment">//出度为0</span></span><br><span class="line">            &#123;</span><br><span class="line">                t=j;    <span class="comment">//找到第一个出度为0的节点  直接退出</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果循环完所有的节点 都没有找到一个出度为0的节点  则说明有环存在</span></span><br><span class="line">        <span class="keyword">if</span>(t==<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//给节点t分配重量i</span></span><br><span class="line">        weight[t]=i;</span><br><span class="line">        <span class="comment">//将节点t的出度设为-1 表示这个节点已经被分配过重量了</span></span><br><span class="line">        d[t]=<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//遍历j的所有邻接点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(g[j][t])<span class="comment">//将t的所有邻接点j的出度全部减1</span></span><br><span class="line">                d[j]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//没有环存在</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(g,<span class="number">0</span>,<span class="keyword">sizeof</span> g);</span><br><span class="line">        <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">        cin &gt;&gt;n&gt;&gt;m;</span><br><span class="line">        <span class="comment">//读入m条边的信息</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a,b;</span><br><span class="line">            cin &gt;&gt;a&gt;&gt;b;</span><br><span class="line">            <span class="keyword">if</span>(!g[a][b])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//a向b建立一条有向边</span></span><br><span class="line">                g[a][b]=<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//节点a的出度+1</span></span><br><span class="line">                d[a]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//有环存在 则无解 输出-1</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">topsort</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//输出标签小球1~n的重量等级</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,weight[i]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,weight[n]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反向图：比较符合拓扑排序的模板</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">210</span>,M=<span class="number">40010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="comment">//g[i][j]=1表示节点i向节点j连一条有向边</span></span><br><span class="line"><span class="keyword">int</span> g[N][N];    <span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="keyword">int</span> d[N];       <span class="comment">//记录每个节点的入度</span></span><br><span class="line"><span class="comment">//weight[i]表示i号标签小球的重量</span></span><br><span class="line"><span class="keyword">int</span> weight[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//i是重量等级</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=<span class="number">-1</span>;   <span class="comment">//找到第一个入度为0的节点</span></span><br><span class="line">        <span class="comment">//j枚举的是节点的编号</span></span><br><span class="line">        <span class="comment">//由于是按照&quot;节点大的标签小球分配大的重量&quot;原则</span></span><br><span class="line">        <span class="comment">//所以这里先枚举大的标签小球</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=n;j&gt;<span class="number">0</span>;j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!d[j])<span class="comment">//入度为0</span></span><br><span class="line">            &#123;</span><br><span class="line">                t=j;    <span class="comment">//找到第一个入度为0的节点  直接退出</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果循环完所有的节点 都没有找到一个入度为0的节点  则说明有环存在</span></span><br><span class="line">        <span class="keyword">if</span>(t==<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//给节点t分配重量i</span></span><br><span class="line">        weight[t]=i;</span><br><span class="line">        <span class="comment">//将节点t的入度设为-1 表示这个节点已经被分配过重量了</span></span><br><span class="line">        d[t]=<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//遍历j的所有邻接点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(g[t][j])<span class="comment">//将j的所有邻接点的入度全部减1</span></span><br><span class="line">                d[j]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//没有环存在</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(g,<span class="number">0</span>,<span class="keyword">sizeof</span> g);</span><br><span class="line">        <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">        cin &gt;&gt;n&gt;&gt;m;</span><br><span class="line">        <span class="comment">//读入m条边的信息</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a,b;</span><br><span class="line">            cin &gt;&gt;a&gt;&gt;b;</span><br><span class="line">            <span class="comment">//由于有重边 这里是为了防止重边</span></span><br><span class="line">            <span class="keyword">if</span>(!g[b][a])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//从b向a连一条有向边</span></span><br><span class="line">                g[b][a]=<span class="number">1</span>;</span><br><span class="line">                d[a]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//有环存在 则无解 输出-1</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">topsort</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//输出标签小球1~n的重量等级</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,weight[i]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,weight[n]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>拓扑排序</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>秩序</title>
    <url>/2021/07/27/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/%E7%A7%A9%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="秩序"><a href="#秩序" class="headerlink" title="秩序"></a>秩序</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><a href="http://poj.org/problem?id=1270">题目传送门</a></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>题意：给定一个有向无环图，按字典序从小到大输出所有的拓扑序列，题目保证拓扑序列一定存在。</p>
<p>本题并不是裸的拓扑排序，题目要求我们<strong>按照字典序输出所有拓扑序列</strong>，那么我们可以使用回溯法搜索所有的拓扑序列。注意，到达叶子节点时就可以输出这个拓扑序列了，然后回溯时还需要记得恢复现场。</p>
<p>根据样例1，画出如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210727114420.png" alt="image-20210727114420479"></p>
<p>由于题目给出的是字符，但是我们知道图的编号都是整数，因此我们可以把$a$到$z$这26个字符映射成为$0$到$25$这26个整数值，用来表示图中的节点编号。</p>
<p><strong>算法设计：</strong></p>
<ul>
<li>将约束变量列表中的字符都转换为数字并统计其出现次数，然后统计出字符的个数（其实也就是统计图中顶点的个数）</li>
<li>将每对约束都转换为数字，用邻接矩阵存储，并统计入度</li>
<li>用回溯法求解所有拓扑序列并输出</li>
</ul>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">55</span>;</span><br><span class="line"><span class="keyword">int</span> n;  <span class="comment">//图中顶点的总个数</span></span><br><span class="line"><span class="comment">//邻接矩阵 g[i][j]=表示节点i有一条指向节点j的有向边</span></span><br><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line"><span class="comment">//d[i]表示节点i的入度  s[i]表示某个字符出现的次数</span></span><br><span class="line"><span class="keyword">int</span> d[N],s[N];</span><br><span class="line"><span class="comment">//拓扑序列</span></span><br><span class="line"><span class="keyword">int</span> seq[N];</span><br><span class="line"><span class="comment">//u表示当前搜索的节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span><span class="comment">//用回溯法求解出所有的拓扑序列并输出</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//有n个节点 u从0到n-1一共有n个节点</span></span><br><span class="line">    <span class="comment">//因此当u&gt;=n时,说明前面的n个节点都枚举完了  那么就直接输出拓扑序列</span></span><br><span class="line">    <span class="keyword">if</span>(u&gt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,seq[i]+<span class="string">&#x27;a&#x27;</span>);<span class="comment">//转换成字符输出</span></span><br><span class="line">        cout &lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">//回溯</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//i从0到25其实就是对应着枚举从a到z,这样就能保证x出现在y前面或者x出现在z前面</span></span><br><span class="line">    <span class="comment">//即能保证字典序从小到大了</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果当前节点入度为0并且它是出现在约束变量列表中的字符</span></span><br><span class="line">        <span class="keyword">if</span>(!d[i]&amp;&amp;s[i])</span><br><span class="line">        &#123;</span><br><span class="line">            s[i]--; <span class="comment">//出现次数-1</span></span><br><span class="line">            <span class="comment">//遍历节点i的所有邻接点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">26</span>;j++)</span><br><span class="line">                <span class="keyword">if</span>(g[i][j])<span class="comment">//如果节点i有一条指向节点j的有向边,则消除这条边,让j的入度-1</span></span><br><span class="line">                    d[j]--;</span><br><span class="line"></span><br><span class="line">            seq[u]=i;   <span class="comment">//u这个位置填的内容是i 记录拓扑序列中的第u个字符对应的是i</span></span><br><span class="line">            <span class="comment">//递归下一个位置  深搜第u+1个字符</span></span><br><span class="line">            <span class="built_in">dfs</span>(u+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//恢复现场</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">26</span>;j++)</span><br><span class="line">                <span class="keyword">if</span>(g[i][j])<span class="comment">//将i的所有邻接点j的入度都+1</span></span><br><span class="line">                    d[j]++;</span><br><span class="line">            s[i]++; <span class="comment">//恢复该字符在变量列表中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str,ord;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getline</span>(cin,str))<span class="comment">//读入变量列表</span></span><br><span class="line">    &#123;</span><br><span class="line">        n=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(g,<span class="number">0</span>,<span class="keyword">sizeof</span> g);</span><br><span class="line">        <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">        <span class="built_in">memset</span>(s,<span class="number">0</span>,<span class="keyword">sizeof</span> s);</span><br><span class="line">        <span class="comment">//读入约束变量列表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.<span class="built_in">length</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i]!=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                s[str[i]-<span class="string">&#x27;a&#x27;</span>]++;    <span class="comment">//转换为数字统计</span></span><br><span class="line">                n++;    <span class="comment">//记录图中顶点的总个数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">getline</span>(cin,ord);   <span class="comment">//读入约束列表</span></span><br><span class="line">        <span class="comment">//读入约束</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ord.<span class="built_in">length</span>();i+=<span class="number">2</span>)    <span class="comment">//有空格 一次读入两个字符</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//将字符a~z映射成为整数0~25 然后0~25就可以代表图中的节点编号了</span></span><br><span class="line">            <span class="keyword">int</span> a=ord[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            i+=<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> b=ord[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="comment">//表示a-&gt;b有边</span></span><br><span class="line">            g[a][b]=<span class="number">1</span>;  <span class="comment">//用邻接矩阵存储</span></span><br><span class="line">            d[b]++; <span class="comment">//节点b的入度+1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从第0个位置开始搜索  即从图中的第0号节点开始深搜</span></span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">        cout &lt;&lt;endl;    <span class="comment">//每组测试数据过后都要换行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>拓扑排序</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>受欢迎的牛</title>
    <url>/2021/07/30/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/%E5%8F%97%E6%AC%A2%E8%BF%8E%E7%9A%84%E7%89%9B/</url>
    <content><![CDATA[<h1 id="受欢迎的牛"><a href="#受欢迎的牛" class="headerlink" title="受欢迎的牛"></a>受欢迎的牛</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210730155213.png" alt="image-20210730155213679"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p><a href="https://blog.csdn.net/qq_45832461/article/details/119248937">tarjan算法</a></p>
<p>题意：求出被所有牛（除自己外）都喜欢的”明星“数量。</p>
<p>有向图的强连通分量有个非常重要的作用：可以把一张图转变为有向无环图DAG。而求解有向图的强连通分量可以使用tarjan算法。</p>
<p>因为，当我们求出一个强连通分量时，可以把这个强连通分量进行缩点操作，缩成一个点，然后再把这个节点与其他节点连边，这样就可以得到一张DAG图。既然是有向无环图，那么就可以运用拓扑排序算法了。但是其实并不需要进行拓扑排序，因为tarjan算法本质是递归，当到了叶子节点时，算出一个连通分量，给它一个编号num，那么叶子节点所在的这个连通分量就是第一个，即num=1。然后回溯，再回溯过程中又求出了另一些连通分量，此时num++，也就是说，从后往前强连通分量的编号是递增的，这非常像DFS版的拓扑排序。而DFS版的拓扑排序的话，就是逆序输出就可以得到从前往后的拓扑序列了。对于tarjan来说，其实也是类似的，我们只需要从大到小输出强连通分量的编号num即可，因此不需要进行拓扑排序了。</p>
<p>对于这题来说，我们发现，使用tarjan算法后得到一张DAG图，如果图中出度为0的节点个数&gt;1，那么则无解了，如果图中出度为0的节点个数=1，则有解。</p>
<p>如下图所示：</p>
<p>如果$A$认为$B$受欢迎，则从$A$向$B$连一条有向边</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210730161045.png" alt="image-20210730161045557"></p>
<p>那么该如何统计结果呢？如上图，这里3是指缩点后的节点3，它其实代表的是第3个强连通分量，假设是$1\to2\to3$，可以知道第3个强连通分量中的牛都受到欢迎。因此，我们只需要统计出度为0的那个强连通分量中的牛的数量，那么就是答案了。</p>
<p>这题我们并不需要把缩点后的图建立出来，我们只需要求出每一个强连通分量，并给它们编上号。对于两个节点$i,k$，$i$和$k$是邻接点的关系，假设$i\to k$，我们先查看它们属于哪一个强连通分量，我们用数组<code>id[]</code>来记录某个节点属于哪个强连通分量。假设节点$i$属于强连通分量$a=id[i]$，节点$k$属于强连通分量$b=id[k]$，那么有两种情况：</p>
<ul>
<li>如果$a=b$，则说明节点$i,k$属于同一个强连通分量，由于我们把一个强连通分量看成了一个缩点，那么它里面的节点就不需要谈论出度了。</li>
<li>如果$a\neq b$，则说明节点$i,k$不属于同一个强连通分量，那么统计强连通分量$a$的出度，即$d[a]$+ +</li>
</ul>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e4</span>+<span class="number">10</span>,M=<span class="number">5e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="comment">//表示节点u深度优先遍历的序号（也就是节点u被访问的时间点）</span></span><br><span class="line"><span class="comment">//表示节点u或节点u的子孙能够通过非父子边追溯到的dfn最小的节点序号</span></span><br><span class="line"><span class="comment">//即回到最早的过去（也就是节点u通过有向边可回溯到的最早的时间点）</span></span><br><span class="line"><span class="comment">//num表示时间戳</span></span><br><span class="line"><span class="keyword">int</span> dfn[N],low[N],num;</span><br><span class="line"><span class="comment">//a=id[x]表示x这个节点属于a这个强连通分量</span></span><br><span class="line"><span class="comment">//cnt[i]=100表示i这个强连通分量有100个节点</span></span><br><span class="line"><span class="comment">//scc表示强连通分量的编号 scc=3表示第3个强连通分量 最终也只有scc个强连通分量</span></span><br><span class="line"><span class="keyword">int</span> id[N],cnt[N],scc;</span><br><span class="line"><span class="comment">//栈用来存储访问的节点  top是栈顶指针</span></span><br><span class="line"><span class="keyword">int</span> stk[N],top; </span><br><span class="line"><span class="comment">//存储每个节点的出度</span></span><br><span class="line"><span class="keyword">int</span> dout[N];</span><br><span class="line"><span class="comment">//in_stk[i]=true表示节点i还在栈中</span></span><br><span class="line"><span class="keyword">bool</span> in_stk[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u]=low[u]=++num;    <span class="comment">//给节点u分配一个时间戳</span></span><br><span class="line">    stk[++top]=u;           <span class="comment">//将节点u入栈</span></span><br><span class="line">    in_stk[u]=<span class="literal">true</span>;         <span class="comment">//标记节点u在栈中</span></span><br><span class="line">    <span class="comment">//遍历节点u的所有邻接点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];~i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j=e[i]; <span class="comment">//u的邻接点j</span></span><br><span class="line">        <span class="comment">//根据分析得出：先会执行else if中的更新语句,才会执行if中的回溯过程中的更新语句</span></span><br><span class="line">        <span class="comment">//如果节点j还没有被访问过</span></span><br><span class="line">        <span class="keyword">if</span>(!dfn[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(j);<span class="comment">//递归访问j</span></span><br><span class="line">            <span class="comment">//回溯是更新从节点j往回到节点u这条路径上的所有节点的low值</span></span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[u],low[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则说明节点j已经被访问过了 看j是否还在栈中</span></span><br><span class="line">        <span class="comment">//如果还在栈中 那么就说明形成了环 即存在强连通分量</span></span><br><span class="line">        <span class="comment">//当走到这里时说明j先于u被访问,因此u可以追溯到更早的过去</span></span><br><span class="line">        <span class="comment">//于是用更早的dfn[j]来更新low[u]</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(in_stk[j])</span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[u],dfn[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//退无可退 即此时u不能追溯到更早的过去了 那么它就是这个强连通分量的入口</span></span><br><span class="line">    <span class="keyword">if</span>(dfn[u]==low[u])</span><br><span class="line">    &#123;</span><br><span class="line">        scc++;  <span class="comment">//强连通分量的个数+1</span></span><br><span class="line">        <span class="keyword">int</span> y;</span><br><span class="line">        <span class="comment">//输出这个强连通分量中所包含的节点</span></span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            y=stk[top--];       <span class="comment">//强连通分量的节点y</span></span><br><span class="line">            in_stk[y]=<span class="literal">false</span>;    <span class="comment">//标记节点y不在栈中</span></span><br><span class="line">            id[y]=scc;      <span class="comment">//节点y属于scc这个强连通分量</span></span><br><span class="line">            cnt[scc]++;     <span class="comment">//scc这个强连通分量中的节点个数增加了y这个节点</span></span><br><span class="line">        &#125;<span class="keyword">while</span>(y!=u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a,b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行tarjan算法</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i])</span><br><span class="line">            <span class="built_in">tarjan</span>(i);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//统计新图中点的出度 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//遍历节点i的所有邻接点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=h[i];~j;j=ne[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> k=e[j]; <span class="comment">//节点i的邻接点k</span></span><br><span class="line">            <span class="comment">//查看节点i和节点k分别属于哪个强连通分量</span></span><br><span class="line">            <span class="keyword">int</span> a=id[i];</span><br><span class="line">            <span class="keyword">int</span> b=id[k];</span><br><span class="line">            <span class="comment">//如果它俩属于不同的强连通分量,由于是i&gt;k</span></span><br><span class="line">            <span class="comment">//所以a这个强连通分量的出度+1</span></span><br><span class="line">            <span class="keyword">if</span>(a!=b)</span><br><span class="line">                dout[a]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//zeros记录出度为0的节点个数</span></span><br><span class="line">    <span class="comment">//sum存储所有出度为0的强连通分量的点的数量</span></span><br><span class="line">    <span class="keyword">int</span> zeros=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=scc;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果第i个强连通分量出度为0</span></span><br><span class="line">        <span class="keyword">if</span>(!dout[i])</span><br><span class="line">        &#123;</span><br><span class="line">            zeros++;</span><br><span class="line">            sum+=cnt[i];    <span class="comment">//加上第i个强连通分量的点的个数</span></span><br><span class="line">            <span class="comment">//如果存在出度为0的节点个数&gt;1,则某一头牛必然不会受到另一头牛的喜欢</span></span><br><span class="line">            <span class="comment">//与题意不符合</span></span><br><span class="line">            <span class="keyword">if</span>(zeros&gt;<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sum=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>有向图的强连通分量</category>
      </categories>
      <tags>
        <tag>tarjan求有向图的强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title>学校网络</title>
    <url>/2021/07/30/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/%E5%AD%A6%E6%A0%A1%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="学校网络"><a href="#学校网络" class="headerlink" title="学校网络"></a>学校网络</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210730181223.png" alt="image-20210730181223122"></p>
<hr>
<h3 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h3><p>抽象一下题意：</p>
<ul>
<li>第一问：最少发送给几个学校，就可以让软件传送到所有学校</li>
<li>第二问：最少添加几条有向边，才能实现发送给任意一个学校，所有学校都能接受到。即最少添加多少条有向边，可以使得图中任意两个节点之间连通，把任意一张有向图变成强连通图。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210730181858.png" alt="image-20210730181858796"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>对于第一问，最少发送给几个学校，就可以让软件传送到所有学校呢？实际上，就是求解强连通分量并缩点后得到的这张DAG图中有多少个入度为0的点，即”零入度点“（这里的点已经是把强连通分量进行缩点操作后得到的点）。为什么呢？首先，”零入度点“无法被其他学校支援，因此必须把软件分配给”零入度点“；其次，若同时向所有”零入度点“提供新软件，则新软件可以从这些点出发沿着网络传送到所有学校（因为这是DAG图，从起点出发，必然能遍历整张有向无环图）。综上所述，第一问，其实就是求解有向无环图中”零入度点“的个数。</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210730183258.png" alt="image-20210730183258072"></p>
<p>使用tarjan算法求解有3个强连通分量，然后进行缩点操作，此时这张DAG图中只有三个顶点，可以发现”零入度点“是红色点，只有一个，即入度为0的强连通分量只有一个，因此我们只需要发送给这个强连通分量中的任意一个学校就行了，即1、2、5小红的任意一个学校。</p>
<p>接下来求解第二问：最少添加几条有向边，才能实现发送给任意一个学校，所有学校都能接受到？也就是说，每个强连通分量都必须既有入度，又有出度。对入度为0的强连通分量，至少要添加一个入度；对出度为0的强连通分量，至少要添加一个出度。添加的边数为$max(p,q)$。</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210730184005.png" alt="image-20210730184005042"></p>
<p>特别地，如果整张图本身就是一个强连通图，那么缩点后，就只是一个点了，由于强连通图形成了环，因此任意两个点之间必然可达，因此不需要添加边，所以答案为0。</p>
<p>接下来给出$max(p,q)$的可行性证明：</p>
<p>设缩点后的这张DAG图，起点（入度为0，即零入度点）的集合为$P$，终点（出度为0，即零出度点）的集合为$Q$，注意这里的P和Q只是统计刚开始这张DAG图中的入度为0的节点和出度为0的节点，并不是向拓扑排序那样还统计进行拓扑排序过程中那些入度为0的点和出度为0的点。分为以下两种情况讨论：</p>
<ul>
<li><p>$|P|\leq|Q|$</p>
<ul>
<li><p>如果$|P|=1$，则只有一个起点，由DAG图的性质可知，可以从起点走到所有的终点，因此要向让图中任意两点之间都连通，则只需要让这$|Q|$个终点向起点连一条有向边即可。因此需要添加的边数为$|Q|$个。</p>
</li>
<li><p>如果$|P|\geq 2$，则有$|Q|\geq|P|\geq2$，此时至少存在2个起点$p_1,p_2$，2个终点$q_1,q_2$，满足从$p_1$能走到$q_1$，从$p_2$能走到$q_2$。反证法：如果不存在两个起点能走到不同的终点，含义就是说这两个起点只能走向同一个终点，也就是说推出了只有一个终点，但是我们知道终点至少有2个，发生矛盾，故得证。如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210730185405.png" alt="image-20210730185405683"></p>
</li>
<li><p>那么我们可以从$q_1$向$p_2$添加一条有向边，这样就会使得“零入度点”和”零出度点“减少一个，即$|P|、|Q|$都少了1，设$|P|$添加了$x$后，可以使得$|P|$中节点个数减为1，那么有$|P|-x=1$，所以$x=|P|-1$，也就是说我们需要添加$|P|-1$条边，就可以使得$|P|$减为1，设此时的集合为$|P’|=1$，那么我们就转换为$|P’|=1$的情况了。同理分析可得此时$|Q’|=|Q|-(|P|-1)$，由于$|P’|=1$这种情况需要添加$|Q’|$条边。因此我们需要添加总的边数为$|P|-1+|Q|-(|P|-1)=|Q|$。</p>
</li>
</ul>
</li>
<li><p>$|Q|\leq |P|$，对称分析，这与情况1相同，此时答案为$|P|$。</p>
</li>
<li><p>因此第二问的答案就是$max(P,Q)$</p>
</li>
</ul>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">110</span>,M=N*N;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="comment">//表示节点u深度优先遍历的序号（也就是节点u被访问的时间点）</span></span><br><span class="line"><span class="comment">//表示节点u或节点u的子孙能够通过非父子边追溯到的dfn最小的节点序号</span></span><br><span class="line"><span class="comment">//即回到最早的过去（也就是节点u通过有向边可回溯到的最早的时间点）</span></span><br><span class="line"><span class="comment">//num表示时间戳</span></span><br><span class="line"><span class="keyword">int</span> dfn[N],low[N],num;</span><br><span class="line"><span class="comment">//a=id[x]表示x这个节点属于a这个强连通分量</span></span><br><span class="line"><span class="comment">//cnt[i]=100表示i这个强连通分量有100个节点</span></span><br><span class="line"><span class="comment">//scc表示强连通分量的编号 scc=3表示第3个强连通分量 最终也只有scc个强连通分量</span></span><br><span class="line"><span class="keyword">int</span> id[N],cnt[N],scc;</span><br><span class="line"><span class="comment">//栈用来存储访问的节点  top是栈顶指针</span></span><br><span class="line"><span class="keyword">int</span> stk[N],top; </span><br><span class="line"><span class="comment">//din存储每个节点的入度 dout存储每个节点的出度 </span></span><br><span class="line"><span class="keyword">int</span> din[N],dout[N];</span><br><span class="line"><span class="comment">//in_stk[i]=true表示节点i还在栈中</span></span><br><span class="line"><span class="keyword">bool</span> in_stk[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u]=low[u]=++num;    <span class="comment">//给节点u分配一个时间戳</span></span><br><span class="line">    stk[++top]=u;           <span class="comment">//将节点u入栈</span></span><br><span class="line">    in_stk[u]=<span class="literal">true</span>;         <span class="comment">//标记节点u在栈中</span></span><br><span class="line">    <span class="comment">//遍历节点u的所有邻接点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];~i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j=e[i]; <span class="comment">//u的邻接点j</span></span><br><span class="line">        <span class="comment">//根据分析得出：先会执行else if中的更新语句,才会执行if中的回溯过程中的更新语句</span></span><br><span class="line">        <span class="comment">//如果节点j还没有被访问过</span></span><br><span class="line">        <span class="keyword">if</span>(!dfn[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(j);<span class="comment">//递归访问j</span></span><br><span class="line">            <span class="comment">//回溯是更新从节点j往回到节点u这条路径上的所有节点的low值</span></span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[u],low[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则说明节点j已经被访问过了 看j是否还在栈中</span></span><br><span class="line">        <span class="comment">//如果还在栈中 那么就说明形成了环 即存在强连通分量</span></span><br><span class="line">        <span class="comment">//当走到这里时说明j先于u被访问,因此u可以追溯到更早的过去</span></span><br><span class="line">        <span class="comment">//于是用更早的dfn[j]来更新low[u]</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(in_stk[j])</span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[u],dfn[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//退无可退 即此时u不能追溯到更早的过去了 那么它就是这个强连通分量的入口</span></span><br><span class="line">    <span class="keyword">if</span>(dfn[u]==low[u])</span><br><span class="line">    &#123;</span><br><span class="line">        scc++;  <span class="comment">//强连通分量的个数+1</span></span><br><span class="line">        <span class="keyword">int</span> y;</span><br><span class="line">        <span class="comment">//输出这个强连通分量中所包含的节点</span></span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            y=stk[top--];       <span class="comment">//强连通分量的节点y</span></span><br><span class="line">            in_stk[y]=<span class="literal">false</span>;    <span class="comment">//标记节点y不在栈中</span></span><br><span class="line">            id[y]=scc;      <span class="comment">//节点y属于scc这个强连通分量</span></span><br><span class="line">            cnt[scc]++;     <span class="comment">//scc这个强连通分量中的节点个数增加了y这个节点</span></span><br><span class="line">        &#125;<span class="keyword">while</span>(y!=u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    cin &gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">while</span>(cin &gt;&gt;j,j)</span><br><span class="line">            <span class="built_in">add</span>(i,j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行tarjan算法</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i])</span><br><span class="line">            <span class="built_in">tarjan</span>(i);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//预处理这个DAG图中入度为0和出度为0的节点个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=h[i];~j;j=ne[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> k=e[j];</span><br><span class="line">            <span class="keyword">int</span> a=id[i];</span><br><span class="line">            <span class="keyword">int</span> b=id[k];</span><br><span class="line">            <span class="keyword">if</span>(a!=b)</span><br><span class="line">            &#123;</span><br><span class="line">                dout[a]++;</span><br><span class="line">                din[b]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//统计这个DAG图中入度为0和出度为0的节点个数</span></span><br><span class="line">    <span class="comment">//p是零入度点的个数  q是零出度点的个数</span></span><br><span class="line">    <span class="keyword">int</span> p=<span class="number">0</span>,q=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=scc;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!din[i])</span><br><span class="line">            p++;</span><br><span class="line">        <span class="keyword">if</span>(!dout[i])</span><br><span class="line">            q++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,p);</span><br><span class="line">    <span class="keyword">if</span>(scc==<span class="number">1</span>)  <span class="comment">//只有一个强连通分量 则不需要添加新边</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">max</span>(p,q));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>有向图的强连通分量</category>
      </categories>
      <tags>
        <tag>tarjan求有向图的强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title>车站分级</title>
    <url>/2021/07/21/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/%E8%BD%A6%E7%AB%99%E5%88%86%E7%BA%A7/</url>
    <content><![CDATA[<h1 id="车站分级"><a href="#车站分级" class="headerlink" title="车站分级"></a>车站分级</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210721151841.png" alt="image-20210721151841388"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>题目中描述的”如果这趟车次停靠了火车站x，则始发站、终点站之间所有级别大于等于火车站x的都必须停靠“，这句话翻译过来就是<strong>停靠过的车站的等级一定严格大于没有停靠过的车站的等级</strong></p>
<p>因此车站的等级均有严格的大小关系，则不存在环，因此可以用拓扑排序每个车站在图中的大小关系。</p>
<p>有些车站会停车，这些车站的集合设为$A$；有些车站不会停车，这些车站的集合设为$B$。由于A中所有车站的级别都严格大于B中车站的级别，因此有$a_i\geq b_i+1$，$a_i\in A$，$b_i\in B$。另外，由于题目说了车站等级最低是$1$，因此有$a_i\geq 1$。</p>
<ul>
<li>对于$a_i\geq b_i+1$，在差分约束中，其实就是$b_i$向$a_i$连一条权值为1的有向边</li>
<li>对于$a_i\geq 1$，其实就是$a_i\geq X_0+1$，其中$X_0=0$，是超级源点。在差分约束中，其实是$X_0$向$a_i$连一条权值为1的有向边</li>
</ul>
<p>由于本题中的所有点的权值都是大于0，并且一定满足要求=&gt;=&gt;所有车站都等级森严=&gt;=&gt;不存在环=&gt;=&gt;可以拓扑排序得到拓扑图使用递推求解差分约束问题。</p>
<p><strong>整体思路：</strong></p>
<ul>
<li>进行拓扑排序得到一张拓扑图</li>
<li>”至少“$\implies$求变量的最小值$\implies$所有条件的下界中取最大值$\implies$跑最长路。因此我们，根据拓扑序跑最长路递推即可</li>
<li>我们求完最长路之后，会得到$n$个<code>dist[i]</code>。取最大的那个$dist[i]$，那么它就是最高等级，而这个最高等级的等级数就是整张图的级数。为什么呢？因为题目要求”$n$个火车站最少划分的级别数“。假设dist有{2，4，5，8}。说明有四个车站，最高等级是8，说明这四个车站最少划分的等级数是8。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210721155006.png" alt="image-20210721155006523"></p>
<p>我们来考虑如何建边：最坏情况下是有1000趟火车，最多存在1000个火车站，每趟上限最多会有500个停靠站（具体原因下述），那么则有$1000-500=500$个不停靠站，不停站的点都向停站的点连有向边，那么对于一趟车次来说，就会建立$500\times500=250000$条边。有1000趟车次，因此总共有$250000\times1000=2.5\times10^{8}$条边，那么则会超过内存。如果用邻接矩阵存储，需要遍历所有的边，遍历的次数也是$2.5\times10^8$，那么则会超时。</p>
<blockquote>
<p>问题：为什么每趟上限最多会有500个停靠站呢？</p>
<p>停靠过的车站的等级一定严格大于为停靠过的车站的等级，不停站的点都向停站的点连有向边，最坏情况下有1000个点，假设停靠站有$x$个，那么不停站就有$1000-x$个。那么需要总共需要建立的总边数就是$y=x(1000-x)$，从这个二元一次方程中可以看出，当$x=500$时，$y$取到最大值。因此，每趟上限最多会有500个停靠站。</p>
</blockquote>
<p>那么有什么技巧能够减少建立的边数呢？一般对于这种把点分成两部分，从一个点集合向另一个点集合引出边，如果最终边数很多的话。那么是可以使用技巧来优化的：</p>
<p>设左边点集合都是不停靠站，右边点集合都是停靠站，那么我们可以在这两个点集合之间建立<strong>辅助节点</strong>（可以看作是连通两个点集合的交通枢纽）。</p>
<p>如下图所示：</p>
<p>可以发现，优化前，左边点集合为$n=4$，右边点集合为$m=4$，那么总边数为$n\times m=16$。优化后，左边点集合为$n=4$，右边点集合为$m=4$，那么总边数为$n+m=8$。因此，边数减少了。当点数特别多时，那么边数就可以大大减少，从而降低了空间复杂度。</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210721162850.png" alt="image-20210721162850371"></p>
<p>对于这种优化后的建图方式来说，每趟车次需要建边$500+500=1000$条边，有1000趟车次，因此总共需要建立边数为$1000\times1000=1e6$，空间复杂度明显降低了。</p>
<p>也就是说，我们可以在中间建一个辅助节点，左边（非停靠站）向辅助节点连一条权值为0的有向边，辅助节点向右边（停靠站）连一条权值为1的有向边，而这就等价于优化前左边直接向右边连一条权值为1的有向边。</p>
<p>注意本题一共有$m$条线路，每条线路都需要一个辅助节点来连通，而原来就已经有了$n$个节点了，因此总的节点数就是$n+m$。</p>
<p>举个栗子：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210721163916.png" alt="image-20210721163916543"></p>
<p><code>dist[i]</code>表示在拓扑图中，点$i$离起点的最长距离。</p>
<p>由于题目保证所有的火车都满足要求，故该图必定是一张有向无环图，在该图上做一遍拓扑排序求出拓扑序之后，从前往后遍历，求一遍最长路，级别的最大值就是最终的答案</p>
<p>注意，假设图中有$n$个点，我们用$1$到$n$表示原来的点，代码实现中，使用$n+i$表示第$i$个辅助节点（$i$从1开始）</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>写法1：求完拓扑排序后得到一张拓扑图，对这张拓扑图求最长路</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2010</span>,M=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],w[M],idx;</span><br><span class="line"><span class="keyword">int</span> d[N],q[N],dist[N];</span><br><span class="line"><span class="comment">//用来距离哪个车站是停靠站  如果st[i]=true表示第i个车站是停靠站</span></span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="comment">//从a向b连一条权值为c的有向边</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    w[idx]=c;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">    d[b]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进行拓扑排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+m;i++)<span class="comment">//一共有n+m个点</span></span><br><span class="line">        <span class="keyword">if</span>(!d[i])</span><br><span class="line">            q[++tt]=i;</span><br><span class="line">    <span class="keyword">while</span>(hh&lt;=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=q[hh++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(--d[j]==<span class="number">0</span>)</span><br><span class="line">                q[++tt]=j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="comment">//输入m趟车次的信息</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//每次都要情况上一趟车次的停靠站信息</span></span><br><span class="line">        <span class="built_in">memset</span>(st,<span class="number">0</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">        <span class="comment">//起始站和终点站</span></span><br><span class="line">        <span class="keyword">int</span> start=n,end=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;cnt);</span><br><span class="line">        <span class="comment">//读入cnt个停靠站的信息</span></span><br><span class="line">        <span class="keyword">while</span>(cnt--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> stop;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;stop);</span><br><span class="line">            start=<span class="built_in">min</span>(start,stop);</span><br><span class="line">            end=<span class="built_in">max</span>(end,stop);</span><br><span class="line">            <span class="comment">//标记stop这个车站是停靠站</span></span><br><span class="line">            st[stop]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//辅助节点的编号</span></span><br><span class="line">        <span class="keyword">int</span> ver=n+i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=start;j&lt;=end;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果是非停靠站  那么从非停靠站j向辅助节点ver连一条长度为0的有向边</span></span><br><span class="line">            <span class="keyword">if</span>(!st[j])</span><br><span class="line">                <span class="built_in">add</span>(j,ver,<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//如果是停靠站  那么从辅助节点ver向停靠站j连一条长度为1的有向边    </span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">add</span>(ver,j,<span class="number">1</span>);    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进行拓扑排序  得到一张拓扑图</span></span><br><span class="line">    <span class="built_in">topsort</span>();</span><br><span class="line">    <span class="comment">//由于车站等级最低为1级 由差分约束可知 这里是相当于建立了一个超级源点</span></span><br><span class="line">    <span class="comment">//这个超级源点到其他n个节点的距离为1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    dist[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//这张拓扑图中有n+m个节点    求最长路</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n+m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//取出拓扑图中的某个节点t</span></span><br><span class="line">        <span class="keyword">int</span> t=q[i];</span><br><span class="line">        <span class="comment">//遍历t的所有邻接点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//j是t的邻接点</span></span><br><span class="line">            <span class="keyword">int</span> j=e[i];</span><br><span class="line">            <span class="comment">//求出最长路</span></span><br><span class="line">            dist[j]=<span class="built_in">max</span>(dist[j],dist[t]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//找到等级最高的那个dist   那么就是整张图的级数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    res=<span class="built_in">max</span>(res,dist[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>写法2：直接在拓扑排序里求dist</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2010</span> , M = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line"><span class="keyword">int</span> e[M] , ne[M] , w[M] , h[N] , idx;</span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="keyword">int</span> q[N] , d[N];</span><br><span class="line"><span class="keyword">int</span> res;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a , <span class="keyword">int</span> b , <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b , ne[idx] = h[a] , w[idx] = c , h[a] = idx++;</span><br><span class="line">    d[b]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span> , tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n + m ; i++)<span class="comment">//因为加入了辅助节点，所以点数是n+m</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!d[i])</span><br><span class="line">        &#123;</span><br><span class="line">            q[++tt] = i;</span><br><span class="line">            <span class="keyword">if</span>(i &lt;= n) </span><br><span class="line">                dist[i] = <span class="number">1</span>;<span class="comment">//普通节点的初始等级是1，辅助节点的初始等级是0.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = q[hh++];</span><br><span class="line">        <span class="keyword">int</span> temp = (t &gt; n);<span class="comment">//如果是辅助节点连向普通点边权是1，普通节点连向辅助节点边权是0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = h[t] ; ~i ; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(--d[j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + temp;</span><br><span class="line">                q[++tt] = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(h , <span class="number">-1</span> , <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(st , <span class="number">0</span> , <span class="keyword">sizeof</span> st);</span><br><span class="line">        <span class="keyword">int</span> cnt;</span><br><span class="line">        cin &gt;&gt; cnt;</span><br><span class="line">        <span class="keyword">int</span> start = n , end = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(cnt--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> stop;</span><br><span class="line">            cin &gt;&gt; stop;</span><br><span class="line">            start = <span class="built_in">min</span>(start , stop);</span><br><span class="line">            end = <span class="built_in">max</span>(end , stop);</span><br><span class="line">            st[stop] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ver = i + n;<span class="comment">//建立辅助节点</span></span><br><span class="line">        <span class="comment">//遍历从始发站到终点站的信息</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = start ; j &lt;= end;  j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果是非停靠站  那么从非停靠站j向辅助节点ver连一条长度为0的有向边</span></span><br><span class="line">            <span class="keyword">if</span>(!st[j])</span><br><span class="line">                <span class="built_in">add</span>(j,ver,<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//如果是停靠站  那么从辅助节点ver向停靠站j连一条长度为1的有向边    </span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">add</span>(ver,j,<span class="number">1</span>);    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">topsort</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++) </span><br><span class="line">        res = <span class="built_in">max</span>(res , dist[i]);</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>写法3：</p>
<p>看到如此鲜明的层级关系，就是拓扑排序了，从未停靠站向停靠站连一条有向边。</p>
<p>此题的要点在于如何计算等级：</p>
<p>利用$dep[son]=dep[father]+1$递推出每一个点在图中是第几层，进而推出了它的等级，然后在计算完一个$dep[i]$时，都用$max$取最大值，最终那个最高等级的等级数就是整张图的级数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>,M=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="comment">//a数组用来记录停靠站的信息  dep数组用来记录拓扑序中的每个节点都处于哪一层,即属于什么等级</span></span><br><span class="line"><span class="keyword">int</span> a[N],dep[N],d[N];</span><br><span class="line"><span class="comment">//st[i]=true表示第i个车站是停靠站</span></span><br><span class="line"><span class="comment">//vst[j][a[p]]表示从非停靠站j向停靠站a[p]连一条有向边</span></span><br><span class="line"><span class="keyword">bool</span> st[N],vst[N][N];</span><br><span class="line"><span class="keyword">int</span> ans;    <span class="comment">//答案</span></span><br><span class="line"><span class="comment">//快读</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> Sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> F=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(c&gt;<span class="string">&#x27;9&#x27;</span> || c&lt;<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            F=<span class="number">-1</span>;</span><br><span class="line">        c=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(c&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; c&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Sum=Sum*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        c=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Sum*F;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">    d[b]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!d[i])</span><br><span class="line">        &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">            <span class="comment">//由于车站等级最低是1级</span></span><br><span class="line">            <span class="comment">//因此那些刚开始时 对于这张图中所有入度为0的节点都是处于同一层</span></span><br><span class="line">            <span class="comment">//即这些入度为0的车站都是相同等级,处于第一层</span></span><br><span class="line">            dep[i]=<span class="number">1</span>;        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">//遍历t的所有邻接点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//j是t的邻接点</span></span><br><span class="line">            <span class="keyword">int</span> j=e[i]; </span><br><span class="line">            <span class="comment">//所有t的邻接点都是处于t的下一层</span></span><br><span class="line">            <span class="comment">//即t的所有邻接点都比节点t的等级多1</span></span><br><span class="line">            dep[j]=dep[t]+<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//找到等级最高的那个就是整张图的级数</span></span><br><span class="line">            ans=<span class="built_in">max</span>(ans,dep[j]);</span><br><span class="line">            <span class="keyword">if</span>(--d[j]==<span class="number">0</span>)</span><br><span class="line">            q.<span class="built_in">push</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span> a);</span><br><span class="line">        <span class="built_in">memset</span>(st,<span class="number">0</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">        <span class="keyword">int</span> start=n,end=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt;</span><br><span class="line">        cin&gt;&gt;cnt;</span><br><span class="line">        <span class="comment">//输入这cnt个停靠站的信息</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=cnt;k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> stop;</span><br><span class="line">            cin &gt;&gt;stop;</span><br><span class="line">            a[k]=stop;</span><br><span class="line">            start=<span class="built_in">min</span>(start,stop);</span><br><span class="line">            end=<span class="built_in">max</span>(end,stop);</span><br><span class="line">            st[stop]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从起始站到终点站</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=start;j&lt;=end;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果j不是停靠站</span></span><br><span class="line">            <span class="keyword">if</span>(!st[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">1</span>;p&lt;=cnt;p++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//如果非停靠站j还没有向停靠站a[p]连过一条有向边</span></span><br><span class="line">                    <span class="keyword">if</span>(!vst[j][a[p]])</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//从非停靠站j向停靠站a[p]连一条有向边</span></span><br><span class="line">                        <span class="built_in">add</span>(j,a[p]);</span><br><span class="line">                        vst[j][a[p]]=<span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">topsort</span>();</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>拓扑排序</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>最大半连通子图</title>
    <url>/2021/07/30/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/%E6%9C%80%E5%A4%A7%E5%8D%8A%E8%BF%9E%E9%80%9A%E5%AD%90%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="最大半连通子图"><a href="#最大半连通子图" class="headerlink" title="最大半连通子图"></a>最大半连通子图</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210730214958.png" alt="image-20210730214958237"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>根据题目给出的 导出子图、半连通子图、最大半连通子图的定义可知，强连通图一定是半连通子图。由于题目要求的是最大半连通图，又由于强连通分量中任意两个点之间都是可以相互到达的，因此，我们最好选择强连通分量。然后我们可以对强连通分量进行缩点，但是这里要注意，我们要把缩点后的图给真的建立出来。我们在缩点后，会得到一张DAG图，在DAG上找到一个最长链（所谓最长是指链上的点最多），这条链上的点的数目就是最大半连通子图的点的数目。因为是拓扑图，所以可以采用递推的方式求解最大半连通子图中点的数目以及对应的方案数，本质上是一个DP。</p>
<p>下面给出<code>f[]</code>和<code>g[]</code>的定义：</p>
<ul>
<li><code>f[i]</code>表示以第 i 个点为终点的最长链节点数量之和</li>
<li><code>g[i]</code>表示让$f[i]$取到最大值时对应的方案数，也就是说有$g[i]$条最长链，可以使$f[i]$取得最大值</li>
</ul>
<p>由于这是DAG，没有后效性，因此可以用dp思想进行递推，如果存在一条从$i$到$j$的边，则状态转移如下：</p>
<ul>
<li>如果$f[j]+cnt[i]&gt;f[i]$，那么更新$f[i]=f[j]+cnt[i]$，由于只是增加了点数，并没有产生新方案，因此$g[i]=g[j]$</li>
<li>如果$f[j]+cnt[i]=f[i]$，虽然相等，但是这是两种不同的方案，因此$g[i]=g[i]+g[j]$</li>
</ul>
<p>这里求方案数的思想与 背包问题求方案数 是一样的，<a href="https://blog.csdn.net/qq_45832461/article/details/115560882">背包问题求方案数</a></p>
<p>这里还需要注意，这条最长链不能有分叉，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210730222120.png" alt="image-20210730222120447"></p>
<p>使用两个表头分别存储原图<code>h[]</code>和缩点后的新图<code>hs[]</code>，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210730222216.png" alt="image-20210730222216652"></p>
<p>这里还需要注意重边，根据最大半连通子图的含义可知，区别不同的最大半连通子图关键在于 <strong>点的不同</strong> 而不是边的不同，也就是说如果对于两个节点$i,j$，它俩之间有很多边，在求解DAG最长链时就会把这些边都当作不同的路径了，所以很产生很多方案。但是由于都是节点$i,j$，因此点是相同的，于是这就不能算作是不同的最大半连通子图。如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210730222908.png" alt="image-20210730222908554"></p>
<p>为了消除重边的影响，我们需要对边进行判重，这里使用哈希表进行判重。我们把边都哈希成不同的整数，这里的哈希函数是$a* 1000000ll + b$。为什么呢？</p>
<p>因为题目中给出了点数最多是1e6，也就是说点的编号最大是1e6。那么边的编号只能从1e6+1开始了。由于节点$a,b$的编号必然不同，因此设置$a* 1000000ll + b$就可以让边的编号从1e6+1开始取并且还不相同了。这样就可以消除重边的影响了。</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="comment">//h[]原图的表头  hs[]缩点后得到的这张DAG图的表头</span></span><br><span class="line"><span class="keyword">int</span> h[N],hs[N],e[M],ne[M],idx;</span><br><span class="line"><span class="comment">//表示节点u深度优先遍历的序号（也就是节点u被访问的时间点）</span></span><br><span class="line"><span class="comment">//表示节点u或节点u的子孙能够通过非父子边追溯到的dfn最小的节点序号</span></span><br><span class="line"><span class="comment">//即回到最早的过去（也就是节点u通过有向边可回溯到的最早的时间点）</span></span><br><span class="line"><span class="comment">//num表示时间戳</span></span><br><span class="line"><span class="keyword">int</span> dfn[N],low[N],num;</span><br><span class="line"><span class="comment">//a=id[x]表示x这个节点属于a这个强连通分量</span></span><br><span class="line"><span class="comment">//cnt[i]=100表示i这个强连通分量有100个节点</span></span><br><span class="line"><span class="comment">//scc表示强连通分量的编号 scc=3表示第3个强连通分量 最终也只有scc个强连通分量</span></span><br><span class="line"><span class="keyword">int</span> id[N],cnt[N],scc;</span><br><span class="line"><span class="comment">//栈用来存储访问的节点  top是栈顶指针</span></span><br><span class="line"><span class="keyword">int</span> stk[N],top; </span><br><span class="line"><span class="comment">//din存储每个节点的入度 dout存储每个节点的出度 </span></span><br><span class="line"><span class="keyword">int</span> din[N],dout[N];</span><br><span class="line"><span class="comment">//in_stk[i]=true表示节点i还在栈中</span></span><br><span class="line"><span class="keyword">bool</span> in_stk[N];</span><br><span class="line"><span class="comment">//f[i]表示以第 i 个点为终点的最长链节点数量之和</span></span><br><span class="line"><span class="comment">//g[i]表示让f[i]取到最大值时对应的方案数</span></span><br><span class="line">LL f[N],g[N];</span><br><span class="line"><span class="keyword">int</span> n,m,mod;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> h[],<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u]=low[u]=++num;    <span class="comment">//给节点u分配一个时间戳</span></span><br><span class="line">    stk[++top]=u;           <span class="comment">//将节点u入栈</span></span><br><span class="line">    in_stk[u]=<span class="literal">true</span>;         <span class="comment">//标记节点u在栈中</span></span><br><span class="line">    <span class="comment">//遍历节点u的所有邻接点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];~i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j=e[i]; <span class="comment">//u的邻接点j</span></span><br><span class="line">        <span class="comment">//根据分析得出：先会执行else if中的更新语句,才会执行if中的回溯过程中的更新语句</span></span><br><span class="line">        <span class="comment">//如果节点j还没有被访问过</span></span><br><span class="line">        <span class="keyword">if</span>(!dfn[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(j);<span class="comment">//递归访问j</span></span><br><span class="line">            <span class="comment">//回溯是更新从节点j往回到节点u这条路径上的所有节点的low值</span></span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[u],low[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则说明节点j已经被访问过了 看j是否还在栈中</span></span><br><span class="line">        <span class="comment">//如果还在栈中 那么就说明形成了环 即存在强连通分量</span></span><br><span class="line">        <span class="comment">//当走到这里时说明j先于u被访问,因此u可以追溯到更早的过去</span></span><br><span class="line">        <span class="comment">//于是用更早的dfn[j]来更新low[u]</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(in_stk[j])</span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[u],dfn[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//退无可退 即此时u不能追溯到更早的过去了 那么它就是这个强连通分量的入口</span></span><br><span class="line">    <span class="keyword">if</span>(dfn[u]==low[u])</span><br><span class="line">    &#123;</span><br><span class="line">        scc++;  <span class="comment">//强连通分量的个数+1</span></span><br><span class="line">        <span class="keyword">int</span> y;</span><br><span class="line">        <span class="comment">//输出这个强连通分量中所包含的节点</span></span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            y=stk[top--];       <span class="comment">//强连通分量的节点y</span></span><br><span class="line">            in_stk[y]=<span class="literal">false</span>;    <span class="comment">//标记节点y不在栈中</span></span><br><span class="line">            id[y]=scc;      <span class="comment">//节点y属于scc这个强连通分量</span></span><br><span class="line">            cnt[scc]++;     <span class="comment">//scc这个强连通分量中的节点个数增加了y这个节点</span></span><br><span class="line">        &#125;<span class="keyword">while</span>(y!=u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">memset</span>(hs,<span class="number">-1</span>,<span class="keyword">sizeof</span> hs);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;mod);</span><br><span class="line">    <span class="comment">//建立原图</span></span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="built_in">add</span>(h,a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i])</span><br><span class="line">            <span class="built_in">tarjan</span>(i);</span><br><span class="line"></span><br><span class="line">    unordered_set&lt;LL&gt;S; <span class="comment">//哈希表  对边判重 消除重边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//遍历节点i的所有邻接点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=h[i];~j;j=ne[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> k=e[j]; <span class="comment">//i的邻接点k</span></span><br><span class="line">            <span class="keyword">int</span> a=id[i];    <span class="comment">//节点i所在的强连通分量 也就是缩点后得到的某个节点a</span></span><br><span class="line">            <span class="keyword">int</span> b=id[k];    <span class="comment">//节点k所在的强连通分量 也就是缩点后得到的某个节点b</span></span><br><span class="line">            <span class="comment">//节点a,b之间这条边的编号哈希成&gt;1000000的一个整数值</span></span><br><span class="line">            LL hash=a*<span class="number">1000000ll</span>+b;</span><br><span class="line">            <span class="comment">//如果a和b都不在同一个强连通分量中并且这条边还没有出现过</span></span><br><span class="line">            <span class="keyword">if</span>(a!=b&amp;&amp;!S.<span class="built_in">count</span>(hash))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//将缩点后的这张DAG图真的建立出来</span></span><br><span class="line">                <span class="built_in">add</span>(hs,a,b);</span><br><span class="line">                S.<span class="built_in">insert</span>(hash);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//tarjan求完后，scc的编号递减顺序就是拓扑序列</span></span><br><span class="line">    <span class="comment">//预处理出f[]和g[]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=scc;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!f[i])   <span class="comment">//如果当前点没有更新，就进行初始化</span></span><br><span class="line">        &#123;</span><br><span class="line">            f[i]=cnt[i];</span><br><span class="line">            g[i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历节点i的所有邻接点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=hs[i];~j;j=ne[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> k=e[j]; <span class="comment">//i的邻接点k</span></span><br><span class="line">            <span class="comment">//通过i能够更新k  只是让f[k]变多了 并没有产生新的方案</span></span><br><span class="line">            <span class="keyword">if</span>(f[k]&lt;f[i]+cnt[k])</span><br><span class="line">            &#123;</span><br><span class="line">                f[k]=f[i]+cnt[k];</span><br><span class="line">                g[k]=g[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//比如f[k]=8  f[i]=5 cnt[k]=3 那么&#123;8&#125;和&#123;5,3&#125;就是两种不同的方案</span></span><br><span class="line">            <span class="comment">//使得节点k的f值都是8  于是如果相同的话就会产生新方案</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(f[k]==f[i]+cnt[k])</span><br><span class="line">                g[k]=(g[k]+g[i])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//maxf是记录最大的f[]  sum是记录最大的g[]</span></span><br><span class="line">    <span class="keyword">int</span> maxf=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=scc;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(f[i]&gt;maxf)</span><br><span class="line">        &#123;</span><br><span class="line">            maxf=f[i];</span><br><span class="line">            sum=g[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(f[i]==maxf)</span><br><span class="line">            sum=(sum+g[i])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,maxf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>有向图的强连通分量</category>
      </categories>
      <tags>
        <tag>tarjan求有向图的强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title>tarjan</title>
    <url>/2021/07/30/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/tarjan/</url>
    <content><![CDATA[<h1 id="tarjan算法求有向图的强连通分量"><a href="#tarjan算法求有向图的强连通分量" class="headerlink" title="tarjan算法求有向图的强连通分量"></a>tarjan算法求有向图的强连通分量</h1><hr>
<h3 id="连通性的相关知识"><a href="#连通性的相关知识" class="headerlink" title="连通性的相关知识"></a>连通性的相关知识</h3><h4 id="无向图的连通分量"><a href="#无向图的连通分量" class="headerlink" title="无向图的连通分量"></a>无向图的连通分量</h4><p>在无向图中，如果从节点$v_i$到节点$v_j$有路径，则称节点$v_i$和节点$v_j$是连通的。如果图中任意两个节点之间都是连通的，则称图$G$为连通图。</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210730140441.png" alt="image-20210730140441026"></p>
<p>无向图$G$的<strong>极大连通子图</strong>被称为图$G$的连通分量。极大连通子图是图$G$的连通子图，如果再向其中加入一个节点，则该子图就不再是连通的。连通图的连通分量就是它自身；非连通图则有两个及以上的连通分量。</p>
<p>如下图所示，有3个连通分量：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210730141251.png" alt="image-20210730141251304"></p>
<h4 id="有向图的强连通分量"><a href="#有向图的强连通分量" class="headerlink" title="有向图的强连通分量"></a>有向图的强连通分量</h4><p>在有向图中，如果图中的任意两个节点从$v_i$到$v_j$都有路径，且从$v_j$到$v_i$也有路径，则称图$G$为强连通图。</p>
<p>有向图$G$的<strong>极大强连通子图</strong>被称为图$G$的强连通分量。极大强连通子图是图$G$的强连通子图，如果再向其中加入一个节点，则该子图就不再是强连通的。</p>
<p>如下图所示，(a)是强连通图，(b)不是强连通图，(c)是(b)的强连通分量：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210730141824.png" alt="image-20210730141824251"></p>
<hr>
<h3 id="tarjan算法"><a href="#tarjan算法" class="headerlink" title="tarjan算法"></a>tarjan算法</h3><p>首先引入时间戳和追溯点的概念</p>
<ul>
<li>时间戳：<code>dfn[u]</code>表示节点$u$深度优先遍历的序号（也就是节点$u$被访问的时间点）</li>
<li>追溯点：<code>low[u]</code>表示节点$u$或者节点$u$的子孙能够通过<strong>非父子边</strong>追溯到的dfn最小的节点序号，即回到最早的过去（也就是节点$u$通过有向边可回溯到的最早的时间点）</li>
</ul>
<p>这里有必要说以下dfs遍历的两种方式：</p>
<ul>
<li>方式一：先访问当前节点，然后再递归访问相邻节点（这类似于树的先序遍历）</li>
<li>方式二：先递归相邻节点，到达叶子节点后回溯时再依次访问路径中的节点（这类似于树的后序遍历）</li>
</ul>
<p>如下图所示，这两种方式输出的结果是不同的：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210730143215.png" alt="image-20210730143214955"></p>
<p>在tarjan算法中，采用的是方式二</p>
<p>举个栗子，在深度优先搜索中，每个点的时间戳和追溯点的求解过程如下：</p>
<p>我们用栈stk来存储访问的节点</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210730145108.png" alt="image-20210730145108651"></p>
<p>初始时，$dfn[u]=low[u]$，从节点$1$开始深搜，如果该节点的邻接点还没有被访问过，则一直递归进行深度优先遍历，$1\to2\to3\to5\to6\to4$，此时栈中内容为{1，2，3，5，6，4}，此时节点$4$的邻接点$1$已经被访问过了，并且节点$1$并不是节点$4$的父节点，节点$4$的父节点是节点$6$（深度优先搜索树上的父节点），那么这条边$4\to1$就是一条非父子边，那么节点$4$顺着这条非父子边能回到最早的节点是节点$1$，那么此时就需要修改节点$4$它的追溯点为$dfn[1]$。我们知道$dfn[1]$必然是小于$low[4]$的，因为节点$1$先于节点$4$被访问，它的时间戳小。所以我们可以直接用$low[4]=dfn[1]$，但是为了严谨，一般都是用$low[4]=min(low[4],dfn[1])$</p>
<blockquote>
<p>但是有个问题，设当前访问节点$u=4$，遍历到它的邻接点$v=1$，要执行$low[u]=min(low[u],dfn[v])$的前提是节点$v$它此刻还是在栈中，为什么呢？</p>
<p>如上图所示，当节点$4$要访问节点$1$时，此时栈内的元素为{1，2，3，5，6，4}，可以发现节点$v=1$还在栈中，也就是说节点$u=4$可以通过这条非父子边到达节点$v=1$。如果节点$v=1$不在栈中，那么可以认为此时节点$u=4$与节点$v=1$这条非父子边是不存在的。既然非父子边不存在，那么就不能通过非父子边回溯到更早，于是也就不能更新节点$u$的时间戳。</p>
</blockquote>
<p>在上面分析中，我们知道了$low[4]=min(low[4],dfn[1])=1$，接下来就要开始回溯了。回溯时需要执行$low[u]=min(low[u],low[v])$，为什么呢？因为既然子孙能够回到更早过去，那么其祖先节点也可以回到更早的过去，于是回溯时此刻$u=6,v=4$，更新$low[6]=min(low[6],low[4])=1$，以此类推，更新节点$5,3,2$的时间戳。</p>
<p>我们可以知道{1，2，3，5，6，4}是一个强连通分量了。同理分析，从节点$1$开始深搜，如果该节点的邻接点还没有被访问过，则一直递归进行深度优先遍历，$1\to2\to3\to5\to7$，此时栈中内容为{1，2，3，5，7}。当前节点$u=7$，可以知道它没有非父子边，所以它不能通过非父子边回溯到更早的过去。于是它自己就是一个强连通分量{7}。</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210730151852.png" alt="image-20210730151852176"></p>
<blockquote>
<p>那么我们什么时候才能输出这个强连通分量呢？</p>
<p>当回溯时，一直回溯到某个节点，它的时间戳<code>dfn[u]</code>与追溯点<code>low[u]</code>是相同时，就可以输出这个强连通分量了。因为此时说明这个节点$u$它不再能够通过非父子边回溯到更早的过去了。</p>
</blockquote>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="comment">//用栈stk来存储强连通分量中的节点</span></span><br><span class="line"><span class="keyword">int</span> stk[N],top;</span><br><span class="line"><span class="comment">//num是时间戳</span></span><br><span class="line"><span class="keyword">int</span> dfn[N],low[N],num;</span><br><span class="line"><span class="comment">//scc_cnt是记录这是第几个强连通分量</span></span><br><span class="line"><span class="comment">//id数组用来存储某个节点是属于哪个强连通分量</span></span><br><span class="line"><span class="comment">//cnt用来记录某个强连通分量中的节点个数</span></span><br><span class="line"><span class="keyword">int</span> id[N],cnt[N],scc_cnt;</span><br><span class="line"><span class="comment">//判断某个节点是否在栈中</span></span><br><span class="line"><span class="keyword">bool</span> in_stk[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u]=low[u]=++num;</span><br><span class="line">    stk[++top]=u;</span><br><span class="line">    in_stk[u]=<span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;调用tarjan(%d) dfn[%d]=low[%d]=%d,栈顶stk[%d]=%d\n&quot;</span>,u,u,u,num,top,u);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];~i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j=e[i];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(j);</span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[u],low[j]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;回溯 %d-&gt;%d low[%d]=%d\n&quot;</span>,j,u,u,low[u]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(in_stk[j])</span><br><span class="line">        &#123;</span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[u],dfn[j]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;有环 %d-&gt;%d low[%d]=%d\n&quot;</span>,u,j,u,low[u]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;判断if(%d==%d)?\n&quot;</span>,dfn[u],low[u]);</span><br><span class="line">    <span class="keyword">if</span>(dfn[u]==low[u])</span><br><span class="line">    &#123;</span><br><span class="line">        scc_cnt++;</span><br><span class="line">        <span class="keyword">int</span> y;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输出第%d个强连通分量:&#123;&quot;</span>,scc_cnt);</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            y=stk[top--];</span><br><span class="line">            in_stk[y]=<span class="literal">false</span>;</span><br><span class="line">            id[y]=scc_cnt;</span><br><span class="line">            cnt[scc_cnt]++;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,y);</span><br><span class="line">        &#125;<span class="keyword">while</span>(y!=u);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&#125;\n输出此时栈顶stk[%d]=%d\n\n&quot;</span>,top,stk[top]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    cin &gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        cin &gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="built_in">add</span>(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i])</span><br><span class="line">            <span class="built_in">tarjan</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如上图中的栗子来说，输出结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210730152417.png" alt="image-20210730152417469"></p>
<ul>
<li>第一个连通分量为{7}</li>
<li>第二个连通分量为{4,6,5,4,2,1}</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>tarjan</category>
      </categories>
      <tags>
        <tag>tarjan求有向图的强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title>无源汇上下界可行流</title>
    <url>/2021/08/06/Algorithm-Advanced/Chapter1---Gragh-Theory/%E6%9C%80%E5%A4%A7%E6%B5%81%E4%B9%8B%E4%B8%8A%E4%B8%8B%E7%95%8C%E5%8F%AF%E8%A1%8C%E6%B5%81/%E6%97%A0%E6%BA%90%E6%B1%87%E4%B8%8A%E4%B8%8B%E7%95%8C%E5%8F%AF%E8%A1%8C%E6%B5%81/</url>
    <content><![CDATA[<h1 id="无源汇上下界可行流"><a href="#无源汇上下界可行流" class="headerlink" title="无源汇上下界可行流"></a>无源汇上下界可行流</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210806180157.png" alt="image-20210806180157259"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>这个题目，给出了容量的下界和上界，这使得与普通的网络流不同。设容量下界为$C_l(u,v)$，容量上界为$C_u(u,v)$，边$(u,v)$上的流量为$f(u,v)$，要求$C_l(u,v)\leq f(u,v)\leq C_u(u,v)$</p>
<p>我们令该式子都减去$C_l(u,v)$，则得到$0\leq f(u,v)-C_l(u,v)\leq C_u(u,v)-C_l(u,v)$。那么就转换为普通网络流的容量限制了。但是此时构建的这张新图中，并不一定满足流量守恒。</p>
<blockquote>
<p>可行流算法的核心是将一个不满足流量守恒的初始流调整成满足流量守恒的流</p>
</blockquote>
<p>初始流即一开始将每条边流量设为$low(i)$的流。显然这个流不一定满足流量守恒。我们要通过调整（再加上一个附加流）将其变为可行流。</p>
<p>设$\sum _{i=u} \limits f_{in}(i)$表示到达点$u$的流入量，$\sum _{i=u} \limits f_{out}(i)$表示从点$u$出去的流出量，我们在原图中，令$A[u]=<script type="math/tex">\sum _{i=u} \limits f_{in}(i)-</script>\sum _{i=u} \limits f_{out}(i)$，即初始流中，点$u$的流入量-流出量</p>
<p>在附加流中，让点$u$的流入量-流出量=$-A[u]$，就能保证流量守恒了。</p>
<ul>
<li>在附加流中，当$-A[u]<0$时，即$A[u]>0$，说明在新图中，点$u$的流入量小于点$u$的流出量，那么在新图中我们就需要增加点$u$的流入量，要增加的流入量为$A[u]$。那么我们就需要增加附加边，使得点$u$的流入量等于点$u$的流出量。因此，我们可以新建一个超级源点$S$，从$S$直接连一条容量为$A[u]$的有向边到点$u$，即$S\to u$。</li>
<li>在附加流中，当$-A[u]&gt;0$，即$A[u]&lt;0$，说明在新图中，点$u$的流入量大于点$u$的流出量，那么在新图中我们就需要增加点$u$的流出量，要增加的流出量为$-A[u]$（因为$A[u]$是负数，我们增加的流量不能是负值）。那么我们就需要增加附加边，使得点$u$的流入量等于点$u$的流出量。因此，我们可以新建一个超级汇点$T$，从点$u$直接连一条容量为$-A[u]$的有向边到汇点$T$，即$u\to T$</li>
</ul>
<p>如下图理解：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210806205908.png" alt="image-20210806205908032"></p>
<p>接着：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210806205951.png" alt="image-20210806205951129"></p>
<p><strong>算法设计：</strong></p>
<p>step1：</p>
<p>建立新图G’。新边容量为d-c（上界-下界）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">S = <span class="number">0</span>, T = n+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b, c, d;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;</span><br><span class="line">    <span class="built_in">add</span>(a, b, c, d);</span><br><span class="line">    A[b] += c, A[a] -= c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>step2：</p>
<p>建立超级源点S和超级汇点T。流入大于流出点，连S到i，容量为A[i]；流出小于流入点，连i到T，容量为-A[i]    </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    <span class="keyword">if</span> (A[i] &gt; <span class="number">0</span>) <span class="built_in">add</span>(s, i, <span class="number">0</span>, A[i]), tot += A[i];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (A[i] &lt; <span class="number">0</span>) <span class="built_in">add</span>(i, t, <span class="number">0</span>, -A[i]);</span><br></pre></td></tr></table></figure>
<p>step3：</p>
<p>判断流量守恒条件dinic() == tot。<strong>所有附加边的最大流满流，说明原图存在可行流</strong>（证明不会qaq，可以参考上图理解…）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (tot != <span class="built_in">dinic</span>()) <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>step4：</p>
<p>由于我们在新图$G’$中每条边都减去了该边的最小下界，因此在输出原图可行流时，是f[i^1]再加上最小下界$l[i]$</p>
<p>这里反向边的容量f[i^1]的值是正向边f[i]的流量值，$i$在附加流中的流量（即反边容量）。这里主要是运用残留网络中双向边的含义。</p>
<p>残留网络中的反向边f[i^1]表示的是原图中的正向边，而原图中正向边的含义就是这条边的流量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m*<span class="number">2</span>; i += <span class="number">2</span>)</span><br><span class="line">        cout &lt;&lt; f[i^<span class="number">1</span>] + l[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意边数的计算：题目描述中给出了最终有$10200$条边，由于我们需要增加从超级源点S到这$200$个点的边已经从这$200$个点到超级汇点$T$的边，在构建残留网络时，需要双向边，因此总共的边数就是$M=(10200+N)\times2$</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">210</span>,M=(<span class="number">10200</span>+N)*<span class="number">2</span>,INF=<span class="number">1e8</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,S,T;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],f[M],l[M],idx;  <span class="comment">//l[]数组存储的是每条边的流量下界</span></span><br><span class="line"><span class="keyword">int</span> q[N],d[N],cur[N],A[N];  <span class="comment">//A[i]表示第i个点的流入量与流出量的差值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c,<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//第idx条边的容量f[idx]为d-c  流量下界l[idx]是c</span></span><br><span class="line">    e[idx]=b,f[idx]=d-c,l[idx]=c,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">    e[idx]=a,f[idx]=<span class="number">0</span>,ne[idx]=h[b],h[b]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==T)</span><br><span class="line">        <span class="keyword">return</span> limit;</span><br><span class="line">    <span class="keyword">int</span> flow=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=cur[u];~i&amp;&amp;flow&lt;limit;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ver=e[i];</span><br><span class="line">        <span class="keyword">if</span>(d[ver]==d[u]+<span class="number">1</span>&amp;&amp;f[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t=<span class="built_in">find</span>(ver,<span class="built_in">min</span>(f[i],limit-flow));</span><br><span class="line">            <span class="keyword">if</span>(!t)</span><br><span class="line">                d[ver]=<span class="number">-1</span>;</span><br><span class="line">            f[i]-=t,f[i^<span class="number">1</span>]+=t,flow+=t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">    <span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>]=S,d[S]=<span class="number">0</span>,cur[S]=h[S];</span><br><span class="line">    <span class="keyword">while</span>(hh&lt;=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=q[hh++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> ver=e[i];</span><br><span class="line">            <span class="keyword">if</span>(d[ver]==<span class="number">-1</span>&amp;&amp;f[i])</span><br><span class="line">            &#123;</span><br><span class="line">                d[ver]=d[t]+<span class="number">1</span>;</span><br><span class="line">                cur[ver]=h[ver];</span><br><span class="line">                <span class="keyword">if</span>(ver==T)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                q[++tt]=ver;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxflow=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> flow;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(flow=<span class="built_in">find</span>(S,INF))</span><br><span class="line">            maxflow+=flow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxflow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    S=<span class="number">0</span>,T=n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c,d;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c,&amp;d);</span><br><span class="line">        <span class="built_in">add</span>(a,b,c,d);</span><br><span class="line">        <span class="comment">//从a流向b  每条边都减去它的流量下界</span></span><br><span class="line">        <span class="comment">//因此节点a减少了c</span></span><br><span class="line">        <span class="comment">//节点b增加了c</span></span><br><span class="line">        A[a]-=c,A[b]+=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tot=<span class="number">0</span>;  <span class="comment">//记录从超级源点S到当前点i的流量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i]&gt;<span class="number">0</span>)<span class="comment">//如果节点i的流入量与流出量的差值大于0</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//从超级源点S到节点i添加一条 流量下界为0 流量上界为A[i] 的附加边</span></span><br><span class="line">            <span class="built_in">add</span>(S,i,<span class="number">0</span>,A[i]);</span><br><span class="line">            tot+=A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(A[i]&lt;<span class="number">0</span>) <span class="comment">//如果节点i的流入量与流出量的差值小于0</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//从节点i到超级汇点T添加一条 流量下界为0 流量上界为-A[i] 的附加边</span></span><br><span class="line">            <span class="built_in">add</span>(i,T,<span class="number">0</span>,-A[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用dinic算法在新图中求出最大流后,如果这个最大流不等于tot</span></span><br><span class="line">    <span class="comment">//则说明不满足&quot;所有附加边的最大流满流，说明原图存在可行流&quot;</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">dinic</span>()!=tot)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">        <span class="comment">//i+=2是因为一条边分成了两条方向相反的有向边 i+=2就可以直接枚举到下一条边</span></span><br><span class="line">        <span class="comment">//即(0,1)是一条边,其中0表示一条有向边,1表示与编号为0的方向相反的边 (2,3)是一条边</span></span><br><span class="line">        <span class="comment">//i+=2那么下次就可以枚举(2,3)这条边了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m*<span class="number">2</span>;i+=<span class="number">2</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[i^<span class="number">1</span>]+l[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>网络流</category>
      </categories>
      <tags>
        <tag>无源汇上下界可行流</tag>
      </tags>
  </entry>
  <entry>
    <title>银河</title>
    <url>/2021/07/31/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/%E9%93%B6%E6%B2%B3/</url>
    <content><![CDATA[<h1 id="银河"><a href="#银河" class="headerlink" title="银河"></a>银河</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210731115115.png" alt="image-20210731115115142"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>这题其实与<a href="https://blog.csdn.net/qq_45832461/article/details/118653628">糖果</a> 是一模一样的，只不过我们在那题中使用的是玄学栈+spfa的差分约束算法来求解的。</p>
<p>我们可以借助差分约束的思想，求这$N$个恒星亮度值总和至少有多大，要想总和最小，则必须要求每个恒星亮度最小，也就是求变量$a_i$的最小值，所有的$a_i$最小，这$N$个恒星亮度值总和也就是最小的了。求变量的最小，那么也就是需要跑最长路。</p>
<ul>
<li>根据题目描述如果$X=1$，则$A=B$，即有$A\geq B+0$，$B\geq A+0$ 。因此需要从节点$B$向节点$A$连一条权值为0的边，从节点$A$向节点$B$连一条权值为0的边</li>
<li>根据题目描述如果$X=2$，则$B\geq A+1$，因此从节点$A$向节点$B$连一条权值为1的边</li>
<li>根据题目描述如果$X=3$，则$A\geq B+0$，因此从节点$B$向节点$A$连一条权值为0的边</li>
<li>根据题目描述如果$X=4$，则$A\geq B+1$，因此从节点$B$向节点$A$连一条权值为1的边</li>
<li>根据题目描述如果$X=5$，则$B\geq A+0$，因此从节点$A$向节点$B$连一条权值为0的边</li>
<li>同时，由题干”要求每个小朋友都要分到苹果“，因此可以知道$a_i&gt;0$，即$a_i\geq 1$，那么可以添加一个超级源点$a_0$，$a_0$为0。那么$a_i+a_0\geq a_0+1$，即$a_i\geq a_0+1$，因此从超级源点$a_0$向节点$a_i$连一条权值为1的边</li>
</ul>
<p>然而，本题数据范围达到了$10^5$级别，并且数据较强，直接使用spfa算法求最长路并判断是否存在正环会超时，那么就需要更加高效的算法了。</p>
<p>仔细观察，我们根据差分约束系统建立的有向图中，边权只有0和1这两种情况。根据差分约束思想可知，这个题无解的条件是图中存在正环。我们知道一个强连通分量它是一个环，如果一个强连通分量中存在至少一条边的权值&gt;0，则这个强连通分量就是一个正环，那么该题目无解。为什么呢？因为假设这个强连通分量有一条边权为1的边，然后该强连通分量中的其他边的权值都0，那么无限在这个强连通分量中转圈，每转一圈，总和+1，那可以在这个环内无限转圈，那么最终总和就为正无穷，那刚好就符合正环的定义。</p>
<p>因此，得出以下结论：</p>
<ul>
<li>如果图中存在环，那么环内所有边的权值都必须为0，此时该题才能有解</li>
<li>如果图中存在环，那么环内至少存在一条边的权值&gt;0，此时该题无解</li>
</ul>
<p>因此，我们可以使用tarjan算法求出强连通分量，只要强连通分量内部存在长度为1的边，则直接判定无解。</p>
<p>如果有解，那么每个强连通分量内部各个恒星到超级源点0的距离都是相等的，也就是说此时每个强连通分量内部各个恒星的亮度是相等的。如下图解释：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210731121249.png" alt="image-20210731121249452"></p>
<p>那么我们就可以用tarjan算法求出强连通分量，然后执行”缩点“，得到一张边权为0或1的有向无环图。强连通分量编号scc从大到小遍历就是拓扑序了，那么可以对这张DAG按照拓扑序进行递推求解最长路了，即可以在$O(N+M)$时间内求出到达每个强连通分量的最长路，那么就是该强连通分量内所有恒星的最小亮度。</p>
<p>设某个强连通分量scc中有$x$个节点，设某个节点$y$到超级源点的最长路是$a$，那么这$x$个节点到超级源点的最长路的权值总和就是$x\times a$。</p>
<p><strong>算法设计：</strong></p>
<ul>
<li>使用tarjan算法求出强连通分量</li>
<li>缩点得到一张DAG图，并把这张有向无环图建立出来</li>
<li>依据拓扑序递推求解最长路</li>
</ul>
<p>需要建立的边数：如果$M$取到最大值1e5，由于$A\to B$，也可以$B\to A$，因此需要2e5条边，同时还要从虚拟源点向这$N$个点建立一条权值为1的边，因此还需要1e5条边，于是需要2e5+1e5=3e5条边。但这是原图需要的总边数，我们还需要考虑新图DAG的边数，那么开2倍的3e5就好了。因此总共需要的边数就是$6\times10^5$条边</p>
<p>注意：由于每颗恒星的亮度是递增的，结果有可能爆int，因此需要开long long 来存储。</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">6e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N],hs[N],e[M],ne[M],w[M],idx;</span><br><span class="line"><span class="comment">//表示节点u深度优先遍历的序号（也就是节点u被访问的时间点）</span></span><br><span class="line"><span class="comment">//表示节点u或节点u的子孙能够通过非父子边追溯到的dfn最小的节点序号</span></span><br><span class="line"><span class="comment">//即回到最早的过去（也就是节点u通过有向边可回溯到的最早的时间点）</span></span><br><span class="line"><span class="comment">//num表示时间戳</span></span><br><span class="line"><span class="keyword">int</span> dfn[N],low[N],num;</span><br><span class="line"><span class="comment">//a=id[x]表示x这个节点属于a这个强连通分量</span></span><br><span class="line"><span class="comment">//cnt[i]=100表示i这个强连通分量有100个节点</span></span><br><span class="line"><span class="comment">//scc表示强连通分量的编号 scc=3表示第3个强连通分量 最终也只有scc个强连通分量</span></span><br><span class="line"><span class="keyword">int</span> id[N],cnt[N],scc;</span><br><span class="line"><span class="comment">//栈用来存储访问的节点  top是栈顶指针</span></span><br><span class="line"><span class="keyword">int</span> stk[N],top; </span><br><span class="line"><span class="comment">//din存储每个节点的入度 dout存储每个节点的出度 </span></span><br><span class="line"><span class="keyword">int</span> din[N],dout[N];</span><br><span class="line"><span class="comment">//in_stk[i]=true表示节点i还在栈中</span></span><br><span class="line"><span class="keyword">bool</span> in_stk[N];</span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> h[],<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u]=low[u]=++num;    <span class="comment">//给节点u分配一个时间戳</span></span><br><span class="line">    stk[++top]=u;           <span class="comment">//将节点u入栈</span></span><br><span class="line">    in_stk[u]=<span class="literal">true</span>;         <span class="comment">//标记节点u在栈中</span></span><br><span class="line">    <span class="comment">//遍历节点u的所有邻接点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];~i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j=e[i]; <span class="comment">//u的邻接点j</span></span><br><span class="line">        <span class="comment">//根据分析得出：先会执行else if中的更新语句,才会执行if中的回溯过程中的更新语句</span></span><br><span class="line">        <span class="comment">//如果节点j还没有被访问过</span></span><br><span class="line">        <span class="keyword">if</span>(!dfn[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(j);<span class="comment">//递归访问j</span></span><br><span class="line">            <span class="comment">//回溯是更新从节点j往回到节点u这条路径上的所有节点的low值</span></span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[u],low[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则说明节点j已经被访问过了 看j是否还在栈中</span></span><br><span class="line">        <span class="comment">//如果还在栈中 那么就说明形成了环 即存在强连通分量</span></span><br><span class="line">        <span class="comment">//当走到这里时说明j先于u被访问,因此u可以追溯到更早的过去</span></span><br><span class="line">        <span class="comment">//于是用更早的dfn[j]来更新low[u]</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(in_stk[j])</span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[u],dfn[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//退无可退 即此时u不能追溯到更早的过去了 那么它就是这个强连通分量的入口</span></span><br><span class="line">    <span class="keyword">if</span>(dfn[u]==low[u])</span><br><span class="line">    &#123;</span><br><span class="line">        scc++;  <span class="comment">//强连通分量的个数+1</span></span><br><span class="line">        <span class="keyword">int</span> y;</span><br><span class="line">        <span class="comment">//输出这个强连通分量中所包含的节点</span></span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            y=stk[top--];       <span class="comment">//强连通分量的节点y</span></span><br><span class="line">            in_stk[y]=<span class="literal">false</span>;    <span class="comment">//标记节点y不在栈中</span></span><br><span class="line">            id[y]=scc;      <span class="comment">//节点y属于scc这个强连通分量</span></span><br><span class="line">            cnt[scc]++;     <span class="comment">//scc这个强连通分量中的节点个数增加了y这个节点</span></span><br><span class="line">        &#125;<span class="keyword">while</span>(y!=u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">memset</span>(hs,<span class="number">-1</span>,<span class="keyword">sizeof</span> hs);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="comment">//从超级源点0向其他n个节点连一条长度为1的有向边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">add</span>(h,<span class="number">0</span>,i,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t,a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;t,&amp;a,&amp;b);</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">add</span>(h,a,b,<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">add</span>(h,b,a,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="number">2</span>)</span><br><span class="line">            <span class="built_in">add</span>(h,a,b,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="number">3</span>)</span><br><span class="line">            <span class="built_in">add</span>(h,b,a,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="number">4</span>)</span><br><span class="line">            <span class="built_in">add</span>(h,b,a,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="number">5</span>)</span><br><span class="line">            <span class="built_in">add</span>(h,a,b,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//由于超级源点可达其他的n个节点  因此直接从超级源点0开始执行tarjan算法即可</span></span><br><span class="line">    <span class="built_in">tarjan</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//给这个DAG建图</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)<span class="comment">//从超级源点0到节点n</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//遍历节点i的所有邻接点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=h[i];~j;j=ne[j])  <span class="comment">//j是边</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> k=e[j]; <span class="comment">//k是i的邻接点</span></span><br><span class="line">            <span class="keyword">int</span> a=id[i];</span><br><span class="line">            <span class="keyword">int</span> b=id[k];</span><br><span class="line">            <span class="comment">//如果节点a和节点b在同一个强连通分量</span></span><br><span class="line">            <span class="keyword">if</span>(a==b)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//如果同一个强连通分量中有长度大于1的边,则说明该强连通分量是一个正环  无解</span></span><br><span class="line">                <span class="keyword">if</span>(w[j]&gt;<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    flag=<span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果节点a和节点b不在同一个强连通分量  则建图</span></span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="built_in">add</span>(hs,a,b,w[j]);   <span class="comment">//w[j]是j这条边的的权值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//无解</span></span><br><span class="line">    <span class="keyword">if</span>(!flag)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//scc从大到小就是拓扑序</span></span><br><span class="line">        <span class="comment">//按照拓扑序递推求解最长路</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=scc;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//遍历节点i的所有邻接点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=hs[i];~j;j=ne[j]) <span class="comment">//j是边</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> k=e[j]; <span class="comment">//k是i的邻接点</span></span><br><span class="line">                dist[k]=<span class="built_in">max</span>(dist[k],dist[i]+w[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        LL res=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//累加每个点到超级源点的最长路</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=scc;i++)</span><br><span class="line">            res+=(LL)dist[i]*cnt[i];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>有向图的强连通分量</category>
      </categories>
      <tags>
        <tag>tarjan求有向图的强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title>次小生成树</title>
    <url>/2021/07/28/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/%E6%AC%A1%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    <content><![CDATA[<h1 id="次小生成树"><a href="#次小生成树" class="headerlink" title="次小生成树"></a>次小生成树</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210728124557.png" alt="image-20210728124557605"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>这题其实与<a href="https://blog.csdn.net/qq_45832461/article/details/119118597">秘密的牛奶运输</a>是完全一样的，都是求解严格次小生成树。只不过在那一题中，我们是用$O(n^2)$的时间复杂度暴力求出了树中任意两点间的距离。但是我们知道LCA可以快速地求解出树中任意两点间的距离。因此，在这一题中，我们将使用LCA来进行优化。</p>
<p>如下图分析：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210728125115.png" alt="image-20210728125115083"></p>
<p>这一题对求解MST中任意两点之间的距离进行了优化处理，即上图中的暴力枚举，将时间复杂度从$O(n^2)$优化到了$O(n\times log(n))$，具体优化过程如下：</p>
<ul>
<li>我们使用$d1[i,j]$表示从节点$i$往上跳$2^j$步路径过程中的边权的最大值，即这个路径上最大边的权值；$d2[i,j]$表示从节点$i$往上跳$2^j$步路径过程中的边权的严格次大值，即这个路径上严格次大边的权值；在向上跳的过程中，记录每次跳跃时的最大值和次大值，那么最终整个路径中的最大值和次大值一定在这些记录的值中，从中求出即可。</li>
<li>那么该如何求解<code>d1[i][j]</code>和<code>d2[i][j]</code>呢？这里其实和求解<code>fa[][]</code>是类似的，可以在BFS的过程中递推求解，如下图：</li>
<li><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210728125743.png" alt="image-20210728125743885"></li>
</ul>
<p><strong>算法设计：</strong></p>
<ul>
<li>使用Kruskal算法求出最小生成树，算出权值总和为$sum$</li>
<li>将这棵最小生成树用图构建出来</li>
<li>在BFS过程中预处理<code>fa[][]</code>和求解出<code>d1[][]</code>和<code>d2[][]</code></li>
<li>依次枚举每条非树边$w$，将其加入树中，一定会形成环，去掉环中树边的最大值或者次大值得到另一棵树，这些树中权值最小的就是次小生成树。</li>
</ul>
<p><strong>注意点：</strong></p>
<ol>
<li>设树边为$w[i]$，非树边为$w$，那么次小生成树为$sum+w-w[i]$，我们设增量$\Delta=w-w[i]$，我们在LCA函数中求出了这个$w$（最大边或次大边），但是函数返回值的其实就是这个增量$\Delta$，而不是$w$，这点要注意哦</li>
<li>对于数组$fa,d1,d2$，由于题目给定最多1e5个点，由于$2^{16}&lt;1e5&lt;2^{17}$，如果第二维取16的话，则不能存储完1e5个点；如果第二维取17的话，虽然说多了，但是可以完全存储1(⊙﹏⊙)个点，因此第二维的大小应该是17，其二进制位是从0到16。</li>
<li>还有一点，题目中给定这个无向图的最大边数$M$是3e5，这是原图的最大边数。但是当我们对已经得到的最小生成树构建图时，由于树中的边是无向边，有$n$个顶点，那么有$n-1$条边，那么构建这个最小生成树的图时需要$2(n-1)$条边，不妨开大点就是$2\times n$条边，当$n$取最大为$N$时，则最多为$2\times N$条边。</li>
</ol>
<blockquote>
<p>问题：为什么跳到了最近公共祖先下一层时，最后只加了最大边$distance[cnt++]=d1[a][0]$，$distance[cnt++]=d1[b][0]$，而没有添加次小边$distance[cnt++]=d2[a][0]$，$distance[cnt++]=d2[b][0]$呢？</p>
<p>此时x和y距离他们的最近公共祖先只有一步了，也就是只有一条边了，显然只有它自身的权值作为最大距离，次大距离初始化为-INF了</p>
<p>但其实写上了也是可以的</p>
</blockquote>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">3e5</span>+<span class="number">10</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">int</span> n,m;    <span class="comment">//点数 边数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a,b,w;</span><br><span class="line">    <span class="keyword">bool</span> flag;  <span class="comment">//判断是否为树边(是否为最小生成树中的边)</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge&amp; W)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w&lt;W.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"><span class="comment">//这个邻接表是用来给最小生成树建图的</span></span><br><span class="line"><span class="keyword">int</span> h[N],e[<span class="number">2</span>*N],ne[<span class="number">2</span>*N],w[<span class="number">2</span>*N],idx;</span><br><span class="line"><span class="keyword">int</span> p[N];   <span class="comment">//并查集的集合数组</span></span><br><span class="line"><span class="keyword">int</span> depth[N];   <span class="comment">//节点的深度</span></span><br><span class="line"><span class="keyword">int</span> fa[N][<span class="number">17</span>],d1[N][<span class="number">17</span>],d2[N][<span class="number">17</span>];  <span class="comment">//d1是最大边 d2是次大边</span></span><br><span class="line"><span class="keyword">int</span> q[N];   <span class="comment">// bfs使用到的队列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    w[idx]=c;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x!=p[x])</span><br><span class="line">        p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Kruskal算法求出这棵最小生成树的权值总和</span></span><br><span class="line"><span class="function">LL <span class="title">Kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(edges,edges+m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        p[i]=i;</span><br><span class="line">    LL res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="built_in">find</span>(edges[i].a);</span><br><span class="line">        <span class="keyword">int</span> b=<span class="built_in">find</span>(edges[i].b);</span><br><span class="line">        <span class="keyword">int</span> w=edges[i].w;</span><br><span class="line">        <span class="keyword">if</span>(a!=b)</span><br><span class="line">        &#123;</span><br><span class="line">            p[a]=b;</span><br><span class="line">            res+=w;</span><br><span class="line">            edges[i].flag=<span class="literal">true</span>; <span class="comment">//标记i这条边是树边</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> res; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Kruskal算法只是求出了最小生成树的权值总和,但是并没有把这棵最小生成树构建出来</span></span><br><span class="line"><span class="comment">//这里是把这棵最小生成树构建成图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(edges[i].flag)<span class="comment">//如果是树边</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a=edges[i].a;</span><br><span class="line">            <span class="keyword">int</span> b=edges[i].b;</span><br><span class="line">            <span class="keyword">int</span> w=edges[i].w;</span><br><span class="line">            <span class="comment">//树中的边都是无向边</span></span><br><span class="line">            <span class="built_in">add</span>(a,b,w);</span><br><span class="line">            <span class="built_in">add</span>(b,a,w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//bfs预处理出fa[][]、d1[][]、d2[][]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> root)</span><span class="comment">//root是根节点  我们这里默认是1号点  其实任意一个点都可以作为根节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(depth,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> depth);</span><br><span class="line">    <span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// depth[0]=0是哨兵  depth[root]=1设置根节点的深度为1</span></span><br><span class="line">    depth[<span class="number">0</span>]=<span class="number">0</span>,depth[root]=<span class="number">1</span>;</span><br><span class="line">    q[<span class="number">0</span>]=root;  <span class="comment">//将根节点入队</span></span><br><span class="line">    <span class="comment">//进行广搜</span></span><br><span class="line">    <span class="keyword">while</span>(hh&lt;=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=q[hh++];  <span class="comment">//取出队头元素</span></span><br><span class="line">        <span class="comment">//遍历t的所有邻接点j</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i]; <span class="comment">//t的某个邻接点j</span></span><br><span class="line">            <span class="keyword">if</span>(depth[j]&gt;depth[t]+<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                depth[j]=depth[t]+<span class="number">1</span>;    <span class="comment">//更新j的深度</span></span><br><span class="line">                q[++tt]=j;  <span class="comment">//将j入队</span></span><br><span class="line">                fa[j][<span class="number">0</span>]=t; <span class="comment">//节点j向上走2^0步就是节点t</span></span><br><span class="line">                <span class="comment">//由于此时节点j到节点t之间只有一条边,那么最大边就是这条边的权值w[i],由于最大边&gt;次大边</span></span><br><span class="line">                <span class="comment">//因此如果只有一条边,那么次大边不存在  我们设置为负无穷</span></span><br><span class="line">                d1[j][<span class="number">0</span>]=w[i];</span><br><span class="line">                d2[j][<span class="number">0</span>]=-INF;</span><br><span class="line">                <span class="comment">//由于已经处理了2^0,那么接下来就是2^1,2^2,...,2^16</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">16</span>;k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> anc=fa[j][k<span class="number">-1</span>]; <span class="comment">//先从j跳2^&#123;k-1&#125;到了anc节点</span></span><br><span class="line">                    fa[j][k]=fa[anc][k<span class="number">-1</span>];  <span class="comment">//然后从anc节点跳2^&#123;k-1&#125;到了fa[j][k]节点</span></span><br><span class="line">                    <span class="comment">//distance数组存储的是从节点j跳2^k到达节点fa[j][k]过程中的最大边和次大边</span></span><br><span class="line">                    <span class="comment">//由于这个过程分为两段：</span></span><br><span class="line">                    <span class="comment">//  (1)从j到anc,这段中的最大边是d1[j][k-1],次大边是d2[j][k-1]</span></span><br><span class="line">                    <span class="comment">//  (2)从anc到fa[j][k],这段中的最大边是d1[anc][k-1],次大边是d2[anc][k-1]</span></span><br><span class="line">                    <span class="comment">//由于我们并不知道这两段中应该选择哪个最大边和次大边,因此我们可以先都存储起来</span></span><br><span class="line">                    <span class="keyword">int</span> distance[<span class="number">4</span>]=&#123;d1[j][k<span class="number">-1</span>],d2[j][k<span class="number">-1</span>],d1[anc][k<span class="number">-1</span>],d2[anc][k<span class="number">-1</span>]&#125;;</span><br><span class="line">                    <span class="comment">//刚开始初始化从j节点到fa[j][k]不可达,因此最大边和次大边都为负无穷</span></span><br><span class="line">                    d1[j][k]=d2[j][k]=-INF;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;<span class="number">4</span>;u++)<span class="comment">//遍历这四个  找到最大边和次大边</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">int</span> d=distance[u];</span><br><span class="line">                        <span class="comment">//如果新边d大于最小生成树中的最大边d1[j][k]  则直接用这个新边去替代这个最大边即可</span></span><br><span class="line">                        <span class="keyword">if</span>(d&gt;d1[j][k])</span><br><span class="line">                        &#123;</span><br><span class="line">                            d2[j][k]=d1[j][k];</span><br><span class="line">                            d1[j][k]=d;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//如果新边d小于最小生成树中的最大边d1[j][k],但是大于最小生成树中的次大边d2[j][k]</span></span><br><span class="line">                        <span class="comment">//那么可以用这个新边去替代这个次大边即可</span></span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(d&lt;d1[j][k]&amp;&amp;d&gt;d2[j][k])</span><br><span class="line">                            d2[j][k]=d;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//次小生成树权值为sum+w-w[i],w是新边,w[i]是最大边,这里LCA返回的是w-w[i]这个增量的值而不是返回w[i]</span></span><br><span class="line"><span class="function">LL <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//缓存数组 记录上跳过程中每段的最大值和次大值</span></span><br><span class="line">    <span class="comment">//由于每个点可能有最大边和次大边,因此数组要开2*N,而不是N</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> distance[<span class="number">2</span>*N];</span><br><span class="line">    <span class="keyword">if</span>(depth[a]&lt;depth[b])</span><br><span class="line">        <span class="built_in">swap</span>(a,b);</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;  <span class="comment">// 记录跳跃的次数，每跳一次，会记录两个数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">16</span>;k&gt;=<span class="number">0</span>;k--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(depth[fa[a][k]]&gt;=depth[b])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//记录节点a的最大边和次大边</span></span><br><span class="line">            distance[cnt++]=d1[a][k];</span><br><span class="line">            distance[cnt++]=d2[a][k];</span><br><span class="line">            a=fa[a][k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a!=b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">16</span>;k&gt;=<span class="number">0</span>;k--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(fa[a][k]!=fa[b][k])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//记录节点a和节点b的最大边和次大边</span></span><br><span class="line">                distance[cnt++]=d1[a][k];</span><br><span class="line">                distance[cnt++]=d2[a][k];</span><br><span class="line">                distance[cnt++]=d1[b][k];</span><br><span class="line">                distance[cnt++]=d2[b][k];</span><br><span class="line">                a=fa[a][k];</span><br><span class="line">                b=fa[b][k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//到这里,说明已经跳到了最大公共祖先的下一层,那么此时只需要再向上跳一步就可以到达了LCA</span></span><br><span class="line">        distance[cnt++]=d1[a][<span class="number">0</span>];</span><br><span class="line">        distance[cnt++]=d1[b][<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//下面的这个写上也是可以的</span></span><br><span class="line">        <span class="comment">// distance[cnt++]=d2[a][0];</span></span><br><span class="line">        <span class="comment">// distance[cnt++]=d2[b][0]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> dist1=-INF,dist2=INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> d=distance[i];</span><br><span class="line">        <span class="keyword">if</span>(d&gt;dist1)</span><br><span class="line">        &#123;</span><br><span class="line">            dist2=dist1;</span><br><span class="line">            dist1=d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(d&lt;dist1&amp;&amp;d&gt;dist2)</span><br><span class="line">            dist2=d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(w&gt;dist1)</span><br><span class="line">        <span class="keyword">return</span> w-dist1;</span><br><span class="line">    <span class="keyword">if</span>(w&gt;dist2)</span><br><span class="line">        <span class="keyword">return</span> w-dist2;</span><br><span class="line">    <span class="keyword">return</span> INF; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> root=<span class="number">1</span>; <span class="comment">//根节点  我们选择1号节点</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)<span class="comment">//读入m条边的信息</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;w);</span><br><span class="line">        edges[i]=&#123;a,b,w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    LL sum=<span class="built_in">Kruskal</span>();   <span class="comment">//求出这棵最小生成树的权值总和</span></span><br><span class="line">    <span class="comment">//这里是把这棵最小生成树构建成图</span></span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    <span class="built_in">bfs</span>(root);</span><br><span class="line">    LL res=<span class="number">1e18</span>;</span><br><span class="line">    <span class="comment">//枚举将每一条非树边去替代最小生成树中的最大边或次大边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!edges[i].flag)<span class="comment">//非树边</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a=edges[i].a;</span><br><span class="line">            <span class="keyword">int</span> b=edges[i].b;</span><br><span class="line">            <span class="keyword">int</span> w=edges[i].w;</span><br><span class="line">            <span class="comment">//有x条非树边,则会有x个res值,这里取最小的那个,那么就是次小生成树的权值总和了</span></span><br><span class="line">            res=<span class="built_in">min</span>(res,sum+<span class="built_in">LCA</span>(a,b,w));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>最近公共祖先</category>
      </categories>
      <tags>
        <tag>LCA+次小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>祖孙询问</title>
    <url>/2021/07/21/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/%E7%A5%96%E5%AD%99%E8%AF%A2%E9%97%AE/</url>
    <content><![CDATA[<h1 id="祖孙询问"><a href="#祖孙询问" class="headerlink" title="祖孙询问"></a>祖孙询问</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210721211507.png" alt="image-20210721211507323"></p>
<hr>
<h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p>最近公共祖先（LCA）是指有根树中距离两个节点最近的公共祖先。祖先是指从当前节点到树根路径上的所有节点。</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210721211850.png" alt="image-20210721211850774"></p>
<p>$u$和$v$的公共祖先是指一个节点它既是$u$的祖先，又是$v$的祖先。$u$和$v$的最近公共祖先是指距离$u$和$v$最近的祖先。如果$v$是$u$的祖先，那么$u$和$v$的最近公共祖先就是$v$。</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210721212059.png" alt="image-20210721212059201"></p>
<p>我们可以使用LCA来求解树上任意两点之间的距离。求$u$和$v$这两个之间的距离时，设为$L$，如果$u$和$v$的最近公共祖先为lca，则$u$和$v$之间的距离为$u$到树根的距离$dist[u]$加上$v$到树根的距离$dist[v]$再减去2倍的lca到树根的距离$2\times dist[lca]$。即有：$L=dist[u]+dist[v]-2\times dist[lca]$。</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210721212512.png" alt="image-20210721212511915"></p>
<p>从图中可以看出$u$到lca的距离加上$v$到lca的距离，其实就是我们想要求的$u$和$v$之间的距离。设$u$到lca的距离$L_1$，设$v$到lca的距离为$L_2$。可知：$dist[u]=L_1+dist[lca]$，所以$L_1=dist[u]-dist[lca]$；$dist[v]=L_2+dist[lca]$，所以$L_2=dist[v]-dist[lca]$。所以$L=L_1+L_2=dist[u]-dist[lca]+dist[v]-dist[lca]=dist[u]+dist[v]-2\times dist[lca]$</p>
<h4 id="树上倍增法"><a href="#树上倍增法" class="headerlink" title="树上倍增法"></a>树上倍增法</h4><p><code>F[i,j]</code>表示$i$的$2^j$辈祖先，即$i$节点向根节点走$2^j$步所到达的那个节点。</p>
<p>$u$节点向上走$2^0$步，则为$u$的父节点$x$，$F[u,0]=x$；$u$节点向上走$2^1$步，到达节点$y$，$F[u,1]=y$；$u$节点向上走$2^2$步，到达节点$z$，$F[u,2]=z$；$u$节点向上走$2^3$步，节点不存在，$F[u,3]=0$；</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210721213504.png" alt="image-20210721213503867"></p>
<p><code>F[i,j]</code>表示$i$的$2^j$辈祖先，即$i$节点向根节点走$2^j$步所到达的那个节点。那么该如何走到$F[i,j]$这个节点呢？可以分为两个步骤：</p>
<ul>
<li>$i$节点先向根节点走$2^{j-1}$步得到$F[i,j-1]$</li>
<li>然后再从$F[i,j-1]$这个节点出发向根节点走$2^{j-1}$步，得到<code>F[F[i,j-1],j-1]</code>，那么此时走到的节点即为$F[i,j-1]$</li>
</ul>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210721213844.png" alt="image-20210721213844186"></p>
<p>递推公式：<code>F[i,j]=F[F[i][j-1],j-1]</code>，$i=1,2,\cdots,n$，$j=0,,1,2,\cdots,k$，$2^k\leq n$，$k=logn$</p>
<p><strong>树上倍增法的两个关键步骤</strong>：</p>
<ol>
<li>先将两个点跳到同一层</li>
<li>让两个点同时向上跳，一直跳到它们的<strong>最近公共祖先的下一层</strong>为止</li>
</ol>
<p>也就是说先让深度大的$y$向上走到与$x$处于同一深度，然后$x,y$一起向上走。但是这里是按照倍增思想走的，而不是一步一步往上走的，因此速度比较快。</p>
<p>现在来思考两个问题：</p>
<ul>
<li>怎么让深度大的$y$向上走与$x$处于同一深度呢？</li>
<li>$x$和$y$一起向上走，怎么找到最近的公共祖先呢？</li>
</ul>
<p>先来解决第一个问题：怎么让深度大的$y$向上走与$x$处于同一深度呢？</p>
<p>假设$y$的深度比$x$的深度大，需要$y$向上走到与$x$处于同一深度，$k=3$，则求解过程如下：</p>
<ul>
<li>$y$向上走$2^3$步，如果此时到达节点的深度比$x$的深度小（说明跳的太远了，跳到了$x$的上面了），那么什么也不做</li>
<li>减小增量，$y$向上走$2^2$步，如果此时到达节点的深度比$x$的深度大（说明此时还处于$x$的下面），则$y$向上移动，令$y=F[y][2]$</li>
<li>减小增量，$y$向上走$2^1$步，如果此时到达节点的深度比$x$的深度相等（说明此时它俩处于同一深度），则$y$向上移动，令$y=F[y][1]$</li>
<li>减小增量，$y$向上走$2^0$步，如果此时到达节点的深度比$x$的深度小，那么什么也不做。由于上一次$y$已经与$x$处于同一深度了，而这次啥也没做，因此$y$仍然与$x$处于同一深度。</li>
</ul>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210721215346.png" alt="image-20210721215345942"></p>
<p>总结：</p>
<p>按照增量递减的方式，如果到达节点的深度比$x$的深度还要小，则什么也不做；如果到达节点的深度$\geq x$的深度时，则$y$向上移动，令$y=F[y][2]$，一直循环到增量为0，那么最后一定会有$x$和$y$处于同一深度。</p>
<p>再来解决第二个问题：$x$和$y$一起向上走，怎么找到最近的公共祖先呢？</p>
<p>假设$x,y$已经处于同一深度了，现在一起向上走，$k=3$，则其求解过程如下：</p>
<ul>
<li>$x$和$y$同时向上走$2^3$步，如果到达的节点相同，说明是公共祖先节点，但是不能保证是最近公共祖先，于是什么也不做</li>
<li>减少增量，$x,y$同时向上走$2^2$步，如果此时到达的节点不相同，则说明肯定不是最近公共祖先节点，那么此时$x,y$都要向上移动，令$x=F[x][2]$，$y=F[y][2]$</li>
<li><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210721220405.png" alt="image-20210721220404938"></li>
<li>减少增量，$x,y$同时向上走$2^1$步，如果此时到达的节点不同，那么此时$x,y$都要向上移动，令$x=F[x][1]$，$y=F[y][1]$</li>
<li>减少增量，$x$和$y$同时向上走$2^0$步，如果到达的节点相同，什么也不做</li>
<li>因此经过这么做，那么最终我们一定让$x,y$都处于它俩的最近公共祖先的下一层了。此时$x,y$的父节点就是最近公共祖先节点了，那么最终只需要$x$或者$y$向上走一步就可以到达最近公共祖先了。即最终的$F[x][0]$或者$F[y][0]$就是答案</li>
<li><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210721220600.png" alt="image-20210721220600144"></li>
</ul>
<p>完整的求解过程如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210721220655.png" alt="image-20210721220655472"></p>
<p>总结：按照增量递减的方式，如果到达的节点相同时，说明是公共祖先，但是不能保证就是最近公共祖先节点，所以什么也不做；如果到达的节点不相同，那么$x,y$同时往上走，一直到增量为0。此时$x,y$的父节点就是最近公共祖先节点了。</p>
<blockquote>
<p>问题：为什么碰到$F[x][k]==F[y][k]$时什么都不做，而且为什么此时就是公共祖先而不能是最近公共祖先呢？</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210722134122.png" alt="image-20210722134122538"></p>
<p>增量从大到小逐渐递减，设$k=2$，那么$F[x][2]=F[y][2]=0$，但是很明显，此时的$0$号节点只是它俩的公共祖先而已，此时我们啥也不做，也就是说$x$和$y$仍然原地踏步，并没有发生跳跃；然后$k$—，此时$k=1$，那么$F[x][1]=F[y][1]=2$，但是很明显，此时的$2$号节点只是它俩的公共祖先而已，此时我们啥也不做，也就是说$x$和$y$仍然原地踏步，并没有发生跳跃；然后$k$—，此时$k=0$，那么$F[x][0]=F[y][0]=4$，注意此时我们可以直观地看出来$4$是它俩的最近公共祖先，但是由于$F[x][0]=F[y][0]$，因此我们也是什么也不做，也就是说$x$和$y$仍然原地踏步，并没有发生跳跃；然后$k$—，此时$k$为-1，退出循环了。那么，我们发现$x$和$y$确实就是在最近公共祖先的下一层！所以最后$x$或者$y$再向上跳一步就到了最近公共祖先节点了，即$F[x][0]$或者$F[y][0]$就是答案了。</p>
</blockquote>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>主要就是利用树上倍增法来求解$LCA$，</p>
<p>这里最多有$N=40000$个节点，那么$2^k\leq40000$，所以$k\leq16$。也就是说我们要给这个<code>F[N][]</code>数组的第二维开的大小应该是$16$，即有$16$位二进制。</p>
<p>还有就是我们用$depth[0]=0$来当作哨兵，它有什么用处呢？假设从$i$开始跳$2^j$步，那么有可能此时已经跳出了整棵树的根节点，那么<code>fa[fa[j][k-1]][k-1]=0</code>，那么到达的那个虚无节点$fa[i][j]=0$，于是$depth[fa[i][j]]=depth[0]=0$。</p>
<blockquote>
<p>如何理解处理超过根节点呢？</p>
<p>举个栗子：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210722140317.png" alt="image-20210722140317627"></p>
<p>因为我们没有对根节点$fa[1][0]$赋值，所以它使用的是全局变量，于是$fa[1][0]=0$。可以知道，$fa[2][0]=1$。假设从$2$节点跳了$2^1$步，那么就会跳出根节点，此时的处理是这样的：$fa[2][1]=fa[fa[2][0]][0]=fa[1][0]=0$，那么$depth[fa[1][0]=depth[0]$，但是此时$depth[0]$还没有定义，那么我们可以给它定义为0，此时就可以表示跳出了根节点了。</p>
</blockquote>
<p>还有个细节要注意，我们是让深度更大的先往上跳到与深度较小的节点处于同一层。我们不妨假设$a$是深度较大的，$b$是深度较小的，那么如果$depth(a)&lt;depth(b)$，则交换，也就是说必须保证$a$的深度是$\geq b$的深度，然后对$a$往上跳。</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//对于树来说 有n个顶点 则有n-1条边  </span></span><br><span class="line"><span class="comment">//由于题目说了是无向边,所以最多有2(n-1)条边</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">40010</span>,M=N*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="comment">//记录每个节点的在树中的深度</span></span><br><span class="line"><span class="keyword">int</span> depth[N];</span><br><span class="line"><span class="comment">//fa[i][j]表示从i节点出发跳2^j步后所到达的节点</span></span><br><span class="line"><span class="keyword">int</span> fa[N][<span class="number">16</span>];</span><br><span class="line"><span class="comment">//宽搜的队列</span></span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//采用bfs,在构建这棵有根树的过程中,预处理出fa[i][j],预处理的时间复杂度是nlogn</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化深度为无穷大</span></span><br><span class="line">    <span class="built_in">memset</span>(depth,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> depth);</span><br><span class="line">    <span class="comment">//由于已知了q[0]是根节点  所以这里直接让tt=0了</span></span><br><span class="line">    <span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>]=root;</span><br><span class="line">    <span class="comment">//哨兵 如果跳超过了根节点,那么就设那些超过根节点的虚无节点的深度为0</span></span><br><span class="line">    depth[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//根节点的深度为1</span></span><br><span class="line">    depth[root]=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//进行宽搜</span></span><br><span class="line">    <span class="keyword">while</span>(hh&lt;=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=q[hh++];<span class="comment">//取出队头元素</span></span><br><span class="line">        <span class="comment">//遍历t的所有邻接点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];<span class="comment">//取出t的邻接点j</span></span><br><span class="line">            <span class="comment">//说明j还没有倍搜索过</span></span><br><span class="line">            <span class="keyword">if</span>(depth[j]&gt;depth[t]+<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//更新顶点j的深度</span></span><br><span class="line">                depth[j]=depth[t]+<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//将j加入队列中</span></span><br><span class="line">                q[++tt]=j;</span><br><span class="line">                <span class="comment">//由于赋值后depth[j]=depth[t]+1 说明j的深度大于t的深度</span></span><br><span class="line">                <span class="comment">//那么从j出发跳2^0步后,到达的节点就是t</span></span><br><span class="line">                fa[j][<span class="number">0</span>]=t;</span><br><span class="line">                <span class="comment">//上面已经处理了从j出发跳2^0步了</span></span><br><span class="line">                <span class="comment">//这里是处理从j出发跳2^1,2^2,...,2^15步所能到达的节点</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">15</span>;k++)</span><br><span class="line">                    fa[j][k]=fa[fa[j][k<span class="number">-1</span>]][k<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树上倍增法求出顶点a和顶点b的最近公共祖先</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//约定顶点a的深度必须&gt;=顶点b的深度,否则就要交换</span></span><br><span class="line">    <span class="keyword">if</span>(depth[a]&lt;depth[b])</span><br><span class="line">        <span class="built_in">swap</span>(a,b);</span><br><span class="line">    <span class="comment">//让深度较大的顶点a先往上跳到与深度较小的顶点b处于同一层(有可能a跳到了b身上)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">15</span>;k&gt;=<span class="number">0</span>;k--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=fa[a][k];</span><br><span class="line">        <span class="comment">//此时跳到了tmp这个节点 如果这节点的深度&gt;=顶点b的深度</span></span><br><span class="line">        <span class="comment">//说明tmp这个节点还没有跳超过顶点b这一层   那么则让a跳到tmp这个节点</span></span><br><span class="line">        <span class="keyword">if</span>(depth[tmp]&gt;=depth[b])</span><br><span class="line">            a=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里说明a跳到了b身上 此时两个重合 最近公共祖先就是a或者b</span></span><br><span class="line">    <span class="keyword">if</span>(a==b)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="comment">//如果能到这里,就说明a跳到了与b处于同一层</span></span><br><span class="line">    <span class="comment">//那么此时让a和b同时往上跳</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">15</span>;k&gt;=<span class="number">0</span>;k--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//说明它俩跳到的顶点不相同,那么不是公共祖先,则必然不可能是LCA</span></span><br><span class="line">        <span class="keyword">if</span>(fa[a][k]!=fa[b][k])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//让a跳到fa[a][k]这个顶点</span></span><br><span class="line">            a=fa[a][k];</span><br><span class="line">            <span class="comment">//让b跳到fa[b][k]这个顶点</span></span><br><span class="line">            b=fa[b][k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//退出循环后,a和b一定是跳到了它俩的最近公共祖先节点的下一层</span></span><br><span class="line">    <span class="comment">//那么此时它俩再向上跳2^0=1步就可以找到LCA了</span></span><br><span class="line">    <span class="comment">//因此最终返回 fa[a][0] 或者 fa[b][0]  都是可以的</span></span><br><span class="line">    <span class="keyword">return</span> fa[a][<span class="number">0</span>];      </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="comment">//整棵树的根节点</span></span><br><span class="line">    <span class="keyword">int</span> root=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="comment">//根据题目意思,如果b为-1,那么a就是整棵树的根节点</span></span><br><span class="line">        <span class="keyword">if</span>(b==<span class="number">-1</span>)</span><br><span class="line">            root=a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//建立无向边</span></span><br><span class="line">            <span class="built_in">add</span>(a,b);</span><br><span class="line">            <span class="built_in">add</span>(b,a);</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在构建这棵有根树的过程中,预处理出fa[i][j]</span></span><br><span class="line">    <span class="built_in">bfs</span>(root);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">    <span class="comment">//处理m个询问</span></span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="comment">//找到顶点a和顶点b的最近公共祖先</span></span><br><span class="line">        <span class="keyword">int</span> p=<span class="built_in">LCA</span>(a,b);</span><br><span class="line">        <span class="comment">//如果a是它俩的最近公共祖先</span></span><br><span class="line">        <span class="keyword">if</span>(p==a)</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="comment">//如果b是它俩的最近公共祖先    </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p==b)</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>最近公共祖先</category>
      </categories>
      <tags>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title>单词游戏</title>
    <url>/2021/08/03/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF%E5%92%8C%E6%AC%A7%E6%8B%89%E8%B7%AF%E5%BE%84/%E5%8D%95%E8%AF%8D%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h1 id="单词游戏"><a href="#单词游戏" class="headerlink" title="单词游戏"></a>单词游戏</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210803210824.png" alt="image-20210803210824022"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>从题目中可以知道，一个单词中，只有首字符和尾字符是有用的，中间的是没有用的，因此我们可以把首字符hash成一个节点，尾字符也hash成一个节点，然后把这个单词看作是一条连接首字符节点和尾字符节点的边。那么题目就相当于再问：一个有向图中是否存在欧拉路径。</p>
<p>一个有向图存在欧拉路径的充要条件是：</p>
<ul>
<li>图是连通的        我们可以使用并查集来判断连通性</li>
<li>除了两个节点之外，其他所有节点的入度等于出度，这两个节点中，其中一个节点的出度比入度多1（这个点就是起点），另一个节点的入度比出度多1（这个点就是终点）</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210803211428.png" alt="image-20210803211428493"></p>
<p>我们可以使用并查集来判断连通性</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">30</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> din[N],dout[N]; <span class="comment">//入度 出度</span></span><br><span class="line"><span class="keyword">int</span> p[N];       <span class="comment">//并查集数组</span></span><br><span class="line"><span class="keyword">bool</span> st[N];     <span class="comment">//标记某个单词的首字符或尾字符是否已经被hash成图中的一个整数节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(din,<span class="number">0</span>,<span class="keyword">sizeof</span> din);</span><br><span class="line">    <span class="built_in">memset</span>(dout,<span class="number">0</span>,<span class="keyword">sizeof</span> dout);</span><br><span class="line">    <span class="built_in">memset</span>(st,<span class="number">0</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">        p[i]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x!=p[x])</span><br><span class="line">        p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">1010</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">            <span class="keyword">int</span> len=<span class="built_in">strlen</span>(str);</span><br><span class="line">            <span class="keyword">int</span> a=str[<span class="number">0</span>]-<span class="string">&#x27;a&#x27;</span>;       <span class="comment">//将首字符hash成图中的一个节点a</span></span><br><span class="line">            <span class="keyword">int</span> b=str[len<span class="number">-1</span>]-<span class="string">&#x27;a&#x27;</span>;   <span class="comment">//将尾字符hash成图中的一个节点b</span></span><br><span class="line">            st[a]=st[b]=<span class="literal">true</span>;   <span class="comment">//标记a和b已经建立成节点  在图中了</span></span><br><span class="line">            <span class="comment">//从a向b连一条有向边  因此a的出度+1  b的入度+1</span></span><br><span class="line">            dout[a]++,din[b]++;</span><br><span class="line">            <span class="comment">//合并节点a和节点b在同一个集合中</span></span><br><span class="line">            <span class="comment">//必然单词acm  那么首字符&#x27;a&#x27;被映射成节点0  尾字符&#x27;b&#x27;被映射成节点1</span></span><br><span class="line">            <span class="comment">//合并节点0和节点1  使得它俩在同一个连通块中</span></span><br><span class="line">            p[<span class="built_in">find</span>(a)]=<span class="built_in">find</span>(b); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> flag=<span class="literal">true</span>; <span class="comment">//标记是否存在欧拉路径  初始化为true</span></span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>,end=<span class="number">0</span>;  <span class="comment">//图中起点的个数和终点的个数</span></span><br><span class="line">        <span class="comment">//图中最多有26个节点  因此依次遍历每个节点的编号即可</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(din[i]!=dout[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(dout[i]==din[i]+<span class="number">1</span>)   <span class="comment">//说明是起点  那么记录起点的个数+1</span></span><br><span class="line">                    start++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(din[i]==dout[i]+<span class="number">1</span>)  <span class="comment">//说明是终点  那么记录终点的个数+1</span></span><br><span class="line">                    end++;</span><br><span class="line">                <span class="keyword">else</span>    <span class="comment">//否则 说明不存在欧拉路径</span></span><br><span class="line">                &#123;</span><br><span class="line">                    flag=<span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//由于我们初始化flag为true 因此这里需要特判起点、终点的个数</span></span><br><span class="line">        <span class="comment">//如果start=end=0,说明图中不存在起点和终点,也就是说明图中所有点的入度=出度,那么就存在欧拉回路,</span></span><br><span class="line">        <span class="comment">//既然存在欧拉回路,那么必然存在欧拉路径</span></span><br><span class="line">        <span class="comment">//如果start=end=1,说明图中只存在一个起点和终点,其中起点的出度=入度+1,终点的入度=出度+1  因此存在欧拉路径</span></span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果不满足上面分析的两个条件 则不存在欧拉路径</span></span><br><span class="line">            <span class="keyword">if</span>(!(start==<span class="number">0</span>&amp;&amp;end==<span class="number">0</span>||start==<span class="number">1</span>&amp;&amp;end==<span class="number">1</span>))</span><br><span class="line">                flag=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rep=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)   <span class="comment">//判断连通性  </span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(st[i])<span class="comment">//如果i是图中的节点</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(rep==<span class="number">-1</span>)</span><br><span class="line">                    rep=<span class="built_in">find</span>(i);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(rep!=<span class="built_in">find</span>(i))</span><br><span class="line">                &#123;</span><br><span class="line">                    flag=<span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;Ordering is possible.&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;The door cannot be opened.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>欧拉路径与欧拉回路</category>
      </categories>
      <tags>
        <tag>欧拉路径与欧拉回路</tag>
      </tags>
  </entry>
  <entry>
    <title>闇の連鎖</title>
    <url>/2021/07/28/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/%E9%97%87%E3%81%AE%EF%A6%9A%E9%8E%96/</url>
    <content><![CDATA[<h1 id="闇の連鎖"><a href="#闇の連鎖" class="headerlink" title="闇の連鎖"></a>闇の連鎖</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210728165603.png" alt="image-20210728165603872"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>题意：有$n-1$条主要边构成一棵树，然后有$m$条附加边，当把其中一条附加边添加到主要边构成的树中，则会与树上$x,y$之间的路径上一起形成一个环。我们需要砍掉一条主要边和一条附加边，使得这棵树不再连通，成为两个独立的部分。我们需要统计有多少种不同的方案，使得这棵树不连通。</p>
<p>显然， “主要边” 构成一棵树，而一条 “附加边” 必然会和其两端的LCA形成环，如图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210728170420.png" alt="image-20210728170420786"></p>
<p>那么，对于每一条主要边，存在三种情况：</p>
<ol>
<li><p>没有被任何环覆盖</p>
<p>如下图所示：红色表示附加边，粉红色表示一条主要边，这条主要边并不在 这条附加边所形成的环中</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210728170657.png" alt="image-20210728170657069"></p>
</li>
<li><p>只被一个环给覆盖</p>
<p>如下图所示：红色表示附加边，粉红色表示一条主要边，这条主要边在 这条附加边所形成的环中</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210728170818.png" alt="image-20210728170817976"></p>
</li>
<li><p>被2个及以上的环覆盖</p>
<p>如下图所示：红色表示附加边，粉红色表示一条主要边，这条主要边在 两条附加边所形成的两个环中</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210728170943.png" alt="image-20210728170943256"></p>
</li>
</ol>
<ul>
<li>对于情况一，枚举的那个主要边并不在环中，很明显，我们只要把这条主要边删除，那么这个图必然是不连通的。由于题目要求必须砍掉一条主要边和砍掉一条附加边。现在砍掉了这条枚举到的主要边，那么还需要砍掉一条附加边。由于有$m$条附加边，因此我们有$m$种选择，所以此时就有$m$种方案。所以让答案ans累加上m即可，$ans+=m$</li>
<li>对于情况二，枚举的那个主要边在环中，可以发现，如果我们把这条主要边删除，要想让图不连通，必然还要再删除这条附加边，因此这是唯一的一种方案了（即必然是砍掉这条枚举到的主要边和这个附加边），所以让答案ans累加上1即可，$ans+=1$</li>
<li>对于情况三，枚举的那个主要边在两个及以上的环中，以两个环为栗子，可以发现，如果我们把这条主要边砍掉，即使再砍掉一条附加边，这张图仍然是连通的，因此必须砍掉两条附加边，才能使得这张图变得不连通，但是题目要求只能砍掉一条主要边和砍掉一条附加边。因此，对于这种情况，不能得出方案，所以不需要累加答案。</li>
</ul>
<p>那么我们怎么统计每条边被环覆盖的次数呢？也就是说，我们如何统计附加边$(x,y)$所在的那个环中每条边上的权值呢？每条边上的权值表示被附加边覆盖的次数。</p>
<p>也就是我们如何让从点$x$出发经过它俩的lca然后到达节点$y$所经过的每一条边都+c呢？这其实可以用<strong>树上差分</strong>来做。</p>
<p>$d[x]$、$d[y]$ 会对它们到根节点上的每一条边都+c，$d[lca]$会对它们到根节点上的每一条边都-2c，那么这样最终的效果就是：让$x$到lca中和$y$到lca中的每条边都+c</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210728180813.png" alt="image-20210728180813869"></p>
<p>树上差分可以分为以下三种：</p>
<ul>
<li>按点差分</li>
<li>按边差分</li>
<li>按深度差分</li>
</ul>
<p>我们这里是按边差分，因为我们想知道每条边上的覆盖次数（可以认为是这条边的边权）。但是呢，一般按边差分不好做，我们都是将边权转换为点权，然后用按点差分来做。我们知道，每个节点最多只有1个父节点，也就是向上连的边只有1条，所以我们把一条边的边权下放到它的子节点的点权上（注意根节点没有点权，因为根节点上面没有边，所以没有边权下放给根节点），这样我们就转化到按点差分了。我们可以采用DFS对这棵树进行深搜，在回溯时，把子树$v$中的所有节点上的权值都累加到节点$u$上，设总和为$sum$，节点$v$的父节点是$u$，那么$sum$其实就是节点$u$和节点$v$之间的边权了，那么也就是覆盖次数了。</p>
<p>如下图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210728181112.png" alt="image-20210728181112585"></p>
<p>以节点$z$所在的子树为栗子，将节点$z$下面的所有点权$d[i]$累加然后统计到节点$z$上，设总和为$sum$，那么节点$p$和节点$z$之间的边权其实就是$sum$。</p>
<p>注意点：对于数组<code>fa[][]</code>，因为点数最多是1e5，由于$2^{16}&lt;1e5&lt;2^{17}$，所以第二维的大小应该取到17，这样才能弄完全部1e5个点。因此$fa$的第二维有0~16一共17个数，第二维需要设置为17。</p>
<p>虽然说题目中有附加边，但是我们建图时，只是把主要边给建立出来，并没有把附加边建到图中去。由于最多有$N$个点，这是树，是无向边，因此最多有$M=2\times N$条边。</p>
<p><strong>算法设计：</strong></p>
<ul>
<li>先将主要边用图建立出来</li>
<li>进行bfs预处理出<code>fa[][]</code></li>
<li>枚举每一条附加边，对于附加边所在环上的所有主要边其两端的点权都+1，预处理出差分数组<code>d[]</code></li>
<li>进行dfs，枚举每一条主要边，进行树上差分得到每条主要边上的权值。查看每条主要边上的权值：<ul>
<li>如果$c=0$，则说明这条主要边并不在附加边所形成的环中，就是情况一，所以答案$ans+=m$</li>
<li>如果$c=1$，则说明这条主要边在附加边所形成的环中，就是情况二，所以答案$ans+=1$</li>
<li>如果$c&gt;1$，则说明这条主要边处于多条附加边所形成的多个环中，就是情况三，不用累加答案</li>
</ul>
</li>
</ul>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">2</span>*N;</span><br><span class="line"><span class="keyword">int</span> n,m;    <span class="comment">//点数 附加边数</span></span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],w[M],idx;</span><br><span class="line"><span class="keyword">int</span> depth[N];</span><br><span class="line"><span class="keyword">int</span> d[N];   <span class="comment">//存储每个点的差分 树上差分，每个点上的权值，可以转化为边上的权值</span></span><br><span class="line"><span class="keyword">int</span> q[N];   <span class="comment">//bfs使用到的队列</span></span><br><span class="line"><span class="keyword">int</span> fa[N][<span class="number">17</span>];  </span><br><span class="line"><span class="keyword">int</span> ans;    <span class="comment">//方案数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//预处理出fa[][]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(depth,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> depth);</span><br><span class="line">    depth[<span class="number">0</span>]=<span class="number">0</span>,depth[root]=<span class="number">1</span>;</span><br><span class="line">    q[<span class="number">0</span>]=root;</span><br><span class="line">    <span class="keyword">while</span>(hh&lt;=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=q[hh++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(depth[j]&gt;depth[t]+<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                depth[j]=depth[t]+<span class="number">1</span>;</span><br><span class="line">                q[++tt]=j;</span><br><span class="line">                fa[j][<span class="number">0</span>]=t;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">16</span>;k++)</span><br><span class="line">                    fa[j][k]=fa[fa[j][k<span class="number">-1</span>]][k<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(depth[a]&lt;depth[b])</span><br><span class="line">        <span class="built_in">swap</span>(a,b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">16</span>;k&gt;=<span class="number">0</span>;k--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(depth[fa[a][k]]&gt;=depth[b])</span><br><span class="line">        &#123;</span><br><span class="line">            a=fa[a][k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a==b)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">16</span>;k&gt;=<span class="number">0</span>;k--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(fa[a][k]!=fa[b][k])</span><br><span class="line">        &#123;</span><br><span class="line">            a=fa[a][k];</span><br><span class="line">            b=fa[b][k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[a][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回以节点u为根的子树中各节点的权值总和</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> father)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=d[u];   <span class="comment">//记录节点u的点权</span></span><br><span class="line">    <span class="comment">//遍历节点u的所有邻接点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];~i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j=e[i]; <span class="comment">//邻接点j</span></span><br><span class="line">        <span class="keyword">if</span>(j!=father)   <span class="comment">///避免向上重复搜索已经遍历过的边</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//递归搜索以j为根的子树中个节点的权值总和</span></span><br><span class="line">            <span class="keyword">int</span> c=<span class="built_in">dfs</span>(j,u);</span><br><span class="line">            <span class="comment">//最终在回溯时就会算出以节点u为根的子树中各节点的权值总和c</span></span><br><span class="line">            <span class="comment">//而这个c其实就是节点u与它的父节点之间的边权</span></span><br><span class="line">            <span class="keyword">if</span>(c==<span class="number">0</span>)    <span class="comment">//如果为0则说明这条主要边并不在附加边所形成的环中</span></span><br><span class="line">                ans+=m;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="number">1</span>)<span class="comment">//如果为1则说明这条主要边在附加边所形成的环中</span></span><br><span class="line">                ans++;</span><br><span class="line">            <span class="comment">//相当于res=d[u]+dfs(j,u) 最开始res记录的是节点u的点权</span></span><br><span class="line">            <span class="comment">//而dfs(j,u)就是把节点u以下的全部节点的点权都累加到节点u身上</span></span><br><span class="line">            <span class="comment">//因此最终节点u的点权就是它自身拥有的d[u]+别上给它的c</span></span><br><span class="line">            res+=c; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回以节点u为根的子树中各节点的权值总和</span></span><br><span class="line">    <span class="comment">//其实也就是返回节点u和它的父节点之间的这条边的边权 及被附加边覆盖的次数</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> root=<span class="number">1</span>; <span class="comment">//树的根节点   我们设1号点为根节点  任意点都是可以的</span></span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)  <span class="comment">//读入n-1条 主要边</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="comment">//建图时只包括主要边  而没有把附加边建出来</span></span><br><span class="line">        <span class="built_in">add</span>(a,b),<span class="built_in">add</span>(b,a);  <span class="comment">//无向图</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//预处理出fa[][]</span></span><br><span class="line">    <span class="built_in">bfs</span>(root);</span><br><span class="line">    <span class="comment">//依次枚举每一条附加边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="comment">//找到当前枚举的这条附加边的两个端点的最近公共祖先</span></span><br><span class="line">        <span class="keyword">int</span> lca=<span class="built_in">LCA</span>(a,b);</span><br><span class="line">        <span class="comment">//差分</span></span><br><span class="line">        d[a]++,d[b]++,d[lca]-=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>最近公共祖先</category>
      </categories>
      <tags>
        <tag>LCA+树上差分</tag>
      </tags>
  </entry>
  <entry>
    <title>距离</title>
    <url>/2021/07/22/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/%E8%B7%9D%E7%A6%BB/</url>
    <content><![CDATA[<h1 id="距离"><a href="#距离" class="headerlink" title="距离"></a>距离</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210722165410.png" alt="image-20210722165410424"></p>
<hr>
<h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><h4 id="tarjan算法"><a href="#tarjan算法" class="headerlink" title="tarjan算法"></a>tarjan算法</h4><p>由于tarjan发明了很多算法，特别是在图论领域，因此很多算法都直接被称为了tarjan算法，需要注意区分的是，这里的tarjan算法是用来解决LCA问题的离线算法。</p>
<p>所谓的<strong>在线做法</strong>和<strong>离线做法</strong>都是针对有<strong>询问</strong>这种类型的题目。</p>
<ul>
<li>在线算法：每读入一个询问，都需要运行一次程序立即得到本次查询的答案。若一次查询需要$O(logn)$，则$m$次查询需要$O(mlogn)$</li>
<li>离线算法：读入所有询问，然后运行一次程序就可以得到所有查询的答案。</li>
</ul>
<p>tarjan算法利用并查集优越的时空复杂性，可以在$O(n+m)$时间内解决LCA问题。</p>
<blockquote>
<p>问题：为什么tarjan算法利用并查集就可以求出LCA呢？</p>
<p>如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210722170818.png" alt="image-20210722170818667"></p>
<p>从图中可以看出，节点$u$与子树$A$中的节点，它俩的最近公共祖先是根节点$root$，而且我们发现一个很强的性质就是：子树$A$中的每个节点的祖宗节点刚好就是$root$；节点$u$与子树$B$中的每个节点，它俩最近公共祖先是那个被涂色的节点，而这个节点LCA刚好就是节点子树$B$中每个节点的祖宗节点，也就是说$v$节点的祖宗节点是那个被涂色节点，而 从图中易知$u$和$v$的最近公共祖先恰好就是那个被涂色的节点。</p>
<p>因此，当我们遍历完$u$时，查询有关$u$的询问，比如$v$，然后使用并查集找到节点$v$的集合号，那么就是$u$和$v$的最近公共祖先LCA了。</p>
</blockquote>
<p>下面是tarjan算法求解LCA的过程：</p>
<ul>
<li>初始化集合号数组和访问数组，即<code>fa[i]=i</code>，<code>vis[i]=0</code>，这里$vis[i]=0$表示$i$这个节点还没有被访问过，$vis[i]=1$表示$i$这个节点已经被访问过了</li>
<li>从节点$u$出发进行深度优先遍历，标记$vis[u]=1$，深搜$u$所有还未被访问的邻接点，在遍历的过程中更新距离，回退时更新节点的集合号（祖宗节点）</li>
<li>当节点$u$的所有邻接点全部遍历完毕时，检查关于$u$的所有询问，若存在一个查询$u,v$，并且$vis[v]=1$，那么就利用并查集查找节点$v$的集合号，找到它的祖宗节点，那么这个祖宗节点就是$u$和$v$的最近公共祖先节点。</li>
</ul>
<p>举个栗子：</p>
<p>在树中求$5、6$的最近公共祖先，求解过程如下：</p>
<p>【1】初始化所有节点的集合号等于自己，访问数组都设置为还没有被访问过，即$fa[i]=i$，$vis[i]=0$</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210722180943.png" alt="image-20210722180942823"></p>
<p>【2】随意选择一个节点进行深搜，这里选择从根节点开始深度优先遍历，在遍历的过程中，将访问过的节点都设置为$vis[i]=1$</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210722181052.png" alt="image-20210722181051956"></p>
<p>【3】$8$号节点的所有邻接点都已经访问完毕了，没有与$8$相关的查询，则回退到$6$，更新$fa[8]=6$</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210722181120.png" alt="image-20210722181120440"></p>
<p>【4】遍历$6$号节点的下一个邻接点$9$，标记$vis[9]=1$，$9$号节点的所有邻接点都已经访问完毕了，没有与$9$相关的查询，则回退到$6$，更新$fa[9]=6$</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210722181141.png" alt="image-20210722181141114"></p>
<p>【5】$6$号节点的所有邻接点都已经访问完毕了，有与$6$相关的查询（查询$5$和$6$），但是由于此时$vis[5]\neq1$，并不满足$vis[u]=1$并且$vis[v]=1$（这里$u=6,v=5$），所以啥也不做，然后回退到$4$，更新$fa[6]=4$</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210722181335.png" alt="image-20210722181334949"></p>
<p>【6】$4$号节点的所有邻接点都已经访问完毕了，没有与$4$相关的查询，回退到$2$，更新$fa[4]=2$</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210722181412.png" alt="image-20210722181412378"></p>
<p>【7】遍历$2$号节点的下一个邻接点$5$，标记$vis[5]=1$，继续深度优先遍历到$7$，标记$vis[7]=1$，$7$号节点的所有邻接点都已经访问完毕了，没有与$7$相关的查询，回退到$5$，更新$fa[7]=5$</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210722181422.png" alt="image-20210722181421905"></p>
<p>【8】$5$号节点的所有邻接点都已经访问完毕了，有与$5$相关的查询（查询$5$和$6$），并且$vis[6]=1$，满足$vis[u]=1$并且$vis[v]=1$（这里$u=5,v=6$），那么就需要执行并查集，找到节点$v$的集合号。回退到$2$，更新$fa[5]=2$。设找到节点$v$的祖宗为$x$，那么$x$就是节点$u$和节点$v$的最近公共祖先</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210722181530.png" alt="image-20210722181530072"></p>
<p>【9】从$6$号节点开始利用并查集查找祖宗的过程如下：首先判断$6$的集合号$fa[6]=4$，找到$4$的集合号$fa[4]=2$，找到$2$的集合号$fa[2]=2$，所以找到祖宗（集合号为其自身）后返回，在回溯过程中更新祖宗到当前节点路径上所有节点的集合号，即更新$6、4$的父节点为$fa[4]=2$，$fa[6]=2$。那么此时$fa[6]=2$，即$2$号节点就是$5$号节点和$6$号节点的最近公共祖先</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210722181540.png" alt="image-20210722181540652"></p>
<p><strong>总结：</strong></p>
<p>在当前节点$u$的所有邻接点都已经访问完毕时，检查与$u$相关的查询$v$，注意此时$vis[u]$已经是1了，如果$vis[v]\neq1$，那么什么也不做；如果$vis[v]=1$，则利用并查集查找$v$的祖宗节点。最终$LCA(u,v)=fa[v]$。实际上，$u$的祖宗就是$u$向上查找第1个邻接点未访问完的节点，因为它的$fa[]$还没有更新，仍满足$fa[i]=i$，它就是$v$的祖宗。</p>
<p><strong>算法实现：</strong></p>
<p>并查集算法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x!=p[x])</span><br><span class="line">        p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tarjan算法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];~i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j=e[i];</span><br><span class="line">        <span class="keyword">if</span>(vis[j])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        dist[j]=dist[u]+w[i];</span><br><span class="line">        <span class="built_in">tarjan</span>(j);</span><br><span class="line">        fa[j]=u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;query[u].<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//query[u][i]存储的是第i次询问时,与u相关的查询号  将其赋值给v</span></span><br><span class="line">        <span class="keyword">int</span> v=query[u][i];</span><br><span class="line">        <span class="comment">//query_id[u][i]存储的是第i次查询</span></span><br><span class="line">        <span class="keyword">int</span> id=query_id[u][i];</span><br><span class="line">        <span class="keyword">if</span>(vis[v])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> lca=<span class="built_in">find</span>(v);</span><br><span class="line">            ans[id]=dist[u]+dist[v]<span class="number">-2</span>*dist[lca];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>这道题就直接利用上面所讲述的方法，使用tarjan+并查集算法来解决LCA的离线算法。</p>
<p>树上任意两点之间的距离公式：$L=dist[u]+divt[v]-2\times dist[lca]$</p>
<p>$dist[u]$表示节点$u$到整棵树的根节点的距离；</p>
<p>$dist[v]$表示节点$v$到整棵树的根节点的距离；</p>
<p>$dist[lca]$，其中$lca$是节点$u$和节点$v$的最近公共祖先，表示节点$lca$到整棵树的根节点的距离；</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//这是一棵树  有N个节点 则有N-1条边 由于是无向边  所以要开2倍</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">10010</span>,M=<span class="number">2</span>*N;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;PII;</span><br><span class="line"><span class="keyword">int</span> n,m;    <span class="comment">//n是点数  m是询问次数</span></span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],w[M],idx;</span><br><span class="line"><span class="keyword">int</span> dist[N];    <span class="comment">//距离</span></span><br><span class="line"><span class="keyword">int</span> p[N];       <span class="comment">//并查集的集合号数组</span></span><br><span class="line"><span class="keyword">int</span> res[M];     <span class="comment">//存储询问的结果</span></span><br><span class="line"><span class="keyword">int</span> st[N];      <span class="comment">//标记当前节点是否已经被访问过  st[i]=1表示i节点被访问过了</span></span><br><span class="line"><span class="comment">//query[u]是存放关于节点u的查询信息</span></span><br><span class="line"><span class="comment">//query[u].first存放的是与u相关的那个查询是啥(比如说查询5 6  那么u就是5  query[5].first就是6)</span></span><br><span class="line"><span class="comment">//query[u].second存放的就是这次询问是第几次</span></span><br><span class="line">vector&lt;PII&gt;query[N]; <span class="comment">//存放查询数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//并查集查找x的祖宗节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x!=p[x])</span><br><span class="line">        p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建边</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    w[idx]=c;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//tarjan算法解决LCA的离线查询</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//标记节点u已经被访问过了</span></span><br><span class="line">    st[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//遍历节点u的所有邻接点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];~i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//j是u的邻接节点</span></span><br><span class="line">        <span class="keyword">int</span> j=e[i];</span><br><span class="line">        <span class="comment">//如果节点j还没有被访问过</span></span><br><span class="line">        <span class="keyword">if</span>(!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//更新顶点j的距离</span></span><br><span class="line">            dist[j]=dist[u]+w[i];</span><br><span class="line">            <span class="comment">//以下两句不能调换  因为调换后 经过find函数会进行路径压缩 更新了节点  导致错误</span></span><br><span class="line">            <span class="comment">//然后对顶点j进行深度优先遍历</span></span><br><span class="line">            <span class="built_in">tarjan</span>(j);</span><br><span class="line">            <span class="comment">//回退时更新顶点j的父节点为u</span></span><br><span class="line">            p[j]=u;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果有查询的话</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> item:query[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v=item.first;   <span class="comment">//取出与u相关的查询v</span></span><br><span class="line">        <span class="keyword">int</span> id=item.second; <span class="comment">//这是第几次查询</span></span><br><span class="line">        <span class="comment">//如果节点v之前已经遍历过了  </span></span><br><span class="line">        <span class="comment">//那么满足st[u]=1并且st[v]=1</span></span><br><span class="line">        <span class="keyword">if</span>(st[v])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//对节点v进行并查集操作  找到它的祖宗节点</span></span><br><span class="line">            <span class="comment">//那么这个祖宗节点就是节点u和节点v的最近公共祖先</span></span><br><span class="line">            <span class="keyword">int</span> lca=<span class="built_in">find</span>(v);</span><br><span class="line">            <span class="comment">//记录这次查询的结果 也就是树上节点u和节点v之间的距离</span></span><br><span class="line">            res[id]=dist[u]+dist[v]<span class="number">-2</span>*dist[lca];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="comment">//读入n-1个数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        <span class="comment">//建立无向边</span></span><br><span class="line">        <span class="built_in">add</span>(a,b,c);</span><br><span class="line">        <span class="built_in">add</span>(b,a,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读入m次询问</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="comment">//如果a==b 即查询自身到自身的距离 那肯定是0  那就直接使用全局res数组的0就好了</span></span><br><span class="line">        <span class="comment">//因此当a!=b时  才记录</span></span><br><span class="line">        <span class="keyword">if</span>(a!=b)</span><br><span class="line">        &#123;</span><br><span class="line">            query[a].<span class="built_in">push_back</span>(&#123;b,i&#125;);</span><br><span class="line">            query[b].<span class="built_in">push_back</span>(&#123;a,i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化每个点都是独立的集合</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        p[i]=i;</span><br><span class="line">    <span class="comment">//这里选择从根节点1进行深度优先遍历,进行tarjan算法</span></span><br><span class="line">    <span class="built_in">tarjan</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//输出这m次查询的结果</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>最近公共祖先</category>
      </categories>
      <tags>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title>欧拉回路</title>
    <url>/2021/08/03/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF%E5%92%8C%E6%AC%A7%E6%8B%89%E8%B7%AF%E5%BE%84/%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF/</url>
    <content><![CDATA[<h1 id="欧拉回路"><a href="#欧拉回路" class="headerlink" title="欧拉回路"></a>欧拉回路</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210803160028.png" alt="image-20210803160028347"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>如何判断欧拉回路：</p>
<ul>
<li>对于无向图，如果所有边连通，且所有点的度数都是偶数则是欧拉回路</li>
<li>对于有向图，如果所有边连通，且所有点的入度等于出度即可</li>
</ul>
<p>打印欧拉回路时，是逆序输出得到的序列，而不是正序输出。</p>
<p>这个题是求欧拉回路。在求欧拉回路时，我们判重是对边进行判重而不是对点进行判重，而且必须是用过一条边就必须把它删除了。对于有向图来说很好做，但是对于无向图，它可以看作两条相反的有向边，因此我们删除一条边的时候，还要考虑到它的反向边，所以就显得有些ex。</p>
<p>下面解释一下，为什么代码中使用的是引用：</p>
<p>假设只有一个点，但是有$m$个自环，即$m$条边都是指向了这个节点，然后使用bool数组存储每条边有没有被遍历过。根据上面伪码描述，第一次运行到dfs中会遍历$m$条边，递归进入dfs后还需要遍历$m$条边，一共需要遍历$m$次，因此$m$个$m$相加等于$m\times m=m^2$，会超时。因此需要进行优化：</p>
<p>优化的方式是每次遍历过这条边后将其从邻接表中删除，保证之后不会再遍历到这条边。这样就可以保证每条边只会被遍历一次，时间复杂度变为线性。</p>
<p>参考如下图解释：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210803160727.png" alt="image-20210803160727788"></p>
<p>或者：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210803160807.png" alt="image-20210803160807842"></p>
<p>边的转化：</p>
<p>我们在建图时，无向图中边的编号是$0$到$2m-1$，但是题目中的编号是$1$到$m$，因此需要转化一下：</p>
<ul>
<li>对于无向图，$(0,1)$对应的是第一条边，$(2,3)$对应的是第二条边。设我们建图时某条边的编号为$x$，则转成题目中边的编号为$x/2+1$。比如有三个节点$A-B-C$，那么$A\to B$这条边就是0号边，$B\to A$这条边就是1号边；$B\to C$这条边就是2号边，$C\to B$这条边就是3号边。所以当$x=0$或者$x=1$时，转成题目中边的编号就是$0/2+1=1$或者$1/2+1=1$。从这里我们可以看出，如果$x$是偶数，则表示正向边，如果$x$是奇数，则表示反向边</li>
<li>对于有向图，则比较简单，如果我们建图时某条边的编号为$x$，那么转成题目中边的编号就是$x+1$即可</li>
</ul>
<p>这里还需要处理入度和出度，我们设立了<code>din[]</code>和<code>dout[]</code>分别表示入度和出度：</p>
<ul>
<li>对于无向图，假设$a-b$，那么应该计算$a$有一个出度，计算$b$有一个入度，即$d[a]+1$，$d[b]+1$。注意这里不要被一条无向边是两条相反的有向边迷惑了，统计度时，是不需要考虑的。</li>
<li>对于有向图，假设$a\to b$，那么应该计算$a$有一个出度，计算$b$有一个入度，即$d[a]+1$，$d[b]+1$</li>
</ul>
<p>因此，可以发现，无向图和有向图处理入度和出度的方式都是一样的。</p>
<p><strong>第一次错误的修改：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = h[u] ; ~i ; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(used[i])</span><br><span class="line">        &#123;</span><br><span class="line">            h[u] = ne[i];</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        used[i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(type == <span class="number">1</span>)used[i ^ <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        <span class="keyword">if</span>(type == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            t = i / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i &amp; <span class="number">1</span>)t = -t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> t = i + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        h[u] = ne[i];</span><br><span class="line">        <span class="built_in">dfs</span>(j);</span><br><span class="line"></span><br><span class="line">        res[++ cnt] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正确修改后的代码一：不使用 引用 的写法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = h[u] ; ~i ; i = h[u])<span class="comment">//区别</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(used[i])</span><br><span class="line">        &#123;</span><br><span class="line">            h[u] = ne[i];<span class="comment">//区别</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        used[i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(type == <span class="number">1</span>)used[i ^ <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        <span class="keyword">if</span>(type == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            t = i / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i &amp; <span class="number">1</span>)t = -t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> t = i + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        h[u] = ne[i];<span class="comment">//区别</span></span><br><span class="line">        <span class="built_in">dfs</span>(j);</span><br><span class="line"></span><br><span class="line">        res[++ cnt] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 引用 的写法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> &amp;i = h[u]; ~i;)<span class="comment">//区别</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (used[i])</span><br><span class="line">        &#123;</span><br><span class="line">            i = ne[i];<span class="comment">//区别</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        used[i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">1</span>) used[i ^ <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            t = i / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &amp; <span class="number">1</span>) t = -t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> t = i + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        i = ne[i];<span class="comment">//区别</span></span><br><span class="line">        <span class="built_in">dfs</span>(j);</span><br><span class="line"></span><br><span class="line">        ans[ ++ cnt] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>写法1</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>, M = <span class="number">4e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> type;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="comment">//used[i]=true表示i这条边已经被用过了</span></span><br><span class="line"><span class="keyword">bool</span> used[M];   </span><br><span class="line"><span class="comment">//ans表示欧拉路径,cnt表示路径上边的数量</span></span><br><span class="line"><span class="keyword">int</span> ans[M], cnt;</span><br><span class="line"><span class="comment">//点的出度与入度;</span></span><br><span class="line"><span class="keyword">int</span> din[N], dout[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> &amp;i=h[u];~i;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(used[i])<span class="comment">//如果边i已经被用过了 则直接去下一条边看</span></span><br><span class="line">        &#123;</span><br><span class="line">            i = ne[i];</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//标记i这条边已经被用过了</span></span><br><span class="line">        used[i]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> t;<span class="comment">//点的编号  无向图时点编号=边编号/2+1 有向图时点编号=便编号+1</span></span><br><span class="line">        <span class="keyword">if</span>(type==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            used[i^<span class="number">1</span>]=<span class="literal">true</span>;<span class="comment">//如果无向边 则把反向边也标记</span></span><br><span class="line">            t=i/<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i&amp;<span class="number">1</span>)t=-t;<span class="comment">//奇数边为反向边 如果 pi 为正数表示从 ve 走到 ue，否则表示从 ue 走到 ve</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            t=i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];<span class="comment">//边上连接的邻点  即节点u的邻接点j</span></span><br><span class="line">        i = ne[i];  <span class="comment">//边用过之后直接删了</span></span><br><span class="line">        <span class="built_in">dfs</span>(j);<span class="comment">// 一直走到底 把终点先压进栈 然后回溯往回走把中间及起点加进栈 最终输出结果 ans[cnt]为起点</span></span><br><span class="line">        ans[++cnt] = t;<span class="comment">//从下往上将点输入到路径中,因为从上往下的过程中,可能边路有些环并没有被顾虑到</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;type);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a,b);</span><br><span class="line">        <span class="keyword">if</span>(type==<span class="number">1</span>) </span><br><span class="line">            <span class="built_in">add</span>(b,a);<span class="comment">//无向图 双向边</span></span><br><span class="line">        din[b]++,dout[a]++; <span class="comment">//记录入度和出度</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(type==<span class="number">1</span>)<span class="comment">//无向图</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> d=din[i]+dout[i];</span><br><span class="line">            <span class="keyword">if</span>(d&amp;<span class="number">1</span>)<span class="comment">//度数为奇数 无解</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//有向图</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            <span class="keyword">if</span> (din[i] != dout[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历时可能有孤立点--找一个包含边的起点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (h[i] != <span class="number">-1</span>) <span class="comment">//有邻边</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(i);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果回路中的边数小于总边数,则不构成欧拉回路</span></span><br><span class="line">    <span class="keyword">if</span>(cnt&lt;m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">    <span class="comment">//因为是逆序将点存储的的,所以要逆序将点打出来;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = cnt;i;i--) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,ans[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写法2：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>, M = <span class="number">4e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> type;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="comment">//used[i]=true表示i这条边已经被用过了</span></span><br><span class="line"><span class="keyword">bool</span> used[M];   </span><br><span class="line"><span class="comment">//ans表示欧拉路径,cnt表示路径上边的数量</span></span><br><span class="line"><span class="keyword">int</span> ans[M], cnt;</span><br><span class="line"><span class="comment">//点的出度与入度;</span></span><br><span class="line"><span class="keyword">int</span> din[N], dout[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = h[u] ; ~i ; i = h[u])<span class="comment">//区别</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(used[i])</span><br><span class="line">        &#123;</span><br><span class="line">            h[u] = ne[i];<span class="comment">//区别</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        used[i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(type == <span class="number">1</span>)used[i ^ <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        <span class="keyword">if</span>(type == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            t = i / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i &amp; <span class="number">1</span>)t = -t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> t = i + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        h[u] = ne[i];<span class="comment">//区别</span></span><br><span class="line">        <span class="built_in">dfs</span>(j);</span><br><span class="line"></span><br><span class="line">        ans[++ cnt] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;type);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a,b);</span><br><span class="line">        <span class="keyword">if</span>(type==<span class="number">1</span>) </span><br><span class="line">            <span class="built_in">add</span>(b,a);<span class="comment">//无向图 双向边</span></span><br><span class="line">        din[b]++,dout[a]++; <span class="comment">//记录入度和出度</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(type==<span class="number">1</span>)<span class="comment">//无向图</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> d=din[i]+dout[i];</span><br><span class="line">            <span class="keyword">if</span>(d&amp;<span class="number">1</span>)<span class="comment">//度数为奇数 无解</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//有向图</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            <span class="keyword">if</span> (din[i] != dout[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历时可能有孤立点--找一个包含边的起点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (h[i] != <span class="number">-1</span>) <span class="comment">//有邻边</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(i);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果回路中的边数小于总边数,则不构成欧拉回路</span></span><br><span class="line">    <span class="keyword">if</span>(cnt&lt;m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">    <span class="comment">//因为是逆序将点存储的的,所以要逆序将点打出来;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = cnt;i;i--) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,ans[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写法3：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, M = <span class="number">400010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> type;  <span class="comment">// 1代表无向图，2代表有向图</span></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="keyword">bool</span> used[M];  <span class="comment">// 记录每条边是否被使用了</span></span><br><span class="line"><span class="keyword">int</span> ans[M / <span class="number">2</span>], cnt;  <span class="comment">// 记录欧拉路径</span></span><br><span class="line"><span class="keyword">int</span> din[N], dout[N];  <span class="comment">// 记录每个点的入度，出度，无向图的度等于入度和出度之和</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (~h[u]) &#123;  <span class="comment">// 这样写是为了跳过应遍历的边</span></span><br><span class="line">        <span class="keyword">int</span> i = h[u];  <span class="comment">// 当前遍历第i条边</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (used[i]) &#123;  <span class="comment">// 防止无向图的反向边被加入答案中</span></span><br><span class="line">            h[u] = ne[i];</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        h[u] = ne[i];  <span class="comment">// 这里h[u]被更新，因为h是全局变量，下次dfs就不会遍历到当前考察的边</span></span><br><span class="line">        used[i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">1</span>) used[i ^ <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(e[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = i / <span class="number">2</span> + <span class="number">1</span>;  <span class="comment">// 无向图当前考察的是第t条边(从1开始)</span></span><br><span class="line">            <span class="keyword">if</span> (i &amp; <span class="number">1</span>) t *= <span class="number">-1</span>;</span><br><span class="line">            ans[++cnt] = t;</span><br><span class="line">        &#125; <span class="keyword">else</span> ans[++cnt] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;type);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a, b);</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">1</span>) <span class="built_in">add</span>(b, a);</span><br><span class="line">        dout[a]++, din[b]++;  <span class="comment">// 一条边只会让两个点的度增加，因此对于无向图也是成立的</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否无解</span></span><br><span class="line">    <span class="keyword">if</span> (type == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">if</span> (din[i] + dout[i] &amp; <span class="number">1</span>) &#123;  <span class="comment">// 成立的话说明点i的度为奇数</span></span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">if</span> (din[i] != dout[i]) &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求解欧拉路径</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (~h[i]) &#123;  <span class="comment">// 即h[i] != -1</span></span><br><span class="line">            <span class="built_in">dfs</span>(i);</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// 只能执行一次dfs函数，否则说明其他边在其他连通分量中</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cnt &lt; m) &#123;  <span class="comment">// 说明所有边不连通</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出答案</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = cnt; i; i--) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ans[i]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>欧拉路径与欧拉回路</category>
      </categories>
      <tags>
        <tag>欧拉路径与欧拉回路</tag>
      </tags>
  </entry>
  <entry>
    <title>骑马修栅栏</title>
    <url>/2021/08/03/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF%E5%92%8C%E6%AC%A7%E6%8B%89%E8%B7%AF%E5%BE%84/%E9%AA%91%E9%A9%AC%E4%BF%AE%E6%A0%85%E6%A0%8F/</url>
    <content><![CDATA[<h1 id="骑马修栅栏"><a href="#骑马修栅栏" class="headerlink" title="骑马修栅栏"></a>骑马修栅栏</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210803171345.png" alt="image-20210803171327395"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>将栅栏的交点看成顶点，栅栏看成边，相当于给我们给我们一个无向图，让我们求一个欧拉路径。题目要求输出字典序最小的一个，我们只需要保证从小到大考虑每个点即可。当我们按照从小到大的顺序遍历所有点后，最终ans逆序后存储的是字典序最小的方案。为什么呢？这是因为如果先遍历1号点（编号从1到n），那么当回溯时，是先把大的编号放入ans中，最后再把1放如ans中，因此我们最终逆序输出这个ans，就可以得到字典序最小的欧拉路径了。</p>
<p>总结：</p>
<p>采用回溯法求解逆序欧拉路径，每次优先搜索编号较小的点，再逆序输出即可。 做法：保证u的出边，从小到大排序，不论从哪个点出发，最后一定会回到这个点。先遍历1号点（编号从1到n），则1号点一定最后被加入欧拉路径。因此只要按照从小到大的点的序号搜，就可以得到字典序最小的欧拉路径（最后逆序输出，最小的点会最后加入ans)。</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">510</span>;</span><br><span class="line"><span class="keyword">int</span> n=<span class="number">500</span>,m;        <span class="comment">// n最大500, m边数</span></span><br><span class="line"><span class="keyword">int</span> g[N][N];        <span class="comment">// 邻接矩阵 g[i][j] = k,表示i到j有k条栅栏</span></span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">1100</span>],cnt;  <span class="comment">// 记录欧拉路径，最多1024条边</span></span><br><span class="line"><span class="keyword">int</span> d[N];           <span class="comment">// 记录每个点的度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(g[i][j])</span><br><span class="line">        &#123;</span><br><span class="line">            g[i][j]--,g[j][i]--;    <span class="comment">//无向边</span></span><br><span class="line">            <span class="built_in">dfs</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//回溯时把i加入ans序列中</span></span><br><span class="line">    ans[++cnt]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        g[a][b]++,g[b][a]++;</span><br><span class="line">        d[a]++,d[b]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> start=<span class="number">1</span>;    <span class="comment">//找到起点</span></span><br><span class="line">    <span class="comment">//跳过孤立点</span></span><br><span class="line">    <span class="keyword">while</span>(!d[start])</span><br><span class="line">        start++;</span><br><span class="line">    <span class="comment">//如果存在0个或者2个度数为奇数的顶点,则从这个顶点出发,可以得到欧拉路径</span></span><br><span class="line">    <span class="comment">//如果不存在度数为奇数的顶点,则从任意点出发都可以得到欧拉路径,由于我们初始化start=1</span></span><br><span class="line">    <span class="comment">//那么此时就是从1号节点开始    </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(d[i]&amp;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            start=i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从start开始</span></span><br><span class="line">    <span class="built_in">dfs</span>(start);</span><br><span class="line">    <span class="comment">//逆序输出</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=cnt;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>欧拉路径与欧拉回路</category>
      </categories>
      <tags>
        <tag>欧拉路径与欧拉回路</tag>
      </tags>
  </entry>
  <entry>
    <title>铲雪车</title>
    <url>/2021/08/02/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF%E5%92%8C%E6%AC%A7%E6%8B%89%E8%B7%AF%E5%BE%84/%E9%93%B2%E9%9B%AA%E8%BD%A6/</url>
    <content><![CDATA[<h1 id="铲雪车"><a href="#铲雪车" class="headerlink" title="铲雪车"></a>铲雪车</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210802212407.png" alt="image-20210802212407641"></p>
<hr>
<h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p>无向图：</p>
<ul>
<li>存在欧拉路径的充要条件 : 度数为奇数的点只能有0或2个</li>
<li>存在欧拉回路的充要条件 : 度数为奇数的点只能有0个，即不存在度数为奇数的点，全都是度为偶数的点</li>
</ul>
<p>有向图：</p>
<ul>
<li>存在欧拉路径的充要条件：<ul>
<li>要么所有点的出度均等于入度，即入度$=$出度</li>
<li>要么除了两个点之外，其他所有点的入度$=$出度，剩下的两个点，其中一个点满足出度=入度+1（起点），另一个点满足入度=出度+1（终点）</li>
</ul>
</li>
<li>存在欧拉回路的充要条件：所有点的出度均等于入度，即入度$=$出度</li>
</ul>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>题目中说到”道路都是双向车道,道路的两个方向均需要铲雪“，则对每个点来说，都有入度=出度。根据有向图中存在欧拉回路的充要条件可知，此时必然存在欧拉回路。那么题目中想要求的最短时间就是 刚好一笔画完所有双向边。而欧拉回路刚好就是从一个点开始只遍历所有边一次，然后又回到这个点。 因此，我们只需要计算这些边的总距离就好了，设为$L$，由于是双向，因此要乘以，即$2\times L$</p>
<p>如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210802213239.png" alt="image-20210802213239299"></p>
<p>所以这题看起来很复杂，但是需要认真读清题意，才会发现如此简单，都不需要建图，而是统计边的长度就好了，那么最短时间就是 $2\times L$除以速度即可。</p>
<p>注意题目中输入的坐标的单位是米，但是给出的速度是$km/h$，因此需要把米转化为千米。需要四舍五入到整数，因此还需要用到round函数。</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> sx,sy;</span><br><span class="line">    <span class="keyword">double</span> x1,y1,x2,y2;</span><br><span class="line">    <span class="keyword">double</span> sum=<span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt;sx&gt;&gt;sy;   <span class="comment">//读入铲雪车的停放坐标</span></span><br><span class="line">    <span class="comment">//读入一条街道的起点坐标和终点坐标</span></span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> dx=x1-x2;</span><br><span class="line">        <span class="keyword">double</span> dy=y1-y2;</span><br><span class="line">        sum+=<span class="built_in">sqrt</span>(dx*dx+dy*dy)*<span class="number">2</span>;   <span class="comment">//总距离</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> minutes=<span class="built_in">round</span>(sum/<span class="number">1000</span>/<span class="number">20</span>*<span class="number">60</span>);  <span class="comment">//四舍五入到整数</span></span><br><span class="line">    <span class="keyword">int</span> hours=minutes/<span class="number">60</span>;</span><br><span class="line">    minutes%=<span class="number">60</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d:%02d\n&quot;</span>,hours,minutes);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>欧拉路径与欧拉回路</category>
      </categories>
      <tags>
        <tag>欧拉路径与欧拉回路</tag>
      </tags>
  </entry>
  <entry>
    <title>Ek求最大流</title>
    <url>/2021/08/05/Algorithm-Advanced/Chapter1---Gragh-Theory/%E6%9C%80%E5%A4%A7%E6%B5%81%E4%B9%8B%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/Ek%E6%B1%82%E6%9C%80%E5%A4%A7%E6%B5%81/</url>
    <content><![CDATA[<h1 id="EK求最大流"><a href="#EK求最大流" class="headerlink" title="EK求最大流"></a>EK求最大流</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210805144728.png" alt="image-20210805144728255"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>残留网络：残留网络$G^<em>$与原网络$G$的节点相同，$G$中的每条边都对应$G^</em>$中的一条或两条边。在残留网络中，与原网络对应的同向边是可增量（还可以增加多少流量），反向边是实际流量。</p>
<p>在残留网络中不显示0流量边，网络$G$及可行流对应的残留网络$G^*$如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210805151526.png" alt="image-20210805151526564"></p>
<p>如下图所示，第一次从$v_1$到$v_3$流出了flow为6的流量，那么由于最大容量cap=10，那么下次还可以从$v_1$到$v_3$流出flow为$10-6=4$的流量。反向边是实际流量可以理解为：$v_1$后悔把6这个流量送给$v_3$了，然后$v_3$就又把6这个流量归还给了$v_1$。</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210805151610.png" alt="image-20210805151610067"></p>
<p>增广路是指残留网络上从源点$S$到汇点$T$的一条简单路径。增广量是指增广路径上每条边都可以增流的最小值。</p>
<p>如下图所示，$s\to v_1\to v_3\to t$就是一条增广路，增广量是这条增广路径上各边的最小值$min(9,5,12)=5$。为什么是取5而不是取9或者12呢？因为比如假设从源点$S$流出了流量9，但是由于$v_1\to v_3$这条水管最多承受流量5，因此当我们把流量9送到这条水管时，这条水管就爆了，不能运输水了，因此是取这条增广路径上各边的最小值。</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210805151639.png" alt="image-20210805151639509"></p>
<p>增广路定理：设$flow$是网络$G$的一个可行流，如果不存在从源点到汇点的增广路，则$flow$是$G$的一个最大流。</p>
<p>增广路算法的基本思想：在残留网络中寻找增广路，然后在实流网络中沿增广路增流，在残留网络中沿增广路减流，重复以上步骤，直到不存在增广路时为止。此时，实流网络中的可行流就是所求的最大流。</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210805151801.png" alt="image-20210805151801874"></p>
<p>如上图所示。图一是原网络中每条边的初始容量。EK算法找到了流量为5的增广路$S\to C\to D\to B\to T$。于是在图二中，剩余容量对应发生了变化。接着，图三中，EK算法又找到了流量为2的增广路$S\to A\to B\to D\to E\to T$。最终在图四中，网络就不存在增广路了，最大流的大小就是$5+2=7$。图中省略了剩余容量为0的边。</p>
<blockquote>
<p>问题：如何理解i=e[pre[i]^1]</p>
<p>如下图</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210805152509.png" alt="image-20210805152509340"></p>
</blockquote>
<p>啊</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>,M=<span class="number">20010</span>,INF=<span class="number">1e8</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,S,T;</span><br><span class="line"><span class="comment">//f是边上的容量</span></span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],f[M],idx;</span><br><span class="line"><span class="comment">//q是宽搜存放点的队列</span></span><br><span class="line"><span class="comment">//d[i]=x表示从起点S到点i这条增广路上各边的最小剩余容量</span></span><br><span class="line"><span class="comment">//pre数组记录的前驱边而不是前驱点 比如pre[ver]=i表示节点ver是从边i走过来的</span></span><br><span class="line"><span class="comment">//即节点ver的前驱边是 边i</span></span><br><span class="line"><span class="keyword">int</span> q[N],d[N],pre[N];</span><br><span class="line"><span class="comment">//宽搜中判断某个点是否已经被访问过了</span></span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//正向边 初始化还没有流出流量 所以正向边课流出的容量保持不变 仍为c</span></span><br><span class="line">    e[idx]=b,f[idx]=c,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">    <span class="comment">//反向边 初始化还没有流出流量 所以反向边没有流量  仍为0</span></span><br><span class="line">    e[idx]=a,f[idx]=<span class="number">0</span>,ne[idx]=h[b],h[b]=idx++;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(st,<span class="number">0</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//由于d是想要求最小  所以一般初始化为无穷大</span></span><br><span class="line">    q[<span class="number">0</span>]=S,st[S]=<span class="literal">true</span>,d[S]=INF;</span><br><span class="line">    <span class="comment">//进行宽搜</span></span><br><span class="line">    <span class="keyword">while</span>(hh&lt;=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=q[hh++];  <span class="comment">//取出队头元素</span></span><br><span class="line">        <span class="comment">//遍历节点t的所有邻接点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])  <span class="comment">//i是边</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> ver=e[i];<span class="comment">//ver是节点t的邻接点</span></span><br><span class="line">            <span class="comment">//如果节点ver还没有被访问过 并且i这条边的容量仍然是大于0</span></span><br><span class="line">            <span class="keyword">if</span>(!st[ver]&amp;&amp;f[i])</span><br><span class="line">            &#123;</span><br><span class="line">                st[ver]=<span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//d[t]表示从起点到节点t这条增广路径上的各边中的最小剩余容量</span></span><br><span class="line">                <span class="comment">//f[i]表示i这条边的容量</span></span><br><span class="line">                <span class="comment">//d[ver]表示从起点S到点ver这条增广路上各边的最小剩余容量</span></span><br><span class="line">                d[ver]=<span class="built_in">min</span>(d[t],f[i]);</span><br><span class="line">                <span class="comment">//pre[ver]=i表示节点ver是从边i走过来的 即节点ver的前驱边是 边i</span></span><br><span class="line">                pre[ver]=i;</span><br><span class="line">                <span class="comment">//如果走到了终点  则找到了一条从起点S到终点S且容量&gt;0的增广路径</span></span><br><span class="line">                <span class="keyword">if</span>(ver==T)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                q[++tt]=ver;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//没有找到增广路径</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EK</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxflow=<span class="number">0</span>;  <span class="comment">//最大流</span></span><br><span class="line">    <span class="comment">//如果一直能找到增广路径  则一直寻找 同时累加每一条增广路径上的d[T]</span></span><br><span class="line">    <span class="comment">//最终就是这张图的最大流</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//累加不同的增广路径上的d[T]</span></span><br><span class="line">        maxflow+=d[T];</span><br><span class="line">        <span class="comment">//从终点T逆向到起点S  更新正向边和反向边的容量</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=T;i!=S;i=e[pre[i]^<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//由于已经流出了d[T],那么pre[i]这条边还可以流出f[pre[i]]-d[T]的流量</span></span><br><span class="line">            f[pre[i]]-=d[T];    <span class="comment">//更新正向边的容量</span></span><br><span class="line">            f[pre[i]^<span class="number">1</span>]+=d[T];  <span class="comment">//更新反向边的容量</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//到这里说明不能再找到一条增广路径了  那么此时就求出了最大流</span></span><br><span class="line">    <span class="keyword">return</span> maxflow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;S,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a,b,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">EK</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>网络流</category>
      </categories>
      <tags>
        <tag>EK算法</tag>
      </tags>
  </entry>
  <entry>
    <title>AC自动机</title>
    <url>/2021/08/08/Algorithm-Advanced/Chapter2---Data-Structure/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h1><hr>
<p>AC自动机的作用：给定一段包含$m$个字符的文章，再给定$n$个单词，找出有多少个单词在文章里面出现过。</p>
<p>AC自动机实际上是先将KMP算法和Trie字典树结合，用多个模式串构建一棵字典树，然后在这棵字典树上构建失配指针，失配指针相当于KMP算法中的<code>next[]</code>数组（匹配失败时的回退位置），最后将主串在Trie树上进行模式匹配。</p>
<p>AC自动机算法分为3步：</p>
<ul>
<li>构建一棵字典树</li>
<li>构建AC自动机</li>
<li>进行模式匹配</li>
</ul>
<p>这里主要讲解如何构建AC自动机和如何进行模式匹配。</p>
<hr>
<h3 id="构建AC自动机"><a href="#构建AC自动机" class="headerlink" title="构建AC自动机"></a>构建AC自动机</h3><p>在构建AC自动机时，其实最主要的就是在求出字典树中每个节点的<strong>失配指针</strong>。什么是失配指针呢？失配指针就是说当你在当前节点失配时，你可以跳回到这颗树中的某个位置，而如何找到这个位置就是由失配指针来告诉的。</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210808215954.png" alt="image-20210808215953877"></p>
<p>AC自动机的失配指针所指向的节点代表的字符串是当前节点所代表的字符串的最长后缀。举个栗子，节点5所代表的字符串是she，这个字符串的后缀有{e}，{he}，我们去字典树中寻找看看是否存在字符串{he}，发现节点2所代表的字符串就是{he}，因此找到了当前节点5所代表的字符串she的最长后缀{he}，那么就从节点5指向节点2，这就是失配指针。特别地，对于根节点来说，它的失配指针就是自己，<strong>根节点所代表的字符是空字符””</strong>。对于根节点的下一层节点，由于这一层节点所代表的字符串只有一个字符，而一个字符是不存在后缀的，也可以理解为它的最长后缀是空字符，因此这一层节点的失配指针都指向根节点，如图中的节点1和节点3。</p>
<p>那么，我们是如何知道当前节点的失配指针应该指向哪个位置的呢？</p>
<p><strong>结论：这个位置就是 当前节点的父节点的失配指针所指向位置的孩子节点</strong></p>
<p>如何理解呢？举个栗子，比如当前节点为4，它所代表的字符串是sh，那么它的最长后缀是{h}。4号节点的父节点是3号节点，如何找到4号节点的失配指针所指向的位置呢？我们来看其父节点3号节点的失配指针所指向的位置是根节点，然后我们看根节点的孩子节点中是否存在{h}呢？我们发现确实是存在的，它就是1号节点。也就是说当前4号节点的父节点3的失配指针所指向位置是根节点，根节点的孩子节点中存在字符为{h}的孩子节点1。于是当前4号节点的失配指针所指向的位置就是1号节点。</p>
<p>再来举个栗子，比如当前节点是5，它所代表的字符串是{she}，那么它的后缀是{he}，{e}。5号节点的父节点是4号节点，我们来看4号节点的失配指针所指向的位置是节点1，而节点1中存在字符e的这个孩子节点2。于是当前5号节点的失配指针所指向的位置就是2号节点。</p>
<p>最后举个栗子，比如当前节点是6，它所代表的字符串是{hi}，那么它的后缀是{i}。6号节点的父节点是1号节点，我们来看1号节点的失配指针所指向的位置是根节点，但是我们发现根节点中并不存在字符为i的这个孩子节点，从图中我们发现节点6的失配指针所指向的位置是根节点。这似乎与我们的结论矛盾了。</p>
<p>但是其实不然，我们当发现当前节点的父节点的失配指针所指向位置不存在这个孩子节点时，我们其实是会把它给虚构出来的。也就是说，我们最终都会把这个节点给弄出来。下面会有解释。</p>
<p>构建AC自动机实际上是添加失配指针的过程。由于失配指针都是向上走的，所以从根节点开始进行广度优先遍历就可以得到了。</p>
<p>下面先来看一下构建AC自动机的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[<span class="number">0</span>][i])</span><br><span class="line">            q[++tt]=tr[<span class="number">0</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(hh&lt;=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=q[hh++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> p=tr[t][i];</span><br><span class="line">            <span class="keyword">if</span>(p)</span><br><span class="line">            &#123;</span><br><span class="line">                ne[p]=tr[ne[t]][i];</span><br><span class="line">                q[++tt]=p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                tr[t][i]=tr[ne[t]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>tr[][]</code>是构建好的字典树</li>
<li><code>ne[]</code>是失败指针</li>
</ul>
<p>由于根节点的失配指针指向自己，含义就是根节点代表空字符。那么我们就可以从根节点孩子节点这一层开始进行BFS，因此如果根节点0存在i这个孩子，那么我们就把这个孩子节点<code>tr[0][i]</code>加入到队列q中。然后接下来就是开始进行BFS的过程了</p>
<p>如何理解里面的那一段for循环代码呢？</p>
<p>t节点是p节点的父节点，p节点是t节点的子节点。如果节点t存在孩子节点i的话，也就是如果<code>p</code>为true，那么就处理好节点p的失配指针应该指向的位置，并把这个节点p加入到队列q中，这样才能接着下一层；反之，如果节点t不存在孩子节点i的话，也就是如果<code>p</code>为false，那么我们也需要处理好节点p的失配指针应该指向的位置，由于并不存在节点p，因此它没有机会被加入到队列q中。</p>
<p>如下图解释：</p>
<p>比如四个字符串:abcd，abd，bcd，cd，建立如下图Trie树：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210808224106.png" alt="image-20210808224106799"></p>
<p>解释这个代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(p)</span><br><span class="line">	&#123;</span><br><span class="line">       ne[p]=tr[ne[t]][i];</span><br><span class="line">       q[++tt]=p;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>比如设t是节点b，设p是t的孩子节点，从图中可以看出节点b是存在孩子节点c的，因此$p$为true，那么我们就更新p的失配指针应该指向的位置。此时p节点所代表的字符串是bc，它的后缀是{c}，根据上面的结论，容易找到p节点的失配指针所指向的位置应该是右侧的root下面的孩子节点c。如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210808224645.png" alt="image-20210808224645252"></p>
<p>接下来再解释这段代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">    tr[t][i]=tr[ne[t]][i];</span><br></pre></td></tr></table></figure>
<p>比如我们尝试匹配abcde，从图中可以知道abcd都已经成功匹配了。设t为节点d，设p为t的孩子节点。但是从图中我们可以知道t并不存在孩子节点p，也就是我们发现d并没有e这个节点，那么我们就跳到d的fail指针，也就是bcd上的d，还是没有e，那么继续，到cd上的d，还是没有，只能到根了，还是没有。。。那么。。。就没有了。我们处理的时候，就可以<strong>把abcd上的d的不存在的儿子，指向d的fail指针的这个儿子</strong>。如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210808225152.png" alt="image-20210808225139949"></p>
<p>此刻t为节点d，$p=tr[t][i]=e$，但是节点e并不存在，我们的做法就是把这个不存在的节点e，它的失配指针=节点d它的失配指针所指向的节点。如上图所示，节点d的失配指针所指向的节点最终是根节点root，然后我们发现节点e并不存在，但是我们把它虚构出来了，并且它的失配指针指向了根节点root。即不存在的节点e成为了节点d的失配指针所指向的最终节点的子节点。如上图最右边根节点root虚构出了一个节点e。对应到代码中，<code>tr[ne[t]][i]</code>表示的就是根节点root，<code>tr[t][i]</code>表示就是不存在的节点e，这样赋值的含义就是节点e的失配指针指向的是root。</p>
<p>而这也刚好解释我们上面结论中说到的，当发现当前节点的父节点的失配指针所指向位置不存在这个孩子节点时，我们其实是会把它给虚构出来的也就是说，我们最终都会把这个节点给弄出来。</p>
<p>以上就是构建AC自动机的过程</p>
<hr>
<h3 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h3><p>模式匹配是指从树根开始处理模式串的每个字符，沿着当前字符的fail指针，一直遍历到<code>cnt[p]</code>为止，在遍历过程中累加这些节点的<code>cnt[p]</code>，累加后就将该节点标记为$cnt[p]=-1$，避免重复统计。 $cnt[p]$大于或等于1的节点都是可以匹配的节点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//res记录的是这n个单词有多少个出现在这篇文章中</span></span><br><span class="line">     <span class="keyword">int</span> res = <span class="number">0</span>;	</span><br><span class="line"> 	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; str[i]; i ++ )</span><br><span class="line">   	&#123;</span><br><span class="line">            <span class="keyword">int</span> t = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="comment">//这里是获得根节点下面一层的孩子节点</span></span><br><span class="line">        <span class="comment">//由于根节点是空字符 所以我们从它的孩子节点开始进行模式匹配</span></span><br><span class="line">            j = tr[j][t];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> p = j;</span><br><span class="line">        	<span class="comment">//如果p=0,则说明fail指针退无可退,退到了根节点,而根节点代表空字符</span></span><br><span class="line">        	<span class="comment">//则说明该字符串的最长后缀是空字符,也就是该字符串没有后缀 那么就可以退出这个模式匹配了,再重新开始新一轮模式匹配</span></span><br><span class="line">        <span class="comment">//并且如果该节点已经被标记为-1,则说明已经遍历过了,那么也应该退出了,不然会重复计算,重复走这些节点,最终会形成死循环</span></span><br><span class="line">        <span class="comment">//因此每走过一个节点就将cnt[p]标记为-1 当碰到cnt[p]=-1则说明已经遍历过了,结束这次模式匹配.再重新开始新一轮模式匹配</span></span><br><span class="line">            <span class="keyword">while</span> (p&amp;&amp;cnt[p]!=<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res += cnt[p];	</span><br><span class="line">                cnt[p] = <span class="number">-1</span>;</span><br><span class="line">                p = ne[p];	<span class="comment">//沿着fail指针走</span></span><br><span class="line">            &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>拿开头的那张图为栗子：</p>
<p>在字符串{shers}中包含了几个单词？首先从字典树的根开始，匹配了第一个字符s，然后匹配了第二个字符b，接着匹配第三个字符c，匹配成功单词{she}。5号节点的fail指针指向2号节点，那么又匹配了单词{he}。继续匹配第四个字符r，5号节点的r子节点指向其fail指针的r子节点，因此访问8号节点，继续匹配第5个字符s，匹配成功单词{hers}。这篇文章匹配完毕，res=3，包含3个单词。</p>
<hr>
]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>Dinic求最大流</title>
    <url>/2021/08/05/Algorithm-Advanced/Chapter1---Gragh-Theory/%E6%9C%80%E5%A4%A7%E6%B5%81%E4%B9%8B%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/Dinic%E6%B1%82%E6%9C%80%E5%A4%A7%E6%B5%81/</url>
    <content><![CDATA[<h1 id="Dinic求最大流"><a href="#Dinic求最大流" class="headerlink" title="Dinic求最大流"></a>Dinic求最大流</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210805171900.png" alt="image-20210805171900504"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>Dinic算法思想：首先通过广度优先搜索将图中的顶点分层，然后通过深度优先搜索，沿着层次增1并且$flow&lt;limit$的方向寻找增广路，回溯时增流。一次深度优先搜索可以找到多条增广路径，实现多次增流，这正是Dinic算法的巧妙之处。</p>
<p>算法步骤：</p>
<ul>
<li>在残留网络上BFS求出各个顶点的层次，构造分层图</li>
<li>在分层图上进行DFS，沿着层次增1并且$flow&lt;limit$的方向寻找增广路径，在回溯时实现更新剩余容量。另外每个点可以流向多条边，因此还可以同时加入剪枝优化</li>
<li>重复以上步骤，直到不存在增广路径为止</li>
</ul>
<p>如何理解一次深度优先搜索可以找到多条增广路径呢？</p>
<p>如下图所示：</p>
<p>我们可以利用一次bfs得到的分层图，然后对这个分层图进行一次dfs，就可以直接得出四条增广路径！！！</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210805180416.png" alt="image-20210805180415972"></p>
<p>Dinic算法在执行过程中每次都要重新分层，从源点到汇点的层次是严格递增的，包含$V$个点的层次图最多有$V$层，所以最多重新分层$V$次。</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210805181540.png" alt="image-20210805181540533"></p>
<p>如何理解<code>limit</code>和<code>flow</code>变量呢？</p>
<p><code>limit</code>表示从起点走到当前点$u$的路径的容量上限，我们要在满足这个限制的基础上，求出从当前点到汇点的最大流量。<code>flow</code>表示从当前点$u$出发，往后面流出的流量。</p>
<p>如何理解$flow&lt;limit$呢？</p>
<ul>
<li>假设$flow&gt;limit$，根据流量守恒可知，这个是绝对不可能的，从起点$S$流到当前点的最大容量是$limit$，那么从当前点$u$流出去的容量不可能超过$limit$</li>
<li>假设$flow=limit$，在一些数据中，如果在一次增广中$flow$刚好等于$limit$，就会继续跑下去，在下一层，开始是我们初始化了$flow=0$，假设经过上一层之后，传到下一层的$limit=0$，那么如果写成$flow\leq limit$，此时就会进入for循环中，又会继续跑下去，就一直调用find函数了，最后就跑不完了。</li>
<li>综上，我们需要写成$flow&lt;limit$</li>
</ul>
<p>如何理解当前弧优化呢？</p>
<p>如图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210805175617.png" alt="image-20210805175617764"></p>
<p>我们定义一个数组cur记录当前边（弧）（功能类比邻接表中的h数组，只是会随着dfs的进行而修改），每次我们找过某条边（弧）时，修改cur数组，改成该边（弧）的编号，那么下次到达该点时，会直接从cur对应的边开始（也就是说从h到cur中间的那一些边（弧）我们就不走了）。首先，我们在按顺序dfs时，先被遍历到的边肯定是已经增广过了（或者已经确定无法继续增广了），那么这条边就可以视为“废边”。那么下次我们再到达该节点时，就可以直接无视掉所有废边，只走还有用的边，也就是说，每次dfs结束后，下次dfs可以更省时间。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == T) <span class="keyword">return</span> limit;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = cur[u]; ~i &amp;&amp; flow &lt; limit; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        cur[u] = i;  <span class="comment">// 当前弧优化</span></span><br><span class="line">        <span class="keyword">int</span> ver = e[i];</span><br><span class="line">        <span class="keyword">if</span> (d[ver] == d[u] + <span class="number">1</span> &amp;&amp; f[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t = <span class="built_in">find</span>(ver, <span class="built_in">min</span>(f[i], limit - flow));</span><br><span class="line">            <span class="keyword">if</span> (!t) d[ver] = <span class="number">-1</span>;</span><br><span class="line">            f[i] -= t, f[i ^ <span class="number">1</span>] += t, flow += t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">10010</span>,M=<span class="number">2e5</span>+<span class="number">10</span>,INF=<span class="number">1e8</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,S,T;</span><br><span class="line"><span class="comment">//f[i]是i这条边上的容量</span></span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],f[M],idx;</span><br><span class="line"><span class="comment">//q是宽搜存放节点的队列</span></span><br><span class="line"><span class="comment">//d[i]=1表示i这个节点是在第一层  记录每个节点处于哪一个层次</span></span><br><span class="line"><span class="comment">//cur数组 是用来 当前边优化</span></span><br><span class="line"><span class="keyword">int</span> q[N],d[N],cur[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b,f[idx]=c,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">    e[idx]=a,f[idx]=<span class="number">0</span>,ne[idx]=h[b],h[b]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="keyword">sizeof</span> d);  <span class="comment">//初始化层次为-1</span></span><br><span class="line">    <span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//起点的层次属于第0层</span></span><br><span class="line">    q[<span class="number">0</span>]=S,d[S]=<span class="number">0</span>,cur[S]=h[S];</span><br><span class="line">    <span class="keyword">while</span>(hh&lt;=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=q[hh++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> ver=e[i];</span><br><span class="line">            <span class="comment">//d[ver]==-1表示ver这个点还没有访问过 没有被分层</span></span><br><span class="line">            <span class="keyword">if</span>(d[ver]==<span class="number">-1</span>&amp;&amp;f[i])</span><br><span class="line">            &#123;</span><br><span class="line">                d[ver]=d[t]+<span class="number">1</span>;</span><br><span class="line">                cur[ver]=h[ver];</span><br><span class="line">                <span class="keyword">if</span>(ver==T)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                q[++tt]=ver;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//u是当前节点</span></span><br><span class="line"><span class="comment">//limit表示从起点走到当前点的路径的容量上限</span></span><br><span class="line"><span class="comment">// 我们要在满足这个限制的基础上,求出从当前点到汇点的最大流量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果u等于T了,那么则找到了从源点S到汇点T的最大流 此时答案就是limit</span></span><br><span class="line">    <span class="keyword">if</span>(u==T)</span><br><span class="line">        <span class="keyword">return</span> limit;</span><br><span class="line">    <span class="comment">//flow表示u节点之后可以流出的流量</span></span><br><span class="line">    <span class="keyword">int</span> flow=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//遍历节点u的所有邻接点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=cur[u];~i&amp;&amp;flow&lt;limit;i=ne[i])<span class="comment">//i是边</span></span><br><span class="line">    &#123;</span><br><span class="line">        cur[u]=i;<span class="comment">//当前弧优化</span></span><br><span class="line">        <span class="keyword">int</span> ver=e[i];</span><br><span class="line">        <span class="keyword">if</span>(d[ver]==d[u]+<span class="number">1</span>&amp;&amp;f[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//由于从点u往后已经输送了flow的流量 那么此时还可以从源点S输出的流量为limit-flow</span></span><br><span class="line">            <span class="comment">//f[i]表示i这条水管的容量 我们应该取f[i]和limit-flow的最小值</span></span><br><span class="line">            <span class="comment">//如果limit-flow&gt;f[i],则这条水管不够容纳 会爆掉</span></span><br><span class="line">            <span class="keyword">int</span> t=<span class="built_in">find</span>(ver,<span class="built_in">min</span>(f[i],limit-flow));</span><br><span class="line">            <span class="comment">//如果t为0 则说明从节点ver往后已经没有可以流出的流量了</span></span><br><span class="line">            <span class="comment">//那么从ver往后就不能找到一条增广路径了 直接d[ver]=-1;进行剪枝</span></span><br><span class="line">            <span class="keyword">if</span>(!t)</span><br><span class="line">                d[ver]=<span class="number">-1</span>;</span><br><span class="line">            f[i]-=t;        <span class="comment">//更新正向边的容量</span></span><br><span class="line">            f[i^<span class="number">1</span>]+=t;      <span class="comment">//更新反向边的容量</span></span><br><span class="line">            flow+=t;        <span class="comment">//往后输出的流量又增加了t</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxflow=<span class="number">0</span>;      <span class="comment">//最大流</span></span><br><span class="line">    <span class="keyword">int</span> flow;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>())<span class="comment">//执行bfs构建分层图</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//对这张分层图进行dfs 寻找增广路径计算出可行流</span></span><br><span class="line">        <span class="keyword">while</span>(flow=<span class="built_in">find</span>(S,INF))</span><br><span class="line">            maxflow+=flow;      <span class="comment">//累加多条可行流 最终得到最大流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxflow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;S,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a,b,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">dinic</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>网络流</category>
      </categories>
      <tags>
        <tag>Dinic算法</tag>
      </tags>
  </entry>
  <entry>
    <title>单词</title>
    <url>/2021/08/09/Algorithm-Advanced/Chapter2---Data-Structure/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/%E5%8D%95%E8%AF%8D/</url>
    <content><![CDATA[<h1 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210809171029.png" alt="image-20210809171029490"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>AC自动机的失配指针所指向的节点代表的字符串是当前节点所代表的字符串的最长后缀。举个栗子，节点5所代表的字符串是she，这个字符串的后缀有{e}，{he}，我们去字典树中寻找看看是否存在字符串{he}，发现节点2所代表的字符串就是{he}，因此找到了当前节点5所代表的字符串she的最长后缀{he}，那么就从节点5指向节点2，这就是失配指针。</p>
<p>结论：一个字符串出现的次数=所有满足”要求“的前缀个数，这个要求：这个前缀的的后缀等于原串。</p>
<p>下面来解释一下这个结论：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210809171256.png" alt="image-20210809171256393"></p>
<p>如图，假设有五个单词she、shr、say、he、her。容易知道单词he在所有单词中出现了3次。我们知道单词she的后缀有{e}，{he}，则最长后缀是{he}；我们知道单词her的前缀有{h}，{he}，最长前缀是{he}。我们发现单词she的最长后缀和单词her的最长前缀是相同的，都是{he}。因此单词he出现的次数就是单词she+单词her+单词he自身。</p>
<p>从上我们发现，我们得出的这个结论，与AC自动机中fail指针的实质是相同的！如上图，单词she的fail指针指向了5号节点，因此我们可以把fail指针累加到该单词上。</p>
<p>对于所有存在的边(i, next[i])，我们都连一条边，则我们会形成一个有向无环图，因为i所在的层一定比next[i]所在的层深。这主要是因为fail指针都是往上的，因此当前节点i的fail指针一定是在节点i的上面，从节点i向其fail指针所指向的节点连一条有向边，最终就会得到一张DAG图。</p>
<p>依据拓扑序进行递推即可，即<code>f[ne[j]]+=f[j]</code>，推之后, f代表当前节点代表的字符串在整个trie中出现的次数。</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> tr[N][<span class="number">26</span>],idx;  <span class="comment">//字典树</span></span><br><span class="line"><span class="comment">// 建立trie后, f代表当前节点代表的字符串(必须从根节点开始形成的字符串)出现的次数</span></span><br><span class="line"><span class="comment">// 递推之后, f代表当前节点代表的字符串在整个trie中出现的次数</span></span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"><span class="keyword">int</span> ne[N];  <span class="comment">//fail指针</span></span><br><span class="line"><span class="keyword">int</span> q[N];   <span class="comment">//宽搜队列</span></span><br><span class="line"><span class="comment">//id[i]=p表示第i个单词它在字典树中对应节点的编号是p</span></span><br><span class="line"><span class="keyword">int</span> id[<span class="number">210</span>];    <span class="comment">//记录每个单词在trie中对应节点的编号</span></span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构建字典树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;str[i];i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u=str[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!tr[p][u])</span><br><span class="line">            tr[p][u]=++idx;</span><br><span class="line">        p=tr[p][u];</span><br><span class="line">        f[p]++; <span class="comment">//统计以节点p结尾的所代表的单词的个数+1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第i个单词它在字典树中对应节点的编号是p</span></span><br><span class="line">    id[i]=p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构建AC自动机</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[<span class="number">0</span>][i])</span><br><span class="line">            q[++tt]=tr[<span class="number">0</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(hh&lt;=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=q[hh++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> p=tr[t][i];</span><br><span class="line">            <span class="keyword">if</span>(p)</span><br><span class="line">            &#123;</span><br><span class="line">                ne[p]=tr[ne[t]][i];</span><br><span class="line">                q[++tt]=p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                tr[t][i]=tr[ne[t]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">        <span class="built_in">insert</span>(i);  <span class="comment">//构建字典树</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>();    <span class="comment">//构建AC自动机</span></span><br><span class="line">    <span class="comment">//由于fail指针都是往上(树根方向)的,因此这里是从下往上进行递推</span></span><br><span class="line">    <span class="comment">//最终累加到不能再跳的fail指针所指向的节点 停止</span></span><br><span class="line">    <span class="comment">//这里不写成i&gt;=0是因为根节点0表示空字符 它的fail指针是它自己 即ne[0]=0</span></span><br><span class="line">    <span class="comment">//不写也是可以的 因为它会使用全局变量中的f[0]=0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=idx;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j=q[i]; <span class="comment">//从宽搜队列中取出该节点的编号j</span></span><br><span class="line">        <span class="comment">//从j开始沿着fail指针往上跳  把fail指针所指向的那些节点的f值最终累加到</span></span><br><span class="line">        <span class="comment">//不能再跳的那个fail指针所指向的节点 为止</span></span><br><span class="line">        f[ne[j]]+=f[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> p=id[i];    <span class="comment">//取出第i次单词在字典树中对应节点的编号</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[p]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>Splay</title>
    <url>/2021/08/26/Algorithm-Advanced/Chapter2---Data-Structure/Splay/Splay/</url>
    <content><![CDATA[<h1 id="Splay"><a href="#Splay" class="headerlink" title="Splay"></a>Splay</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210826230513.png" alt="image-20210826230513616"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>这里主要理解一下该怎么删除一段区间$[L,R]$中的数呢？设区间$[L,R]$为子树$t$</p>
<p>我们先找到$L$的前驱$L-1$，找到$R$的后继$R+1$，然后将$L-1$旋转到根，将$R+1$旋转成为$L-1$的儿子，根据中序遍历可知，此时应该为$L-1,t,R+1$，而$t$就是$R+1$的左子树，因此我们想要删除区间$[L,R]$中的数，就等价于要删除$R+1$的左子树。</p>
<p>如下图理解：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210826150845.png" alt="image-20210826150844956"></p>
<p>在Splay中，由于我们用到了$L-1$和$R+1$。假设序列为$[1,n]$。设$L=1,R=n$，那么$L-1=1-1=0,R+1=n+1$。但是我们并没有创建0和$n+1$。因此我们需要多开两个哨兵$0$和$n+1$。</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//旋转到最后：使用pushup</span></span><br><span class="line"><span class="comment">//在递归之前：使用pushdown</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="comment">//ch[2]表示当前节点的左右儿子</span></span><br><span class="line">    <span class="comment">//fa表示当前节点父节点</span></span><br><span class="line">    <span class="comment">//v表示当前节点编号(这道题目中下标就是点的权值 也就是说点的编号就是点的权值)</span></span><br><span class="line">    <span class="keyword">int</span> ch[<span class="number">2</span>],fa,v;</span><br><span class="line">    <span class="comment">//size表示以u为根的这颗子树中的节点总数</span></span><br><span class="line">    <span class="comment">//tag是懒标记  用来记录是否要翻转</span></span><br><span class="line">    <span class="keyword">int</span> size,tag;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> _v,<span class="keyword">int</span> _fa)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        v=_v,fa=_fa;</span><br><span class="line">        size=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;tr[N];</span><br><span class="line"><span class="comment">//root是这棵树的根节点   idx是节点编号  每开辟一个节点就分配一个编号idx</span></span><br><span class="line"><span class="keyword">int</span> root,idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从下往上利用子节点的信息更新父节点的信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//以u为根的这棵树的节点总数=u的左子树中的节点个数+u的右子树中的节点个数+u这个节点</span></span><br><span class="line">    tr[u].size=tr[tr[u].ch[<span class="number">0</span>]].size+tr[tr[u].ch[<span class="number">1</span>]].size+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里进行的是翻转区间[L,R]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果u这个节点需要翻转</span></span><br><span class="line">    <span class="keyword">if</span>(tr[u].tag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//要翻转整颗子树，要先把左右两个儿子翻转，然后递归翻转左右两棵子树</span></span><br><span class="line">        <span class="built_in">swap</span>(tr[u].ch[<span class="number">0</span>],tr[u].ch[<span class="number">1</span>]);</span><br><span class="line">        tr[tr[u].ch[<span class="number">0</span>]].tag^=<span class="number">1</span>; <span class="comment">//翻转标记往下传</span></span><br><span class="line">        tr[tr[u].ch[<span class="number">1</span>]].tag^=<span class="number">1</span>; <span class="comment">//翻转标记往下传</span></span><br><span class="line">        tr[u].tag=<span class="number">0</span>;    <span class="comment">//当前标记清空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//左旋和右旋可以直接用一个旋转函数实现</span></span><br><span class="line"><span class="comment">//这里以图中的右旋为例子理解来写</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//y是x的父节点  z是y的父节点</span></span><br><span class="line">    <span class="keyword">int</span> y=tr[x].fa,z=tr[y].fa;</span><br><span class="line">    <span class="comment">//tr[y].ch[1]==x判断x是否为y的右儿子</span></span><br><span class="line">    <span class="comment">// k=0表示x是y的左儿子；k=1表示x是y的右儿子</span></span><br><span class="line">    <span class="comment">//以图中例子 那么k=0 因此k=0就是左儿子  k^1=0^1=1就是右儿子</span></span><br><span class="line">    <span class="keyword">int</span> k=(tr[y].ch[<span class="number">1</span>]==x);</span><br><span class="line">    <span class="comment">//红边</span></span><br><span class="line">    tr[z].ch[tr[z].ch[<span class="number">1</span>]==y]=x,tr[x].fa=z;</span><br><span class="line">    <span class="comment">//橙边</span></span><br><span class="line">    tr[y].ch[k]=tr[x].ch[k^<span class="number">1</span>],tr[tr[x].ch[k^<span class="number">1</span>]].fa=y;</span><br><span class="line">    <span class="comment">//绿边</span></span><br><span class="line">    tr[x].ch[k^<span class="number">1</span>]=y,tr[y].fa=x;</span><br><span class="line">    <span class="comment">//x,y子树信息变了,又因为y在x下面,所以先维护更新y子树,再维护更新x子树</span></span><br><span class="line">    <span class="built_in">pushup</span>(y);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//伸展操作：将x旋转成为goal的子节点</span></span><br><span class="line"><span class="comment">//情况一：Zig(x)或者Zag(x)	</span></span><br><span class="line"><span class="comment">//情况二：Zig(y)-Zig(x)或者Zag(y)-Zig(x)	</span></span><br><span class="line"><span class="comment">//情况三：Zig(x)-Zag(x)或者Zag(x)-Zag(x)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> goal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//当x还没有旋转成为goal的子节点时 就一直继续</span></span><br><span class="line">    <span class="keyword">while</span>(tr[x].fa!=goal)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//y是x的父节点  z是y的父节点</span></span><br><span class="line">        <span class="keyword">int</span> y=tr[x].fa,z=tr[y].fa;</span><br><span class="line">        <span class="comment">//如果z等于goal 则不会进入if执行体  而是执行最后的rotate(x); 那么这就是情况一</span></span><br><span class="line">        <span class="comment">//如果z!=goal,如果(tr[z].ch[1]==y)^(tr[y].ch[1]==x)成立 则说明是情况三</span></span><br><span class="line">        <span class="comment">//如果z!=goal,如果(tr[z].ch[1]==y)^(tr[y].ch[1]==x)不成立 则说明是情况二</span></span><br><span class="line">        <span class="keyword">if</span>(z!=goal)</span><br><span class="line">            (tr[z].ch[<span class="number">1</span>]==y)^(tr[y].ch[<span class="number">1</span>]==x)?<span class="built_in">rotate</span>(x):<span class="built_in">rotate</span>(y);</span><br><span class="line">        <span class="built_in">rotate</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果goal为0 则表明需要更新根节点为x</span></span><br><span class="line">    <span class="keyword">if</span>(!goal)</span><br><span class="line">        root=x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//u是当前节点	p的u的父节点</span></span><br><span class="line">    <span class="keyword">int</span> u=root,p=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//当u还没有遍历到叶子节点时 还存在子树 则一直遍历</span></span><br><span class="line">    <span class="keyword">while</span>(u)</span><br><span class="line">    &#123;</span><br><span class="line">        p=u;	<span class="comment">//记录u的父节点</span></span><br><span class="line">        <span class="comment">//如果tr[u].v&lt;v成立,则结果为1 表明要插入这个节点的值v比当前节点u的值v还大 则说明在右子树</span></span><br><span class="line">        u=tr[u].ch[tr[u].v&lt;v];</span><br><span class="line">    &#125;</span><br><span class="line">    u=++idx;	<span class="comment">//找到了要插入的节点的位置  给它分配一个编号</span></span><br><span class="line">    <span class="comment">//如果p为0 则说明u的父节点就是根节点0 那么就没有必要记录p的信息了</span></span><br><span class="line">    <span class="keyword">if</span>(p)	<span class="comment">//记录一下u的父节点p的信息</span></span><br><span class="line">        tr[p].ch[tr[p].v&lt;v]=u;	<span class="comment">//初始化点u的值和父节点</span></span><br><span class="line">    tr[u].<span class="built_in">init</span>(v,p);</span><br><span class="line">    <span class="comment">//将新插入的这个节点旋转成为根节点0的儿子</span></span><br><span class="line">    <span class="built_in">splay</span>(u,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取第k大的数字  在这道题中，Splay是以序列下标作为关键字的</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_k</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u=root;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//因为查第几个数是查操作后的数,得先把tag传下去</span></span><br><span class="line">        <span class="built_in">pushdown</span>(u);</span><br><span class="line">        <span class="comment">//tr[tr[u].s[0]].size表示左儿子的节点数 如果它&gt;=k 则去左子树中查询</span></span><br><span class="line">        <span class="keyword">if</span>(tr[tr[u].ch[<span class="number">0</span>]].size&gt;=k)</span><br><span class="line">            u=tr[u].ch[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//如果左儿子的节点数+当前节点u等于k  则说明u就是要查询的</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tr[tr[u].ch[<span class="number">0</span>]].size+<span class="number">1</span>==k)</span><br><span class="line">            <span class="keyword">return</span> u;   <span class="comment">//走到左子树</span></span><br><span class="line">        <span class="comment">//说明在右子树中 那么需要去右子树中查询第k-(tr[tr[u].ch[0]].size+1)个数</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            k-=tr[tr[u].ch[<span class="number">0</span>]].size+<span class="number">1</span>;</span><br><span class="line">            u=tr[u].ch[<span class="number">1</span>];  <span class="comment">//走到右子树</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//找不到返回-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//递归之前先传懒标记</span></span><br><span class="line">    <span class="built_in">pushdown</span>(u);</span><br><span class="line">    <span class="comment">// 如果u有左儿子 先递归输出左儿子</span></span><br><span class="line">    <span class="keyword">if</span>(tr[u].ch[<span class="number">0</span>])</span><br><span class="line">        <span class="built_in">output</span>(tr[u].ch[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// 如果u不是哨兵则输出当前点</span></span><br><span class="line">    <span class="keyword">if</span>(tr[u].v&gt;=<span class="number">1</span>&amp;&amp;tr[u].v&lt;=n)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,tr[u].v);</span><br><span class="line">    <span class="comment">// 如果u有右儿子 递归输出右儿子</span></span><br><span class="line">    <span class="keyword">if</span>(tr[u].ch[<span class="number">1</span>])</span><br><span class="line">        <span class="built_in">output</span>(tr[u].ch[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="comment">//在这道题中 序列中的位置从左到右依次标号为1~n Splay中是以下标作为某个节点权值</span></span><br><span class="line">    <span class="comment">//也就是说某个节点的编号其实就是该点的权值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n+<span class="number">1</span>;i++) <span class="comment">//插入哨兵 0,n+1 防止L-1和R+1越界</span></span><br><span class="line">        <span class="built_in">insert</span>(i);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l,r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">        <span class="comment">//由于我们添加了哨兵0和n+1 因此整体都平移了一个</span></span><br><span class="line">        <span class="comment">//那么题目想要翻转的[L,R]就变成了[L+1,R+1]</span></span><br><span class="line">        <span class="comment">//找到L+1的前驱是L  R+1的后继是R+2</span></span><br><span class="line">        l=<span class="built_in">get_k</span>(l);     <span class="comment">//找到l在序列中的位置下标</span></span><br><span class="line">        r=<span class="built_in">get_k</span>(r+<span class="number">2</span>);   <span class="comment">//找到r在序列中的位置下标</span></span><br><span class="line">        <span class="comment">//先将l旋转到树根 再将r旋转成为l的子节点</span></span><br><span class="line">        <span class="built_in">splay</span>(l,<span class="number">0</span>),<span class="built_in">splay</span>(r,l);</span><br><span class="line">        <span class="comment">//对r的左子树进行翻转</span></span><br><span class="line">        tr[tr[r].ch[<span class="number">0</span>]].tag^=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出中序遍历  就是 翻转某段区间[L,R]后得到的序列</span></span><br><span class="line">    <span class="built_in">output</span>(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>Splay</category>
      </categories>
      <tags>
        <tag>Splay</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索关键词</title>
    <url>/2021/08/09/Algorithm-Advanced/Chapter2---Data-Structure/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/%E6%90%9C%E7%B4%A2%E5%85%B3%E9%94%AE%E8%AF%8D/</url>
    <content><![CDATA[<h1 id="搜索关键词"><a href="#搜索关键词" class="headerlink" title="搜索关键词"></a>搜索关键词</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210809153129.png" alt="image-20210809153129054"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>这题就是一道裸的AC自动机模板题。如果不了解AC自动机，可以阅读这篇博客<a href="https://blog.csdn.net/qq_45832461/article/details/119539153">AC自动机</a></p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>写法一：数组模拟指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e5</span>+<span class="number">10</span>,M=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> tr[N][<span class="number">26</span>],idx;  <span class="comment">//字典树</span></span><br><span class="line"><span class="keyword">int</span> cnt[N]; <span class="comment">//记录以每个节点结尾的字符串的个数</span></span><br><span class="line"><span class="keyword">int</span> ne[N];  <span class="comment">//失配fail指针</span></span><br><span class="line"><span class="keyword">int</span> q[N];   <span class="comment">//宽搜队列</span></span><br><span class="line"><span class="keyword">char</span> str[M];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(tr,<span class="number">0</span>,<span class="keyword">sizeof</span> tr);</span><br><span class="line">    <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span> cnt);</span><br><span class="line">    <span class="built_in">memset</span>(ne,<span class="number">0</span>,<span class="keyword">sizeof</span> ne);</span><br><span class="line">    idx=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构建trie树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;str[i];i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u=str[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!tr[p][u])</span><br><span class="line">            tr[p][u]=++idx;</span><br><span class="line">        p=tr[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构建AC自动机</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//根节点0所代表的字符是空字符  不存在后缀 所以我们从根节点的下一层开始进行宽搜</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果根节点存在i这个孩子</span></span><br><span class="line">        <span class="keyword">if</span>(tr[<span class="number">0</span>][i])</span><br><span class="line">            q[++tt]=tr[<span class="number">0</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开始宽搜</span></span><br><span class="line">    <span class="keyword">while</span>(hh&lt;=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=q[hh++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> p=tr[t][i];</span><br><span class="line">            <span class="comment">//如果t存在p这个孩子</span></span><br><span class="line">            <span class="keyword">if</span>(p)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//节点p的失配指针应该指向的位置ne[p]就等于</span></span><br><span class="line">                <span class="comment">//节点p的父节点t的失配指针最终所指向的节点tr[ne[t]][i]</span></span><br><span class="line">                ne[p]=tr[ne[t]][i];</span><br><span class="line">                <span class="comment">//将p加入队列中  这样才能继续扩展下一层</span></span><br><span class="line">                q[++tt]=p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//否则如果t不存在p这个孩子</span></span><br><span class="line">            <span class="comment">//则这个树节点值 也等于 父节点的fail指向的节点中具有相同字母的子节点</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                tr[t][i]=tr[ne[t]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进行模式匹配</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;str[i];i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=str[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        j=tr[j][t];</span><br><span class="line">        <span class="keyword">int</span> p=j;</span><br><span class="line">        <span class="keyword">while</span>(p&amp;&amp;cnt[p]!=<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res+=cnt[p];</span><br><span class="line">            cnt[p]=<span class="number">-1</span>;</span><br><span class="line">            p=ne[p];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">            <span class="built_in">insert</span>();   <span class="comment">//构建trie树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">build</span>();    <span class="comment">//构建AC自动机</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">        <span class="keyword">int</span> res=<span class="built_in">query</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写法二：指针写法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> K=<span class="number">26</span>,M=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    node *fail;     <span class="comment">//失配指针</span></span><br><span class="line">    node *ch[K];    <span class="comment">//字典树中的节点</span></span><br><span class="line">    <span class="keyword">int</span> count;      <span class="comment">//字典树中以某个节点结尾的这个单词的个数</span></span><br><span class="line">    <span class="built_in">node</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        fail=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">memset</span>(ch,<span class="literal">NULL</span>,<span class="keyword">sizeof</span> ch);</span><br><span class="line">        count=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">node *superRoot,*root;  <span class="comment">//超根和树根</span></span><br><span class="line"><span class="keyword">char</span> str[M];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span><span class="comment">//初始化操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    superRoot=<span class="keyword">new</span> node; <span class="comment">//给超根分配空间</span></span><br><span class="line">    root=<span class="keyword">new</span> node;      <span class="comment">//给树根分配空间</span></span><br><span class="line">    root-&gt;fail=superRoot;       <span class="comment">//树根的失配指针指向的是超根</span></span><br><span class="line">    <span class="comment">//树根的超根的孩子</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;K;i++)</span><br><span class="line">        superRoot-&gt;ch[i]=root;</span><br><span class="line">    superRoot-&gt;count=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构建字典树trie</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node *t=root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;str[i];i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u=str[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(t-&gt;ch[u]==<span class="literal">NULL</span>)</span><br><span class="line">            t-&gt;ch[u]=<span class="keyword">new</span> node;</span><br><span class="line">        t=t-&gt;ch[u];</span><br><span class="line">    &#125;</span><br><span class="line">    t-&gt;count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构建AC自动机</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;node*&gt;q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        node *t=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;K;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//t存在孩子节点t-&gt;ch[i]</span></span><br><span class="line">            <span class="keyword">if</span>(t-&gt;ch[i])</span><br><span class="line">            &#123;</span><br><span class="line">                t-&gt;ch[i]-&gt;fail=t-&gt;fail-&gt;ch[i];</span><br><span class="line">                q.<span class="built_in">push</span>(t-&gt;ch[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                t-&gt;ch[i]=t-&gt;fail-&gt;ch[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    node *t=root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;str[i];i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x=str[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        t=t-&gt;ch[x];</span><br><span class="line">        <span class="keyword">for</span>(node *u=t;u-&gt;count!=<span class="number">-1</span>;u=u-&gt;fail)</span><br><span class="line">        &#123;</span><br><span class="line">            res+=u-&gt;count;</span><br><span class="line">            u-&gt;count=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">init</span>(); <span class="comment">//初始化</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">            <span class="built_in">insert</span>();   <span class="comment">//  构建字典树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">build</span>(); <span class="comment">//构建AC自动机</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">        <span class="keyword">int</span> res=<span class="built_in">query</span>();    <span class="comment">//进行模式匹配</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>圆桌问题</title>
    <url>/2021/08/06/Algorithm-Advanced/Chapter1---Gragh-Theory/%E6%9C%80%E5%A4%A7%E6%B5%81%E4%B9%8B%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/%E5%9C%86%E6%A1%8C%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="圆桌问题"><a href="#圆桌问题" class="headerlink" title="圆桌问题"></a>圆桌问题</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210806135351.png" alt="image-20210806135351909"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>题意：求二分图的多重匹配，输出其中的一个方案</p>
<p>二分图的多重匹配可以使用网络流算法来求解，可以先看一下这个题<a href="https://blog.csdn.net/qq_45832461/article/details/119452567">网络流求二分图的最大匹配</a>，这里的建图方式灵感来源于那道题。</p>
<p>什么是二分图的多重匹配呢？其实也就是左侧的一个节点，它可以同时连向右侧的好多个节点，即一夫多妻制。而二分图的最大匹配是左侧的一个节点只能连向右侧的一个节点，即一夫一妻制。</p>
<p>我们设左侧点集是 单位，右侧点集是 餐桌。有$n$个单位，第$i$个单位中有$r_i$个代表，因此我们可以从源点$S$向第$i$个单位这个节点连一条容量为$r_i$的有向边。有$m$个餐桌，第$i$张餐桌能容纳$c_i$个代表，因此我们可以从第$i$个餐桌向汇点$T$连一条容量为$c_i$的有向边。左侧节点向右侧节点连一条容量为1的有向边。如果存在匹配边，则该匹配边上的流量是1，否则是0。这样就构建好了整个网络。</p>
<p>假设说最大流跑满了的话，从源点出去的所有流量应该都是跑满的，到达汇点的所有流量应该都是占满了$c_i$的.换句话说如果最大流就是$\sum r_i$的话，就说明所有的单位里的人都找到一个不同的位置坐。这就是题目判断是否坐满了的条件，也就是说这样处理了之后，新的网络上跑最大流等价于原来的二分图上跑多重匹配，因此是正确的.</p>
<p>如何知道方案呢？</p>
<p>当最大流$maxflow$与这$m$个单位的总人数$tot$相等时，则说明是方案。</p>
<p>如何输出方案呢？</p>
<p>先遍历所有的正向边，找到这条边连通的两个端点，枚举右侧节点$m+1\leq e[j]\leq n+m$，如果该节点$e[j]$与e[j^1]的连边上的容量为0，已经满了，则说明是一条匹配边，此时输出餐桌的编号，即$e[j]-m$即可，减去$m$是因为我们把题目中餐桌的编号在建图时都加上了$m$，因此要还原输出。</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210806141106.png" alt="image-20210806141106110"></p>
<p>如上图所示</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">430</span>, M = (<span class="number">150</span> * <span class="number">270</span> + N) * <span class="number">2</span>, INF = <span class="number">1e8</span>;</span><br><span class="line"><span class="keyword">int</span> m, n, S, T;</span><br><span class="line"><span class="keyword">int</span> h[N], e[M], f[M], ne[M], idx;</span><br><span class="line"><span class="keyword">int</span> q[N], d[N], cur[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">    e[idx] = a, f[idx] = <span class="number">0</span>, ne[idx] = h[b], h[b] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    q[<span class="number">0</span>] = S, d[S] = <span class="number">0</span>, cur[S] = h[S];</span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = q[hh ++ ];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> ver = e[i];</span><br><span class="line">            <span class="keyword">if</span> (d[ver] == <span class="number">-1</span> &amp;&amp; f[i])</span><br><span class="line">            &#123;</span><br><span class="line">                d[ver] = d[t] + <span class="number">1</span>;</span><br><span class="line">                cur[ver] = h[ver];</span><br><span class="line">                <span class="keyword">if</span> (ver == T) </span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                q[ ++ tt] = ver;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == T) </span><br><span class="line">        <span class="keyword">return</span> limit;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = cur[u]; ~i &amp;&amp; flow &lt; limit; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        cur[u] = i;</span><br><span class="line">        <span class="keyword">int</span> ver = e[i];</span><br><span class="line">        <span class="keyword">if</span> (d[ver] == d[u] + <span class="number">1</span> &amp;&amp; f[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t = <span class="built_in">find</span>(ver, <span class="built_in">min</span>(f[i], limit - flow));</span><br><span class="line">            <span class="keyword">if</span> (!t) </span><br><span class="line">                d[ver] = <span class="number">-1</span>;</span><br><span class="line">            f[i] -= t, f[i ^ <span class="number">1</span>] += t, flow += t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxflow = <span class="number">0</span>, flow;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">bfs</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (flow = <span class="built_in">find</span>(S, INF)) </span><br><span class="line">            maxflow += flow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxflow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;m, &amp;n);</span><br><span class="line">    S = <span class="number">0</span>, T = m + n + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;    <span class="comment">//记录这m个单位的总人数</span></span><br><span class="line">    <span class="comment">//从源点S向左侧点集连一条容量为1的有向边</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c);</span><br><span class="line">        <span class="built_in">add</span>(S, i, c);</span><br><span class="line">        tot += c;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从右侧点集向汇点T连一条容量为1的有向边</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c);</span><br><span class="line">        <span class="built_in">add</span>(m + i, T, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">///从左侧点集向右侧点集连一条容量为1的有向边</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="built_in">add</span>(i, m + j, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最大流不等于总人数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dinic</span>() != tot) </span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ )<span class="comment">//左侧点集</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//遍历节点i的所有邻接点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = h[i]; ~j; j = ne[j])<span class="comment">//j是边</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (e[j] &gt; m &amp;&amp; e[j] &lt;= m + n &amp;&amp; !f[j])</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, e[j] - m);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>网络流</category>
      </categories>
      <tags>
        <tag>网络流求二分图的多重匹配</tag>
      </tags>
  </entry>
  <entry>
    <title>后缀自动机</title>
    <url>/2021/08/15/Algorithm-Advanced/Chapter2---Data-Structure/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="后缀自动机"><a href="#后缀自动机" class="headerlink" title="后缀自动机"></a>后缀自动机</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><a href="https://www.luogu.com.cn/problem/P3804">洛谷P3804</a></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>考虑如何求出 “子串的出现数量”</p>
<p>结论：子串substr出现的数量=|endpos(substr)|</p>
<p>也就是说，子串substr出现的数量，其实就是endpos(substr)这个集合中的元素的个数</p>
<p>如下图感性理解一下：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210815164451.png" alt="image-20210815164444420"></p>
<p>如上图所示，设原串为$abca$，我们想要求出子串a的出现数量，由原串一眼就看出子串a出现了两次。但是我们观察endpos发现，$endpos(“a”)=[1,4]$，这个集合中的元素个数为2，这刚好就说明了子串a出现了两次。</p>
<p>接下来就要考虑怎么才能求出某个endpos集合的大小呢？</p>
<p>这里要注意，其实endpos集合只与后缀自动机中的后缀链接link有关，因此我们建图时，就只需要把含有link的边建立出来就好了。</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210815165154.png" alt="image-20210815165154096"></p>
<p>如上图所示，我们发现一个性质：叶子节点endpos的并集就构成了它们父节点的endpos中的元素。但是要注意有可能父节点是有属于自己特有的元素的。因此我们要计算<code>endpos[u]</code>的大小时，就先计算自己特有的元素的大小<code>endpos[u]</code>，然后再计算它的子节点的元素大小<code>endpos[v]</code>，那么相加，就会得到状态节点$u$的endpos集合的大小$|endpos(u)|$</p>
<p>虽然再后缀自动机中，我们是从子节点向父节点引了后缀链接边，但是在这题中，我们建图时，我们是从父节点向子节点建立一条有向边。为什么呢？因为这样当我们进行dfs时，从根节点开始，一直递归到叶子节点，然后统计出了叶子节点$v$的endpos集合大小$endpos(v)$，那么在回溯时就会累加到其父节点$u$，那么就可以算出父节点$u$的endpos集合大小$endpos(u)$了</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="comment">//N是后缀自动机中的状态节点个数 要开2倍  M是建立出只含link后缀链接时图中边的总数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e6</span>+<span class="number">10</span>,M = N;</span><br><span class="line"><span class="comment">//tot记录的是后缀自动机中的状态节点 初始化为根节点1</span></span><br><span class="line"><span class="comment">//last记录的是上一个状态节点</span></span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">1</span>, last = <span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> len;    <span class="comment">//记录这个状态节点所形成的串中最大的那个串的长度</span></span><br><span class="line">    <span class="keyword">int</span> link;   <span class="comment">//后缀链接</span></span><br><span class="line">    <span class="keyword">int</span> ch[<span class="number">26</span>]; <span class="comment">//类似于trie树中的孩子</span></span><br><span class="line">&#125;node[N];</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="comment">//endpos集合   ans是答案</span></span><br><span class="line">LL endpos[N], ans;  </span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后缀自动机模板</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">extend</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//先用p来记录上一个状态节点</span></span><br><span class="line">    <span class="comment">//然后由于来了一个字符c,需要进行状态转移了</span></span><br><span class="line">    <span class="comment">// 因此给转移后得到的节点np分配一个编号tot</span></span><br><span class="line">    <span class="keyword">int</span> p = last, np = last = ++ tot;</span><br><span class="line">    <span class="comment">//以tot这个位置结尾形成串它自己就是一个前缀</span></span><br><span class="line">    endpos[tot] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//由于np是从p通过新添一个字符c转移过去的  因此长度+1</span></span><br><span class="line">    node[np].len = node[p].len + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//沿着p的后缀链接遍历节点  如果遍历到的节点p它没有孩子c</span></span><br><span class="line">    <span class="comment">//则要创建出来  让np连一条后缀链接边到node[p].ch[c]就相当于</span></span><br><span class="line">    <span class="comment">//该节点p通过字符c转移到了np</span></span><br><span class="line">    <span class="keyword">for</span> (; p &amp;&amp; !node[p].ch[c];p = node[p].link)</span><br><span class="line">        node[p].ch[c] = np;</span><br><span class="line">    <span class="comment">//沿着后缀链接一直来到了根节点  仍然没有发现</span></span><br><span class="line">    <span class="comment">//那么np的后缀链接就是根节点</span></span><br><span class="line">    <span class="keyword">if</span> (!p)</span><br><span class="line">        node[np].link = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> q = node[p].ch[c];  <span class="comment">//找到状态节点p的c孩子节点 q</span></span><br><span class="line">        <span class="comment">//np沿着后缀链接找到了q 发现q中有np想要的串 能够进行后缀邻接</span></span><br><span class="line">        <span class="comment">//那么此时nq就可以引出一条后缀链接边到q</span></span><br><span class="line">        <span class="keyword">if</span> (node[q].len == node[p].len + <span class="number">1</span>)</span><br><span class="line">            node[np].link = q;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//将q一分为二 变成q 和 nq</span></span><br><span class="line">            <span class="keyword">int</span> nq = ++ tot;</span><br><span class="line">            <span class="comment">//nq是q克隆出来了  但是nq包含了从q中抽离出来的能够让np进行后缀链接的串</span></span><br><span class="line">            node[nq] = node[q], node[nq].len = node[p].len + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//分裂前的q引一条后缀链接边到nq</span></span><br><span class="line">            <span class="comment">//从新开的状态节点np引一条后缀链接边到nq</span></span><br><span class="line">            node[q].link = node[np].link = nq;</span><br><span class="line">            <span class="comment">//沿着p的后缀链接一直往回走 将所遍历到的节点 都 引一条后缀链接边到nq</span></span><br><span class="line">            <span class="keyword">for</span> (; p &amp;&amp; node[p].ch[c] == q; p = node[p].link)</span><br><span class="line">                node[p].ch[c] = nq;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v=e[i];</span><br><span class="line">        <span class="built_in">dfs</span>(v);</span><br><span class="line">        <span class="comment">//当前状态节点u的endpos就等于它自身特有的endpos[u]加上它的孩子节点的endpos[v]</span></span><br><span class="line">        <span class="comment">//比如u=&#123;1,2,3,4,5&#125;  v1=&#123;1,2&#125;,v2=&#123;3,4&#125; 那么它特有的就是&#123;5&#125;</span></span><br><span class="line">        <span class="comment">//所以u的endpos集合中元素的个数 就是  它自己特有的&#123;5&#125; 加上 |v1|+|v2|</span></span><br><span class="line">        <span class="comment">//一共就是5个 即endpos[u]的元素个数为5</span></span><br><span class="line">        endpos[u] += endpos[v];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出现次数不为 1</span></span><br><span class="line">    <span class="keyword">if</span> (endpos[u] &gt; <span class="number">1</span>) </span><br><span class="line">        ans = <span class="built_in">max</span>(ans, endpos[u] * node[u].len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; str[i]; i ++ )</span><br><span class="line">        <span class="built_in">extend</span>(str[i] - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="comment">//虽然后缀自动机中后缀链接是从子节点引向父节点</span></span><br><span class="line">    <span class="comment">//但是我们这里是建边时是从父节点引向子节点  因为这样的话</span></span><br><span class="line">    <span class="comment">//我们在dfs时是从父节点递归到子节点  然后统计子节点的endpos值</span></span><br><span class="line">    <span class="comment">//回溯时累加到其父节点的endpos上     这样就刚好满足 &quot;父节点是它子节点的并集&quot; 的性质</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= tot; i ++ )</span><br><span class="line">        <span class="built_in">add</span>(node[i].link, i);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>); <span class="comment">//从后缀状态机的根节点开始深搜</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>后缀自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>伸展树</title>
    <url>/2021/08/26/Algorithm-Advanced/Chapter2---Data-Structure/Splay/%E4%BC%B8%E5%B1%95%E6%A0%91/</url>
    <content><![CDATA[<h1 id="Splay伸展树"><a href="#Splay伸展树" class="headerlink" title="Splay伸展树"></a>Splay伸展树</h1><hr>
<h3 id="Splay简介"><a href="#Splay简介" class="headerlink" title="Splay简介"></a>Splay简介</h3><p>Splay 是一种二叉查找树，它通过不断将某个节点旋转到根节点，使得整棵树仍然满足二叉查找树的性质，并且保持平衡而不至于退化为链。它由 Daniel Sleator 和 Robert Tarjan 发明。</p>
<p>伸展树，也叫做分裂树，是一种二叉搜索树，可以在$O(logn)$内完成插入、查找、删除操作。在整体上多呈现极强的规律性，其中最为典型的就是数据局部性。数据局部性包括时间局部性和空间局部性。伸展树正是基于数据的时间局部性和空间局部性原理产生的。举个栗子，我们使用输入法时，第一次输入的内容，那么第二次输入时就很大概率排在前面。</p>
<ul>
<li>时间局部性：刚刚被访问的元素，极有可能在不久后再次被访问</li>
<li>空间局部性：刚刚被访问的元素，它的相邻节点也很有可能被访问</li>
</ul>
<p>考虑到局部性原理，伸展树会在每次操作后都将刚被访问的节点旋转到树根，加速后续操作。旋转前后的搜索树必须是等价的。这样查询频率高的节点应该经常处于靠近树根的位置。</p>
<p>旋转的巧妙之处在于：在不打乱数列中数据大小关系（中序遍历有序性）的情况下，所有基本操作的均摊复杂度仍为$O(logn)$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ch[<span class="number">2</span>];	<span class="comment">//该节点左右儿子</span></span><br><span class="line">    <span class="keyword">int</span> fa;		<span class="comment">//该节点的父节点</span></span><br><span class="line">    <span class="keyword">int</span> v;		<span class="comment">//该节点的编号(在不同的问题中还可以理解为该节点的权值)</span></span><br><span class="line">    <span class="keyword">int</span> size;	<span class="comment">//该节点的子树中的节点个数</span></span><br><span class="line">    <span class="comment">//初始化点该节点的编号和父节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> _v,<span class="keyword">int</span> _fa)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        v=_v,fa=_fa;</span><br><span class="line">        size=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><p>为了使 Splay 保持平衡而进行旋转操作，旋转的本质是将某个节点上移一个位置。</p>
<p>旋转需要保证：</p>
<ul>
<li>整棵 Splay 的中序遍历不变（不能破坏二叉查找树的性质）。</li>
<li>受影响的节点维护的信息依然正确有效。</li>
<li><code>root</code> 必须指向旋转后的根节点。</li>
</ul>
<p>在 Splay 中旋转分为两种：左旋(Zig)和右旋(Zag)</p>
<p>如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210826114933.png" alt="image-20210826114932945"></p>
<p>左旋操作：口诀：<strong>左旋带子右，删左挂父右，两极反转</strong></p>
<p>对$x$左旋，带子右 表示带着$x$的右子树，删左 表示删除$x$的左子树，挂父右 表示将$x$的左子树挂到其父节点$y$的右子树上，两极反转 表示原来$y$是$x$的父节点，那么左旋后$x$是$y$的父节点。</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210826115131.png" alt="image-20210826115131540"></p>
<p>右旋操作：口诀：<strong>右旋带子左，删右挂父左，两极反转</strong></p>
<p>对$x$右旋，带子左 表示带着$x$的左子树，删右 表示删除$x$的右子树，挂父左 表示将$x$的右子树挂到其父节点$y$的左子树上，两极反转 表示原来$y$是$x$的父节点，那么右旋后$x$是$y$的父节点。</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210826115454.png" alt="image-20210826115454817"></p>
<p>其实不管左旋还是右旋，最主要的就是保持旋转前后，中序遍历不改变</p>
<p>Splay它虽然分为左旋和右旋，但是经过前人的总结，可以直接在一个rotate函数中就同时实现左旋和右旋：</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y=tr[x].fa;	<span class="comment">//x的父节点是y</span></span><br><span class="line">    <span class="keyword">int</span> z=tr[y].fa;	<span class="comment">//y的父节点是z</span></span><br><span class="line">    <span class="keyword">int</span> k=(tr[y].ch[<span class="number">1</span>]==x);	<span class="comment">//k=0表示x是y的左儿子；k=1表示x是y的右儿子</span></span><br><span class="line">    tr[z].ch[tr[z].ch[<span class="number">1</span>]==y]=x,tr[x].fa=z;	<span class="comment">//处理红色边</span></span><br><span class="line">    tr[y].ch[k]=tr[x].ch[k^<span class="number">1</span>],tr[tr[x].ch[k^<span class="number">1</span>]].fa=y;	<span class="comment">//处理橙色边</span></span><br><span class="line">    tr[x].ch[k^<span class="number">1</span>]=y,tr[y].fa=x;		<span class="comment">//处理绿色边</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面以这幅图只讨论一种情况 右旋$x$ 来理解代码：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210826121104.png" alt="image-20210826121104608"></p>
<p><code>tr[y].ch[1]==x</code>判断右旋前$y$的右儿子是不是$x$，如果是，则结果为1；如果不是，则结果为0</p>
<p>因此k=0表示x是y的左儿子；k=1表示x是y的右儿子</p>
<p>由上图可知，$x$是$y$的左儿子，因此$k=0$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> k=(tr[y].ch[<span class="number">1</span>]==x);	<span class="comment">//k=0表示x是y的左儿子；k=1表示x是y的右儿子</span></span><br></pre></td></tr></table></figure>
<p><code>tr[z].ch[1]==y</code>判断右旋前$z$的右儿子是不是$y$，如果是，则结果为1；如果不是，则结果为0</p>
<p>由上图可知，$y$是$z$的左儿子，因此结果为0，即$tr[z].ch[0]=x$，对应到右旋后的红色边就表示$z$的左孩子是$x$，$tr[x].fa=z$就表示$x$的父节点是$z$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">tr[z].ch[tr[z].ch[<span class="number">1</span>]==y]=x,tr[x].fa=z;	<span class="comment">//处理红色边</span></span><br></pre></td></tr></table></figure>
<p>由于上面$k=0$，因此$tr[y].ch[k]$表示右旋后$y$的左孩子，表示<code>tr[x].ch[k^1]</code>的右旋前$x$的右孩子B，因此执行<code>tr[y].ch[k]=tr[x].ch[k^1]</code>就表示$y$的左儿子是B，执行<code>tr[tr[x].ch[k^1]].fa=y</code>就表示$B$的父节点是$y$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">tr[y].ch[k]=tr[x].ch[k^<span class="number">1</span>],tr[tr[x].ch[k^<span class="number">1</span>]].fa=y;	<span class="comment">//处理橙色边</span></span><br></pre></td></tr></table></figure>
<p>由于上面$k=0$，因此<code>tr[x].ch[k^1]</code>表示右旋后$x$的右儿子，<code>tr[y].fa=x</code>表示$y$的父节点是$x$，执行<code>tr[x].ch[k^1]=ytr[x].ch[k^1]=y</code>就表示$y$是$x$的右儿子，执行<code>tr[y].fa=x</code>就表示$y$的父节点是$x$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">tr[x].ch[k^<span class="number">1</span>]=y,tr[y].fa=x;		<span class="comment">//处理绿色边</span></span><br></pre></td></tr></table></figure>
<p>代码就根据图示来理解就好了</p>
<hr>
<h3 id="伸展"><a href="#伸展" class="headerlink" title="伸展"></a>伸展</h3><p>分为3种情况：</p>
<p><strong>情况1：Zig/Zag</strong></p>
<p>如果$x$的父节点$y$是根节点，则只需要进行一次右旋$x$或者左旋$x$即可。也就是说，如果$x$是根节点$y$的左儿子，则执行右旋$x$操作(图1)，否则执行左旋$x$操作(图2)</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210826124514.png" alt="image-20210826124514807"></p>
<p><strong>情况2：Zig-Zig/Zag-Zag</strong></p>
<p>如果$x$的父节点$y$不是根节点，设$z$是$y$的父节点，如果$x$是$y$的左儿子并且$y$是$z$的左儿子，而先进行右旋$y$，再进行右旋$x$(图3)；或者如果$x$是$y$的右儿子并且$y$是$z$的右儿子，而先进行左旋$y$，再进行左旋$x$(图4)</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210826125055.png" alt="image-20210826125055445"></p>
<p><strong>情况3：Zig-Zag/Zag-Zig</strong></p>
<p>如果$x$的父节点$y$不是根节点，设$z$是$y$的父节点，如果$x$是$y$的左儿子并且$y$是$z$的右儿子，则先右旋$x$，再左旋$x$(图5)；或者如果$x$是$y$的右儿子并且$y$是$z$的左儿子，则先右旋$x$，再左旋$x$(图6)</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210826134357.png" alt="image-20210826134357128"></p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将x旋转为goal的儿子</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> goal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//当x还没有旋转成为goal的儿子时  就一直进行</span></span><br><span class="line">    <span class="keyword">while</span>(tr[x].fa!=goal)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y=tr[x].fa;	<span class="comment">//x的父节点是y</span></span><br><span class="line">        <span class="keyword">int</span> z=tr[y].fa;	<span class="comment">//y的父节点是z</span></span><br><span class="line">        <span class="comment">//如果z不是goal 则排除情况一</span></span><br><span class="line">        <span class="comment">//如果(tr[z].ch[1]==y)^(tr[y].ch[1]==x)成立 则说明是情况三</span></span><br><span class="line">        <span class="comment">//如果(tr[z].ch[1]==y)^(tr[y].ch[1]==x)不成立 则说明是情况二</span></span><br><span class="line">        <span class="keyword">if</span>(z!=goal)</span><br><span class="line">            (tr[z].ch[<span class="number">1</span>]==y)^(tr[y].ch[<span class="number">1</span>]==x)?<span class="built_in">rotate</span>(x):<span class="built_in">rotate</span>(y);</span><br><span class="line">        <span class="built_in">rotate</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果goal为0 则表明需要更新根节点为x</span></span><br><span class="line">    <span class="keyword">if</span>(!goal)</span><br><span class="line">        root=x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果$z=goal$，那么就不会进入if的执行体，，而是执行rotate(x)，这与我们的讨论的情况一是对应的。因此这种情况就对应着情况一。</p>
<p><code>tr[z].ch[1]==y</code>判断$y$是否为$z$的右儿子，<code>tr[y].ch[1]==x</code>表示$x$是否为$y$的右儿子。</p>
<ul>
<li>如果$y$为$z$的左儿子，则<code>tr[z].ch[1]==y</code>结果为0，如果$x$为$y$的左儿子，则<code>tr[y].ch[1]==x</code>结果为0。那么<code>0^0=0</code>，那么三目表达式就会执行rotate(y)，最后退出if后，还会执行一次rotate(x)。我们发现这种情况是先旋转$y$，再旋转$x$。而这对应的就是情况二</li>
<li>如果$y$为$z$的左儿子，则<code>tr[z].ch[1]==y</code>结果为0，如果$x$为$y$的右儿子，则<code>tr[y].ch[1]==x</code>结果为1。那么<code>0^1=1</code>，那么三目表达式就会执行rotate(x)，最后退出if后，还会执行一次rotate(x)。我们发现这种情况是先旋转$x$，再旋转$x$。而这对应的就是情况三</li>
<li>如果$y$为$z$的右儿子，则<code>tr[z].ch[1]==y</code>结果为1，如果$x$为$y$的左儿子，则<code>tr[y].ch[1]==x</code>结果为0。那么<code>1^0=1</code>，那么三目表达式就会执行rotate(x)，最后退出if后，还会执行一次rotate(x)。我们发现这种情况是先旋转$x$，再旋转$x$。而这对应的就是情况三</li>
<li>如果$y$为$z$的右儿子，则<code>tr[z].ch[1]==y</code>结果为1，如果$x$为$y$的右儿子，则<code>tr[y].ch[1]==x</code>结果为1。那么<code>1^1=0</code>，那么三目表达式就会执行rotate(y)，最后退出if后，还会执行一次rotate(x)。我们发现这种情况是先旋转$y$，再旋转$x$。而这对应的就是情况二</li>
</ul>
<p>如果goal为0，则表明需要更新根节点为$x$。</p>
<hr>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>与二叉搜索树的插入一样，将$v$插入到伸展树的相应位置，由于新插入了节点，因此需要把这个节点旋转到根，使其成为根的儿子，因此需要执行splay(u,0)。初始时，$u=root$。如果$tr[u].v&lt;v$，则到$u$的右子树中去寻找，否则到$x$的左子树中去寻找。如果$u$的子树不存在，则停止，生成新节点挂到$u$的子树上，然后将插入的节点旋转到树根。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//u是当前节点	p的u的父节点</span></span><br><span class="line">    <span class="keyword">int</span> u=root,p=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//当u还没有遍历到叶子节点时 还存在子树 则一直遍历</span></span><br><span class="line">    <span class="keyword">while</span>(u)</span><br><span class="line">    &#123;</span><br><span class="line">        p=u;	<span class="comment">//记录u的父节点</span></span><br><span class="line">        <span class="comment">//如果tr[u].v&lt;v成立,则结果为1 表明要插入这个节点的值v比当前节点u的值v还大 则说明在右子树</span></span><br><span class="line">        u=tr[u].ch[tr[u].v&lt;v];</span><br><span class="line">    &#125;</span><br><span class="line">    u=++idx;	<span class="comment">//找到了要插入的节点的位置  给它分配一个编号</span></span><br><span class="line">    <span class="comment">//如果p为0 则说明u的父节点就是根节点0 那么就没有必要记录p的信息了</span></span><br><span class="line">    <span class="keyword">if</span>(p)	<span class="comment">//记录一下u的父节点p的信息</span></span><br><span class="line">        tr[p].ch[tr[p].v&lt;v]=u;</span><br><span class="line">    tr[u].<span class="built_in">init</span>(v,p);	<span class="comment">//初始化点u的值和父节点</span></span><br><span class="line">    <span class="comment">//将新插入的这个节点旋转成为根节点0的儿子</span></span><br><span class="line">    <span class="built_in">splay</span>(u,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>Splay</category>
      </categories>
      <tags>
        <tag>Splay</tag>
      </tags>
  </entry>
  <entry>
    <title>最长公共子串</title>
    <url>/2021/08/15/Algorithm-Advanced/Chapter2---Data-Structure/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="最长公共子串"><a href="#最长公共子串" class="headerlink" title="最长公共子串"></a>最长公共子串</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210815213633.png" alt="image-20210815213633720"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>题意：求$n$个字符串的最长公共子串</p>
<p>我们先来考虑暴力解法：</p>
<p>先将第一个字符串$A$去构建好后缀自动机，然后对于第二个字符串$B$，我们先枚举$B$的左端点，从第一个字符开始，然后去SAM中查找，如果存在这个字符，那么就继续第二个字符，存在则继续，假设到第$i+1$个字符时，发现SAM中查找不到了，那么则说明字符串$B$中$1$到$i$的这部分子串是与$A$的最长公共子串了，设此时结果为$x_1$。然后枚举第二个字符为起点，得到结果为$x_2$，一直这样，最终比较$x_1,x_2,\cdots,x_n$的大小，取最大值即可。</p>
<p>我们上面的这种做法就是：当去跑SAM时，假设到了某个状态节点$p$之后没有边了，不能继续跑下去了，那么这趟寻找最长公共子串的过程就结束了。然后我们就会继续枚举B的下一个起始字符，又去跑一遍SAM。</p>
<p>那么，我们有没有一种做法，可以不用让B又回到上一次枚举的位置的下一个字符呢？</p>
<p>如下图分析：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210815221404.png" alt="image-20210815221404684"></p>
<p>由此可见，既然状态节点$p$所表示的字符串中，最长的那个字符串都已经不能成功了， 那么比它小的那个串肯定也不能成功，那么我们就可以必要去考虑这些串了，也就是说我们不一定每次都要回到前面的某个位置又开始去匹配，而是可以考虑从某个特定位置去匹配。</p>
<p>那么状态节点$p$中怎样才能可以接上$c$呢？由于$t_2$是$t_1$去掉首字符得到的，因此如果$t_1$不能接上$c$，那么$t_2$大概率不能接上$c$，以此类推分析可知，假设$t_3$是状态节点$p$中的最短串，那么$t_3$去掉首字符后所得到的串，是最有可能产生质变的，这时候是可以接上$c$的。也就是说，我们最应该考虑的就是$p$中的最短串。</p>
<p>那么我们联想到后缀链接的本质可以知道，某个状态节点$x$的后缀链接，其实就是寻找状态节点$x$所表示的字符串中最短的那个串，然后去掉其首字符，得到一个字符串$str$，然后我们看哪个状态节点所形成的字符串中是含有字符串$str$的，那么状态节点$x$的后缀链接就指向这个节点。  那么这个性质不就刚好与我们上面的一致嘛？我们上面的想法是下一次枚举时，就尽量去枚举当前状态节点$x$所表示的字符串中最短的那个串去掉首字符后所形成的新串$str$，把它当作枚举的起点。</p>
<p>因此，这就启发我们，当在$p$后面不能接$c$时，我们下次枚举的起点应该是从$p$的后缀链接节点开始枚举，而不是又去从前面开始枚举了。感觉这其实和KMP有点类似hhh</p>
<p>如下图所示，我们来感性认识一下上面提到的这个后缀链接的性质：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210816010947.png" alt="image-20210816010947913"></p>
<p>如图，状态节点6所代表的字符串有{$bab$，$abab$，$aabab$}，其中最短的串为$bab$，去掉首字符后得到的新串为$ab$，然后我们发现状态节点$7$是包含这个新串的，而且可以发现状态节点6的后缀链接确实是连向了状态节点7。</p>
<p>这里来解释一下这段代码是啥意思：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;str[j];j++)</span><br><span class="line">&#123;</span><br><span class="line">    now[p] = <span class="built_in">max</span>(now[p], t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里其实是处理单个字符串的，比如这里是处理B串，对于新来的一个字符$str[j]$，我们去SAM中看有没有可以接上它的，假设是状态节点$p$，<code>now[p]</code>就表示B串此刻在SAM中与A串匹配的最长公共子串的长度。然后能接上$str[j]$的状态节点$p$可能有多个，因此我们取最大的那个，所以这里是$max$操作</p>
<p>再来看这一段代码的意思：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot; j ++ ) ans[j] = <span class="built_in">min</span>(ans[j], now[j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里其实是处理多个字符串的。假设有$B,C,D$这三个字符串，它们在跑SAM时，所对应的某个状态节点$p$的now值分别为$now_1[p]=3$，$now_2[p]=4$，$num_3[p]=5$。那么对于这三个串，考虑这个状态节点$p$，我们应该取哪个now值呢？很明显，应该取最小的$now_1[p]=3$。因为$now_1[p]$一定是$now_2[p]$的子集，因此$now_1[p]$中有的，那么$now_2[p]$中也一定都有；但是$now_2[p]$中有的，$now_1[p]$中却不一定有，如果我们选择较长的$now_2[p]$，那么就不能保证最长公共子串了（因为$now_1[p]$中没有$now_2[p]$含有的字符）。因此，这里是$min$操作。而且这里是对于SAM中的每个状态节点，处理多个字符串时，都是取$min$操作</p>
<p>最后再来看这一段代码的意思：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i ++ ) res = <span class="built_in">max</span>(res, ans[i]);</span><br></pre></td></tr></table></figure>
<p>这里其实也是处理多个字符串的。上面的那一段代码我们是综合考虑了所有串在状态节点$p$的取值。但是SAM中有多个状态节点，假设在上一段代码中我们求出了$p_1$所对应的为$x_1$，$p_2$所对应的为$x_2$，$\cdots$，那么我们现在就应该来考虑$x_1,x_2\cdots,x_n$中哪个是最大的呢？然后选取最大的那个，那么就是这些字符串的最长公共子串的长度了。因此这里是遍历SAM中的所有状态节点，选择最大的那个<code>ans[]</code>。因此，这里是取$max$操作</p>
<p>这里还有一个关键的地方容易忽略，就是比如状态节点$p$所表示的串为$cba$，状态节点$q$所表示的串为$dba$，虽然它们不是最长公共子串，但是它俩中的后缀$ba$是相同，因此我们要把状态节点$p$所表示的串的信息传递给它的后缀$ba$，同理也要把状态节点$q$所表示的串的信息传递给它的后缀$ba$。那么我们该如何将p串的信息传递给它的后缀呢？这在SAM中其实可以把p串理解为子节点，它的后缀看作是p串后缀链接后的父节点。我们可以把含有后缀链接的边建立出来，然后我们是从p串后缀向p中连一条有向边，为什么呢？因为这样当我们dfs到叶子节点时，我们就会把叶子节点的信息传递给其父节点，而我们建图时叶子节点其实也就是p串，其父节点其实也就是p串的后缀，回溯时将叶子节点的信息传递给其父节点，也就是将p串的信息传递给了p串的后缀。因此是正确的。</p>
<p>这就是下面这段代码的意思：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= tot; i ++ ) <span class="built_in">add</span>(node[i].fa, i);</span><br></pre></td></tr></table></figure>
<p>下面解释这段代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i ++ ) ans[i] = node[i].len;</span><br><span class="line">now[u] = <span class="built_in">max</span>(now[u], now[e[i]]);</span><br></pre></td></tr></table></figure>
<p>要注意，p串传递的信息的长度可以会超过p串后缀的长度，因此要选择最长的那个，不然容易丢失信息。</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">20010</span>,M=N;</span><br><span class="line"><span class="comment">//tot记录的是后缀自动机中的状态节点 初始化为根节点1</span></span><br><span class="line"><span class="comment">//last记录的是上一个状态节点</span></span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">1</span>, last = <span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> len;    <span class="comment">//记录这个状态节点所形成的串中最大的那个串的长度</span></span><br><span class="line">    <span class="keyword">int</span> link;   <span class="comment">//后缀链接</span></span><br><span class="line">    <span class="keyword">int</span> ch[<span class="number">26</span>]; <span class="comment">//类似于trie树中的孩子</span></span><br><span class="line">&#125;node[N];</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> ans[N],now[N];</span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后缀自动机模板</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">extend</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//先用p来记录上一个状态节点</span></span><br><span class="line">    <span class="comment">//然后由于来了一个字符c,需要进行状态转移了</span></span><br><span class="line">    <span class="comment">// 因此给转移后得到的节点np分配一个编号tot</span></span><br><span class="line">    <span class="keyword">int</span> p = last, np = last = ++ tot;</span><br><span class="line">    <span class="comment">//由于np是从p通过新添一个字符c转移过去的  因此长度+1</span></span><br><span class="line">    node[np].len = node[p].len + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//沿着p的后缀链接遍历节点  如果遍历到的节点p它没有孩子c</span></span><br><span class="line">    <span class="comment">//则要创建出来  让np连一条后缀链接边到node[p].ch[c]就相当于</span></span><br><span class="line">    <span class="comment">//该节点p通过字符c转移到了np</span></span><br><span class="line">    <span class="keyword">for</span> (; p &amp;&amp; !node[p].ch[c];p = node[p].link)</span><br><span class="line">        node[p].ch[c] = np;</span><br><span class="line">    <span class="comment">//沿着后缀链接一直来到了根节点  仍然没有发现</span></span><br><span class="line">    <span class="comment">//那么np的后缀链接就是根节点</span></span><br><span class="line">    <span class="keyword">if</span> (!p)</span><br><span class="line">        node[np].link = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> q = node[p].ch[c];  <span class="comment">//找到状态节点p的c孩子节点 q</span></span><br><span class="line">        <span class="comment">//np沿着后缀链接找到了q 发现q中有np想要的串 能够进行后缀邻接</span></span><br><span class="line">        <span class="comment">//那么此时nq就可以引出一条后缀链接边到q</span></span><br><span class="line">        <span class="keyword">if</span> (node[q].len == node[p].len + <span class="number">1</span>)</span><br><span class="line">            node[np].link = q;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//将q一分为二 变成q 和 nq</span></span><br><span class="line">            <span class="keyword">int</span> nq = ++ tot;</span><br><span class="line">            <span class="comment">//nq是q克隆出来了  但是nq包含了从q中抽离出来的能够让np进行后缀链接的串</span></span><br><span class="line">            node[nq] = node[q], node[nq].len = node[p].len + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//分裂前的q引一条后缀链接边到nq</span></span><br><span class="line">            <span class="comment">//从新开的状态节点np引一条后缀链接边到nq</span></span><br><span class="line">            node[q].link = node[np].link = nq;</span><br><span class="line">            <span class="comment">//沿着p的后缀链接一直往回走 将所遍历到的节点 都 引一条后缀链接边到nq</span></span><br><span class="line">            <span class="keyword">for</span> (; p &amp;&amp; node[p].ch[c] == q; p = node[p].link)</span><br><span class="line">                node[p].ch[c] = nq;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v=e[i];</span><br><span class="line">        <span class="built_in">dfs</span>(v);</span><br><span class="line">        <span class="comment">//回溯时将u串的信息传递给其后缀v</span></span><br><span class="line">        now[u]=<span class="built_in">max</span>(now[u],now[v]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//将第一个串去构建后缀自动机</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; str[i]; i ++ ) </span><br><span class="line">        <span class="built_in">extend</span>(str[i] - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    <span class="comment">//初始化每个状态节点的答案为其长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i ++ ) </span><br><span class="line">        ans[i] = node[i].len;</span><br><span class="line">    <span class="comment">//这里是从i=2开始  因此i=2的link是根节点1 所以从2开始就可以了</span></span><br><span class="line">    <span class="comment">//从后缀链接的那个节点node[i].link向节点i连一条有向边</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= tot; i ++ ) </span><br><span class="line">        <span class="built_in">add</span>(node[i].link, i);</span><br><span class="line">    <span class="comment">//读入剩下的n-1个串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">memset</span>(now, <span class="number">0</span>, <span class="keyword">sizeof</span> now);</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">1</span>, t = <span class="number">0</span>;   <span class="comment">//t是长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; str[j]; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> c = str[j] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="comment">//当沿着后缀链接还没有走到根节点</span></span><br><span class="line">            <span class="comment">//并且状态节点p所表示的串中后面不能接上字符c时</span></span><br><span class="line">            <span class="keyword">while</span> (p &gt; <span class="number">1</span> &amp;&amp; !node[p].ch[c]) </span><br><span class="line">            &#123;</span><br><span class="line">                p = node[p].link;   <span class="comment">//沿着后缀链接一直往前走</span></span><br><span class="line">                t = node[p].len;    <span class="comment">//更新此时最长公共串的长度</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//退出循环时 特判如果node[p].ch[c]不为0</span></span><br><span class="line">            <span class="comment">//则在状态节点p所表示的串中接上字符c</span></span><br><span class="line">            <span class="keyword">if</span> (node[p].ch[c])</span><br><span class="line">            &#123;</span><br><span class="line">                p = node[p].ch[c];  <span class="comment">//新添了一个字符 p转移到下一个状态节点node[p].ch[c]</span></span><br><span class="line">                t++;    <span class="comment">//长度+1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//取每个状态节点中的最大值</span></span><br><span class="line">            now[p] = <span class="built_in">max</span>(now[p], t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从根节点1开始进行深搜遍历这颗后缀链接树</span></span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//选择所有的这些串中关于状态节点p的最小的那个长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot; j ++ ) </span><br><span class="line">            ans[j] = <span class="built_in">min</span>(ans[j], now[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;    <span class="comment">//这些串的最长公共子串的长度</span></span><br><span class="line">    <span class="comment">//遍历所有状态节点  选择能够取到最大值的那个状态节点p</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i ++ ) </span><br><span class="line">        res = <span class="built_in">max</span>(res, ans[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>后缀自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>玄武密码</title>
    <url>/2021/08/15/Algorithm-Advanced/Chapter2---Data-Structure/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/%E7%8E%84%E6%AD%A6%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<h1 id="玄武密码"><a href="#玄武密码" class="headerlink" title="玄武密码"></a>玄武密码</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><a href="https://www.luogu.com.cn/problem/P5231">洛谷P5231</a></p>
<p>题意：给你一个母串$T$，然后$m$个匹配串$S_i$，求 $T$ 对于$S_i$能匹配的最长前缀长度</p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>这题可以使用SAM来解决，这是因为SAM有个最简单、也最重要的性质：</p>
<p>它包含关于字符串$s$的所有子串的信息。任意从初始状态$t_0$开始的路径，如果我们将转移路径上的标号写下来，都会形成$s$ 的一个子串 。反之每个$s$的子串对应从$t_0$开始的某条路径。</p>
<p>有了这个性质之后，那么对于这道题，我们就可以得到这个：从$t_0$出发的每一条路径都是某个后缀的前缀。</p>
<p>先对母串$T$建立一个后缀自动机，然后对于每个匹配串$S_i$，我们从SAM的起始状态点$t_0$出发，然后如果它转移后得到的一个状态节点是$S_i$中的一个字符，则可以走过去，并且匹配长度res+1。如果它不能转移过去得到$S_i$中的一个字符，那么直接退出，说明后面的也都是不能匹配的。</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e7</span>+<span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> len;    <span class="comment">//记录这个状态节点所形成的串中最大的那个串的长度</span></span><br><span class="line">    <span class="keyword">int</span> link;   <span class="comment">//后缀链接</span></span><br><span class="line">    <span class="keyword">int</span> ch[<span class="number">4</span>];   <span class="comment">//类似于trie树中的孩子</span></span><br><span class="line">&#125;node[N];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="comment">//tot记录的是后缀自动机中的状态节点 初始化为根节点1</span></span><br><span class="line"><span class="comment">//last记录的是上一个状态节点</span></span><br><span class="line"><span class="keyword">int</span> tot=<span class="number">1</span>,last=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//映射  将字符c转成整数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="string">&#x27;E&#x27;</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;S&#x27;</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;W&#x27;</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span>    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SAM模板</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">extend</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p=last,np=last=++tot;</span><br><span class="line">    node[np].len=node[p].len+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;p&amp;&amp;!node[p].ch[c];p=node[p].link)</span><br><span class="line">        node[p].ch[c]=np;</span><br><span class="line">    <span class="keyword">if</span>(!p)</span><br><span class="line">        node[np].link=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> q=node[p].ch[c];</span><br><span class="line">        <span class="keyword">if</span>(node[q].len==node[p].len+<span class="number">1</span>)</span><br><span class="line">            node[np].link=q;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> nq=++tot;</span><br><span class="line">            node[nq]=node[q],node[nq].len=node[p].len+<span class="number">1</span>;</span><br><span class="line">            node[q].link=node[np].link=nq;</span><br><span class="line">            <span class="keyword">for</span>(;q&amp;&amp;node[p].ch[c]==q;p=node[p].link)</span><br><span class="line">                node[p].ch[c]=nq;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//对这个母串构建后缀自动机</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> c=<span class="built_in">get</span>(str[i]);</span><br><span class="line">        <span class="built_in">extend</span>(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读入这m段文字</span></span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//初始时从SAM的起点1出发  答案为0</span></span><br><span class="line">        <span class="keyword">int</span> p=<span class="number">1</span>,res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;str[i];i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> c=<span class="built_in">get</span>(str[i]);</span><br><span class="line">            <span class="comment">//如果状态节点p有node[p].ch[c]这个子节点 则可以走过去</span></span><br><span class="line">            <span class="keyword">if</span>(node[p].ch[c])</span><br><span class="line">            &#123;</span><br><span class="line">                p=node[p].ch[c];</span><br><span class="line">                <span class="comment">//从状态节点p通过一个字符c转移得到了状态节点node[p].ch[c]</span></span><br><span class="line">                <span class="comment">//因此又多匹配了一个字符</span></span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//否则说明在匹配一个字符的话 就已经失配了 那么上一个匹配到的就是最大匹配串长度了</span></span><br><span class="line">            <span class="comment">//接下来往后走也是不匹配  那么就没有必要继续往后走了  因此直接break</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出这一段文字的前缀与母串的最大匹配串长度</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>后缀自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>一个简单的整数问题2--分块算法</title>
    <url>/2021/08/16/Algorithm-Advanced/Chapter2---Data-Structure/%E5%88%86%E5%9D%97/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B4%E6%95%B0%E9%97%AE%E9%A2%982-%E5%88%86%E5%9D%97%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="一个简单的整数问题2—分块算法"><a href="#一个简单的整数问题2—分块算法" class="headerlink" title="一个简单的整数问题2—分块算法"></a>一个简单的整数问题2—分块算法</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210816213534.png" alt="image-20210816213534080"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>这题可以采用分块思想，如果想要了解分块思想，请移步这篇文章<a href="https://blog.csdn.net/qq_45832461/article/details/119741669">分块基本思想</a></p>
<p>具体思想详见注释</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="comment">//a数组是存储每个数的序列 add[i]+=d表示将第i块中的所有数都+d 这是一个懒标记</span></span><br><span class="line"><span class="comment">//sum[i]记录的是第i块中所有数的总和</span></span><br><span class="line">LL a[N],add[N],sum[N];</span><br><span class="line"><span class="comment">//p=pos[i]表示下标i所在的块是第p块</span></span><br><span class="line"><span class="comment">//L[i]记录的是第i块的左端点   R[i]记录的是第i块的右端点</span></span><br><span class="line"><span class="keyword">int</span> pos[N],L[N],R[N];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="comment">//预处理</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t= <span class="built_in">sqrt</span>(n*<span class="number">1.0</span>); <span class="comment">//t表示每个块内的长度(即元素个数)</span></span><br><span class="line">    <span class="keyword">int</span> num=n/t;    <span class="comment">//num记录的是有多少个块</span></span><br><span class="line">    <span class="comment">//这里处理的是最后剩余的那一小部分 让它自己成为独立的一块</span></span><br><span class="line">    <span class="comment">//比如n=10,t=3,那么分成n/t=10/3=3块后，我们发现第10个并不属于前面的3块</span></span><br><span class="line">    <span class="comment">//因此它必须新开一个块</span></span><br><span class="line">    <span class="keyword">if</span>(n%t)</span><br><span class="line">        num++;</span><br><span class="line">    <span class="comment">//分别处理这num个块的左端点和右端点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;i++) <span class="comment">//i遍历的是块号</span></span><br><span class="line">    &#123;</span><br><span class="line">        L[i]=(i<span class="number">-1</span>)*t+<span class="number">1</span>; <span class="comment">//第i块的左端点</span></span><br><span class="line">        R[i]=i*t;   <span class="comment">//第i块的右端点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里要注意 当上面处理完第num块时 R[num]是按照长度为t进行分配的右端点</span></span><br><span class="line">    <span class="comment">//但是这个右端点有可能比n还大 然而我们只需要处理到n就可以了</span></span><br><span class="line">    <span class="comment">//因此这里还要特殊处理最后一段的右端点 取到n即可 不一定取最后一段分配到的右端点</span></span><br><span class="line">    R[num]=n;</span><br><span class="line">    <span class="comment">//遍历这num个块 预处理出下标j是属于哪个块  同时预处理出这个块内的总和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;i++) <span class="comment">//i遍历的是块</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=L[i];j&lt;=R[i];j++)<span class="comment">//j遍历的是这个块的元素</span></span><br><span class="line">        &#123;</span><br><span class="line">            pos[j]=i;   <span class="comment">//下标j所对应的元素应该属于块号i</span></span><br><span class="line">            sum[i]+=a[j];   <span class="comment">//记录第i块的元素总和</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//区间修改  将区间[l,r]中的元素都+d</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p=pos[l];   <span class="comment">//获取下标l所在的块号p</span></span><br><span class="line">    <span class="keyword">int</span> q=pos[r];   <span class="comment">//获取下标r所在的块号q</span></span><br><span class="line">    <span class="comment">//如果区间[l,r]在同一个块内</span></span><br><span class="line">    <span class="keyword">if</span>(p==q)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//直接将区间[l,r]内的所有元素都+d</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++)</span><br><span class="line">            a[i]+=d;</span><br><span class="line">        sum[p]+=(r-l+<span class="number">1</span>)*d;  <span class="comment">//记录第p块内的所有元素的总和</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则说明区间[l,r]跨越了不同的块</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//先处理中间被完全覆盖的块 让这些块的懒标记都+d</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=p+<span class="number">1</span>;i&lt;=q<span class="number">-1</span>;i++)<span class="comment">//i枚举的中间被完全覆盖的块号</span></span><br><span class="line">            add[i]+=d;</span><br><span class="line">        <span class="comment">//处理左边剩余部分 将区间[l,R[p]]内的所有元素都+d</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=R[p];i++)</span><br><span class="line">            a[i]+=d;</span><br><span class="line">        sum[p]+=(R[p]-l+<span class="number">1</span>)*d;   <span class="comment">//记录左边剩余部分的所有元素的总和</span></span><br><span class="line">        <span class="comment">//处理右边剩余部分 将区间[L[q],r]内的所有元素都+d</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=L[q];i&lt;=r;i++)</span><br><span class="line">            a[i]+=d;</span><br><span class="line">        sum[q]+=(r-L[q]+<span class="number">1</span>)*d;   <span class="comment">//记录右边剩余部分的所有元素的总和</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//区间查询</span></span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p=pos[l];   <span class="comment">//获取下标l所在的块号p</span></span><br><span class="line">    <span class="keyword">int</span> q=pos[r];   <span class="comment">//获取下标r所在的块号q</span></span><br><span class="line">    LL ans=<span class="number">0</span>;   <span class="comment">//记录区间[l,r]中的元素总和</span></span><br><span class="line">    <span class="comment">//如果区间[l,r]在同一个块内</span></span><br><span class="line">    <span class="keyword">if</span>(p==q)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//累加这个区间[l,r]中所有元素的总和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++)</span><br><span class="line">            ans+=a[i];</span><br><span class="line">        ans+=(r-l+<span class="number">1</span>)*add[p];    <span class="comment">//同时要记得加上第p块中的懒标记</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则说明区间[l,r]跨越了不同的块</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//先累加中间被完全覆盖的这些块的懒标记</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=p+<span class="number">1</span>;i&lt;=q<span class="number">-1</span>;i++)   <span class="comment">//i遍历的是中间被完全覆盖的这些块的块号</span></span><br><span class="line">            ans+=sum[i]+(R[i]-L[i]+<span class="number">1</span>)*add[i];</span><br><span class="line">        <span class="comment">//累加左边剩余部分的所有元素的总和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=R[p];i++)</span><br><span class="line">            ans+=a[i];</span><br><span class="line">        <span class="comment">//累加左侧剩余部分的第p块中的懒标记</span></span><br><span class="line">        ans+=(R[p]-l+<span class="number">1</span>)*add[p];</span><br><span class="line">        <span class="comment">//累加左=右边剩余部分的所有元素的总和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=L[q];i&lt;=r;i++)</span><br><span class="line">            ans+=a[i];</span><br><span class="line">        <span class="comment">//累加右侧剩余部分的第q块中的懒标记</span></span><br><span class="line">        ans+=(r-L[q]+<span class="number">1</span>)*add[q];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans; <span class="comment">//返回答案</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="built_in">init</span>();     <span class="comment">//预处理</span></span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> l,r,d;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>,op,&amp;l,&amp;r);</span><br><span class="line">        <span class="keyword">if</span>(*op==<span class="string">&#x27;C&#x27;</span>)    <span class="comment">//区间修改</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;d);</span><br><span class="line">            <span class="built_in">change</span>(l,r,d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>        <span class="comment">//区间查询</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">query</span>(l,r));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>分块</category>
      </categories>
      <tags>
        <tag>分块之基本思想</tag>
      </tags>
  </entry>
  <entry>
    <title>飞行员配对方案问题</title>
    <url>/2021/08/06/Algorithm-Advanced/Chapter1---Gragh-Theory/%E6%9C%80%E5%A4%A7%E6%B5%81%E4%B9%8B%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/%E9%A3%9E%E8%A1%8C%E5%91%98%E9%85%8D%E5%AF%B9%E6%96%B9%E6%A1%88%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="飞行员配对方案问题"><a href="#飞行员配对方案问题" class="headerlink" title="飞行员配对方案问题"></a>飞行员配对方案问题</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210806121131.png" alt="image-20210806121131016"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>题意：求二分图的最大匹配并且输出任意一个匹配方案</p>
<p>这个题可以直接用匈牙利算法来求解，时间复杂度是$O(nm)$。但是也可以用网络流来求解，时间复杂度是$O(m\sqrt n)$，可见使用网络流算法后，效率大大增加了。</p>
<p>结论：</p>
<ul>
<li>网络流中的某一条可行流 对应着 二分图中的一组匹配</li>
<li>网络流中的最大流 对应着  二分图的最大匹配</li>
</ul>
<p>因此，我们想要求出二分图的最大匹配，那么就可以使用Dinic算法来求出这个网络的最大流。</p>
<p>那么，我们来思考一下该怎么构建这张网络图呢？</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210806122021.png" alt="image-20210806122021585"></p>
<p>那么我们该怎么输出匹配方案呢？</p>
<p>我们可以遍历所有的正向边，如果发现边的容量为$0$，那么说明这个边被用到了，构成了一组方案。具体就是枚举正向边，如果这条正向边的终点编号是<code>[m+1,n]</code>，则说明这条正向边是外籍飞行员点集和英国飞行员点集之间的一条边，然后我们判断这条边的容量$f[i]$是否为0，如果为0，则说明它是一条匹配边，那么我们输出这条匹配边的起点e[i^1]，这条匹配边的终点e[i]即可。</p>
<p>注意：边数的计算，最坏情况是左侧点集为$50$，右侧点集为$50$，那么会有$50\times 50=2500$条边，由于网络图需要建立反向边，因此需要开2倍，即$2500\times2=5000$，然后从源点$S$向左侧这$50$个点需要连边$50$，同理从右侧这$50$个点向汇点$T$需要连边$50$，由于需要建立反向边，因此是$(50+50)\times2=200$，因此总共需要边数为$5000+200=5200$。</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>网络流Dinic算法求解二分图最大匹配：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">110</span>,M=<span class="number">5210</span>,INF=<span class="number">1e8</span>;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],f[M],idx;</span><br><span class="line"><span class="keyword">int</span> q[N],d[N],cur[N];</span><br><span class="line"><span class="keyword">int</span> n,m,S,T;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b,f[idx]=c,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">    e[idx]=a,f[idx]=<span class="number">0</span>,ne[idx]=h[b],h[b]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">    q[<span class="number">0</span>]=S,d[S]=<span class="number">0</span>,cur[S]=h[S];</span><br><span class="line">    <span class="keyword">while</span>(hh&lt;=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=q[hh++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> ver=e[i];</span><br><span class="line">            <span class="keyword">if</span>(d[ver]==<span class="number">-1</span>&amp;&amp;f[i])</span><br><span class="line">            &#123;</span><br><span class="line">                d[ver]=d[t]+<span class="number">1</span>;</span><br><span class="line">                cur[ver]=h[ver];</span><br><span class="line">                <span class="keyword">if</span>(ver==T)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                q[++tt]=ver;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==T)</span><br><span class="line">        <span class="keyword">return</span> limit;</span><br><span class="line">    <span class="keyword">int</span> flow=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=cur[u];~i&amp;&amp;flow&lt;limit;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        cur[u]=i;</span><br><span class="line">        <span class="keyword">int</span> ver=e[i];</span><br><span class="line">        <span class="keyword">if</span>(d[ver]==d[u]+<span class="number">1</span>&amp;&amp;f[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t=<span class="built_in">find</span>(ver,<span class="built_in">min</span>(f[i],limit-flow));</span><br><span class="line">            <span class="keyword">if</span>(!t)</span><br><span class="line">                d[ver]=<span class="number">-1</span>;</span><br><span class="line">            f[i]-=t;</span><br><span class="line">            f[i^<span class="number">1</span>]+=t;</span><br><span class="line">            flow+=t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxflow=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> flow;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(flow=<span class="built_in">find</span>(S,INF))</span><br><span class="line">            maxflow+=flow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxflow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;m,&amp;n);</span><br><span class="line">    <span class="comment">//由于左侧点集编号是[1,m] 右侧点集编号是[m+1,n]</span></span><br><span class="line">    <span class="comment">//所以给源点和汇点的编号都不能存在于左侧点集和右侧点集中</span></span><br><span class="line">    S=<span class="number">0</span>,T=n+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//从源点S向左侧点集连一条容量为1的有向边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="built_in">add</span>(S,i,<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//从右侧点集向汇点T连一条容量为1的有向边    </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=m+<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">add</span>(i,T,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="comment">//从左侧点集向右侧点集连一条容量为1的有向边 </span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b),a!=<span class="number">-1</span>&amp;&amp;b!=<span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">add</span>(a,b,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">dinic</span>());</span><br><span class="line">    <span class="comment">//遍历所有的正向边  找到那些属于左侧点集和右侧点集之间的匹配边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;idx;i+=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(e[i]&gt;m&amp;&amp;e[i]&lt;=n&amp;&amp;!f[i])</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,e[i^<span class="number">1</span>],e[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>匈牙利算法求解二分图最大匹配：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">110</span>,M=<span class="number">5210</span>;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="keyword">int</span> match[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="keyword">int</span> n,m,S,T;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];~i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v=e[i];</span><br><span class="line">        <span class="keyword">if</span>(!st[v])</span><br><span class="line">        &#123;</span><br><span class="line">            st[v]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(!match[v]||<span class="built_in">find</span>(match[v]))</span><br><span class="line">            &#123;</span><br><span class="line">                match[v]=u;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;m,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b),a!=<span class="number">-1</span>&amp;&amp;b!=<span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">add</span>(a,b);</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(st,<span class="number">0</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(i))</span><br><span class="line">            res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=m+<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(match[i])</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,match[i],i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>网络流</category>
      </categories>
      <tags>
        <tag>网络流求二分图的最大匹配</tag>
      </tags>
  </entry>
  <entry>
    <title>分块之基本思想</title>
    <url>/2021/08/16/Algorithm-Advanced/Chapter2---Data-Structure/%E5%88%86%E5%9D%97/%E5%88%86%E5%9D%97%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3/</url>
    <content><![CDATA[<h1 id="分块之基本思想"><a href="#分块之基本思想" class="headerlink" title="分块之基本思想"></a>分块之基本思想</h1><hr>
<h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>树状数组和线段树虽然非常方便，但是它们维护的信息都必须满足信息合并特性（区间可加、可减），若补满足此特性，则不能用树状数组和线段树来做。分块算法可以维护一些线段树维护不了的内容，它其实就是优化过后的暴力算法。分块算法可以解决几乎所有区间更新和区间查询问题，但是效率相对于树状数组和线段树要差一些。</p>
<p>分块算法是将所有数据都分成若干个块，维护块内信息，使得块内查询为$O(1)$的时间，而总询问可以被看作若干块询问的总和。</p>
<p>分块算法将长度为$n$的序列分成若干个块，每一块都有$t$个元素，最后一块可能少于$t$个元素。为了使时间复杂度均摊，通常将块的大小设定为$t=\sqrt n$。用<code>pos[i]</code>来表示第$i$个位置所属的块，对每个块都进行信息维护。</p>
<p>分开算法可以解决以下问题：</p>
<ul>
<li>单点更新：一般先将对应块的懒标记下传，再暴力更新块的状态，时间复杂度为$O(\sqrt n)$</li>
<li>区间更新：如果更新的区间横跨若干个块，则只需要对中间完全被覆盖的块打上懒标记，然后对两端剩余部分暴力更新其所属块的状态。每次更新都最多遍历$\sqrt n$个块，遍历每个块的时间复杂度都是$O(1)$，两端的两个块暴力更新$\sqrt n$次。总的时间复杂度是$O(\sqrt n)$</li>
<li>区间修改：和区间更新类似，对中间跨过的整个块直接利用块存储的信息统计答案，对两端剩余的部分可以暴力扫描统计。总的时间复杂度是$O(\sqrt n)$</li>
</ul>
<p>将整个序列分成若干块后进行修改或查询时，对完全覆盖的块直接进行修改，像线段树一样标记或累加；对两端剩余的部分进行暴力修改。分块算法遵循 <strong>大段维护，局部朴素</strong> 的原则。</p>
<hr>
<h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>（1）将序列分块，然后将每个块都标记左右端点$L[i]$和$R[i]$，对最后一块的右端点需要特别处理。</p>
<p>如下图所示，$n=10$，$t=\sqrt n=3$，每3个元素为一块，那么已经处理了9个元素。但是第10个元素还没有自己的块，因此需要新开一个块来存放第10个元素。因此总共有$num=4$个块</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210816203458.png" alt="image-20210816203458800"></p>
<p><strong>算法代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> t= <span class="built_in">sqrt</span>(n*<span class="number">1.0</span>); <span class="comment">//t表示每个块内的长度(即元素个数)</span></span><br><span class="line">    <span class="keyword">int</span> num=n/t;    <span class="comment">//num记录的是有多少个块</span></span><br><span class="line">    <span class="comment">//这里处理的是最后剩余的那一小部分 让它自己成为独立的一块</span></span><br><span class="line">    <span class="comment">//比如n=10,t=3,那么分成n/t=10/3=3块后，我们发现第10个并不属于前面的3块</span></span><br><span class="line">    <span class="comment">//因此它必须新开一个块</span></span><br><span class="line">    <span class="keyword">if</span>(n%t)</span><br><span class="line">        num++;</span><br><span class="line">    <span class="comment">//分别处理这num个块的左端点和右端点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;i++) <span class="comment">//i遍历的是块号</span></span><br><span class="line">    &#123;</span><br><span class="line">        L[i]=(i<span class="number">-1</span>)*t+<span class="number">1</span>; <span class="comment">//第i块的左端点</span></span><br><span class="line">        R[i]=i*t;   <span class="comment">//第i块的右端点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里要注意 当上面处理完第num块时 R[num]是按照长度为t进行分配的右端点</span></span><br><span class="line">    <span class="comment">//但是这个右端点有可能比n还大 然而我们只需要处理到n就可以了</span></span><br><span class="line">    <span class="comment">//因此这里还要特殊处理最后一段的右端点 取到n即可 不一定取最后一段分配到的右端点</span></span><br><span class="line">    R[num]=n;</span><br></pre></td></tr></table></figure>
<p>（2）用<code>pos[]</code>标记每个元素所属的块，用<code>sum[]</code>累加每一块的总和</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210816203520.png" alt="image-20210816203520043"></p>
<p>算法代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//遍历这num个块 预处理出下标j是属于哪个块  同时预处理出这个块内的总和</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;i++) <span class="comment">//i遍历的是块</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=L[i];j&lt;=R[i];j++)<span class="comment">//j遍历的是这个块的元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        pos[j]=i;   <span class="comment">//下标j所对应的元素应该属于块号i</span></span><br><span class="line">        sum[i]+=a[j];   <span class="comment">//记录第i块的元素总和</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>预处理的算法代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//预处理</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t= <span class="built_in">sqrt</span>(n*<span class="number">1.0</span>); <span class="comment">//t表示每个块内的长度(即元素个数)</span></span><br><span class="line">    <span class="keyword">int</span> num=n/t;    <span class="comment">//num记录的是有多少个块</span></span><br><span class="line">    <span class="comment">//这里处理的是最后剩余的那一小部分 让它自己成为独立的一块</span></span><br><span class="line">    <span class="comment">//比如n=10,t=3,那么分成n/t=10/3=3块后，我们发现第10个并不属于前面的3块</span></span><br><span class="line">    <span class="comment">//因此它必须新开一个块</span></span><br><span class="line">    <span class="keyword">if</span>(n%t)</span><br><span class="line">        num++;</span><br><span class="line">    <span class="comment">//分别处理这num个块的左端点和右端点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;i++) <span class="comment">//i遍历的是块号</span></span><br><span class="line">    &#123;</span><br><span class="line">        L[i]=(i<span class="number">-1</span>)*t+<span class="number">1</span>; <span class="comment">//第i块的左端点</span></span><br><span class="line">        R[i]=i*t;   <span class="comment">//第i块的右端点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里要注意 当上面处理完第num块时 R[num]是按照长度为t进行分配的右端点</span></span><br><span class="line">    <span class="comment">//但是这个右端点有可能比n还大 然而我们只需要处理到n就可以了</span></span><br><span class="line">    <span class="comment">//因此这里还要特殊处理最后一段的右端点 取到n即可 不一定取最后一段分配到的右端点</span></span><br><span class="line">    R[num]=n;</span><br><span class="line">    <span class="comment">//遍历这num个块 预处理出下标j是属于哪个块  同时预处理出这个块内的总和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;i++) <span class="comment">//i遍历的是块</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=L[i];j&lt;=R[i];j++)<span class="comment">//j遍历的是这个块的元素</span></span><br><span class="line">        &#123;</span><br><span class="line">            pos[j]=i;   <span class="comment">//下标j所对应的元素应该属于块号i</span></span><br><span class="line">            sum[i]+=a[j];   <span class="comment">//记录第i块的元素总和</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="区间更新"><a href="#区间更新" class="headerlink" title="区间更新"></a>区间更新</h3><p>区间更新，例如将区间$[l,r]$内的元素都加上$d$</p>
<ol>
<li>求$l$和$r$所属的块，即$p=pos[l]$，$q=pos[r]$</li>
<li>如果属于同一个块($p=q$)，则对该区间的元素进行暴力修改，同时更新该块的和值</li>
<li>如果不属于同一个块，则对中间被完全覆盖的块都打上懒标记，$add[i]+=d$，对首尾两端的剩余部分进行暴力修改。</li>
</ol>
<p>例如下图，将区间$[3,8]$内的元素都加上5，操作过程：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210816203544.png" alt="image-20210816203544411"></p>
<ul>
<li>读取$3$和$8$所属的块，$p=pos[3]=1$，$q=pos[8]=3$</li>
<li>不属于同一个块，中间完整块$[p+1,q-1]$为第2块，为该块打上懒标记$add[2]+=5$</li>
<li>对首尾两端剩余部分的元素（下标3，7，8）进行暴力修改，并修改和值</li>
</ul>
<p>算法代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//区间修改  将区间[l,r]中的元素都+d</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p=pos[l];   <span class="comment">//获取下标l所在的块号p</span></span><br><span class="line">    <span class="keyword">int</span> q=pos[r];   <span class="comment">//获取下标r所在的块号q</span></span><br><span class="line">    <span class="comment">//如果区间[l,r]在同一个块内</span></span><br><span class="line">    <span class="keyword">if</span>(p==q)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//直接将区间[l,r]内的所有元素都+d</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++)</span><br><span class="line">            a[i]+=d;</span><br><span class="line">        sum[p]+=(r-l+<span class="number">1</span>)*d;  <span class="comment">//记录第p块内的所有元素的总和</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则说明区间[l,r]跨越了不同的块</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//先处理中间被完全覆盖的块 让这些块的懒标记都+d</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=p+<span class="number">1</span>;i&lt;=q<span class="number">-1</span>;i++)<span class="comment">//i枚举的中间被完全覆盖的块号</span></span><br><span class="line">            add[i]+=d;</span><br><span class="line">        <span class="comment">//处理左边剩余部分 将区间[l,R[p]]内的所有元素都+d</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=R[p];i++)</span><br><span class="line">            a[i]+=d;</span><br><span class="line">        sum[p]+=(R[p]-l+<span class="number">1</span>)*d;   <span class="comment">//记录左边剩余部分的所有元素的总和</span></span><br><span class="line">        <span class="comment">//处理右边剩余部分 将区间[L[q],r]内的所有元素都+d</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=L[q];i&lt;=r;i++)</span><br><span class="line">            a[i]+=d;</span><br><span class="line">        sum[q]+=(r-L[q]+<span class="number">1</span>)*d;   <span class="comment">//记录右边剩余部分的所有元素的总和</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h3><p>区间查询，例如查询区间$[l,r]$内的元素和值</p>
<ol>
<li>求$l$和$r$所属的块，即$p=pos[l]$，$q=pos[r]$</li>
<li>如果属于同一个块($p=q$)，则对该区间的元素进行暴力累加，然后加上该块的懒标记</li>
<li>如果不属于同一个块，则对中间被完全覆盖的块累加<code>sum[]</code>值和懒标记<code>add[]</code>上的值，然后对首尾两端剩余部分暴力累加其元素及懒标记的值</li>
</ol>
<p>如下图，查询区间$[2,7]$的元素和值，操作过程：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210816203607.png" alt="image-20210816203607676"></p>
<ul>
<li>读取$2$和$7$所属的块，$p=pos[2]=1$，$q=pos[7]=3$</li>
<li>不属于同一个块，中间完整块$[p+1,q-1]$为第2块，累加这些块的懒标记，$ans=sum[2]+(R[2]-L[2]+1)\times add[2]=42+5\times3=57$</li>
<li>对首尾两端剩余部分的元素暴力累加元素值及懒标记值，此时懒标记$add[1]=add[3]=0$，$ans+=5+7+9+(R[p]-l+1)\times add[p]+(r-L[q]+1)\times add[q]=5+7+9+(3-2+1)\times add[1]+(7-7+1)\times add[3]=78$</li>
</ul>
<p>算法代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//区间查询</span></span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p=pos[l];   <span class="comment">//获取下标l所在的块号p</span></span><br><span class="line">    <span class="keyword">int</span> q=pos[r];   <span class="comment">//获取下标r所在的块号q</span></span><br><span class="line">    LL ans=<span class="number">0</span>;   <span class="comment">//记录区间[l,r]中的元素总和</span></span><br><span class="line">    <span class="comment">//如果区间[l,r]在同一个块内</span></span><br><span class="line">    <span class="keyword">if</span>(p==q)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//累加这个区间[l,r]中所有元素的总和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++)</span><br><span class="line">            ans+=a[i];</span><br><span class="line">        ans+=(r-l+<span class="number">1</span>)*add[p];    <span class="comment">//同时要记得加上第p块中的懒标记</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则说明区间[l,r]跨越了不同的块</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//先累加中间被完全覆盖的这些块的懒标记</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=p+<span class="number">1</span>;i&lt;=q<span class="number">-1</span>;i++)   <span class="comment">//i遍历的是中间被完全覆盖的这些块的块号</span></span><br><span class="line">            ans+=sum[i]+(R[i]-L[i]+<span class="number">1</span>)*add[i];</span><br><span class="line">        <span class="comment">//累加左边剩余部分的所有元素的总和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=R[p];i++)</span><br><span class="line">            ans+=a[i];</span><br><span class="line">        <span class="comment">//累加左侧剩余部分的第p块中的懒标记</span></span><br><span class="line">        ans+=(R[p]-l+<span class="number">1</span>)*add[p];</span><br><span class="line">        <span class="comment">//累加左=右边剩余部分的所有元素的总和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=L[q];i&lt;=r;i++)</span><br><span class="line">            ans+=a[i];</span><br><span class="line">        <span class="comment">//累加右侧剩余部分的第q块中的懒标记</span></span><br><span class="line">        ans+=(r-L[q]+<span class="number">1</span>)*add[q];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans; <span class="comment">//返回答案</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>分块</category>
      </categories>
      <tags>
        <tag>分块之基本思想</tag>
      </tags>
  </entry>
  <entry>
    <title>食物链</title>
    <url>/2021/07/15/Algorithm-Improvement/Chapter4---Advanced%20Data%20Structure/%E5%B9%B6%E6%9F%A5%E9%9B%86/%E9%A3%9F%E7%89%A9%E9%93%BE/</url>
    <content><![CDATA[<h1 id="食物链"><a href="#食物链" class="headerlink" title="食物链"></a>食物链</h1><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210715205916.png" alt="image-20210715205849019"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>这题刚开始看的时候，都想不到会用到并查集。那么，我们就来分析一下，为什么需要用到并查集呢？</p>
<p>题目中提到，只有三类动物，但是每类动物中可能有很多个，每个动物都会有各自的编号。并且$A$吃$B$，$B$吃$C$，$C$吃$A$，这三类动物的食物链构成了有趣的环形。我们设如果$x$吃了$y$，则记录表示为$y\to x$。那么$A$吃$B$，$B$吃$C$，$C$吃$A$，可以表达为$B\to A,C\to B,A\to C$，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210715230906.png" alt="image-20210715230906789"></p>
<p>题目会给出一些信息，那么我们如何根据这些信息来判断各个动物之间的关系呢？是同类呢还是天敌关系呢？</p>
<p>我们把这些动物看成是军人，假设有$100$个军人，我们想知道每个军人是什么等级。</p>
<ul>
<li>如果我们是两两比较军人的关系，那么需要$O(n^2)$才能知道每个军人是什么等级</li>
<li>但是如果我们知道编号为$1$的军人它是司令，然后知道了剩下的$99$个军人与司令的关系，那么就可以在$O(n)$内知道每个军人是什么等级了。比如$2$号说：我比司令低一级，那么$2$号军人的等级就是军长，$5$号军人说：我比司令低两级，那么$5$号军人的等级就是师长。如果$90$号军人说：我比司令低一级，那么$90$号军人的等级就是军长。那么$2$号和$90$就是同类，处于同一个等级。不要被编号迷惑了，可以理解为$2$号成为军长的时间较早，$90$号成为军长较晚，但是他俩都是军长，是同类，处于同一个等级。</li>
</ul>
<p>因此，我们可以把司令看作是一个根节点，那么我们怎么知道每个点与司令这个根节点的关系呢？这其实就需要用到并查集呢！想要知道每个点与司令这个根节点的关系，其实就类似于并查集中的路径压缩。因此，我们可以使用并查集来查询和合并食物链中动物之间的关系。</p>
<p>这里给出<code>d[]</code>数组的解释：</p>
<p><code>d[i]</code>的含义：表示第$i$个动物在食物链中的深度，其实也就是第$i$个动物到它父节点的距离。</p>
<p>设根节点的深度为0，我们有以下定义：</p>
<ul>
<li>如果某类动物，它到根节点距离为0，则表明该类动物与根节点这类动物是同一类动物</li>
<li>如果某类动物，它到根节点距离为1，则表明根节点被该类动物吃</li>
<li>如果某类动物，它到根节点距离为2，则表明该类动物可以吃上一种情况的动物，而且该类动物被根节点吃（因为三类动物形成环）</li>
</ul>
<p>在本题中，我们可以用深度来表达动物在食物链中的关系。由于本题只有三种类型的动物，这三类动物的食物链构成了有趣的环形。$A$吃$B$，$B$吃$C$，$C$吃$A$，那么深度也只有$0,1,2$，因此当深度$\geq3$时，则可以通过模$3$运算，将其转换成$0,1,2$中的某一个。</p>
<p>现在来思考一个问题，我们 <strong>在查找时如何更新深度</strong>？</p>
<p>首先，通过并查集的查询操作，找到祖宗节点，当集合号等于自身时回溯，在回溯过程中需要更新集合号为祖宗的集合号，并且要更新当前节点的深度累加其父节点的深度。当深度$\geq3$时，则可以通过模$3$运算即可。即$d[x]=(d[x]+d[f_x])\%3$</p>
<blockquote>
<p>如何理解$d[x]=(d[x]+d[f_x])\%3$这个式子呢？</p>
<p>如图：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210718000800.png" alt="image-20210718000753778"></p>
</blockquote>
<p>当输入1吃2、2吃3、3吃4时，并查集如下左图所示。当查询1的集合号时，首先找到祖宗节点4，回溯时更新3号节点的深度为1，集合号为4；更新2号节点的深度为2，集合号为4；更新1号节点的深度为0，集合号为4，如下右图所示：</p>
<ul>
<li>对于3号节点来说，路径压缩前，它的父节点是4，距离为1，所以$d[x]=d[3]=1$；路径压缩后，找到集合的根节点是4号节点，那么3号节点的父节点就是4，距离为1，所以$d[x]=d[3]=1$，其父节点的深度其实就是4号节点到4号节点的深度，所以$d[f_x]=0$；所以路径压缩后，3号节点的深度为$d[3]=(d[x]+d[f_x])\%3=(1+0)\%3=1$</li>
<li>对于2号节点来说，路径压缩前，它的父节点是3，距离为1，所以$d[x]=d[2]=1$；路径压缩后，找到集合的根节点是4号节点，那么路径压缩后2号节点的父节点就是4，其父节点的深度其实就是3号节点到4号节点的深度，所以$d[f_x]=1$；所以路径压缩后，2号节点的深度为$d[2]=(d[x]+d[f_x])\%3=(1+1)\%3=2$</li>
<li>对于1号节点来说，路径压缩前，它的父节点是2，距离为1，所以$d[x]=d[2]=1$；路径压缩后，找到集合的根节点是4号节点，那么路径压缩后1号节点的父节点就是4，其父节点的深度其实就是2号节点到4号节点的深度，所以$d[f_x]=2$；所以路径压缩后，1号节点的深度为$d[1]=(d[x]+d[f_x])\%3=(1+2)\%3=0$</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210718002228.png" alt="image-20210718002227975"></p>
<p>再来考虑一个问题：<strong>合并时如何更新深度呢</strong>？</p>
<p>假设节点$x$的集合号为$a$，节点$y$的集合号为$b$，如果$a\neq b$，则合并集合号$p[a]=b$，更新$a$的深度为$d[a]=(d[y]-d[x]+c-1)\%3$。如何理解这个式子呢？</p>
<p>路径压缩后，节点$x$到祖宗节点$a$的距离为$d[x]$，节点$y$到祖宗节点$b$的距离为$d[y]$，那么如果合并集合号$p[a]=b$后？那么如何求节点$a$到它的祖宗节点$b$的距离呢？</p>
<p>由于$a\neq b$，说明$x$和$y$不在同一个集合中，所以才需要用到合并操作。</p>
<ul>
<li><p>当$x$和$y$是同类时，根据<code>d[]</code>的定义可知，同类的深度差为0。即$d[x]+?$与$dy$是相等的。因此有如下式子推导：</p>
<p>$dx+?=dy$$\iff$</p>
<p>$dx+?=dy+0$$\iff$</p>
<p>$?=dy-dx+0$$\iff$</p>
<p>$?=(dy-dx+3+0)\%3$       由于$x$和$y$是同类， 根据题意，此时$c=1$，我们可以发现式子中的0其实就是$c-1=1-1=0$。因此用$c-1$代替0即可</p>
<p>$\iff ?=(dy-dx+3+c-1)\%3$   这里$dy-dx+3$之所以要加3是因为有可能$dy-dx$是负数，导致最终结果是负数，负数不能取模，所以需要转换为正数。模3是因为该食物链为环形</p>
</li>
<li><p>当$x$和$y$是异类时，不妨假设$x$吃$y$，根据<code>d[]</code>的定义可知，合并集合后，$x$到祖宗节点的距离 比 $y$到祖宗节点的距离 多1。即$d[x]+?$与$dy+1$是相等的。因此有如下式子推导：</p>
<p>$dx+?=dy+1$$\iff$</p>
<p>$?=(dy-dx+1)$$\iff$</p>
<p>$?=(dy-dx+3+1)\%3$     由于$x$和$y$是异类，$x$吃$y$， 根据题意，此时$c=2$，我们可以发现式子中的1其实就是$c-1=2-1=1$。因此用$c-1$代替1即可</p>
<p>$\iff ?=(dy-dx+3+c-1)\%3$  这里$dy-dx+3$之所以要加3是因为有可能$dy-dx$是负数，导致最终结果是负数，负数不能取模，所以需要转换为正数。模3是因为该食物链为环形</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210718094601.png" alt="image-20210718094601633">      </p>
</li>
</ul>
<p>举个栗子：</p>
<p>输入6吃2，两个节点属于不同的集合，其中6号节点属于4号集合，6号节点属于7号集合，执行合并，那么$p[7]=4$，更新7号节点的深度为$d[7]=(d[2]-d[6]+3+2-1)\%3=2$，合并更新图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210718210130.png" alt="image-20210718210130274"></p>
<p>当下次查询6号节点的集合号时，找到它的祖宗节点4，回溯时同时更新6号节点的深度为$d[6]=(d[6]+d[7])\%3=0$，查询更新图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210718210557.png" alt="image-20210718210557278"></p>
<p>因此，我们来总结以下就是，如果$x$的集合号$a$与$y$的集合号$b$不相同，则说明它俩不在同一个集合中，这是才需要用到并查集的合并操作。根据以上分析推导可知，最终合并时更新深度其实就只有一个式子：$?=(dy-dx+3+c-1)\%3$ </p>
<p>最后再来看一个问题，<strong>深度满足什么关系是真话</strong>？</p>
<p>这里判断是否为真话或假话，是在$x$和$y$属于同一个集合中讨论的，因为属于同一个集合的话，则不需要合并操作，那么就没有未知变量$d[a]$，不需要求未知变量，而且在这里的全部变量都是已知的，因此我们可以用这些已知变量推导出一些式子，然后我们判断这些式子是否正确就可以判断是否为真话还是假话了。因此可以在这里讨论真假话：</p>
<ul>
<li><p>如果$x$和$y$是同类，那么深度差为0，那么有如下式子推导：</p>
<p>$dx=dy\iff$</p>
<p>$dx=dy+0\iff$</p>
<p>$dx-dy=0\iff$</p>
<p>$(dx-dy+3)\%3=0$    由于$x$和$y$是同类， 根据题意，此时$c=1$，我们可以发现式子中的0其实就是$c-1=1-1=0$。因此用$c-1$代替0即可</p>
<p>$\iff (dx-dy+3)\%3=c-1$   也就是说当$x$和$y$在同一个集合，然后$x$和$y$是同类时，如果满足$(dx-dy+3)\%3$与$c-1$相等，则说明是真话，否则就是假话</p>
</li>
<li><p>如果$x$和$y$是异类，假设$x$吃$y$，那么深度差为$d[x]-d[y]=1$或者$d[x]-d[y]=-2$。如上图所示，1吃2，那么深度差为$d[1]-d[2]=0-2=-2$；2吃3，那么深度差为$d[2]-d[3]=2-1=1$，对于深度差为-2的话，我们可以先加上3，然后就会变为1了，接着在模3即可，对于深度差为1的话，我们先加上3，然后就会变为4，接着再模3即可。那么有如下式子推导：</p>
<p>$dx=dy+1\iff$</p>
<p>$dx-dy=1\iff$</p>
<p>$(dx-dy+3)\%3=1\iff $    由于$x$和$y$是异类，$x$吃$y$，根据题意，此时$c=2$，我们可以发现式子中的1其实就是$c-1=2-1=1$。因此用$c-1$代替1即可</p>
<p>$(dx-dy+3)\%3=c-1$   也就是说当$x$和$y$在同一个集合，然后$x$和$y$是异类时，如果满足$(dx-dy+3)\%3$与$c-1$相等，则说明是真话，否则就是假话</p>
<p>因此，从上面分析可知，在同一个集合中，不论是同类还是被吃关系，公式统一为$(dx-dy+3)\%3=c-1$，如果不满足此等式，则为假话</p>
</li>
</ul>
<p>  <strong>算法设计</strong>：</p>
<ol>
<li>若$x$或$y$大于$n$，或者$c=2$并且$x==y$，则为假话</li>
<li><p>执行c x y指令时，首先查询$x$和$y$的集合号。查询集合号回归时，更新这条路径上每个节点的深度，$d[x]=(d[x]+d[f_x])\%3$。设$x$的集合号为$a$，$y$的集合号为$b$，则分以下两种情况讨论：</p>
<ul>
<li>当$a\neq b$时，说明$x$和$y$不在同一个集合中，那么需要合并$p[a]=b$，更新$a$的深度为$d[a]=(d[y]-d[x]+3+c-1)\%3$</li>
<li>当$a=b$时，说明$x$和$y$在同一个集合中，如果$(d[x]-d[y]+3)\%3!=c-1$，则为假话</li>
</ul>
<p><strong>算法实现：</strong></p>
<p>（1）初始化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    p[i]=i;</span><br><span class="line">      d[i]=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>（2）查找集合号。查询$x,y$的集合号，在返回过程中，除了要统一路径上每个节点的集合号外，还要更新$d[x]$的值（将当前节点的$d$值($d[x]$)累加其父节点的$d$值$d[f_x]$模3）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x!=p[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u=<span class="built_in">find</span>(p[x]);</span><br><span class="line">        d[x]=(d[x]+d[p[x]])%<span class="number">3</span>;</span><br><span class="line">        p[x]=u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>  （3）判断假话数量。对输入的每一条指令，如果$x$或$y$大于$n$，或者$c=2$并且$x==y$，则为假话，$total$++；否则查询集合号，设$x$的集合号为$a$，$y$的集合号为$b$，当$a\neq b$时，合并集合号$p[a]=b$，更新$a$的深度为$d[a]=(d[y]-d[x]+3+c-1)\%3$，当$a=b$时，说明$x$和$y$在同一个集合中，如果$(d[x]-d[y]+3)\%3!=c-1$，则为假话，$total++$。</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(k--)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;c,&amp;x,&amp;y);</span><br><span class="line">    <span class="keyword">if</span>(x&gt;n||y&gt;n||(c==<span class="number">2</span>&amp;&amp;x==y))</span><br><span class="line">        total++;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="built_in">find</span>(x);</span><br><span class="line">        <span class="keyword">int</span> b=<span class="built_in">find</span>(y);</span><br><span class="line">        <span class="keyword">if</span>(a==b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((dx-dy+<span class="number">3</span>)%<span class="number">3</span>!=c<span class="number">-1</span>)</span><br><span class="line">                total++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p[a]=b;</span><br><span class="line">            d[a]=(d[y]-d[x]+<span class="number">3</span>+c<span class="number">-1</span>)%<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 50010</span></span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="keyword">int</span> total;</span><br><span class="line"><span class="keyword">int</span> p[N],d[N];</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">//每个点都是独立的集合  集合号为它自身</span></span><br><span class="line">		p[i]=i;</span><br><span class="line">        <span class="comment">//每个节点到它自身的距离为0  即自身深度为0</span></span><br><span class="line">		d[i]=<span class="number">0</span>;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在查询点x的祖宗节点过程中  更新d[x]的新值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x!=p[x])</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">//寻找节点x的父节点</span></span><br><span class="line">		<span class="keyword">int</span> u=<span class="built_in">find</span>(p[x]);</span><br><span class="line">        <span class="comment">//更新d[x]的值</span></span><br><span class="line">		d[x]=(d[x]+d[p[x]])%<span class="number">3</span>;</span><br><span class="line">        <span class="comment">//回溯时进行了路径压缩,记录每个节点x的祖宗节点为u</span></span><br><span class="line">        p[x]=u;</span><br><span class="line">	&#125; 	</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="comment">//先进行初始化操作</span></span><br><span class="line">	<span class="built_in">init</span>();</span><br><span class="line">	<span class="keyword">while</span>(k--)</span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="keyword">int</span> c,x,y;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;c,&amp;x,&amp;y);</span><br><span class="line">        <span class="comment">//x或y大于n,或者是x吃y,并且x==y,即同类吃同类  则为假话</span></span><br><span class="line">		<span class="keyword">if</span>(x&gt;n||y&gt;n||(c==<span class="number">2</span>&amp;&amp;x==y))</span><br><span class="line">			total++;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> a=<span class="built_in">find</span>(x);  <span class="comment">//查询节点x的集合号(祖宗节点)</span></span><br><span class="line">			<span class="keyword">int</span> b=<span class="built_in">find</span>(y);  <span class="comment">//查询节点y的集合号(祖宗节点)</span></span><br><span class="line">            <span class="comment">//如果集合号相同,说明x和y在同一个集合中,那么不需要合并</span></span><br><span class="line">			<span class="keyword">if</span>(a==b)</span><br><span class="line">			&#123;</span><br><span class="line">                <span class="comment">//如果d[x]-d[y]+3)%3不等于c-1,则为假话</span></span><br><span class="line">				<span class="keyword">if</span>((d[x]-d[y]+<span class="number">3</span>)%<span class="number">3</span>!=c<span class="number">-1</span>)</span><br><span class="line">					total++;</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">//否则说明集合号不同,说明x和y不在同一个集合中,那么就需要进行合并操作了</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				p[a]=b; <span class="comment">//a的父节点是b</span></span><br><span class="line">                <span class="comment">//更新节点a到父节点的距离d[a]</span></span><br><span class="line">				d[a]=(d[y]-d[x]+<span class="number">3</span>+c<span class="number">-1</span>)%<span class="number">3</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,total);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>树</title>
    <url>/2021/09/08/Algorithm-Advanced/Chapter2---Data-Structure/%E7%82%B9%E5%88%86%E6%B2%BB/%E6%A0%91/</url>
    <content><![CDATA[<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210908151139.png" alt="image-20210908151120448"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>这里节点的编号是从0开始的，我们可以再输入时，都让编号+1，也就是说，我们让节点编号从1开始。</p>
<p>我们可以采用树上分治算法进行点分治。以树的重心root为划分点，则树上任意两点$u,v$的路径分为两种：</p>
<ul>
<li>经过root</li>
<li>不经过root，也就是说两个节点都在同一棵子树中</li>
</ul>
<p>但是我们发现第二类其实是可以转换为第一类的，因为对于第二类来说，虽然这两个节点是在同一颗子树中，那么我们可以找到它俩的所在子树的重心c，那么此时它俩就是经过重心c的节点了。因此，对于第二类路径来说，根据分治策略继续采用重心分解即可得到。</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210908151849.png" alt="image-20210908151849222"></p>
<p><strong>算法设计：</strong></p>
<ul>
<li>求解树的重心root</li>
<li>从树的重心root出发，统计每个节点到root的距离</li>
<li>对距离数组排序，以双指针扫描，统计以root为根的子树中满足条件的节点数</li>
<li>对root的每一棵子树v都减去重复统计的节点数</li>
<li>从v出发重复上述过程</li>
</ul>
<p><strong>算法图解：</strong></p>
<p>一棵数如下图所示，求解树上两点之间距离不超过4的路径条数：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210908152316.png" alt="image-20210908152316674"></p>
<p>（1）求解树的重心，root=1</p>
<p>（2）从树的重心root出发，统计每个节点到root的距离，得到距离数组<code>dep[]</code></p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210908152752.png" alt="image-20210908152752530"></p>
<p>（3）对距离数组进行非递减排序，结果如下图所示，然后以双指针扫描，统计以root为根的子树中满足条件的节点个数：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210908153001.png" alt="image-20210908153001782"></p>
<ul>
<li><p>$L=1,R=7$，如果$dep[L]+dep[R]&gt;4$，那么R—，如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210908153302.png" alt="image-20210908153302779"></p>
</li>
<li><p>此时$L=1,R=5$，$dep[L]+dep[R]\leq 4$，那么$ans+=R-L=4$，然后L++，如下图</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210908154002.png" alt="image-20210908154002680"></p>
</li>
</ul>
<p>为什么这么计算呢？因为序列是升序的，当$dep[L]+dep[R]\leq 4$时，$[L,R]$区间的其他节点与$dep[L]$的和必然也是$\leq 4$的，该区间的节点个数为$R-L$，累加即可。我们用$(1,2)$表示节点1与节点2的路径。也就是，$(1,2),(1,3),(1,4),(1,5)$是满足长度不超过4的路径，因此是$R-L$而不是$R-L+1$哦。</p>
<ul>
<li><p>$L=2,R=5$，如果$dep[L]+dep[R]\leq 4$，则$ans+=R-L=7$，L++，如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210908154042.png" alt="image-20210908154042632"></p>
</li>
<li><p>$L=3,R=5$，如果$dep[L]+dep[R]&gt;4$，则R—，如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210908154226.png" alt="image-20210908154226820"></p>
</li>
<li><p>$L=3,R=4$，如果$dep[L]+dep[R]\leq 4$，则$ans+=R-L=8$，L++，此时L=R，结束循环，如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210908154357.png" alt="image-20210908154357869"></p>
</li>
</ul>
<p>也就是说，以1为根的树，满足条件的路径有8个。在这些路径中，有些是合并路径，例如$(1,2)$和$(1,3)$，它俩合并后为$(2,1,3)$，长度为4，是满足$\leq 4$的。</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210908154855.png" alt="image-20210908154855475"></p>
<p>上表中的第7条路径是错误的。$(1,3)$和$(1,3,7)$单独来看都是合法的路径，但是我们不能把它俩合并后的路径当作是合法路径，即使它的长度3是满足$\leq 4$的。因为它不是简单路径，树中任意两个节点之间的路径都是不重复的。如果合并后，那么可以认为是从$3\to 1\to 3\to 7$，路径长度是3。但是这样就不是简单路径了，因为重复经过了边$(1,3)$。这就启发我们需要去重。</p>
<p>那么该怎么去重呢？我们需要在对它的子树进行分治时，先去重，然后再递归去处理它的子树。</p>
<p><strong>算法实现：</strong></p>
<p>（1）求解树的重心。只需要进行一次深度优先遍历，找到删除该节点后最大子树最小的节点。用<code>f[u]</code>表示删除节点u后最大子树的大小(不包括u)，<code>siz[u]</code>表示以$u$为根的子树的节点数(包括根节点$u$)，<code>nt</code>表示当前整棵子树的节点数。先统计$u$的所有子树中最大子树的节点数$f[u]$，然后与$nt-siz[u]$比较，取两者的最大值。如果$f[u]&lt;f[root]$，则更新当前树的重心为$root=u$。</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210908155842.png" alt="image-20210908155842401"></p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取当前树的重心  fa是父节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getroot</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    siz[u]=<span class="number">1</span>;	<span class="comment">//先把节点u算进去</span></span><br><span class="line">    f[u]=<span class="number">0</span>;		<span class="comment">//f是删除节点u后最大子树的大小 初始化为0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];~i;i=ne[i])<span class="comment">//遍历节点u的所有邻接点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v=e[i];	<span class="comment">//节点u的邻接点是v</span></span><br><span class="line">        <span class="comment">//如果v不是u的父节点 并且 节点v还没有被删除</span></span><br><span class="line">        <span class="keyword">if</span>(v!=fa&amp;&amp;!st[v])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">getroot</span>(v,u);	<span class="comment">//一直递归</span></span><br><span class="line">            <span class="comment">//递归到叶子节点后  由叶子节点的信息更新其父节点的信息</span></span><br><span class="line">            siz[u]+=siz[v];</span><br><span class="line">            f[u]=<span class="built_in">max</span>(f[u],siz[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f[u]=<span class="built_in">max</span>(f[u],nt-siz[u]);	<span class="comment">//找到删除节点u后最大子树的大小</span></span><br><span class="line">    <span class="keyword">if</span>(f[u]&lt;f[root])	<span class="comment">//更新当前树的重心</span></span><br><span class="line">        root=u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）统计每个点到重心$u$的距离，把$dep[0]$当作计数器使用，初始化为0，也就是说<code>dep[]</code>数组中的有效数据是从下标1开始算的，不使用下标0存储数据。进行深度优先遍历，将每个节点到$u$的距离<code>d[]</code>都存入<code>dep[]</code>数组中。$d[]$它存储的是某个子树中的节点到这个子树的重心的距离，但是$dep[]$存储的是整棵树中的所有节点到其所在子树的重心的距离，也就是说<code>dep[]</code>存储的就是<code>d[]</code>的值。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取每个节点到其所在子树中的重心的距离   然后把它们存入dep数组中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getdist</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dep[++dep[<span class="number">0</span>]]=d[u];	<span class="comment">//先将节点u到其所在子树中的重心的距离存入dep数组中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];~i;i=ne[i])<span class="comment">//遍历节点u的所有邻接点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v=e[i];<span class="comment">//节点u的邻接点是v</span></span><br><span class="line">         <span class="comment">//如果v不是u的父节点 并且 节点v还没有被删除</span></span><br><span class="line">        <span class="keyword">if</span>(v!=fa&amp;&amp;!st[v])</span><br><span class="line">        &#123;</span><br><span class="line">            d[v]=d[u]+w[i];	<span class="comment">//节点v到其所在子树中的重心的距离=节点u到其所在子树中的重心的距离+节点u和节点v之间这条边的权值</span></span><br><span class="line">            <span class="built_in">getdist</span>(v,u);	<span class="comment">//递归处理节点v</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（3）统计重心$u$的子树中满足条件的个数。初始化$d[u]=dis$，并且$dep[0]=0$（用于计数)，调用getdist函数，将每个节点到$u$的距离<code>d[]</code>都存入<code>dep[]</code>数组中，然后对<code>dep</code>数组进行排序，$L=1,R=dep[0]$(此时的$dep[0]$其实就表示<code>dep</code>数组的大小了，也就是最后一个数的下标)，用$sum$来累加满足$\leq4$的路径个数。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取以u为根的子树中满足条件的路径个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> dis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    d[u]=dis;	<span class="comment">//初始化u到根节点u的距离为dis</span></span><br><span class="line">    dep[<span class="number">0</span>]=<span class="number">0</span>;	<span class="comment">//初始化计数器dep[0]为0</span></span><br><span class="line">    <span class="comment">//调用getdist函数求出以u为重心的子树中的其他节点到u的距离d  并存入dep数组中</span></span><br><span class="line">    <span class="built_in">getdist</span>(u,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sort</span>(dep+<span class="number">1</span>,dep+<span class="number">1</span>+dep[<span class="number">0</span>]);	<span class="comment">//将距离数组从小到大排序</span></span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">1</span>,r=dep[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;	<span class="comment">//统计满足条件的路径个数</span></span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[l]+dep[r]&lt;=k)</span><br><span class="line">        &#123;</span><br><span class="line">            sum+=r-l;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（4）对重心$u$的所有子树都先去重，然后再递归求解答案。对$u$的每一颗子树$v$都减去$v$中重复统计的答案，然后再从$v$出发重复上述过程即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//求解答案</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u]=<span class="literal">true</span>;	<span class="comment">//将节点u删除</span></span><br><span class="line">    <span class="comment">//先将以u作为整棵树的重心时 满足条件的路径条数统计处理</span></span><br><span class="line">    <span class="comment">//满足条件的路径条数包含了 真正合法的路径 和 不合法的路径</span></span><br><span class="line">    ans+=<span class="built_in">calc</span>(u,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];~i;i=ne[i])<span class="comment">//遍历节点u的所有邻接点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v=e[i];<span class="comment">//节点u的邻接点是v</span></span><br><span class="line">        <span class="comment">//如果节点v没有被删除</span></span><br><span class="line">        <span class="keyword">if</span>(!st[v])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//再递归处理v所在的子树前  先减去v子树中的重复部分</span></span><br><span class="line">            ans-=<span class="built_in">calc</span>(v,w[i]);</span><br><span class="line">             </span><br><span class="line">            root=<span class="number">0</span>;	<span class="comment">//初始化v子树的重心为0</span></span><br><span class="line">            nt=siz[v];	<span class="comment">//初始化以v为根的子树的节点个数</span></span><br><span class="line">            <span class="comment">//找到v子树的重心</span></span><br><span class="line">            <span class="built_in">getroot</span>(v,<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//然后再递归去计算v子树的路径条数</span></span><br><span class="line">            <span class="built_in">solve</span>(root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里最难理解的部分就是$ans+=calc(u,0)$和$ans-=calc(v,w[i])$，这是怎么做到去重的呢？</p>
<p>如下图，假设$k=4$</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210908165701.png" alt="image-20210908165701812"></p>
<p>如果都写了那两个代码，则答案为6，即：</p>
<ul>
<li>$(1,2)$，长度为1</li>
<li>$(1,4)$，长度为2</li>
<li>$(2,3)$，长度为1</li>
<li>$(2,1,4)$，长度为3</li>
<li>$(1,2,3)$，长度为2</li>
<li>$(3,2,1,4)$，长度为4</li>
</ul>
<p>但是如果我们不写后面$ans-=calc(v,w[i])$这个代码，则答案为7，即：</p>
<ul>
<li>$(1,2)$，长度为1</li>
<li>$(1,4)$，长度为2</li>
<li>$(2,3)$，长度为1</li>
<li>$(2,1,4)$，长度为3</li>
<li>$(1,2,3)$，长度为2</li>
<li>$(3,2,1,4)$，长度为4</li>
<li>$(2,1,2,3)$，长度为3</li>
</ul>
<p>这里最后一条路径就是我们之前所说的不合法路径，它不是简单路径，然而我们却把它算进去了。那么我们如果我们执行了$ans-=calc(v,w[i])$，该怎么理解它是如何去重的呢？</p>
<p>对于上面那个图，假设此时$u=1$，然后$v=2$，现在对子树v去重，可以发现，我们传参是$w[i]$，即节点$u$和节点$v$之间的边权1。我们处理子树v时，这棵子树中只有2——3。但是当我们把参数$w[i]$传进来后，就相当于我们把节点1放进来来，也就是说，此时得到树1——2——3。执行calc函数，得到dep数组是{1,2}，这里的1表示的就是$(1,2)$，这里的2表示的就是$(1,2,3)$。然后排序，进行双指针算法，得到$sum=1$，那么$ans-1$。减去的1其实就是$(1,2)$这条重复的边。也就是说，这个$calc(v,w[i])$主要就是把$v$子树和$u$节点联系起来构建出一棵树，这样就得到了从$u$出发的路径。然后就可以去掉子树v中重复的部分了。</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e4</span>+<span class="number">10</span>,M=<span class="number">2</span>*N;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],w[M],idx;</span><br><span class="line"><span class="keyword">int</span> n,k,ans;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * root记录重心 nt表示记录当前子树总的结点数</span></span><br><span class="line"><span class="comment"> * siz[u] 表示以u为根的子树的节点数(包括u)</span></span><br><span class="line"><span class="comment"> * f[u] 表示删除u后最大子树的大小(不包括u)</span></span><br><span class="line"><span class="comment"> * d[i] 表示i到其所在子树的重心的距离</span></span><br><span class="line"><span class="comment"> * dep[] 存储的是整棵树中的所有节点到其子树重心的距离  也就是存储d[]的值</span></span><br><span class="line"><span class="comment"> * st[i]=true表示结点i已经被当做根节点进行分治处理了</span></span><br><span class="line"><span class="comment"> *为什么需要st数组呢？因为对整个树求出一个重心,对重心这个点进行分治,先统计出经过这个点的路径</span></span><br><span class="line"><span class="comment"> * 然后把这个点删掉,把整个树分解成很多子树,对每个子树继续求重心,继续进行分治</span></span><br><span class="line"><span class="comment"> * 因此st[i]=true其实也就是表明将结点i删除</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> root,nt,siz[N],f[N],d[N],dep[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当前树的重心  fa是父节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getroot</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    siz[u]=<span class="number">1</span>;	<span class="comment">//先把节点u算进去</span></span><br><span class="line">    f[u]=<span class="number">0</span>;		<span class="comment">//f是删除节点u后最大子树的大小 初始化为0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];~i;i=ne[i])<span class="comment">//遍历节点u的所有邻接点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v=e[i];	<span class="comment">//节点u的邻接点是v</span></span><br><span class="line">        <span class="comment">//如果v不是u的父节点 并且 节点v还没有被删除</span></span><br><span class="line">        <span class="keyword">if</span>(v!=fa&amp;&amp;!st[v])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">getroot</span>(v,u);	<span class="comment">//一直递归</span></span><br><span class="line">            <span class="comment">//递归到叶子节点后  由叶子节点的信息更新其父节点的信息</span></span><br><span class="line">            siz[u]+=siz[v];</span><br><span class="line">            f[u]=<span class="built_in">max</span>(f[u],siz[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f[u]=<span class="built_in">max</span>(f[u],nt-siz[u]);	<span class="comment">//找到删除节点u后最大子树的大小</span></span><br><span class="line">    <span class="keyword">if</span>(f[u]&lt;f[root])	<span class="comment">//更新当前树的重心</span></span><br><span class="line">        root=u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取每个节点到其所在子树中的重心的距离   然后把它们存入dep数组中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getdist</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dep[++dep[<span class="number">0</span>]]=d[u];	<span class="comment">//先将节点u到其所在子树中的重心的距离存入dep数组中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];~i;i=ne[i])<span class="comment">//遍历节点u的所有邻接点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v=e[i];<span class="comment">//节点u的邻接点是v</span></span><br><span class="line">        <span class="comment">//如果v不是u的父节点 并且 节点v还没有被删除</span></span><br><span class="line">        <span class="keyword">if</span>(v!=fa&amp;&amp;!st[v])</span><br><span class="line">        &#123;</span><br><span class="line">            d[v]=d[u]+w[i];	<span class="comment">//节点v到其所在子树中的重心的距离=节点u到其所在子树中的重心的距离+节点u和节点v之间这条边的权值</span></span><br><span class="line">            <span class="built_in">getdist</span>(v,u);	<span class="comment">//递归处理节点v</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取以u为根的子树中满足条件的路径个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> dis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    d[u]=dis;	<span class="comment">//初始化u到根节点u的距离为dis</span></span><br><span class="line">    dep[<span class="number">0</span>]=<span class="number">0</span>;	<span class="comment">//初始化计数器dep[0]为0</span></span><br><span class="line">    <span class="comment">//调用getdist函数求出以u为重心的子树中的其他节点到u的距离d  并存入dep数组中</span></span><br><span class="line">    <span class="built_in">getdist</span>(u,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sort</span>(dep+<span class="number">1</span>,dep+<span class="number">1</span>+dep[<span class="number">0</span>]);	<span class="comment">//将距离数组从小到大排序</span></span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">1</span>,r=dep[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;	<span class="comment">//统计满足条件的路径个数</span></span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[l]+dep[r]&lt;=k)</span><br><span class="line">        &#123;</span><br><span class="line">            sum+=r-l;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求解以u为重心的情况</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u]=<span class="literal">true</span>;	<span class="comment">//将节点u删除</span></span><br><span class="line">    <span class="comment">//先将以u作为整棵树的重心时 满足条件的路径条数统计处理</span></span><br><span class="line">    <span class="comment">//满足条件的路径条数包含了 真正合法的路径 和 不合法的路径</span></span><br><span class="line">    ans+=<span class="built_in">calc</span>(u,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];~i;i=ne[i])<span class="comment">//遍历节点u的所有邻接点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v=e[i];<span class="comment">//节点u的邻接点是v</span></span><br><span class="line">        <span class="comment">//如果节点v没有被删除</span></span><br><span class="line">        <span class="keyword">if</span>(!st[v])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//再递归处理v所在的子树前  先减去v子树中的重复部分</span></span><br><span class="line">            ans-=<span class="built_in">calc</span>(v,w[i]);</span><br><span class="line"></span><br><span class="line">            root=<span class="number">0</span>;	<span class="comment">//初始化v子树的重心为0</span></span><br><span class="line">            nt=siz[v];	<span class="comment">//初始化以v为根的子树的节点个数</span></span><br><span class="line">            <span class="comment">//找到v子树的重心</span></span><br><span class="line">            <span class="built_in">getroot</span>(v,<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//然后再递归去计算v子树的路径条数</span></span><br><span class="line">            <span class="built_in">solve</span>(root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">0x7fffffff</span>;<span class="comment">//初始化超根</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k),n+k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(st,<span class="number">0</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">        <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">        ans=<span class="number">0</span>;	<span class="comment">//答案</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a,b,c;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">            <span class="comment">//让点的编号从1开始 不使用0</span></span><br><span class="line">            <span class="comment">//因为我们再dep数组中使用了dep[0]作为计数器 </span></span><br><span class="line">            <span class="comment">//dep数组是从下标1开始存入有效数据的</span></span><br><span class="line">            a++,b++;	</span><br><span class="line">            <span class="built_in">add</span>(a,b,c);</span><br><span class="line">            <span class="built_in">add</span>(b,a,c);</span><br><span class="line">        &#125;</span><br><span class="line">        root=<span class="number">0</span>;		<span class="comment">//初始化整棵树的重心为超根0</span></span><br><span class="line">        nt=n;	<span class="comment">//初始化当前子树的大小为n</span></span><br><span class="line">        <span class="comment">//寻找整棵树的重心</span></span><br><span class="line">        <span class="built_in">getroot</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//开始点分治</span></span><br><span class="line">        <span class="built_in">solve</span>(root);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>点分治</category>
      </categories>
      <tags>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title>分组背包问题</title>
    <url>/2021/08/28/Algorithm-Improvement/Chapter1---Dynamic%20Programming/%E8%83%8C%E5%8C%85%E6%A8%A1%E5%9E%8B/%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85%E6%A8%A1%E5%9E%8B/%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="分组背包问题"><a href="#分组背包问题" class="headerlink" title="分组背包问题"></a>分组背包问题</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210828155816.png" alt="image-20210828155808951"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>最大价值应该是物品组i和背包容量j的函数。设<code>f[i][j]</code>表示前i组物品，能放入容量为j的背包的最大价值</p>
<p>朴素算法应该是循环物品组，循环背包容量，对第$i$组物品，容量为$j$的背包，有$s+1$种选法，即$max(f[i-1][j],f[i-1][j-v_1]+w_1,f[i-1][j-v_2]+w_2,\cdots,f[i-1][j-v_s]+w_s)$</p>
<p>其中$f[i-1][j]$表示我不选择第$i$组中的任何一个物品所得到的最大价值，$f[i-1][j-v_1]+w[i]$表示我选择第$i$组物品中的第一个物品所得到的最大价值，由于第$i$组物品中的第一个物品用掉了$v_1$的体积，那么还剩下$j-v_1$的体积，因此我们从前$i-1$组物品中选择，那么最大价值就是$f[i-1][j-v_1]$，然后加上选择第$i$组中的第一个物品的价值$w[i]$。因此总的最大价值就是$f[i-1][j-v_1]+w[i]$</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210828160850.png" alt="image-20210828160849901"></p>
<p>可以对空间进行优化，将$f$优化为一维</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>没有优化空间，$f$是二维数组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">朴素算法：循环物品组,循环背包容量 对于第i组物品,容量为j的背包,有s+1种选法</span></span><br><span class="line"><span class="comment">max(f[i-1][j],f[i-1][j-V1]+W1,f[i-1][j-2V1]+W2,...,f[i-1][j-Vs]+Ws);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> v[N][N],w[N][N];    <span class="comment">//体积  价值</span></span><br><span class="line"><span class="comment">//f[i][j]表示前i组物品，能放入容量为j的背包的最大价值</span></span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"><span class="keyword">int</span> s[N];   <span class="comment">//s[i]=x表示第i组内有x件物品</span></span><br><span class="line"><span class="keyword">int</span> n,m;    <span class="comment">//物品  体积</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   <span class="comment">//n组物品</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;s[i]);  <span class="comment">//第i组物品中有s[i]件物品</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=s[i];j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;v[i][j],&amp;w[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   <span class="comment">//n组物品</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)   <span class="comment">//体积</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=s[i];k++)    <span class="comment">//决策 选择该组中的哪个物品</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=v[i][k])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//max中的f[i][j]表示不选第i组中第k个物品，已获取的价值</span></span><br><span class="line">                    <span class="comment">//f[i-1][j-v[i][k]]+w[i][k]表示选入第i组物品中的第k个物品,能获取的价值</span></span><br><span class="line">                    f[i][j]=<span class="built_in">max</span>(f[i][j],f[i<span class="number">-1</span>][j-v[i][k]]+w[i][k]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[n][m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化空间，$f$是一维数组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> v[N],w[N];  <span class="comment">//体积  价值</span></span><br><span class="line"><span class="keyword">int</span> f[N];   <span class="comment">//将物品装入背包容量为m的最大价值</span></span><br><span class="line"><span class="keyword">int</span> n,m;    <span class="comment">//体积  价值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   <span class="comment">//物品</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> s;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;s);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=s;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;v[j],&amp;w[j]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=<span class="number">1</span>;j--)   <span class="comment">//体积</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=s;k++)   <span class="comment">//决策  选择第i组中的第k件物品</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=v[k])</span><br><span class="line">                    f[j]=<span class="built_in">max</span>(f[j],f[j-v[k]]+w[k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>背包模型</category>
      </categories>
      <tags>
        <tag>分组背包</tag>
      </tags>
  </entry>
  <entry>
    <title>二维费用01背包</title>
    <url>/2021/08/18/Algorithm-Improvement/Chapter1---Dynamic%20Programming/%E8%83%8C%E5%8C%85%E6%A8%A1%E5%9E%8B/01%E8%83%8C%E5%8C%85%E6%A8%A1%E5%9E%8B/%E4%BA%8C%E7%BB%B4%E8%B4%B9%E7%94%A801%E8%83%8C%E5%8C%85/</url>
    <content><![CDATA[<h1 id="二维费用01背包"><a href="#二维费用01背包" class="headerlink" title="二维费用01背包"></a>二维费用01背包</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210818163346.png" alt="image-20210818163346335"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>这个是二维费用01背包问题。那么什么是二维费用01背包问题呢？我们知道在一维费用01背包问题中，一般只有体积这个约束条件，然后求将何种物品装入背包能够得到最大价值。二维费用01背包问题，只不过是又增加了一个约束条件，比如题目中有两个约束条件 “总体积不超过背包容量” 和 “总重量不超过背包可承受的最大重量”，此时就是二维费用01背包问题。</p>
<p>我们先来回顾一下一维费用01背包问题</p>
<p><code>f[j]</code>表示背包容量为$j$时，能放入的最大价值，因此当背包容量为$V$时，能放入的最大价值就是$f[V]$，即为全局最优解。</p>
<p>一维费用01背包的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cin &gt;&gt;n&gt;&gt;V;		<span class="comment">//物品数量  背包容量</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//枚举物品</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> v,w;</span><br><span class="line">    cin &gt;&gt;v&gt;&gt;w;		<span class="comment">//体积  价值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=V;j&gt;=v;j--)	<span class="comment">//枚举体积</span></span><br><span class="line">        f[j]=<span class="built_in">max</span>(f[j],f[j-v]+w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[V]);</span><br></pre></td></tr></table></figure>
<p>那么我们可以参照一维费用01背包问题，再增加一维即可：</p>
<p><code>f[j][k]</code>表示背包容量为$j$，且承重为$k$时，能放入的最大价值。因此当背包容量为$V$，承重为$M$时，能放入的最大价值就是$f[V][M]$，即为全局最优解。</p>
<p>二维费用01背包问题的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cin &gt;&gt;n&gt;&gt;V&gt;&gt;M;	<span class="comment">//物品件数	背包容量	背包承重</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//枚举物品</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> v,m,w;	<span class="comment">//体积	重量	价值</span></span><br><span class="line">    cin &gt;&gt;v&gt;&gt;m&gt;&gt;w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=V;j&gt;=v;j--)<span class="comment">//枚举体积</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=M;k&gt;=m;k--)<span class="comment">//枚举承重</span></span><br><span class="line">            f[j][k]=<span class="built_in">max</span>(f[j][k],f[j-v][k-m]+w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[V][M]);</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>背包模型</category>
      </categories>
      <tags>
        <tag>二维费用01背包</tag>
      </tags>
  </entry>
  <entry>
    <title>回文串</title>
    <url>/2021/08/22/Algorithm-Advanced/Chapter2---Data-Structure/%E5%9B%9E%E6%96%87%E6%A0%91/%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="回文串"><a href="#回文串" class="headerlink" title="回文串"></a>回文串</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><a href="https://www.luogu.com.cn/problem/P3649">洛谷P3649</a></p>
<hr>
<h3 id="回文树"><a href="#回文树" class="headerlink" title="回文树"></a>回文树</h3><p>回文树 (EER Tree，Palindromic Tree，也被称为回文自动机）是一种可以存储一个串中所有回文子串的高效数据结构，使用回文树可以简单高效地解决一系列涉及回文串的问题。</p>
<p>回文树大概长这样：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210822180354.png" alt="image-20210822180354470"></p>
<p>回文树是由<strong>转移边</strong>和<strong>后缀链接 (fail 指针）</strong>组成，每个<strong>节点</strong>都可以代表一个<strong>回文子串</strong>。</p>
<p>因为回文串长度分为奇数和偶数，因此我们需要建立两棵树，一棵树中的节点对应的回文子串长度均为奇数，另一棵树中的节点对应的回文子串长度均为偶数。也就是说，这棵回文树其实包含了两棵树。树中一个节点的 fail 指针指向的是这个节点所代表的回文串的最长回文后缀所对应的节点，但是转移边并非代表在原节点代表的回文串后加一个字符，而是表示在原节点代表的回文串前后各加一个相同的字符（不难理解，因为要保证存的是回文串）。</p>
<p>我们还需要在每个节点上维护此节点对应回文子串的长度 len，这个信息保证了我们可以轻松地构造出回文树。</p>
<p>回文树有两个初始状态，分别代表长度为-1，0的回文串。我们可以称它们为奇根，偶根，其中偶根节点是0，奇根节点是1。它们不表示任何实际的字符串，仅作为初始状态存在，这与其他自动机的根节点是异曲同工的。</p>
<p>特殊规定：偶根的 fail 指针指向奇根，也就是<code>fail[0]=1</code>。而我们并不关心奇根的 fail 指针，因为奇根不可能失配，因为奇根不代表任何实际的字符串，那么从奇根转移出去得到的是一个单字符，对于一个单字符来说，它自身本来就是回文串，因此不可能失配。</p>
<p>回文串的性质：比如”bcdcb”是一个回文串，那么我们在前后两端各加上一个字符a，得到的新字符串”abcdcba”仍然是一个回文串。</p>
<p>先给出以下变量的定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">len[i]:表示编号为i的这个节点所表示的回文串的长度</span><br><span class="line">ch[i][c]:表示在编号为i的节点所表示的回文串前后两端加上字符c后所形成的新的回文串,这个新的回文串可以用一个节点来表示 也就是ch[i][c] ch[i][c]也就是新的回文串所对应的状态节点</span><br><span class="line">fail[i]:表示节点i失配后应该跳转到不等于自身的最长回文后缀所对应的节点</span><br><span class="line">cnt[i]:表示节点i所表示的回文串的出现次数</span><br><span class="line">last:表示上一个插入字符所在的节点</span><br><span class="line">tot:表示这个回文树中添加的节点个数(不包括奇根和偶根) 我们用tot=<span class="number">0</span>来表示了$字符,因此tot是从<span class="number">1</span>开始来表示题目中输入的字符的</span><br><span class="line">sz:表示这个回文数中的节点总数(包括奇根和偶根) 初始化时sz=<span class="number">-1</span>,然后规定sz=<span class="number">0</span>表示偶根 sz=<span class="number">1</span>表示奇根,最终sz=tot+<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>下面我们来看一下字符串”eertree”这个回文树是怎么被建造出来的：</p>
<p>图中的蓝边表示转移边，红边就是表示后缀链接fail指针。</p>
<p>图中的0表示偶根的回文长度，规定偶根的节点为0；-1表示奇根的回文长度，规定奇根的节点为1。那为什么从奇根转移出去得到的一个字符呢？首先，我们是在前后两端加上同 一个字符，那么转移后的节点长度就增加了2。由于是从奇根转移出去，因此-1+2=1，也就是1个字符。比如图中的字符e，t，r。本来是增长了两个字符ee，tt，rr，但是由于是奇根，长度为-1，因此+2后得到1，于是我们认为从奇根转移出去的得到的字符是e，t，r而不是ee，tt，rr。这也就是为什么从奇根转移出去得到的是一个单字符。</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210822181256.png" alt="image-20210822181256347"></p>
<p>规定偶根0的fail指针指向奇根 ，奇根的fail指针指向其自身：</p>
<p>但是要注意明确定义了$fail[0]=1$，但是没有明确定义$fail[1]$，不过它使用的全局变量，因此默认$fail[1]=0$ 注意不是$fail[1]=1$哦</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210822182415.png" alt="image-20210822182415752"></p>
<p>插入第一个字符E：</p>
<p>规定：单个字符的fail指针指向的是偶根0</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210822182819.png" alt="image-20210822182819548"></p>
<p>接下来插入第二个字符E：</p>
<p>为什么ee不是从前面已经得到e连出来的呢？而是从偶根0连出来的呢？因为如果从e连出来，那么在其前后两端添加字符e，则会得到eee，而不是我们想要的ee；如果我们从偶根0连出来，由于偶根0不代表任何实际字符串，那么在其前后两端添加字符e，则会得到ee，符合我们的预期。因此是从偶根0转移出来的。</p>
<p>那么我们来思考一下为什么ee的fail指针会指向e呢？根据fail指针的含义可知，我们要找当前串中最长的回文后缀，对于ee来说，其后缀只有一个e，对于单个字符肯定是回文的，于是ee的最长回文后缀就是e，因此ee的fail指针指向了e，即图中ee指向e的红色边。</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210822182937.png" alt="image-20210822182937052"></p>
<p>接下来插入第三个字符R</p>
<p>由于此时EER并不是回文串，因此插入的这单个字符R它是从奇根转移过来的（图中奇根到r的蓝边），而且我们规定了单个字符的fail指向的是偶根0（图中r到偶根0的红边）</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210822204248.png" alt="image-20210822204248118"></p>
<p>接下来插入第四个字符T</p>
<p>由于此时EERT并不是回文串，因此插入的这单个字符T它是从奇根转移过来的（图中奇根到t的蓝边），而且我们规定了单个字符的fail指向的是偶根0（图中t到偶根0的红边）</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210822204537.png" alt="image-20210822204537921"></p>
<p>接下来插入第五个字符R：</p>
<p>此时字符串为EERTR，我们发现RTR是回文串，而且它是在字符T前后两端添加字符R后转移得到的，因此从t到rtr有一条蓝边。然后我们来看RTR的fail指针该怎么求呢？RTR它的后缀有R，TR，明显TR不是回文的，而单个字符R一定是回文的，因此RTR的最长回文后缀就是R，于是从RTR到R有一条红边，即fail指针。</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210822204925.png" alt="image-20210822204925826"></p>
<p>接下来插入第六个字符E：</p>
<p>此时字符串为EERTRE，我们发现ERTRE是回文串，而且它是在RTR前后两端添加字符E后转移得到的，因此从rtr到eertre有一条蓝边。然后我们来看ERTRE的fail指针该怎么求呢？ERTRE的后缀有E，RE，TRE，RERE，显然RE，TRE，RERE都不是回文的，而单个字符E一定是回文的，因此ERTRE的最长回文后缀就是E，于是从ERTRE到E有一条红边，即fail指针。</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210822205409.png" alt="image-20210822205409415"></p>
<p>最后插入第七个字符E：</p>
<p>此时字符串为EEREREE，它就是一个回文串，而且它是在ERTRE的前后两端添加字符E后转移得到的，因此从ERTRE到EEREREE有一条蓝边。然后我们来看EEREREE的fail指针该怎么求呢？EEREREE的后缀有E，EE，REE，EREE，REREE，EREREE，从中发现EE的最长的回文后缀，于是从EEREREE到EE有一条红边，即fail指针。</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210822205753.png" alt="image-20210822205753864"></p>
<p><strong>引理1：向S末尾添加一个字符，最多只会新生成一个回文子串。</strong></p>
<p>这里得到的新的回文子串其实是S的最长回文后缀末端增加c，且原来的前端也恰好是c，所产生的。如下图直观感受一下：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210822211029.png" alt="image-20210822211029800"></p>
<p><strong>引理2：设节点$u$的回文长度为$len[u]$，任何一个满足$len[u]&gt;1$的节点$u$的入度为1（注意这里的入度是对于蓝色的转移边来说的，而不考虑红色的fail指针的后缀链接边）</strong></p>
<p>从上面的构造图中，我们可以发现：</p>
<ul>
<li>如果$len[u]=1$，则其唯一的入边必然是奇根$\to u$，例如上图中的节点e，节点t，节点r，回文长度都为1，而且都是从奇根引出的蓝边</li>
<li>如果$len[u]=2$，则其唯一的入边必然是偶根$\to u$，例如上图中的节点ee，是从偶根引出的蓝边</li>
<li>如果$len[u]\geq 3$，则其唯一的入边必然为$v\to u$，满足：节点$v$所表示的回文串T的前后两端添加某个字符c后，使得节点$u$表示的回文串S满足S=cTc。例如上图中的节点rtr，其回文长度为3，它是从节点t前面两端添加字符r后转移得到的。</li>
</ul>
<p>下面主要讲解这段代码是啥意思：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> c)</span> <span class="comment">//建树</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s[++tot] = c;</span><br><span class="line">    <span class="comment">//设此时得到的回文后缀所对应的节点是now  设其回文后缀是Q</span></span><br><span class="line">    <span class="keyword">int</span> now = <span class="built_in">getfail</span>(last);</span><br><span class="line">    <span class="keyword">if</span> (!ch[now][c - <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//在回文后缀前后两端添加字符c后 得到回文串cQc 对应的状态节点是x 同时其回文长度是len[now] + 2</span></span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">node</span>(len[now] + <span class="number">2</span>);</span><br><span class="line">        <span class="comment">//注意下面的这两个顺序不能相反</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//找到x的fail指针应该连向的节点是哪个  那么我们就顺着now的fail指针走 直到不能走为止</span></span><br><span class="line">        fail[x] = ch[<span class="built_in">getfail</span>(fail[now])][c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        ch[now][c - <span class="string">&#x27;a&#x27;</span>] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    last = ch[now][c - <span class="string">&#x27;a&#x27;</span>];    <span class="comment">//将当前节点ch[now][c - &#x27;a&#x27;]给last  更新last</span></span><br><span class="line">    cnt[last]++;    <span class="comment">//last状态节点所表示的回文串的出现次数+1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如上述栗子中，现在插入第一个字符E，那么s[1]=E，last=0，执行getfail(0)，由图可知0是偶根节点，它的fail指向的是奇根1，因此经过getfail(0)后返回的结果是1，所以此时now=1，指向的是奇根节点。然后由图可知，此时奇根now还没有存在E这个节点，那么我们就创建出这个节点E，len[now]+2=len[1]+2=-1+2=1，因此经过node(1)后，返回的结果是2，即x=2，也就是说新建出来的这个节点E的编号是2。然后我们就要处理E节点它的fail指针应该指向哪个节点呢？此时fail[now]=fail[1]，而我们知道fail[1]使用的是全局变量的0，因此fail[1]=0，所以经过getfail(0)后返回的结果是1，所以$ch[1][‘e’-‘a’]=ch[1][4]$，由于我们初始化$ch[][]$都为0了，所以此时$ch[1][4]=0$，即$fail[2]=ch[1][4]=0$，也就是说当前新建的这个节点E它的fail指针指向偶根0，这与我们之前所说的单个字符的fail指针指向的是偶根0 是等同的。然后将创建出来的这个节点编号$x=2$赋给now的儿子$ch[now][4]$，表示已经把now的孩子c已经建立出来了。接着让last移动到新创建的这个节点，最后统计一下last状态节点所表示的回文串的出现次数即可。</p>
<p>插入完第一个字符E后，此时now=1，接着插入第二个字符E，s[2]=E，last=2，执行getfail(2)后返回结果为1，即2号点的fail指针是奇根1，所以now=1，发现now已经存在E这个节点了，于是不需要再建立出来了。</p>
<p>通过这两步我们就能理解为什么需要变量$last$了，有了变量$last$，我们就能知道回文树中是否已经存在了我们当前即将插入的这个字符c的节点了。不然的话，我们会重复插入。</p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>有了上面的前置知识，那么我们来解决这题：</p>
<p>题目想要求的是所有回文子串中的最大存在值，而每个回文串的最大存在值=该回文串出现的次数$\times$ 该回文串的长度</p>
<p>由回文树可知，利用回文树可以统计直接统计出每个回文串出现的次数和回文串的长度，因此这题可以直接使用回文树来解决。</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">//len[i]:表示编号为i的这个节点所表示的回文串的长度</span></span><br><span class="line"><span class="comment">//ch[i][c]:表示在编号为i的节点所表示的回文串前后两端加上字符c后所形成的新的回文串</span></span><br><span class="line"><span class="comment">//这个新的回文串可以用一个节点来表示 也就是ch[i][c] ch[i][c]也就是新的回文串所对应的状态节点</span></span><br><span class="line"><span class="comment">//fail[i]:表示节点i失配后应该跳转到不等于自身的最长回文后缀所对应的节点</span></span><br><span class="line"><span class="comment">//cnt[i]:表示节点i所表示的回文串的出现次数</span></span><br><span class="line"><span class="comment">//last:表示上一个插入字符所在的节点</span></span><br><span class="line"><span class="comment">//tot:表示这个回文树中添加的节点个数(不包括奇根和偶根) 我们用tot=0来表示了$字符</span></span><br><span class="line"><span class="comment">//因此tot是从1开始来表示题目中输入的字符的</span></span><br><span class="line"><span class="comment">//sz:表示这个回文数中的节点总数(包括奇根和偶根) 初始化时sz=-1,然后规定sz=0表示偶根 sz=1表示奇根</span></span><br><span class="line"><span class="comment">// 最终sz=tot+1</span></span><br><span class="line"><span class="comment">//n添加的字符个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> sz, tot, last;</span><br><span class="line"><span class="keyword">int</span> cnt[N], ch[N][<span class="number">26</span>], len[N], fail[N];</span><br><span class="line"><span class="keyword">char</span> s[N];  <span class="comment">//字符串  下标从1开始</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">node</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">//建立一个新节点，长度为x</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sz++;   <span class="comment">//新建了一个节点  因此节点总数+1</span></span><br><span class="line">    <span class="built_in">memset</span>(ch[sz], <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(ch[sz]));  <span class="comment">//该节点目前还没有孩子节点</span></span><br><span class="line">    len[sz] = x;    <span class="comment">//sz这个节点的所表示的回文长度为x 就是它自身的长度</span></span><br><span class="line">    <span class="comment">//对于新插入的一个字符  我们都规定它的fail指向的是偶根0</span></span><br><span class="line">    fail[sz] = cnt[sz] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> sz;  <span class="comment">//得到新建出来的这个节点的编号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="comment">//初始化</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sz = <span class="number">-1</span>;</span><br><span class="line">    last = <span class="number">0</span>;</span><br><span class="line">    s[tot] = <span class="string">&#x27;$&#x27;</span>;</span><br><span class="line">    <span class="built_in">node</span>(<span class="number">0</span>);    <span class="comment">//建立偶根节点</span></span><br><span class="line">    <span class="built_in">node</span>(<span class="number">-1</span>);   <span class="comment">//建立奇根节点</span></span><br><span class="line">    <span class="comment">//特殊地规定 0号点的fail指针指向1 也就是偶根的fail指向的是奇根</span></span><br><span class="line">    <span class="comment">//非0、1号点并且后缀中不存在回文串的节点(其实也就是单个字符)不指向它本身，而是指向0</span></span><br><span class="line">    fail[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getfail</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">//找后缀回文</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//查看区间[tot - len[x],tot-1]内的字符串S已经是回文串了</span></span><br><span class="line">    <span class="comment">//s[tot - len[x] - 1]是S左端点前面的一个字符  s[tot]是S右端点的下一个新增的字符c  如果它俩不匹配</span></span><br><span class="line">    <span class="comment">//那么就顺着fail指针去到这个字符串S的内部寻找最大的回文后缀</span></span><br><span class="line">    <span class="keyword">while</span> (s[tot - len[x] - <span class="number">1</span>] != s[tot])</span><br><span class="line">        x = fail[x];</span><br><span class="line">    <span class="keyword">return</span> x;   <span class="comment">//找到了最大的回文后缀</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> c)</span> <span class="comment">//建树</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s[++tot] = c;</span><br><span class="line">    <span class="comment">//设此时得到的回文后缀所对应的节点是now  设其回文后缀是Q</span></span><br><span class="line">    <span class="keyword">int</span> now = <span class="built_in">getfail</span>(last);</span><br><span class="line">    <span class="keyword">if</span> (!ch[now][c - <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//在回文后缀前后两端添加字符c后 得到回文串cQc 对应的状态节点是x 同时其回文长度是len[now] + 2</span></span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">node</span>(len[now] + <span class="number">2</span>);</span><br><span class="line">        <span class="comment">//注意下面的这两个顺序不能相反</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//找到x的fail指针应该连向的节点是哪个  那么我们就顺着now的fail指针走 直到不能走为止</span></span><br><span class="line">        fail[x] = ch[<span class="built_in">getfail</span>(fail[now])][c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        ch[now][c - <span class="string">&#x27;a&#x27;</span>] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    last = ch[now][c - <span class="string">&#x27;a&#x27;</span>];    <span class="comment">//将当前节点ch[now][c - &#x27;a&#x27;]给last  更新last</span></span><br><span class="line">    cnt[last]++;    <span class="comment">//last状态节点所表示的回文串的出现次数+1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//这里需要从sz遍历到0  因为fail[0]=1是存在的</span></span><br><span class="line">    <span class="comment">//cnt[p]表示回文串p出现的次数 我们知道p表示的是最长回文串 不妨设p=&quot;cQcQc&quot;,那么每次p出现的时候</span></span><br><span class="line">    <span class="comment">//其回文后缀cQc,c是不是也跟着出现一次呢  因此我们当p出现的时候</span></span><br><span class="line">    <span class="comment">//我们一定要记得把p中的回文后缀的出现次数也更新  即也要更新cQc和c的出现次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = sz; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        cnt[fail[i]] += cnt[i];</span><br><span class="line">    <span class="comment">//这里其实从0到sz也是可以的   只不过由于node(0)时初始化len[0]=0了</span></span><br><span class="line">    <span class="comment">//因此len[0]*cnt[0]=0*cnt[0]=0  不影响答案</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sz; i++)   <span class="comment">//更新答案</span></span><br><span class="line">        ans = <span class="built_in">max</span>(ans, <span class="number">1LL</span> * len[i] * cnt[i]);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>(); <span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; s[i]; i++)</span><br><span class="line">        <span class="built_in">insert</span>(s[i]);   <span class="comment">//将字符插入到回文树中</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">query</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>回文树</tag>
      </tags>
  </entry>
  <entry>
    <title>宠物小精灵之收服</title>
    <url>/2021/08/28/Algorithm-Improvement/Chapter1---Dynamic%20Programming/%E8%83%8C%E5%8C%85%E6%A8%A1%E5%9E%8B/01%E8%83%8C%E5%8C%85%E6%A8%A1%E5%9E%8B/%E5%AE%A0%E7%89%A9%E5%B0%8F%E7%B2%BE%E7%81%B5%E4%B9%8B%E6%94%B6%E6%9C%8D/</url>
    <content><![CDATA[<h1 id="宠物小精灵之收服"><a href="#宠物小精灵之收服" class="headerlink" title="宠物小精灵之收服"></a>宠物小精灵之收服</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210828171020.png" alt="image-20210828171020531"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>从题干中抽取”收服野生小精灵需要花费精灵球”和”收服野生小精灵需要花费皮卡丘的体力值”，这是两个约束条件，每次只允许用一个精灵球来收服一个野生小精灵，因此这是一道二维费用01背包问题。</p>
<p>第一维表示收服野生小精灵所需要花费精灵球的数量，第二维表示收服野生小精灵所需要花费皮卡丘的体力值</p>
<ul>
<li>体积1：精灵球数量</li>
<li>体积2：皮卡丘体力</li>
<li>价值：小精灵数量</li>
</ul>
<p>状态表示：<code>f[i][j][k]</code>表示只从前i个物品中选，体积1不超过j，体积2不超过k的选法集合的最大价值</p>
<p>状态计算：$f[i][j][k] = max(f[i - 1][j][k], f[i - 1][j - v1[i]][k - v2[i]] + 1)$</p>
<p>注意：使得皮卡丘体力小于等于0的野生小精灵也不会被小智收服，设皮卡丘的最大体力为$x$，那么不可能用到$x$，至少得留下一个体力吧(题意描述的)，因此最多用到的体力值是$x-1$而不是$x$</p>
<p>那么最多收服野生小精灵的数量为$f[K][N][M-1]$</p>
<p>那么我们该如何求出剩余的最大体力值呢？</p>
<p>我们可以先考虑收服这么多野生小精灵受到的最小伤害是$f[K][N][m]=f[K][N][M-1]$，其中$m$可取0,1,2..,M-1，那么剩余的最大体力就是$M-m$。</p>
<p>注意：$f[K][N][]$数组一定是单调递增的，即精灵球数量一致时，皮卡丘体力用的越多收服的精灵也一定越多，因此我们可以正序或逆序去扫描一遍$f[K][N][]$，找到值等于最优解的$f[K][N][M - 1]$的最小体力$k$，那么此时的$k$含义就是收服这些野生小精灵消耗的最少体力值，那么剩余的最大体力值就是$M-k$</p>
<p>参考01背包可以把二维数组优化为一维数组，这里也可以进行优化。</p>
<blockquote>
<p>问题：为什么是k&gt;0&amp;&amp;$f[m1][k-1]==f[m1][m2-1]$呢？</p>
<p>首先$k&gt;0$，是因为题目说了皮卡丘的体力不能为0，至少要有1血。然后$f[m1][m2-1]$是我们求出来的能够收服的最多野生小精灵的数量。这里为什么是$f[m1][k-1]$而不是$f[m1][k]$主要是因为比如$f$值有1 3 5 6 6 6 ，如果写成$f[m1][k]$，那么最终$k$停在了值为5的地方，但是使用$f[m1][k-1]$，那么最终$k$停在了值为$6$的地方，而这个6就是最左侧的，它所对应的体力值就是最小的，正是我们需要的答案。</p>
</blockquote>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>,M=<span class="number">510</span>;</span><br><span class="line"><span class="comment">//f[j][k]表示花费了j个精灵球,花费了k个体力值,所获得的野生小精灵的最大数量</span></span><br><span class="line"><span class="keyword">int</span> f[N][M];</span><br><span class="line"><span class="comment">//m1表示小智的精灵球数量 m2表示皮卡丘初始的体力值 n表示野生小精灵的数量</span></span><br><span class="line"><span class="keyword">int</span> n,m1,m2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;m1,&amp;m2,&amp;n);</span><br><span class="line">    <span class="comment">//把野生小精灵当作物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)    <span class="comment">//枚举物品</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v1,v2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;v1,&amp;v2);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=m1;j&gt;=v1;j--) <span class="comment">//枚举花费1小智的精灵球数量</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=m2;k&gt;=v2;k--) <span class="comment">//枚举花费2皮卡丘的体力值</span></span><br><span class="line">            &#123;</span><br><span class="line">                f[j][k]=<span class="built_in">max</span>(f[j][k],f[j-v1][k-v2]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//由于使得皮卡丘体力小于等于0的野生小精灵也不会被小智收服</span></span><br><span class="line">    <span class="comment">//因此皮卡丘的体力值不可能用到最大m2  最多就用到体力m2-1  至少得剩下1血吧</span></span><br><span class="line">    <span class="comment">//最多收服f[m1][m2-1]个野生小精灵</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,f[m1][m2<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">int</span> k=m2<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//找到那些价值等于f[m1][m2-1]的花费体力值最小的那个</span></span><br><span class="line">    <span class="keyword">while</span>(k&gt;<span class="number">0</span>&amp;&amp;f[m1][k<span class="number">-1</span>]==f[m1][m2<span class="number">-1</span>])</span><br><span class="line">        k--;</span><br><span class="line">    <span class="comment">//上面的k求出来的是 消耗的最少体力值是k</span></span><br><span class="line">    <span class="comment">//那么剩余体力值最多为m2-k</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,m2-k);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>背包模型</category>
      </categories>
      <tags>
        <tag>二维费用01背包</tag>
      </tags>
  </entry>
  <entry>
    <title>HH的项链</title>
    <url>/2021/08/16/Algorithm-Advanced/Chapter2---Data-Structure/%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95/%E8%8E%AB%E9%98%9F%E4%B9%8B%E5%9F%BA%E7%A1%80%E8%8E%AB%E9%98%9F/HH%E7%9A%84%E9%A1%B9%E9%93%BE/</url>
    <content><![CDATA[<h1 id="HH的项链"><a href="#HH的项链" class="headerlink" title="HH的项链"></a>HH的项链</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210816204831.png" alt="image-20210816204831076"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>题意：求一段区间内不同数的个数</p>
<p>这题为了了解莫队算法，就用莫队算法来写吧（但是<a href="https://www.luogu.com.cn/problem/P1972">洛谷P1972</a>把莫队算法给卡了）。莫队算法是一种离线查询的算法</p>
<p>设$n$是序列的总个数，$m$是询问次数</p>
<p>当$n$和$m$同阶时，时间复杂度是$O(n\sqrt n)$</p>
<p>但是但是对于$m$的其他取值，如$m&lt;n$，分块方式需要改变才能变的更优。</p>
<p>那么该怎么分块呢？</p>
<p>我们设块长度为$a$，那么对于任意多个在同一块内的询问，挪动的距离就是$n$，一共有$\dfrac {n}{a}$个块，移动的总次数就是$\dfrac {n^2}{a}$，移动可能跨越块，所以还要加上一个$ma$的复杂度，总复杂度为$O(\dfrac {n^2}{a}+ma)$，我们要让这个值尽量小，那么就要将这两个项尽量相等，也就是$\dfrac {n^2}{a}=ma$，解得$a=\dfrac {n}{\sqrt m}$是最优的，此时复杂度为$O(\dfrac {n^2}{\dfrac {n}{\sqrt m}}+m\times\dfrac{n}{\sqrt m})=O(n\sqrt m)$</p>
<p>莫队算法在排序时，普通原则是这样的：如果$A$和$B$不在同一个块内，即$pos[A.l]\neq pos[B.l]$，则按块号进行从小到达排序，即$pos[A.l]&lt;pos[B].l$；否则如果在同一个块内，则按右端点排序从小到大排序，即$A.r&lt;B.r$</p>
<p>如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Query &amp;A,<span class="keyword">const</span> Query &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pos[A.l]==pos[B.l]?A.r&lt;B.r:pos[A.l]&lt;pos[B.l];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果使用了奇偶化排序，那么原则是这样的：当他俩不属于同一个块时，比较A.l和B.l是否相等，如果不相等 则按A.l&lt;B.l排序；对于属于奇数块的询问，r 按从小到大排序，对于属于偶数块的排序，r 从大到小排序，这样我们的 r 指针在处理完这个奇数块的问题后，将在返回的途中处理偶数块的问题，再向 n 移动处理下一个奇数块的问题，优化了 r 指针的移动次数</p>
<p>如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Query &amp;A,<span class="keyword">const</span> Query &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">//写法二：使用奇偶化排序  不压行</span></span><br><span class="line"><span class="comment">//    if(pos[A.l]!=pos[B.l])  //不在同一个块内</span></span><br><span class="line"><span class="comment">//        return A.l&lt;B.l;</span></span><br><span class="line"><span class="comment">//    if(pos[A.l]&amp;1)  //奇数块</span></span><br><span class="line"><span class="comment">//        return A.r&lt;B.r;</span></span><br><span class="line"><span class="comment">//    else    //偶数块</span></span><br><span class="line"><span class="comment">//        return A.r&gt;B.r;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//写法三：使用奇偶化排序  压行</span></span><br><span class="line">    <span class="keyword">return</span> pos[A.l]^pos[B.l]?A.l&lt;B.l:(pos[A.l]&amp;<span class="number">1</span>)?A.r&lt;B.r:A.r&gt;B.r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面解释这段代码的意思：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(q[i].l&lt;l) <span class="built_in">add</span>(w[--l],res);</span><br><span class="line"><span class="keyword">while</span>(q[i].r&gt;r) <span class="built_in">add</span>(w[++r],res);</span><br><span class="line"><span class="keyword">while</span>(q[i].l&gt;l) <span class="built_in">del</span>(w[l++],res);</span><br><span class="line"><span class="keyword">while</span>(q[i].r&lt;r) <span class="built_in">del</span>(w[r--],res);</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210816211936.png" alt="image-20210816211936652"></p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210816212046.png" alt="image-20210816212046005"></p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">50010</span>,M=<span class="number">2e5</span>+<span class="number">10</span>,S=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id,l,r; <span class="comment">//id存储的是第几次询问  l是询问的左端点  r是询问的右端点 </span></span><br><span class="line">&#125;q[M];</span><br><span class="line"><span class="comment">//pos[i]=x表示第i个数是在x块内  ans记录询问的答案</span></span><br><span class="line"><span class="keyword">int</span> w[N],pos[N],ans[M];</span><br><span class="line"><span class="comment">//cnt[i]=a表示w[i]这个数出现了a次  记录某个数的出现次数</span></span><br><span class="line"><span class="keyword">int</span> cnt[S];</span><br><span class="line"><span class="keyword">int</span> n,m,len;    <span class="comment">//len是每个块的大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">奇偶化排序的思想：</span></span><br><span class="line"><span class="comment">当他俩不属于同一个块时，比较A.l和B.l是否相等，如果不相等 则按A.l&lt;B.l排序</span></span><br><span class="line"><span class="comment">对于属于奇数块的询问，r 按从小到大排序，对于属于偶数块的排序，r 从大到小排序</span></span><br><span class="line"><span class="comment">这样我们的 r 指针在处理完这个奇数块的问题后，将在返回的途中处理偶数块的问题，</span></span><br><span class="line"><span class="comment"> 再向 n 移动处理下一个奇数块的问题，优化了 r 指针的移动次数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Query &amp;A,<span class="keyword">const</span> Query &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//写法一：不使用奇偶化排序</span></span><br><span class="line">    <span class="comment">//return pos[A.l]==pos[B.l]?A.r&lt;B.r:pos[A.l]&lt;pos[B.l];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//写法二：使用奇偶化排序  不压行</span></span><br><span class="line"><span class="comment">//    if(pos[A.l]!=pos[B.l])  //不在同一个块内</span></span><br><span class="line"><span class="comment">//        return A.l&lt;B.l;</span></span><br><span class="line"><span class="comment">//    if(pos[A.l]&amp;1)  //奇数块</span></span><br><span class="line"><span class="comment">//        return A.r&lt;B.r;</span></span><br><span class="line"><span class="comment">//    else    //偶数块</span></span><br><span class="line"><span class="comment">//        return A.r&gt;B.r;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//写法三：使用奇偶化排序  压行</span></span><br><span class="line">    <span class="keyword">return</span> pos[A.l]^pos[B.l]?A.l&lt;B.l:(pos[A.l]&amp;<span class="number">1</span>)?A.r&lt;B.r:A.r&gt;B.r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> &amp;res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!cnt[x]) <span class="comment">//如果还没有出现过x这个数</span></span><br><span class="line">        res++;  <span class="comment">//不同的数的个数+1</span></span><br><span class="line">    cnt[x]++;   <span class="comment">//记录x这个数的出现次数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> &amp;res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt[x]--;       <span class="comment">//x这个数的出现次数-1</span></span><br><span class="line">    <span class="keyword">if</span>(!cnt[x]) <span class="comment">//如果为cnt[x]=0了 则说明x的出现次数为0  </span></span><br><span class="line">        res--;  <span class="comment">//那么不同数的个数-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w[i]);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">    len=<span class="built_in">sqrt</span>(<span class="number">1.0</span>*n*n/m);    <span class="comment">//每个块的大小</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   <span class="comment">//记录每个数是属于哪个块</span></span><br><span class="line">        pos[i]=i/len;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)    <span class="comment">//读入m个询问</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l,r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">        q[i]=&#123;i,l,r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(q,q+m,cmp);    <span class="comment">//将这些询问排序</span></span><br><span class="line">    <span class="comment">//这里初始化一定要写成l比r大 这样才能表示这个区间是空的</span></span><br><span class="line">    <span class="comment">//假设l=r=0,则区间[0,0]中有0这个元素  这样子是不正确的 初始时区间内不能有任何信息</span></span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">1</span>,r=<span class="number">0</span>;    <span class="comment">//当前维护的区间是[l,r]</span></span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;  <span class="comment">//记录某次询问中 不同数的个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> id=q[i].id;</span><br><span class="line">        <span class="comment">//这四个while的顺序不能随便调换</span></span><br><span class="line">        <span class="keyword">while</span>(q[i].l&lt;l) <span class="built_in">add</span>(w[--l],res);</span><br><span class="line">        <span class="keyword">while</span>(q[i].r&gt;r) <span class="built_in">add</span>(w[++r],res);</span><br><span class="line">        <span class="keyword">while</span>(q[i].l&gt;l) <span class="built_in">del</span>(w[l++],res);</span><br><span class="line">        <span class="keyword">while</span>(q[i].r&lt;r) <span class="built_in">del</span>(w[r--],res);</span><br><span class="line">        ans[id]=res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)    <span class="comment">//输出这m次询问的结果</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>莫队算法</category>
      </categories>
      <tags>
        <tag>莫队之基础莫队</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉查找树</title>
    <url>/2021/08/27/Algorithm-Advanced/Chapter2---Data-Structure/Splay/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/</url>
    <content><![CDATA[<h1 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h1><hr>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>二叉查找树(Binary Search Tree，BST)，又叫做二叉排序树、二叉搜索树，是一种对查找和排序都有用的特殊二叉树。</p>
<p>二叉查找树或是空树，或是满足如下三个性质的二叉树：</p>
<ul>
<li>若其左子树非空，则左子树上所有节点的值都小于根节点的值</li>
<li>若其右子树非空，则右子树上所有节点的值都大于根节点的值</li>
<li>其左右子树都是一棵二叉查找树</li>
</ul>
<p>二叉查找树的特性：左子树&lt;根&lt;右子树，即二叉查找树的中序遍历是一个递增序列。</p>
<p>如下图所示，其中序遍历为{5,18,29,25,32,25,69}</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210827132158.png" alt="image-20210827132158313"></p>
<p>我们来定义一下二叉查找树的数据结构：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;   <span class="comment">//节点数据域</span></span><br><span class="line">    BSTNode *lchild,*rchild;    <span class="comment">//左孩子指针  右孩子指针</span></span><br><span class="line">&#125;BSTNode,*BSTree;</span><br></pre></td></tr></table></figure>
<p>也就是说我们用类型<code>BSTNode</code>代替了类型<code>struct BSTNode</code>，用类型<code>BSTree</code>代替了类型<code>struct BSTNode*</code>，此时就要注意了<code>BSTree</code>就是一个指针类型哦</p>
<hr>
<h3 id="二叉查找树的查询"><a href="#二叉查找树的查询" class="headerlink" title="二叉查找树的查询"></a>二叉查找树的查询</h3><p>因为二叉查找树的中序遍历有序性，即得到的递增的序列，由于有序，因此其查找与二分查找类似，每次都可以缩小查找范围，查询效率较高。</p>
<p><strong>算法步骤：</strong></p>
<ul>
<li>若二叉查找树为空，则查找失败，返回空指针</li>
<li>若二叉查找树非空，则将待查找关键字key与根节点的关键字$T-&gt;data$进行比较：<ul>
<li>如果$x=T-&gt;data$，则查找成功，返回查询到的当前节点T</li>
<li>如果$x<T->data$，则递归查找左子树</li>
<li>如果$x&gt;T-&gt;data$，则递归查找右子树</li>
</ul>
</li>
</ul>
<p>如下图所示，查找关键字32：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210827133612.png" alt="image-20210827133612101"></p>
<p>（1）将32与二叉查找树的树根25比较，发现$32&gt;25$，于是到右子树中查询，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210827133631.png" alt="image-20210827133631125"></p>
<p>（２）将32与右子树的树根69比较，发现$32&lt;69$，于是到左子树中查询，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210827133644.png" alt="image-20210827133644671"></p>
<p>（3）将32与左子树的树根32比较，发现$32=32$，相等，查询成功，返回该节点的指针，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210827133710.png" alt="image-20210827133710524"></p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二叉排序树的递归查找</span></span><br><span class="line"><span class="function">BSTree <span class="title">find</span><span class="params">(BSTree T,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果二叉排序树为空则返回T为NULL 或者查找成功则返回指向该数据元素结点的指针</span></span><br><span class="line">    <span class="keyword">if</span>(!T||T-&gt;data==key)</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    <span class="comment">//递归查找左子树</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key&lt;T-&gt;data)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(T-&gt;lchild,key);</span><br><span class="line">    <span class="comment">//递归查找右子树</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(T-&gt;rchild,key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>算法分析：</p>
<ul>
<li>时间复杂度：最好情况是$O(logn)$，最坏情况是$O(n)$</li>
<li>空间复杂度：$O(1)$</li>
</ul>
<hr>
<h3 id="二叉查找树的插入"><a href="#二叉查找树的插入" class="headerlink" title="二叉查找树的插入"></a>二叉查找树的插入</h3><p>因为二叉查找树的中序遍历存在有序性，所以首先要查找待插入元素的插入位置，当查找不成功时再将待插入元素作为新的叶子节点成为最后一个查找节点的左孩子或者右孩子。</p>
<p><strong>算法步骤：</strong></p>
<ul>
<li>若二叉查找树为空，则创建一个新的节点$S$，将待插入关键字放入新节点的数据域，然后将$S$节点作为根节点，$S$节点的左右子树都设置为空。</li>
<li>若二叉查找树非空，则将带插入元素e和根节点的关键字$T-&gt;data$比较：<ul>
<li>如果$e<T->data$，则将$e$插入到左子树中</li>
<li>如果$e&gt;T-&gt;data$，则将$e$插入到右子树中</li>
</ul>
</li>
</ul>
<p>如图，向其中插入元素30：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210827133612.png" alt="image-20210827133612101"></p>
<p>（1）将30与根节点25比较，发现$25&lt;30$，因此到右子树中查询，如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210827134816.png" alt="image-20210827134816782"></p>
<p>（2）将30与右子树的树根69比较，发现$30&lt;69$，则到69的左子树中查询，如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210827134827.png" alt="image-20210827134827165"></p>
<p>（3）将30与左子树的树根32比较，发现$30&lt;32$，在32的左子树中查找，如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210827134840.png" alt="image-20210827134840693"></p>
<p>（4）将30作为新的叶子节点插入到32的左子树中，如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210827134850.png" alt="image-20210827134850443"></p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二叉排序树的插入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(BSTree &amp;T,<span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果二叉查找树为空</span></span><br><span class="line">    <span class="keyword">if</span>(!T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//则创建一个新的节点S</span></span><br><span class="line">        BSTree S=<span class="keyword">new</span> BSTNode;</span><br><span class="line">        <span class="comment">//将待插入关键字e放入新节点S的数据域中</span></span><br><span class="line">        S-&gt;data=e;</span><br><span class="line">        <span class="comment">//新节点S的左右子树都为空</span></span><br><span class="line">        S-&gt;lchild=S-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//将新节点S作为根节点</span></span><br><span class="line">        T=S;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果二叉排序树非空 则将待插入关键字e与根节点的关键字T-&gt;data比较</span></span><br><span class="line">    <span class="comment">//如果e&lt;T-&gt;data,则说明应该将x插入到左子树中</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(e&lt;T-&gt;data)</span><br><span class="line">        <span class="built_in">insert</span>(T-&gt;lchild,e);</span><br><span class="line">    <span class="comment">//如果e&gt;T-&gt;data,则说明应该将x插入到右子树中</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(e&gt;T-&gt;data)</span><br><span class="line">        <span class="built_in">insert</span>(T-&gt;rchild,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>算法分析：</strong></p>
<p>在二叉查找树中进行插入操作时需要先查找插入位置，插入本身只需要常数时间，但是查找插入位置的时间复杂度为$O(logn)$</p>
<hr>
<h3 id="二叉查找树的创建"><a href="#二叉查找树的创建" class="headerlink" title="二叉查找树的创建"></a>二叉查找树的创建</h3><p>二叉查找树的创建可以从空树开始，按照输入关键字的顺序依次进行插入操作，最终得到一棵二叉查找树。</p>
<p><strong>算法步骤：</strong></p>
<ul>
<li>初始化二叉查找树为空树，$T=NULL$</li>
<li>输入一个关键字$e$，将$e$插入到二叉查找树T中</li>
<li>重复步骤2，直到关键字输入完毕。</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二叉排序树的创建</span></span><br><span class="line"><span class="comment">//二叉查找树的创建可以从空树开始 按照输入关键字的顺序依次进行插入操作 最终得到一棵二叉排序树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(BSTree &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T=<span class="literal">NULL</span>; <span class="comment">//从空树开始 初始化二叉排序树为空树</span></span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">    <span class="comment">//每输入一个节点</span></span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;e,e!=<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">insert</span>(T,e);    <span class="comment">//则把该节点插入到二叉排序树中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>算法分析：</strong></p>
<p>有$n$个即将插入的元素，因此二叉查找树的创建需要$n$次插入，每次插入在最好情况和平均情况下都需要$O(logn)$时间，在最坏情况需要$O(n)$时间，因此在最好情况和平均情况下的时间复杂度为$O(nlogn)$，最坏情况下的时间复杂度为$O(n^2)$</p>
<p>创建二叉查找树时，输入序列的次序不同， 创建的二叉查找树也是不同的。</p>
<hr>
<h3 id="二叉查找树的删除"><a href="#二叉查找树的删除" class="headerlink" title="二叉查找树的删除"></a>二叉查找树的删除</h3><p>首先在二叉查找树中找到待删除节点，然后执行删除操作。假设指针p指向待删除节点，指针f指向p的父节点。根据待删除节点所在位置的不同，删除操作的处理方法也不同，可以分为以下三种情况：</p>
<p>（1）被删除节点的左子树为空：那么令其右子树子承父业代替被删除节点的位置即可。</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210827140626.png" alt="image-20210827140625948"></p>
<p>（2）被删除节点的右子树为空：那么令其左子树子承父业代替被删除节点的位置即可。</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210827140637.png" alt="image-20210827140637470"></p>
<p>（3）被删除节点的左右子树都不为空：如果被删除节点的左右子树都不为空，那么就不能采用子承父业的方法了。根据二叉查找树的中序遍历有序性，删除该节点，可以利用其直接前驱或者直接后继来代替被删除节点的位置，然后删除其直接前驱或者其直接后继即可。</p>
<p>那么在中序遍历中，一个节点的直接前驱或者直接后继是哪个节点呢？</p>
<p>其实$x$的直接前驱就是那些$<x$中的最大的那个节点，$x$的直接后继就是那些$>x$中的最小的那个节点</p>
<ul>
<li>直接前驱：在中序遍历中，节点p的直接前驱就是其<strong>左子树中的最右节点</strong>。即沿着p的左子树一直访问其右子树，直到没有右子树，这样就找到了最右节点，也就是直接前驱。如图a</li>
<li>直接后继：在中序遍历中，节点p的直接后继就是其<strong>右子树中的最左节点</strong>。即沿着p的右子树一直访问其左子树，直到没有左子树，这样就找到了最左节点，也就是直接后继。如图b</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210827140705.png" alt="image-20210827140705115"></p>
<p>以找直接前驱为栗子：在二叉查找树中删除24。首先找到24的位置p，然后找到p的直接前驱s(22)，把22赋值给p的数据域，删除s，删除过程如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210827140927.png" alt="image-20210827140927472"></p>
<p>删除节点之后是不是仍然满足二叉查找树的中序遍历有序性呢？</p>
<p>需要注意的是，有一种特殊情况，即p的左孩子没有右子树，s就是其左子树的最右节点(直接前驱)，即s代替p，然后删除s即可。因为s为最右节点且没有右子树，删除后，左子树子承父业。</p>
<p>举个栗子：在二叉查找树中删除20，删除过程如下图所示，由图可知，20的左孩子是8，8没有右子树了，那么8就是20的左子树的最右节点了，即8是20的直接前驱。</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210827141515.png" alt="image-20210827141515371"></p>
<p><strong>算法步骤：</strong></p>
<ul>
<li>在二叉查找树中查找待删除关键字的位置，p指向待删除节点，f指向p的父节点。如果查找失败，则返回</li>
<li>如果查找成功，则分为三种情况进行删除操作：<ul>
<li>如果被删除节点的左子树为空，则令其右子树子承父业代替其位置即可</li>
<li>如果被删除节点的右子树为空，则令其左子树子承父业代替其位置即可</li>
<li>如果被删除节点的左右子树都不为空，则令其直接前驱或者直接后继代替它，再删除其直接前驱或者直接后继即可</li>
</ul>
</li>
</ul>
<p>（1）左子树为空。在二叉查找树中删除32，首先查找到32所在的位置，判断其左子树为空，则令其右子树子承父业代替其位置，删除过程如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210827142353.png" alt="image-20210827142353368"></p>
<p>（2）右子树为空。在二叉查找树中删除69，首先查找到69所在的位置，判断其右子树为空，则令其左子树子承父业代替其位置，删除过程如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210827142422.png" alt="image-20210827142422008"></p>
<p>（3）左右子树都不为空。在二叉查找树中删除25，首先查找到25所在的位置，判断其左右子树都不为空，则令其直接前驱(左子树最右节点是20)代替它，在删除其直接前驱20，删除20时i，其左子树代替其位置。删除过程如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210827142444.png" alt="image-20210827142444487"></p>
<p>二叉查找树的删除操作较为复杂，代码要结合上面的图示理解</p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二叉排序树的删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(BSTree &amp;T,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//从二叉排序树T中删除关键字等于key的结点</span></span><br><span class="line">    BSTree p=T;</span><br><span class="line">    BSTree f=<span class="literal">NULL</span>;</span><br><span class="line">    BSTree q,s;</span><br><span class="line">    <span class="keyword">if</span>(!T) <span class="keyword">return</span>; <span class="comment">//树为空则返回</span></span><br><span class="line">    <span class="keyword">while</span>(p)<span class="comment">//查找</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data==key)</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">//找到关键字等于key的结点p，结束循环</span></span><br><span class="line">        f=p;                <span class="comment">//f为p的双亲</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;data&gt;key)</span><br><span class="line">            p=p-&gt;lchild; <span class="comment">//在p的左子树中继续查找</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p=p-&gt;rchild; <span class="comment">//在p的右子树中继续查找</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p)</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">//找不到被删结点则返回</span></span><br><span class="line">    <span class="comment">//三种情况：p左右子树均不空、无右子树、无左子树</span></span><br><span class="line">    <span class="keyword">if</span>((p-&gt;lchild)&amp;&amp;(p-&gt;rchild))<span class="comment">//被删结点p左右子树均不空</span></span><br><span class="line">    &#123;</span><br><span class="line">        q=p;</span><br><span class="line">        s=p-&gt;lchild;</span><br><span class="line">        <span class="keyword">while</span>(s-&gt;rchild)<span class="comment">//在p的左子树中继续查找其前驱结点，即最右下结点</span></span><br><span class="line">        &#123;</span><br><span class="line">            q=s;</span><br><span class="line">            s=s-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;data=s-&gt;data;  <span class="comment">//s的值赋值给被删结点p,然后删除s结点</span></span><br><span class="line">        <span class="keyword">if</span>(q!=p)</span><br><span class="line">            q-&gt;rchild=s-&gt;lchild; <span class="comment">//重接q的右子树</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            q-&gt;lchild=s-&gt;lchild; <span class="comment">//重接q的左子树</span></span><br><span class="line">        <span class="keyword">delete</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!p-&gt;rchild)<span class="comment">//被删结点p无右子树，只需重接其左子树</span></span><br><span class="line">        &#123;</span><br><span class="line">            q=p;</span><br><span class="line">            p=p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!p-&gt;lchild)<span class="comment">//被删结点p无左子树，只需重接其右子树</span></span><br><span class="line">        &#123;</span><br><span class="line">            q=p;</span><br><span class="line">            p=p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*――――――――――将p所指的子树挂接到其双亲结点f相应的位置――――――――*/</span></span><br><span class="line">        <span class="keyword">if</span>(!f)</span><br><span class="line">            T=p;  <span class="comment">//被删结点为根结点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(q==f-&gt;lchild)</span><br><span class="line">            f-&gt;lchild=p; <span class="comment">//挂接到f的左子树位置</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            f-&gt;rchild=p;<span class="comment">//挂接到f的右子树位置</span></span><br><span class="line">        <span class="keyword">delete</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>算法分析：</p>
<p>二叉查找树的删除主要是查找的过程，需要$O(logn)$时间。在删除过程中，如果需要查找被删除节点前驱，则也需要$O(logn)$时间。所以，在二叉查找树中进行删除操作的时间复杂度为$O(logn)$</p>
<hr>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p>以下面这幅图为例子在DevC++上测试：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210827144402.png" alt="image-20210827144402278"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;   <span class="comment">//节点数据域</span></span><br><span class="line">    BSTNode *lchild,*rchild;    <span class="comment">//左孩子指针  右孩子指针</span></span><br><span class="line">&#125;BSTNode,*BSTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉排序树的插入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(BSTree &amp;T,<span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果二叉查找树为空</span></span><br><span class="line">    <span class="keyword">if</span>(!T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//则创建一个新的节点S</span></span><br><span class="line">        BSTree S=<span class="keyword">new</span> BSTNode;</span><br><span class="line">        <span class="comment">//将待插入关键字e放入新节点S的数据域中</span></span><br><span class="line">        S-&gt;data=e;</span><br><span class="line">        <span class="comment">//新节点S的左右子树都为空</span></span><br><span class="line">        S-&gt;lchild=S-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//将新节点S作为根节点</span></span><br><span class="line">        T=S;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果二叉排序树非空 则将待插入关键字e与根节点的关键字T-&gt;data比较</span></span><br><span class="line">    <span class="comment">//如果e&lt;T-&gt;data,则说明应该将x插入到左子树中</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(e&lt;T-&gt;data)</span><br><span class="line">        <span class="built_in">insert</span>(T-&gt;lchild,e);</span><br><span class="line">    <span class="comment">//如果e&gt;T-&gt;data,则说明应该将x插入到右子树中</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(e&gt;T-&gt;data)</span><br><span class="line">        <span class="built_in">insert</span>(T-&gt;rchild,e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉排序树的创建</span></span><br><span class="line"><span class="comment">//二叉查找树的创建可以从空树开始 按照输入关键字的顺序依次进行插入操作 最终得到一棵二叉排序树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(BSTree &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T=<span class="literal">NULL</span>; <span class="comment">//从空树开始 初始化二叉排序树为空树</span></span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">    <span class="comment">//每输入一个节点</span></span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;e,e!=<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">insert</span>(T,e);    <span class="comment">//则把该节点插入到二叉排序树中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历 原则：左根右</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BSTree &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">InOrderTraverse</span>(T-&gt;lchild);     <span class="comment">//左</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,T-&gt;data);      <span class="comment">//根</span></span><br><span class="line">        <span class="built_in">InOrderTraverse</span>(T-&gt;rchild);     <span class="comment">//右</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉排序树的递归查找</span></span><br><span class="line"><span class="function">BSTree <span class="title">find</span><span class="params">(BSTree T,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果二叉排序树为空则返回T为NULL 或者查找成功则返回指向该数据元素结点的指针</span></span><br><span class="line">    <span class="keyword">if</span>(!T||T-&gt;data==key)</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    <span class="comment">//递归查找左子树</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key&lt;T-&gt;data)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(T-&gt;lchild,key);</span><br><span class="line">    <span class="comment">//递归查找右子树</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(T-&gt;rchild,key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉排序树的删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(BSTree &amp;T,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//从二叉排序树T中删除关键字等于key的结点</span></span><br><span class="line">    BSTree p=T;</span><br><span class="line">    BSTree f=<span class="literal">NULL</span>;</span><br><span class="line">    BSTree q,s;</span><br><span class="line">    <span class="keyword">if</span>(!T) <span class="keyword">return</span>; <span class="comment">//树为空则返回</span></span><br><span class="line">    <span class="keyword">while</span>(p)<span class="comment">//查找</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data==key)</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">//找到关键字等于key的结点p，结束循环</span></span><br><span class="line">        f=p;                <span class="comment">//f为p的双亲</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;data&gt;key)</span><br><span class="line">            p=p-&gt;lchild; <span class="comment">//在p的左子树中继续查找</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p=p-&gt;rchild; <span class="comment">//在p的右子树中继续查找</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p)</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">//找不到被删结点则返回</span></span><br><span class="line">    <span class="comment">//三种情况：p左右子树均不空、无右子树、无左子树</span></span><br><span class="line">    <span class="keyword">if</span>((p-&gt;lchild)&amp;&amp;(p-&gt;rchild))<span class="comment">//被删结点p左右子树均不空</span></span><br><span class="line">    &#123;</span><br><span class="line">        q=p;</span><br><span class="line">        s=p-&gt;lchild;</span><br><span class="line">        <span class="keyword">while</span>(s-&gt;rchild)<span class="comment">//在p的左子树中继续查找其前驱结点，即最右下结点</span></span><br><span class="line">        &#123;</span><br><span class="line">            q=s;</span><br><span class="line">            s=s-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;data=s-&gt;data;  <span class="comment">//s的值赋值给被删结点p,然后删除s结点</span></span><br><span class="line">        <span class="keyword">if</span>(q!=p)</span><br><span class="line">            q-&gt;rchild=s-&gt;lchild; <span class="comment">//重接q的右子树</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            q-&gt;lchild=s-&gt;lchild; <span class="comment">//重接q的左子树</span></span><br><span class="line">        <span class="keyword">delete</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!p-&gt;rchild)<span class="comment">//被删结点p无右子树，只需重接其左子树</span></span><br><span class="line">        &#123;</span><br><span class="line">            q=p;</span><br><span class="line">            p=p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!p-&gt;lchild)<span class="comment">//被删结点p无左子树，只需重接其右子树</span></span><br><span class="line">        &#123;</span><br><span class="line">            q=p;</span><br><span class="line">            p=p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*――――――――――将p所指的子树挂接到其双亲结点f相应的位置――――――――*/</span></span><br><span class="line">        <span class="keyword">if</span>(!f)</span><br><span class="line">            T=p;  <span class="comment">//被删结点为根结点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(q==f-&gt;lchild)</span><br><span class="line">            f-&gt;lchild=p; <span class="comment">//挂接到f的左子树位置</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            f-&gt;rchild=p;<span class="comment">//挂接到f的右子树位置</span></span><br><span class="line">        <span class="keyword">delete</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BSTree T;   <span class="comment">//整棵二叉排序树的根节点</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;请输入一些整型数，以-1结束&quot;</span>);</span><br><span class="line">    <span class="comment">//建立一棵二叉排序树</span></span><br><span class="line">    <span class="built_in">build</span>(T);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;当前有序二叉树中序遍历结果为&quot;</span>);</span><br><span class="line">    <span class="comment">//对这棵二叉排序树进行中序遍历</span></span><br><span class="line">    <span class="built_in">InOrderTraverse</span>(T);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;请输入待查找关键字&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;key);</span><br><span class="line">    <span class="comment">//在二叉排序树查找关键字key</span></span><br><span class="line">    BSTree ans=<span class="built_in">find</span>(T,key);</span><br><span class="line">    <span class="comment">//查找成功</span></span><br><span class="line">    <span class="keyword">if</span>(ans)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;找到%d了\n&quot;</span>,key);</span><br><span class="line">    <span class="keyword">else</span>    <span class="comment">//查找失败</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;没有找到%d\n&quot;</span>,key);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;请输入待删除关键字&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;key);</span><br><span class="line">    <span class="comment">//在二叉排序树中删除关键字key</span></span><br><span class="line">    <span class="built_in">del</span>(T,key);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;当前有序二叉树中序遍历结果为&quot;</span>);</span><br><span class="line">    <span class="comment">//对删除节点后的这棵二叉排序树进行中序遍历</span></span><br><span class="line">    <span class="built_in">InOrderTraverse</span>(T);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>二叉查找树</category>
      </categories>
      <tags>
        <tag>二叉查找树</tag>
      </tags>
  </entry>
  <entry>
    <title>后缀数组</title>
    <url>/2021/08/11/Algorithm-Advanced/Chapter2---Data-Structure/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="后缀数组"><a href="#后缀数组" class="headerlink" title="后缀数组"></a>后缀数组</h1><hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">n:代表字符串长度 m:代表字符集大小 </span></span><br><span class="line"><span class="comment">s数组：字符串数组,内容从下标1开始</span></span><br><span class="line"><span class="comment">rk数组:排名数组</span></span><br><span class="line"><span class="comment">c数组：基数排序的数组，下标为待排序的数字，值为该数字出现的次数。排序过程中，我们会对其求前缀和以便计算排名</span></span><br><span class="line"><span class="comment">x数组：是一个中间量数组，意义为得到第一关键字的大小，对于一次排序，下标为代表后缀编号，值为象征对应后缀编号第一关键字大小的值（事实上可以视作排名）</span></span><br><span class="line"><span class="comment">y数组：是一个中间量数组，意义为第二关键字的排名，对于一次排序，下标为排名，值为第二关键字对应的后缀的编号</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_sa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//统计该次第一关键字（首字母）的出现次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) c[x[i] = s[i]] ++ ;</span><br><span class="line">    <span class="comment">//计算前缀和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; i ++ ) c[i] += c[i - <span class="number">1</span>];	</span><br><span class="line">    <span class="comment">//计算第一次排序的sa,此次基数排序,仅区分首字母和后缀编号，首字母小的在前，首字母相同，后缀编号小（后缀长度大）的在前</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; i -- ) sa[c[x[i]] -- ] = i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//从21~31都是倍增计算y数组 先进行第二关键字排序</span></span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//有一些后缀拆分后的第二关键字为空，这个循环将这些后缀的排名提到最前，以表示空字符的最高优先级</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - k + <span class="number">1</span>; i &lt;= n; i ++ ) y[ ++ num] = i;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        对于满的第二关键字排序，利用某一后缀的后缀也是原串的后缀这一特点,由上一次的sa计算而来.</span></span><br><span class="line"><span class="comment">        考虑那些排名靠前的后缀，如果往前补倍增长度位，那么这个后缀对应的长度前缀就变成了第二关键字</span></span><br><span class="line"><span class="comment">        比如我们有后缀aa和abaa,长度为2,计算abaa的第二关键字的时候，实际上查到的是aa的排名，并且往前补了2位。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            <span class="keyword">if</span> (sa[i] &gt; k)</span><br><span class="line">                y[ ++ num] = sa[i] - k;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        从36~44是基数排序倍增计算x[] 这是对第一关键字排序 此时求得的x[]含义是旧的排名,是长度为2^k的排名</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ ) c[i] = <span class="number">0</span>;	<span class="comment">//清空</span></span><br><span class="line">        <span class="comment">//y[i]表示的是第二关键字排名为i的后缀编号  </span></span><br><span class="line">        <span class="comment">//而x[i]拿到的则是第一关键字排序时，后缀编号为i的后缀对应的象征第一关键字大小的值</span></span><br><span class="line">        <span class="comment">//（在初始化过程中，我们将该值设置为首字母的值了，因此，对初始化还有一种理解，即y[i] = i，并没对第二关键字排序）</span></span><br><span class="line">        <span class="comment">//因此x[y[i]]的值反映的是代表第一关键字大小的值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) c[x[y[i]]] ++ ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; i ++ ) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//对i逆序统计，其用意是：当第一关键字相同的时候，第二关键字排名大的，计算后sa的值也会更大</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; i -- ) sa[c[x[y[i]]] -- ] = y[i], y[i] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//从48~54都是在求新的x[],即求长度为2^(k+1)的排名</span></span><br><span class="line">        <span class="comment">//y已经清空了,把旧的x数组值换到y数组上</span></span><br><span class="line">        <span class="built_in">swap</span>(x, y);</span><br><span class="line">        <span class="comment">//规定当前排名第一的后缀x值为1,以后的后缀x值不会小于1</span></span><br><span class="line">        x[sa[<span class="number">1</span>]] = <span class="number">1</span>, num = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//考虑什么时候一个后缀和前面的后缀下一次的第一关键字=这一次的第一+第二关键字，因为是倍增）相同</span></span><br><span class="line">        <span class="comment">//只有这一次的第一第二关键字都相等才可以判定下一次的第一关键字相等，否则应该比上一次的大。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">            x[sa[i]] = (y[sa[i]] == y[sa[i - <span class="number">1</span>]] &amp;&amp; y[sa[i] + k] == y[sa[i - <span class="number">1</span>] + k]) ? num : ++ num;</span><br><span class="line">        <span class="comment">//当本次排序中已经产生了不小于n种不同的第一关键字的值，排序便没有必要继续下去了，因为已经区分开了这些后缀。</span></span><br><span class="line">        <span class="keyword">if</span> (num == n) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//本次排序更新了关键字的种类数，因此要更新m值  更新基数排序的值域</span></span><br><span class="line">        m = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="后缀数组的相关概念"><a href="#后缀数组的相关概念" class="headerlink" title="后缀数组的相关概念"></a>后缀数组的相关概念</h3><h5 id="后缀"><a href="#后缀" class="headerlink" title="后缀"></a>后缀</h5><p>后缀：指从某个位置开始到字符串末尾的一个特殊子串。字符串$s$从第$i$个字符开始的后缀被表示为$Suffix(i)$，也可以称之为下标为$i$的后缀。</p>
<p>例如字符串$s=$”$aabaaaab$”，其所有的后缀如下：</p>
<ul>
<li>$Suffix(0)=$”$aabaaaab$”</li>
<li>$Suffix(1)=$”$abaaaab$”</li>
<li>$Suffix(2)=$”$baaaab$”</li>
<li>$Suffix(3)=$”$aaaab$”</li>
<li>$Suffix(4)=$”$aaab$”</li>
<li>$Suffix(5)=$”$aab$”</li>
<li>$Suffix(6)=$”$ab$”</li>
<li>$Suffix(7)=$”$b$”</li>
</ul>
<h5 id="后缀数组-1"><a href="#后缀数组-1" class="headerlink" title="后缀数组"></a>后缀数组</h5><p>将所有后缀都从小到大排序之后，将排好序的后缀的下标$i$放入数组中，则该数组就叫做后缀数组（Suffix Array），$SA[num]=i$表示排名为$num$的后缀其下标为$i$</p>
<p>将上面的所有后缀都按字典序排序之后，取其下标$i$，即可得到后缀数组：</p>
<ul>
<li>$Suffix(3)=$”$aaaab$”</li>
<li>$Suffix(4)=$”$aaab$”</li>
<li>$Suffix(5)=$”$aab$”</li>
<li>$Suffix(0)=$”$aabaaaab$”</li>
<li>$Suffix(6)=$”$ab$”</li>
<li>$Suffix(1)=$”$abaaaab$”</li>
<li>$Suffix(7)=$”$b$”</li>
<li>$Suffix(2)=$”$baaaab$”</li>
</ul>
<p>后缀数组<code>SA[]=&#123;3,4,5,0,6,1,7,2&#125;</code></p>
<h5 id="排名数组"><a href="#排名数组" class="headerlink" title="排名数组"></a>排名数组</h5><p>排名数组是指下标为$i$的后缀排序后的名次，即第$i$个后缀排名是啥，$rank[i]=num$表示第$i$个后缀其排名为$num$</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>名次</th>
<th>下标</th>
<th>后缀</th>
</tr>
</thead>
<tbody>
<tr>
<td>num</td>
<td>i</td>
<td>Suffix(i)</td>
</tr>
<tr>
<td>1</td>
<td>3</td>
<td>aaaab</td>
</tr>
<tr>
<td>2</td>
<td>4</td>
<td>aaab</td>
</tr>
<tr>
<td>3</td>
<td>5</td>
<td>aab</td>
</tr>
<tr>
<td>4</td>
<td>0</td>
<td>aabaaaab</td>
</tr>
<tr>
<td>5</td>
<td>6</td>
<td>ab</td>
</tr>
<tr>
<td>6</td>
<td>1</td>
<td>abaaaab</td>
</tr>
<tr>
<td>7</td>
<td>7</td>
<td>b</td>
</tr>
<tr>
<td>8</td>
<td>2</td>
<td>baaaab</td>
</tr>
</tbody>
</table>
</div>
<p>下标为3的后缀，排名为1，即$rank[3]=1$；排名第1的后缀，下标为$3$，即$SA[1]=3$。排名数组和后缀数组是互逆的，可以相互转换，并且$rank[SA[l]]=l$，$SA[rank[i]]=i$</p>
<p>用$rk[]$推导$sa[]$：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    sa[rk[i]]=i;</span><br></pre></td></tr></table></figure>
<p>用$sa[]$推导$rk[]$：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    rk[sa[i]]=i;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="后缀数组的构建思路"><a href="#后缀数组的构建思路" class="headerlink" title="后缀数组的构建思路"></a>后缀数组的构建思路</h3><p>构建后缀数组有两种方法：$DC3$算法和倍增算法。前者时间复杂度为$O(n)$，后者时间复杂度为$O(nlogn)$。一般来说都是使用倍增算法</p>
<p>采用倍增算法，对字符串从每个下标开始的长度为$2^k$的子串进行排序，得到排名。$k$从0开始，每次都增加1，相当于长度增加了1倍。当$2^k\geq n$时，从每个下标开始的长度为$2^k$的子串都相当于所有后缀。每次子串排序都需要用到上一次子串的排名得到。</p>
<p>图解如下：</p>
<p>设字符串$s$=”$aabaaaab$”</p>
<p>（1）将字符串$s$从每个下标开始长度为1的子串进行排名，一般来说都是将该字符的ASCII码作为其排名，但是这里直接将每个字符转成数字$s[i]-$’$a$’+$1$，如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210811213544.png" alt="image-20210811213313872"></p>
<p>（2）求解长度为$2^1$的子串排名，将上一次$rank$值的第$i$个和第$i+1$个结合，相当于得到长度为$2^1$的子串的每个位置排名，然后排序，即可得到长度为$2^1$的子串排名，如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210811213614.png" alt="image-20210811213614247"></p>
<p>（3）求解长度为$2^2$的子串排名，将上一次$rank$值的第$i$个和第$i+2$个结合，相当于得到长度为$2^2$的子串的每个位置排名，然后排序，即可得到长度为$2^2$的子串排名，如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210811213636.png" alt="image-20210811213636706"></p>
<p>（4）求解长度为$2^3$的子串排名，将上一次$rank$值的第$i$个和第$i+4$个结合，相当于得到长度为$2^3$的子串的每个位置排名，然后排序，即可得到长度为$2^3$的子串排名，如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210811213748.png" alt="image-20210811213748859"></p>
<p>由于此时$2^k=2^3=8$，已经等于了$n=8$，因此，结束。</p>
<p>我们发现第4步和第3步的结果是相同的，实际上，如果在$rank$没有相同值时已经得到了后缀排名，就不需要再继续运算了。这主要是根据字符串比较的规则，如果两个字符串的前面几个字符已经比出了大小关系，那么就不再需要考虑后面字符的比较了。</p>
<p>将排名数组转换成后缀数组，排名第1的下标为3，排名第2的下标为4，排名第3的下标为5，排名第4的下标为0，排名第5的下标为6，排名第6的下标为1，排名第7的下标为7，排名第8的下标为2</p>
<p>因此得到后缀数组<code>SA[]=&#123;3,4,5,0,6,1,7,2&#125;</code></p>
<p>因为是倍增算法，每次比较的字符数都翻倍，因此长度为$n$的字符串最多需要$O(logn)$次排序，采用基数排序，其时间复杂度为$O(n)$，因此进行$n$趟排序后，求解后缀数组总的时间复杂度就是$O(nlogn)$</p>
<p>记<code>sub[i][k]</code>表示$s$从$i$开始长度为$2^k$的子串，$sub[i][k]$其实也就是$s[i],s[i+1],\cdots,s[i+(1&lt;&lt;k)-1]$，超过$n$的部分都被视为’\0’（ASCII为0，字典序最小的字符，即空字符）</p>
<p>记<code>rank[i][k]</code>表示$sub[i][k]$在长度为$2^k$的所有子串中的排名</p>
<p>记<code>sa[l][k]</code>表示在长度为$2^k$的所有子串中排名第$l$的子串的开始位置</p>
<p>倍增过程：</p>
<ul>
<li>step 1：求出长度为$2^0$的子串的字典排序，即求出$sub[1][0]$，$sub[2][0]$，$\cdots$，$sub[n][0]$的字典排序</li>
<li>step 2：求出长度为$2^1$的子串的字典排序，即求出$sub[1][1]$，$sub[2][1]$，$\cdots$，$sub[n][1]$的字典排序</li>
<li>$\cdots$</li>
<li><p>step k：求出长度为$2^k$的子串的字典排序，即求出$sub[1][k]$，$sub[2][k]$，$\cdots$，$sub[n][k]$的字典排序</p>
</li>
<li><p>当子串长度$2^k\geq n$时，子串排序就是后缀排序</p>
</li>
</ul>
<p>现在来思考一下，如何利用$rank[1\cdots n][k]$，求出$rank[1\cdots n][k+1]$呢？</p>
<p>对于两个子串$sub[i][k+1]$和$sub[j][k+1]$，我们可以这么比较：将长度一分为二，先比较前一半，如果前一半能得到结果则结束；否则再接着比较后一半</p>
<ul>
<li>先比较$rank[i][k]$和$rank[j][k]$</li>
<li>如果相等，再比较$rank[i+2^k]$和$rank[j+2^k]$</li>
<li>那么我们发现，其实我们就是再对二元组$(rank[i][k],rank[i+2^k][k])$进行排序。联想C++中pair二元组可知，先按first比较，如果相等，再按second比较。受此启发，我们可以知道要解决这个问题，需要对第一个关键字和第二个关键字进行排序</li>
</ul>
<p>从上可以观察到一个性质：想要求出长度为$k+1$的排名，需要用到长度为$k$的排名</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210811221227.png" alt="image-20210811221227880"></p>
<p>注意到$rank[i][j]$值域是不会超过$n$的正整数（可能会有相同），因此可以使用基数排序。对于一个三位的十进制数，如果使用基数排序，则先排个位，再排十位，最后排百位，即从低位到高位进行排序。联想C++中的pair是$<first,second>$，那么我们可以类比于十进制的基数排序，从右到左分别是从低位到高位，因此对于二元组排序来说，是先排second，再排first，即先排第二关键字，然后再排第一关键字。</p>
<hr>
<h3 id="后缀数组的实现"><a href="#后缀数组的实现" class="headerlink" title="后缀数组的实现"></a>后缀数组的实现</h3><p>如何理解下面这段代码呢？</p>
<p>这一段代码其实是处理长度为$2^k=2^0=1$的单个字符的后缀</p>
<p>这里$n$是该字符串$s$的长度，$m=122$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) c[x[i] = s[i]] ++ ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; i ++ ) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; i -- ) sa[c[x[i]] -- ] = i;</span><br></pre></td></tr></table></figure>
<p>首先来理解第一行代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) c[x[i] = s[i]] ++ ;</span><br></pre></td></tr></table></figure>
<p><code>x[i]=s[i]</code>表示将$s[i]$这个字符的ASCII值作为这个字符的排名，假设字符串$s$为$adcab$，那么有：</p>
<ul>
<li>$x[1]=s[1]=$’$a$’=97，$c[97]$++，所以$c[97]=1$</li>
<li>$x[2]=s[2]=$’$d$’=100，$c[100]$++，所以$c[100]=1$</li>
<li>$x[3]=s[3]=$’$c$’=99，$c[99]$++，所以$c[99]=1$</li>
<li>$x[4]=s[4]=$’$a$’=97，$c[97]$++，所以$c[97]=2$</li>
<li>$x[5]=s[5]=$’$b$’=98，$c[98]$++，所以$c[98]=1$</li>
</ul>
<p>再来理解第二行代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; i ++ ) c[i] += c[i - <span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p>这里其实就是类似于求前缀和</p>
<ul>
<li>当$i=97$时，$c[97]=c[i]+c[i-1]=c[97]+c[96]=2+0=2$</li>
<li>当$i=98$时，$c[98]=c[i]+c[i-1]=c[98]+c[97]=1+2=3$</li>
<li>当$i=99$时，$c[99]=c[i]+c[i-1]=c[99]+c[98]=1+3=4$</li>
<li>当$i=100$时，$c[100]=c[i]+c[i-1]=c[100]+c[99]=1+4=5$</li>
</ul>
<p>最后来理解第三行代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; i -- ) sa[c[x[i]] -- ] = i;</span><br></pre></td></tr></table></figure>
<ul>
<li>当$i=5$时，$x[5]=9$8，$c[98]=3$，则$sa[3]=5$，然后$c[98]$—，于是$c[98]=2$</li>
<li>当$i=4$时，$x[4]=97$，$c[97]=2$，则$sa[2]=4$，然后$c[97]$—，于是$c[97]=1$</li>
<li>当$i=3$时，$x[3]=99$，$c[99]=4$，则$sa[4]=3$，然后$c[99]$—，于是$c[99]=3$</li>
<li>当$i=2$时，$x[2]=100$，$c[100]=5$，则$sa[5]=2$，然后$c[100]$—，于是$c[100]=4$</li>
<li>当$i=1$时，$x[1]=97$，$c[97]=1$，则$sa[1]=1$，然后$c[97]$—，于是$c[97]=0$</li>
<li>因此得到长度为$2^k=2^0=1$的子串的后缀数组<code>SA[]=&#123;1,4,5,3,2&#125;</code></li>
</ul>
<p>图示理解如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210812011156.png" alt="image-20210812011156027"></p>
<p>总结：</p>
<p>for k=1~logn</p>
<ul>
<li>先按第二关键字排序，即按$rank[i+2^k][k]$进行基数排序</li>
<li>然后再按第一关键字排序，即按$rank[i][k]$进行基数排序</li>
<li>通过上面图片中的栗子可以看出，求出了$rangk[i+2^k][k]$和$rank[i][k]$后，就可以递推得到了$k+1$时的后缀数组<code>Sa[]</code>，即得到$sa[i][k+1]$</li>
<li>最后我们又用$sa[i][k+1]$求出了$k+1$时的排名数组$rank[i][k+1]$</li>
</ul>
<p>如何理解下面这段代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n - k + <span class="number">1</span>; i &lt;= n; i ++ ) y[ ++ num] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    <span class="keyword">if</span> (sa[i] &gt; k)</span><br><span class="line">        y[ ++ num] = sa[i] - k;</span><br></pre></td></tr></table></figure>
<p>理解如下：</p>
<p>比如字符串$s$为$aabaaaab$，我们将每个字符都转换成数字，转换规则是$s[i]-‘a’+1$，求出长度为$k=0,2^k=2^0=1$的子串的排名数组$x[]$（相当于<code>rank[]</code>），进行基数排序，为了放置比较时越界，在末尾用0封装：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210812125305.png" alt="image-20210812125304993"></p>
<p>接下来求解子串长度为$k=1,2^k=2^1=2$的：</p>
<p>我们对第二关键字进行基数排序，将排序结果存储在<code>y[]</code>中：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210812132933.png" alt="image-20210812132933201"></p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210812132433.png" alt="image-20210812132432956"></p>
<p>从上面我们发现，将上一次的排名<code>x[]</code>前移错位（-k），就可以得到第2关键字的排序结果（下标）<code>y[]</code></p>
<p>如何理解下面这段代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ ) c[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) c[x[y[i]]] ++ ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; i ++ ) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; i -- ) sa[c[x[y[i]]] -- ] = y[i], y[i] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>理解如下：</p>
<p>这段代码其实是在对第1关键字进行基数排序，特别是需要注意理解<code>c[x[y[i]]] ++</code>和<code>sa[c[x[y[i]]] -- ] = y[i]</code>是什么意思：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210812133551.png" alt="image-20210812133551552"></p>
<ul>
<li>当$i=0$时，$y[0]=8$，然后$x[8]=0$，而这个0刚好就是补0的空字符的第1关键字的大小</li>
<li>当$i=1$时，$y[1]=7$，然后$x[7]=2$，而这个2刚好就是第1关键字’b’的大小</li>
<li>当$i=2$时，$y[2]=0$，然后$x[0]=1$，而这个1刚好就是第1关键字’a’的大小</li>
<li>当$i=3$时，$y[3]=$2，然后$x[2]=2$，而这个2刚好就是第1关键字’b’的大小</li>
<li>当$i=4$时，$y[4]=3$，然后$x[3]=1$，而这个1刚好就是第1关键字’a’的大小</li>
<li>…</li>
</ul>
<p>因此，我们发现：将第2关键字的排序结果<code>y[]</code>转换成排名，正好是第1关键字！由于我们是对第1关键字进行基数排序，因此通过<code>x[y[i]]</code>的转换，就巧妙地利用已经求出来的<code>y[]</code>来得到我们想要的第1关键字<code>x[]</code>。</p>
<p>因此这就解释了<code>c[x[y[i]]] ++</code></p>
<p>对第1关键字进行基数排序，按第1关键字的排名顺序将<code>x[]</code>中的值$x[i]$作为桶的编号，由上图可知，$x[]$的值域有0、1、2，然后将$y[i]$的值丢入桶中：</p>
<ul>
<li>当$i=0$时，$y[0]=8$，这个8丢入桶中，$x[8]=0$，即$x[y[0]]=0$，这个0作为桶的编号</li>
<li>当$i=1$时，$y[1]=7$，这个7丢入桶中，$x[7]=2$，即$x[y[1]]=2$，这个2作为桶的编号</li>
<li>当$i=2$时，$y[2]=0$，这个0丢入桶中，$x[0]=1$，即$x[y[2]]=1$，这个1作为桶的编号</li>
<li>当$i=3$时，$y[3]=2$，这个2丢入桶中，$x[2]=2$，即$x[y[3]]=2$，这个2作为桶的编号</li>
<li>当$i=4$时，$y[4]=3$，这个3丢入桶中，$x[3]=1$，即$x[y[4]]=1$，这个1作为桶的编号</li>
<li>当$i=5$时，$y[5]=4$，这4丢入桶中，$x[4]=1$，即$x[y[5]]=1$，这个1作为桶的编号</li>
<li>当$i=6$时，$y[6]=5$，这个5丢入桶中，$x[5]=1$，即$x[y[6]]=1$，这个1作为桶的编号</li>
<li>当$i=7$时，$y[7]=1$，这个1丢入桶中，$x[1]=1$，即$x[y[7]]=1$，这个1作为桶的编号</li>
<li>当$i=8$时，$y[8]=6$，这个6丢入桶中，$x[6]=1$，即$x[y[8]]=1$，这个1作为桶的编号</li>
</ul>
<p>如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210812164242.png" alt="image-20210812164242433"></p>
<p>因此这就是解释了<code>sa[c[x[y[i]]] -- ] = y[i]</code></p>
<p>如何理解这段代码呢？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">swap</span>(x, y);</span><br><span class="line">x[sa[<span class="number">1</span>]] = <span class="number">1</span>, num = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    x[sa[i]] = (y[sa[i]] == y[sa[i - <span class="number">1</span>]] &amp;&amp; y[sa[i] + k] == y[sa[i - <span class="number">1</span>] + k]) ? num : ++ num;</span><br><span class="line"><span class="keyword">if</span> (num == n) <span class="keyword">break</span>;</span><br><span class="line">m = num;</span><br></pre></td></tr></table></figure>
<p>理解如下：</p>
<p>根据$sa[]$和$x[]$数组计算新的排名数组（长度为2的子串排名）。因为要使用旧的<code>x[]</code>数组计算新的<code>x[]</code>数组，由于我们之前已经把$y[i]$都清0了，因此此时的<code>y[]</code>是空的没有用了，因此将$x[]$和$y[]$交换，swap(x,y)，此时的$y[]$数组就是旧的$x[]$数组了，然后现在需要计算新的$x[]$数组</p>
<p>我们初始化<code>x[sa[1]] = 1</code>，因为$sa[1]$表示排名为1的子串所对应的下标位置，既然这个子串它是排名第1，那么它在新的排名中也仍然是第一，因此我们把它初始化为1</p>
<p>下面举个栗子：</p>
<p>设字符串$s$为 $aabaab</p>
<p>当$k=0$时，已经处理完了长度为$2^0$的子串了</p>
<p>然后现在来处理$k=1$，即长度为$2^1$的子串：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210812112112.png" alt="image-20210812112112094"></p>
<p>接下来理解如何用得到的新的<code>SA[]</code>数组求出下一轮的排名数组<code>tempRA[]</code>，即通过$sa[i][k+1]$求出$rank[i][k+1]$</p>
<p>我们从上往下扫描，即$i=0$扫描到$i=8$，比较当前$i$这一层中的$RA[SA[i]]$、$RA[SA[i]+k]$与上一层$i-1$中的$RA[SA[i]]$、$RA[SA[i]+k]$，如果都相等，则说明它俩都是同一个排名，如果第$i$层的大，则说明第$i$层的排名比上一层$i-1$的排名多1</p>
<ul>
<li>当$i=0$时，$tempRA[0]=0$</li>
<li>当$i=1$时，由于$RA[SA[1]]&gt;RA[SA[0]]$，因此，$tempRA[1]=1$</li>
<li>当$i=2$时，由于$RA[SA[2]]=RA[SA[1]]$并且$RA[SA[2]+k]=RA[SA[1]+k]$，因此$tempRA[2]=tempRA[1]=1$</li>
<li>当$i=3$时，由于$RA[SA[3]]=RA[SA[2]]$并且$RA[SA[3]+k]=RA[SA[2]+k]$，因此$tempRA[3]=tempRA[2]=1$</li>
<li>当$i=4$时，由于$RA[SA[4]]=RA[SA[3]]$并且$RA[SA[4]+k]=RA[SA[3]+k]$，因此$tempRA[4]=tempRA[3]=1$</li>
<li>当$i=5$时，由于$RA[SA[5]]=RA[SA[4]]$但是$RA[SA[5]+k]&gt;RA[SA[4]+k]$，因此$tempRA[5]=2$</li>
<li>当$i=6$时，由于$RA[SA[6]]=RA[SA[5]]$并且$RA[SA[6]+k]=RA[SA[5]+k]$，因此$tempRA[6]=2$</li>
<li>当$i=7$时，由于$RA[SA[7]]&gt;RA[SA[6]]$，因此$tempRA[7]=3$</li>
<li>当$i=8$时，由于$RA[SA[8]]=RA[SA[7]]$但是$RA[SA[8]+k]&gt;RA[SA[7]+k]$，因此$tempRA[8]=4$</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210812115251.png" alt="image-20210812115250875"></p>
<p>然后再根据$RA[SA[i]]$和$RA[SA[i]+2]$求出新的<code>SA[]</code>：</p>
<p>再从上往下遍历，更新$tempRA[]$</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210812115937.png" alt="image-20210812115937390"></p>
<p>然后当$k=3$时，子串长度为$2^3$，需要用到子串长度为$2^2$，因此我们将当$k=2$时得到的$tempRA[]$作为$k=3$时的第一关键字，比如当$k=3$时为$aabaab，则我们需要用到前面四个</p>
<p>$aab，则这已经在上一层k=2时求出来了，于是直接把上一层k=2的排名直接复制给k=3时的第一关键字就好了：</p>
<p>如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210812121029.png" alt="image-20210812121029257"></p>
<p>通过上面一顿操作，我们发现，如果当前第$i$层的$y[sa[i]]$等于上一层$i-1$层的$y[sa[i - 1]]$，并且当前第$i$层的$y[sa[i] + k]$等于上一层$i-1$层的$y[sa[i - 1] + k]$，则说明这俩层的子串的排名都都是相同的，否则第$i$层的排名就比第$i-1$层的排名要高（因为我们已经基础排序了，从小到大了），所以num++即可。当$num=n$时，则说明有$n$个不同的排名，因此就可以退出了。最后$m=num$其实就是优化基数排序的值域。</p>
<hr>
<h3 id="最长公共前缀LCP"><a href="#最长公共前缀LCP" class="headerlink" title="最长公共前缀LCP"></a>最长公共前缀LCP</h3><p>最长公共前缀是指两个字符串中长度最大的公共前缀，例如$s_1=$”$abcxd$”，$s_2=$”$abcdef$”，那么$LCP(s_1,s_2)=$”$abc$”，其长度为3。</p>
<p>对于字符串$s=$”$aabaaaab$”，$suffix(sa[i])$表示从第$sa[i]$个字符开始的后缀，其排名为$i$。例如$sa[3]=5$，$suffix(sa[3])=$”$aab$”，表示从第5个字符开始的后缀，其排名为3。</p>
<p>$height$表示排名相邻的两个后缀的最长公共前缀的长度，$height[2]=3$表示排名第2的后缀和排名前一个后缀的最长公共前缀的长度为3。</p>
<p>如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210812155643.png" alt="image-20210812155643145"></p>
<p>$height[i]$表示$suffix(sa[i])$和$suffix(sa[i-1])$的最长公共前缀的长度。</p>
<p><strong>性质1：</strong>对于任意两个后缀$suffix(i)、suffix(j)$，如果$rank[i]&lt;rank[j]$，则它们的最长公共前缀的长度为$height[rank[i]+1]，height[rank[i]+2]，\cdots，height[rank[j]]$的最小值</p>
<p>例如，$suffix(4)=$”$aaab$”，$suffix(1)=$”$abaaab$”，$rank[4]=2$，$rank[1]=6$，它们的最长公共前缀长度为$height[3]$，$height[4]$，$height[5]$，$height[6]$的最小值。</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210812155705.png" alt="image-20210812155704904"></p>
<p>那么我们该如何求解$height$数组呢？如果两两比较，则时间复杂度为$O(n^2)$；若利用它们之间的关系进行线性递推，则时间复杂度为$O(n)$</p>
<p>定义$h$数组，$h[i]=height[rank[i]]$，其中$h[i]$的含义：<strong>第$i$个后缀</strong>（下标为$i$开始的后缀）和<strong>排名在第$i$个后缀前面的那个后缀</strong>的 <strong>最长公共前缀</strong></p>
<p>根据$rank[]$和$sa[]$的互逆性，$rank[3]=1$，$h[3]=height[rank[3]]=height[1]=0$；$rank[4]=2$，$h[4]=height[rank[4]]=height[2]=3$。实际上，<code>height[]</code>和<code>h[]</code>只是下标不同而已，前者使用$rank$作为下标，后者使用$sa$作为下标。</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210812155728.png" alt="image-20210812155728075"></p>
<p><strong>性质2：</strong>$h[i]\geq h[i-1]-1$</p>
<p>有了这个性质，我们就可以枚举$i$从1到$n$，枚举以$i$结尾的后缀，先求解出$h[i-1]$，设$k=h[i-1]$，如果$k&gt;0$，则<code>k--</code>，也就是$h[i-1]-1$了，然后得到新的$k$，最后把这个$k$赋值给$h[i]$就好了。我们在求出$h[i-1]-1$的基础上继续计算$h[i]$即可，没有必要再从$1$开始枚举了。</p>
<p>完美图解：</p>
<p>（1）$i=0$</p>
<ul>
<li>先将下标转换为排名，$rank[0]=4$</li>
<li>求它的前一名，于是$rank[0]-1=4-1=3$</li>
<li>将前一名转换为下标，$sa[3]=5$，因此$j=5$</li>
<li>从$k=0$开始比较，如果$s[i+k]==s[j+k]$，那么<code>k++</code>，在比较结束时，$k=3$，那么$height[rank[0]]=height[4]=k=3$</li>
</ul>
<p>如下图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210812155751.png" alt="image-20210812155751087"></p>
<p>（2）$i=1$</p>
<ul>
<li>先将下标转换为排名，$rank[1]=6$</li>
<li>求它的前一名，于是$rank[1]-1=6-1=5$</li>
<li>将前一名转换为下标，$sa[5]=6$，因此$j=6$</li>
<li>此时$k=3,k\neq0$，因此从上一次的运算结果$k-1$开始接着比较，其实也就是$k=h[i-1]$，$k-1$就相当于$h[i-1]-1$，所以此时新的$k=2$，因为$s[i+k]\neq s[j+k]$，则$k$不能增加，即此时不能在对比这两个后缀了，因此$height[6]=2$。</li>
</ul>
<p>如下图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210812155814.png" alt="image-20210812155814628"></p>
<p>（3）继续求解$i=2,3,\cdots,n$，即可得到所有的<code>height[]</code></p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_Height</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//先初始化rk</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        rk[sa[i]]=i;</span><br><span class="line">    <span class="comment">//i从1到n,枚举以下标i开始的后缀</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,k=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//这里的k相当于h[i-1] 如果k&gt;0,那么k-1就相当于h[i-1]-1</span></span><br><span class="line">        <span class="keyword">if</span>(k)</span><br><span class="line">            k--;</span><br><span class="line">        <span class="comment">//根据h[i]的定义可知,现在是在枚举下标i开始的后缀</span></span><br><span class="line">        <span class="comment">//rk[i]-1表示排名在 以下标i开始的后缀 的前面那个后缀的排名</span></span><br><span class="line">        <span class="comment">//那么sa[rk[i]-1]就可以得到 前面那个后缀 的 下标j</span></span><br><span class="line">        <span class="keyword">int</span> j=sa[rk[i]<span class="number">-1</span>];</span><br><span class="line">        <span class="comment">//依次扫描对比这两个后缀,如果i+k下标不超过n,并且j+k下标不超过n</span></span><br><span class="line">        <span class="comment">//并且扫描到的字符都相等s[i+k]==s[j+k],则让k继续走</span></span><br><span class="line">        <span class="keyword">while</span>(i+k&lt;=n&amp;&amp;j+k&lt;=n&amp;&amp;s[i+k]==s[j+k])</span><br><span class="line">            k++;</span><br><span class="line">        <span class="comment">//我们知道h[i]=height[rk[i]],而这里的k是更新过后的h[i-1]-1,因此height[rk[i]]=k就相当于</span></span><br><span class="line">        <span class="comment">//h[i]=h[i-1]-1</span></span><br><span class="line">        height[rk[i]]=k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>后缀数组</tag>
      </tags>
  </entry>
</search>
