<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>单词环</title>
    <url>/2021/07/12/Algorithm-Improvement/Chapter3---Gragh-Theory/Negative-Circle/%E5%8D%95%E8%AF%8D%E7%8E%AF/</url>
    <content><![CDATA[<h1 id="单词环"><a href="#单词环" class="headerlink" title="单词环"></a>单词环</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210712192242.png" alt="image-20210712192242017"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>这题主要是要用到spfa判断正环+01分数规划+spfa玄学优化</p>
<p>我们先来思考一下该怎么建图呢？</p>
<p>如果按照常规思路，我们把一个字符串看作一个节点，那么题目最多有$10^5$个节点，那么会最多会有多少条边呢？我们来考虑最坏情况，这$10^5$个字符串都是相同的，以3个完全相同的字符串为栗子，比如：</p>
<ul>
<li>【1】$aaaaa$</li>
<li>【2】$aaaaa$</li>
<li>【3】$aaaaa$</li>
</ul>
<p>可以发现对于【1】来说，它可以接到【2】和【3】上，那么有$3-1=2$种可能，也就是说要从【1】引出两条有向边，分别指向【2】和【3】。同理分析可知，如果$10^5$个字符串都相同，则对于每个字符串来说，都会引出$10^5-1$条边，为了方便起见，就看作是引出$10^5$条边。有$10^5$个节点，每个节点会引出$10^5$条有向边，因此总共有$10^5\times 10^5=10^{10}$条有向边。很明显，点数为$10^5$，边数为$10^{10}$，存储空间要爆炸。因此，我们需要思考该怎么建图呢？</p>
<p>从题目描述中，我们可以知道，一个字符串除了前面的2个字符和后面的2个字符有用之外，字符串中间的其他所有字符都没有用，因此，我们可以这样建图：</p>
<p>直接hash前面的两个字符和后面的两个字符作为节点，该字符串的长度作为这两个节点之间的边的权值。对于一个字符串来说，它后面的两个字符，每个字符都有26种可能，因此这两个字符产生了$26\times26=676$种可能，也就是最多会有$676$个节点。例如题目中的第一个字符串$ababc$，它后面的$bc$就确定了图中的一个顶点，第二个字符串$bckjaca$，它后面的$ca$就确定了图中的一个顶点，第三个字符串$caahoynaab$，它后面的$ab$就确定了图中的一个顶点。也就是说对于后面两个字符所确定的一种可能，都会对应地确定了图中的一个顶点。那么有$26\times 26$种可能，也就是确定了图中最多会有$676$个顶点。由之前分析可知，每个节点最多很引出$10^5$条有向边。因此这种建图方式最多会引出$676\times 10^5=6.76\times 10^7$条有向边，空间还算好一些。</p>
<p>如下图解释题目中的栗子：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210712194716.png" alt="image-20210712194716858"></p>
<p>知道了该怎么建图后，我们再来思考题目要求的是什么？题目想要求的是形成环的这个串它的平均长度最大，转换到我们建好的图中，意思就是：边权之和/节点个数 最大。即$\dfrac {\sum w_i}{\sum 1}$要最大</p>
<p>要求这个值最大，满足单调性，很明显这就是一个01分数规划问题，那么就可以使用二分算法来二分答案了。我们设某一时刻二分出来的答案为$mid$（但不保证这就是最终正确想要的最大的那个答案），如果当前这个答案$mid$不够大，则说明还可以更大，即</p>
<p>$\dfrac {\sum w_i}{\sum 1}&gt;mid$</p>
<p>$\iff$ $\sum w_i&gt;mid*\sum 1$</p>
<p>$\iff$ $\sum w_i-mid*\sum 1&gt;0$</p>
<p>$\iff$$\sum w_i-\sum mid*1&gt;0$</p>
<p>$\iff$ $\sum (w_i-mid*1)$</p>
<p>那么也就是说，对于每一条边，给它赋权值为$w_i-mid*1$，如果存在正环，也就意味着有一个环的权值和大于0，也就是$\sum (w_i-mid\times 1)&gt;0$，就意味着$mid$需要更大，由于是单调递增的，那么此时就应该执行$L=mid$，否则就是执行$R=mid$。</p>
<p>这里还要思考一下二分的区间是啥？由于$\sum w_i$和$\sum 1$都是正数，因此相除的话一定是大于0的，注意这里是浮点数相除哦！因此左范围一定大于0。由$\dfrac {\sum w_i}{\sum 1}$式子可知，要想取最大，则分子要最大，分子要最小，由于最多有$10^5$条边，每条边的权值最大是$1000$，所以$\sum w_i$最大是$1000\times 10^5$。由于最多有$10^5$条边，所以至少有$10^5$个节点，所以$\sum 1$最小为$10^5$，于是$\dfrac {\sum w_i}{\sum 1}=\dfrac {1000\times 10^5}{10^5}$最大为$1000$。因此答案区间就是$(0,1000]$。</p>
<p>题目说了不一定存在环串，那么我们该怎么知道呢？从$w_i-mid\times1$可知，这是一个递减的线性函数，当$mid$取0时，有最大值，因此我们可以先尝试$mid=0$，如果$w_i-mid\times 1\leq 0$，那么$\sum w_i-mid\times 1\leq0$，因此对于剩下的所有节点，必定是$\sum w_i-mid\times 1\leq0$，但是这个式子显然与$\sum (w_i-mid\times 1)&gt;0$这个存在正环的式子不矛盾。因此，只要带入$mid=0$，验证一下看看这个式子$\sum (w_i-mid*1)$是否满足正环，如果不满足，那么全部都不满足，输出无解，否则说明可以求解。</p>
<p>一般来说，如果题目要求保留$k$位小数，那么我们一般把精度多控制两位，即精度位$eps=1e^{-(k+2)}$</p>
<blockquote>
<p>问题：如何理解一下代码呢？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> left=(s[<span class="number">0</span>]-<span class="string">&#x27;a&#x27;</span>)*<span class="number">26</span>+(s[<span class="number">1</span>]-<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">int</span> right=(s[len<span class="number">-2</span>]-<span class="string">&#x27;a&#x27;</span>)*<span class="number">26</span>+s[len<span class="number">-1</span>]-<span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>我们这里是以字符串的前面两个字符和后面两个字符来作为节点，那么这个节点该怎么编号呢？其实我们可以利用字符串hash的思想，把这两个字符hash成对应的一个整数值。比如字符串$ababc$前面的两个字符$ab$其实就是$(‘a’-‘a’)\times 26^1+(‘b’-‘a’)\times 26^0=1$，所以字符$ab$这个节点的编号就是1；比如字符$ababc$后面的两个字符$bc$其实就是$(‘b’-‘a’)\times 26^1+(‘c’-‘a’)\times 26^0=28$，所以字符$bc$这个节点的编号就是28</p>
</blockquote>
<p>这里还有一个spfa判环的玄学优化（不太常用）：</p>
<p>当图中所有顶点的更新次数（入队次数)<code>count</code>大于图中顶点的个数的2倍时，则认为存在环。如果2倍不行，那就长度3倍、4倍…  这玩意很玄学</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">700</span>, M = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps=<span class="number">1e-4</span>;  <span class="comment">//控制精度</span></span><br><span class="line"><span class="keyword">int</span> h[N], e[M], w[M], ne[M], idx;</span><br><span class="line"><span class="keyword">double</span> dist[N];</span><br><span class="line"><span class="keyword">int</span> q[N], cnt[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="comment">//建图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    w[idx] = c;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//spfa判正环</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">double</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">-0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> cnt);</span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//图中最多有676个顶点,一开始就把原图中的所有顶点都放入队列q中</span></span><br><span class="line">    <span class="comment">//就等效于建立了一个虚拟源点和其他676个节点的新图</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">676</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        q[tt ++ ] = i;</span><br><span class="line">        <span class="comment">//初始化该虚拟源点到其他676个节点的权值为0</span></span><br><span class="line">        dist[i]=<span class="number">0</span>;</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;  <span class="comment">//统计图中所有节点的更新次数即所有节点的入队次数</span></span><br><span class="line">    <span class="keyword">while</span> (hh != tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = q[hh ++ ];</span><br><span class="line">        <span class="keyword">if</span> (hh == N) </span><br><span class="line">        hh = <span class="number">0</span>;</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &lt; dist[t] + w[i] - mid)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i] - mid;</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">                count++;    <span class="comment">//更新次数+1  即入队次数+1</span></span><br><span class="line">                <span class="comment">//一般经验上来说是count &gt;2N 但是这里点数少,边数实在太多了 </span></span><br><span class="line">                <span class="comment">//那么就3N,4N...一直尝试吧</span></span><br><span class="line">                <span class="keyword">if</span> (count&gt; <span class="number">10</span>*N) </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 经验上的trick</span></span><br><span class="line">                <span class="comment">//说明存在正环</span></span><br><span class="line">                <span class="keyword">if</span> (cnt[j] &gt;= N) </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q[tt ++ ] = j;</span><br><span class="line">                    <span class="keyword">if</span> (tt == N) tt = <span class="number">0</span>;</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//说明不存在正环</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">1010</span>]; <span class="comment">//字符串</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T), T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//初始化表头</span></span><br><span class="line">        <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//T个字符串</span></span><br><span class="line">        <span class="keyword">while</span>(T--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">            <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">            <span class="keyword">if</span> (len &gt;= <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//该字符串的前面两个字符  hash 成一个整数值 作为 一个节点的编号</span></span><br><span class="line">                <span class="keyword">int</span> left = (str[<span class="number">0</span>] - <span class="string">&#x27;a&#x27;</span>) * <span class="number">26</span> + str[<span class="number">1</span>] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="comment">//该字符串的后面两个字符  hash 成一个整数值 作为 一个节点的编号</span></span><br><span class="line">                <span class="keyword">int</span> right = (str[len - <span class="number">2</span>] - <span class="string">&#x27;a&#x27;</span>) * <span class="number">26</span> + str[len - <span class="number">1</span>] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="comment">//从left节点想right节点连一条长度为len的有向边</span></span><br><span class="line">                <span class="built_in">add</span>(left, right, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果把0带进去计算都不能得到正环的话,那么1,2,...,1000就不可能得到正环</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">check</span>(<span class="number">0</span>)) </span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;No solution&quot;</span>);</span><br><span class="line">        <span class="comment">//说明还是可以得到正环的</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">double</span> l = <span class="number">0</span>, r = <span class="number">1000</span>;</span><br><span class="line">            <span class="comment">//二分答案</span></span><br><span class="line">            <span class="keyword">while</span> (l+eps&lt;r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">                <span class="comment">//由于答案是单调递增的 </span></span><br><span class="line">                <span class="comment">//所以当满足性质时  往右侧收缩 寻找答案</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) </span><br><span class="line">                l = mid;</span><br><span class="line">                <span class="comment">//否则不满足性质  往左侧收缩 寻找答案</span></span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//输出最终的答案</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>负环</category>
      </categories>
      <tags>
        <tag>负环</tag>
      </tags>
  </entry>
  <entry>
    <title>虫洞</title>
    <url>/2021/07/11/Algorithm-Improvement/Chapter3---Gragh-Theory/Negative-Circle/%E8%99%AB%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="虫洞"><a href="#虫洞" class="headerlink" title="虫洞"></a>虫洞</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210711231829.png" alt="image-20210711231829264"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>这题主要是要读懂题目，刚开始读不懂，后来再理解这题其实就是一个裸的求负环。</p>
<p>虫洞它是单向边，路径是双向边，因此建图时，图中就会既有单项边，又有双向边。”通过虫洞，它可以回到过去的某个时刻“这句话的意思其实就是说明虫洞的单向边是负值</p>
<p>读懂题目的意思后，用spfa求负环就好了</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//边数=路径的双向边2500*2+虫洞的单向边200=5200</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">510</span>,M=<span class="number">5210</span>;</span><br><span class="line"><span class="comment">//n表示田地的数量  m1表示路径的数量  m2表示虫洞单向边的数量</span></span><br><span class="line"><span class="keyword">int</span> n,m1,m2;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],w[M],idx;</span><br><span class="line"><span class="keyword">int</span> q[N],cnt[N],dist[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="comment">//建图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    w[idx]=c;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//spfa求负环</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//有多组测试数据 要初始化</span></span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);  <span class="comment">//求负环时  对于dist数组没有任何要求,不用初始化都可以</span></span><br><span class="line">    <span class="built_in">memset</span>(st,<span class="number">0</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span> cnt);</span><br><span class="line">    <span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//在新图中添加一个虚拟源点就等效于 一开始将原图中的所有节点都加入循环队列q中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        q[tt++]=i;</span><br><span class="line">        <span class="comment">//这里从初始化为0 其实含义就是：在新图中,虚拟源点到其他n个节点连一条长度为0的边</span></span><br><span class="line">        dist[i]=<span class="number">0</span>;</span><br><span class="line">        st[i]=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(hh!=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=q[hh++];</span><br><span class="line">        <span class="keyword">if</span>(hh==N)</span><br><span class="line">        hh=<span class="number">0</span>;</span><br><span class="line">        st[t]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j]&gt;dist[t]+w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j]=dist[t]+w[i];</span><br><span class="line">                cnt[j]=cnt[t]+<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//存在负环  那么他可以回到过去</span></span><br><span class="line">                <span class="keyword">if</span>(cnt[j]&gt;=n) </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q[tt++]=j;</span><br><span class="line">                    <span class="keyword">if</span>(tt==N)</span><br><span class="line">                    tt=<span class="number">0</span>;</span><br><span class="line">                    st[j]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//说明不存在负环  那么他不可用回到过去</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">        idx=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m1,&amp;m2);</span><br><span class="line">        <span class="comment">//给路径的双向边建图</span></span><br><span class="line">        <span class="keyword">while</span>(m1--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a,b,c;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">            <span class="built_in">add</span>(a,b,c);</span><br><span class="line">            <span class="built_in">add</span>(b,a,c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//给虫洞的单向边建图</span></span><br><span class="line">        <span class="keyword">while</span>(m2--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a,b,c;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">            <span class="comment">//注意边的权值是-c</span></span><br><span class="line">            <span class="built_in">add</span>(a,b,-c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//存在负环 则可以回到过去</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">spfa</span>())</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">        <span class="comment">//不存在负环 则不可以回到过去</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>负环</category>
      </categories>
      <tags>
        <tag>负环</tag>
      </tags>
  </entry>
  <entry>
    <title>观光奶牛</title>
    <url>/2021/07/12/Algorithm-Improvement/Chapter3---Gragh-Theory/Negative-Circle/%E8%A7%82%E5%85%89%E5%A5%B6%E7%89%9B/</url>
    <content><![CDATA[<h1 id="观光奶牛"><a href="#观光奶牛" class="headerlink" title="观光奶牛"></a>观光奶牛</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210712160410.png" alt="image-20210712160410274"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>一般来说，求 点权之和/边权之和 的最值问题，都属于01分数规划问题。</p>
<p>图论的01分数规划问题的步骤：</p>
<ul>
<li>确认答案区间，然后用二分算法，判断性质</li>
<li>借助二分出来的中点，推导出性质的公式</li>
<li>套用图论模板</li>
</ul>
<p>本题要求我们求一个环内$\dfrac {\sum f_i}{\sum t_i}$的最大值，而这个答案本身就是具有单调性，因此可以用二分算法，来二分出最终的答案。</p>
<p>首先来确定答案的区间：</p>
<p>我们设$c =\dfrac {\sum f_i}{\sum t_i}$</p>
<ul>
<li>要想求出区间的左范围，那么分子应该最小，分母应该最大，那么分子应该取一个点，该点的点权为1；分母应该取5000条边，边权为1000，那么此时$c=\dfrac {1\times1}{5000\times1000}$，很难明显，这个$c$不为0，肯定是大于0的，注意这里不能理解为C++中的整除会向下取整，这里应该理解为浮点数的除法，因为题目说了要保留两位小数。因此，我们确定了左范围是大于0的</li>
<li>要想求出区间的右范围，那么分子应该最大，分母应该最小，那么分子应该取1000个点，每个点的点权都为1000；由于有了1000个点，那么对于环来说，至少得是1000条边（注意不可能说有1000个点，然后取1条边，这样不能形成环），这1000条边的权值都为1，那么此时$c=\dfrac {1000\times1000}{1000\times1}=1000$。因此，我们确定了右范围是1000</li>
<li>所以，答案区间就是<code>(0,1000]</code></li>
</ul>
<p>由于我们发现答案区间是单调递增的，也就是说具有单调性，那么就可以用二分算法，来快速地求出$c$。我们设$L=0,R=1000$，假设某个时刻，我们设中点为$mid$，那么：</p>
<p>$\dfrac {\sum f_i}{\sum t_i}&gt;mid$</p>
<p>$\iff$ $\sum f_i&gt;mid*\sum t_i$</p>
<p>$\iff$ $\sum f_i-mid*\sum t_i&gt;0$</p>
<p>$\iff$ $\sum (f_i-mid*t_i)&gt;0$</p>
<p>根据上述推导的公式可知，对于满足要求的$mid$，就是要满足图中存在一个<code>环</code>，它的$\sum (f_i-mid*t_i)&gt;0$ ，要求一个环，它的权值之和大于0，这不就是想让我们求正环嘛？</p>
<p>因此，原问题就转换为 求图中是否存在一个正环 的问题了</p>
<p>我们每次二分出一个$mid$，然后$check(mid)$，如果它满足上面的这个式子，那么由于答案是单调递增的，我们想要求出最大的$mid$，因此此时左范围$L$应该往右侧收缩，即$L=mid$，不可能让右范围往左收缩吧，即不可能是$R=mid$（如果这样的话，那么更新过后的区间的最大值不就小于$mid$了嘛，这就不可能找到最大值了）。因此一旦二分出的$mid$满足上述式子，那么就往右侧收缩$L=mid$，这样会更快地逼近最大值；如果二分出的这个$mid$不满足上述式子，则说明答案肯定比当前二分的$mid$还小，那么就要往左侧收缩$R=mid$，因为右边已经不可能了。</p>
<p>浮点数的二分比较简单，就是执行$L=mid$或者$R=mid$。</p>
<p>这里还有个问题，就是我们该怎么处理点权和边权呢？我们以前都只是见过有边权的情况。其实，我们可以把节点的点权放到它的出边上，那么此时就只有边权的情况了，不存在点权。为什么可以这么做呢？</p>
<ul>
<li>假设同时存在点权和边权，那么所有点权之和为$\sum f_i$，所有边权之和为$\sum t_i$，因此，总的权值之和为$\sum f_i+\sum t_i$</li>
<li>假设把点权放到出边上，此时只有边权，那么某个出边的权值为$f_i+t_i$，因此，总的权值之和为$\sum (f_i+t_i)$</li>
<li>由于$\sum$是可以分开的，因此$\sum(f_i+t_i)=\sum f_i+\sum t_i$</li>
</ul>
<p>有了上面的处理之和，我们建图就会更加方便了，只需要处理边权就好了。</p>
<p>我们来看这个式子 $\sum(f_i-mid\times t_i)$，那么其实就是$\sum (f_i+(-mid\times t_i))&gt;0=\sum f_i+\sum-mid\times t_i$，也就是说把原来的边权$t_i$换成了$f_i-mid\times t_i$来存储了，把每个点的权值都放入它的出边中。</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>,M=<span class="number">5010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="comment">//点权</span></span><br><span class="line"><span class="keyword">int</span> wf[N];</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],wt[M],idx;  <span class="comment">//wt是边权</span></span><br><span class="line"><span class="keyword">int</span> q[N],cnt[N];</span><br><span class="line"><span class="keyword">double</span> dist[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    wt[idx]=c;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//spfa判断正环</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">double</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">-0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">memset</span>(st,<span class="number">0</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span> cnt);</span><br><span class="line">    <span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//一开始将原图中所有点加入队列q中就  等效于建立了一个带有虚拟源点的新图 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        q[tt++]=i;</span><br><span class="line">        dist[i]=<span class="number">0</span>;</span><br><span class="line">        st[i]=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(hh!=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=q[hh++];</span><br><span class="line">        <span class="keyword">if</span>(hh==N)</span><br><span class="line">        hh=<span class="number">0</span>;</span><br><span class="line">        st[t]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];</span><br><span class="line">            <span class="comment">//wf[t]-mid*wt[i]是将点权放到了边上</span></span><br><span class="line">            <span class="keyword">if</span>(dist[j]&lt;dist[t]+wf[t]-mid*wt[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j]=dist[t]+wf[t]-mid*wt[i];</span><br><span class="line">                cnt[j]=cnt[t]+<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//说明存在正环</span></span><br><span class="line">                <span class="keyword">if</span>(cnt[j]&gt;=n)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q[tt++]=j;</span><br><span class="line">                    <span class="keyword">if</span>(tt==N)</span><br><span class="line">                    tt=<span class="number">0</span>;</span><br><span class="line">                    st[j]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//说明不存在正环</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;wf[i]);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a,b,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> l=<span class="number">0</span>,r=<span class="number">1e4</span>;</span><br><span class="line">    <span class="comment">//二分找到答案</span></span><br><span class="line">    <span class="keyword">while</span>(l+<span class="number">1e-4</span>&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//满足条件 则向右侧收缩</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid))</span><br><span class="line">        l=mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        r=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>,l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>负环</category>
      </categories>
      <tags>
        <tag>负环</tag>
      </tags>
  </entry>
  <entry>
    <title>关押罪犯</title>
    <url>/2021/07/14/Algorithm-Improvement/Chapter3---Gragh-Theory/%E4%BA%8C%E5%88%86%E5%9B%BE/%E5%85%B3%E6%8A%BC%E7%BD%AA%E7%8A%AF/</url>
    <content><![CDATA[<h1 id="关押罪犯"><a href="#关押罪犯" class="headerlink" title="关押罪犯"></a>关押罪犯</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210714161314.png" alt="image-20210714161314811"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>从题干中，警察局长会把怒气值从大到小排序送给市长看，而市长只会看第一个最大的那个怒气值，如果这个最大的怒气值达到某种程度，则警察局长会被撤职。题目想让我们求的就是：有没有一个分配囚犯的方案，使得那个最大的怒气值，能够达到最小。</p>
<p>一般求 最大值最小 或者 最小值最大，都可以考虑用二分算法。 这里是想求最大值最小，因此，我们可以考虑一下使用二分算法。那么该如何进行二分呢？</p>
<p>考虑这样一个判定问题：是否存在一种分配罪犯的方案，使得$Z$市长看到的那个冲突事件的影响力不超过$mid$。对于当$mid$满足要求时，那么所有大于$mid$也是满足要求的。也就是说题目的答案是具有单调性的，一旦具有单调性，那么一定可以用二分算法。</p>
<blockquote>
<p>问题：为什么对于当$mid$满足要求时，那么所有大于$mid$也是满足要求的呢？</p>
<p>设当前二分的值为$mid$，那么对于那些怒气值大于$mid$的囚犯应该关在不同的监狱。假设它俩关在同一所监狱，那么他们会产生更大的影响力（设其值为$a$)，这个影响力会大于现优解$mid$，即$a&gt;mid$，那么$a$就要在排行榜上当第一了，又由于市长只看第一，因此市长看到更大的$a$就会撤换警察局长，相对来说如果让$mid$在排行榜上当第一，那么影响力会更小一些。</p>
<p>举个栗子，假设当前$mid=50$，如果有两个囚犯，他们之间的怒气值为$100$，假设它俩关在同一个监狱$A$，那么监狱$A$就会产生影响力$100$，但是如果我们让它俩关在不同的监狱$A$和$B$，那么此时监狱$A$产生的影响力为0。因此，我们发现，当怒气值大于$mid$时，我们就更应该把它俩放到不同的监狱，这样会使得同一个监狱内的怒气值相对降低。但是如果他们之间的怒气值小于$mid$，那么就算把他俩放到不同监狱，此时排行榜上第一仍然是$mid$，并没有让第一的值减小，反而还浪费了一次分配机，这导致后面如果有大于$mid$的囚犯本应该被分配到两个不同的监狱却因为位置不够而被迫关在同一个监狱，导致这个监狱内的怒气值大于$mid$，排行榜上第一的值增大，这与我们想要的结果事与愿违。</p>
<p>这也就证明了 当$mid$满足要求时，那些怒气值大于$mid$就更能满足要求了，而那些怒气值$\leq mid$的就不满足条件了。</p>
</blockquote>
<p>二分答案，设当前二分的值为$mid$。此时，任意两个仇恨程度大于$mid$的囚犯都必须被安排在不同的监狱。我们把每个囚犯都看作是一个节点，如果两个囚犯之间的仇恨程度大于$mid$，那么我们就在这两个囚犯之间连一条无向边，这样最终就会得到一张无向图。由于两个囚犯被分配到两个不同的监狱，因此这两个节点属于不同的点集合，也就是说这张无向图需要被分成两个点集合。由于我们把怒气值大于$mid$的两个囚犯分别关到两个不同的监狱中了，那么此时同一个监狱内的囚犯之间的怒气值必然是$\leq mid$。而我们定义了当怒气值大于$mid$才连边，所以对于怒气值$\leq mid$都不需要连边。也就是说每个集合内部都没有边（同一个监狱内没有仇恨程度大于$mid$的罪犯）。我们发现，这种把节点划分成两种点集合，并且只能从一个点集合向另一个点集合连边，这种做法不正是二分图的定义嘛？</p>
<p>刚开始，我们对输入的数据都进行无向图$T$，然后再这张图中，如果边权怒气值$\leq mid$，那么我们就不看这些边（可以认为是从原图$G$中删除这些边），然后如果边权怒气值$&gt;mid$，则保留，那么最终全部保留下来的这个子图也就是一张无向图，设为$G$。然后我们对这个无向图$G$判定是否为二分图。</p>
<p>因此总的算法思路如下：</p>
<ul>
<li>先二分一个答案$mid$，此时$mid$其实就是对应一种分配罪犯的方案。</li>
<li>对每一个$ mid$，都使用染色法来check一下，来判定这个无向图$G$是否为二分图<ul>
<li>如果$check(mid)$成功，则说明是二分图，点$mid$位于右侧绿色满足性质的区间，那么对于所有大于$mid$的分配方案都是合理的，即$mid$右侧都满足，为了求最小，我们让$r=mid$，往左侧收缩，找到最小值</li>
<li>如果$check(mid)$失败，则说明不是二分图，点$mid$位于左侧红色不满足性质的区间，那么此时应该让左侧边界跳到$mid$的下一个位置，即$l=mid+1$，这样才能满足性质</li>
</ul>
</li>
</ul>
<p>那么该如何确定二分的边界呢？由于题目说了$0\leq c\leq 1e9$，因此答案最小值为$0$，最大值为$1e9$，因此二分的区间为<code>[0,1e9]</code>。</p>
<p>题目要求“如果本年内监狱中未发生任何冲突事件，请输出 $0$”，这个我们并不需要特殊处理，因为我们二分的答案区间中就包含了$0$。因此我们的算法一定可以考虑到这种情况。</p>
<p>设二分的性质为 <strong>当同一个监狱的两个囚犯之间的怒气值很大，则分配到两个不同的监狱中</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210714170229.png" alt="image-20210714170229547"></p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//题目给的边数为1e5 但是由于是二分图 它是无向图 所以边数要开2倍</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>,M=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],w[M],idx;</span><br><span class="line"><span class="keyword">int</span> color[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    w[idx]=c;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//染色法判定二分图</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> c,<span class="keyword">int</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    color[u]=c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];~i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j=e[i];</span><br><span class="line">        <span class="comment">//在mid左侧的都在红色不满足性质的区间</span></span><br><span class="line">        <span class="keyword">if</span>(w[i]&lt;=mid)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//如果j还没有被染色</span></span><br><span class="line">        <span class="keyword">if</span>(!color[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">dfs</span>(j,<span class="number">3</span>-c,mid))<span class="comment">//染色有矛盾</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//j被染过色了,但是它的颜色与相邻节点的颜色都是相同的 染色有矛盾</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(color[j]==c)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//说明染色无矛盾  是二分图</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(color,<span class="number">0</span>,<span class="keyword">sizeof</span> color);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!color[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">dfs</span>(i,<span class="number">1</span>,mid))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        <span class="comment">//建图</span></span><br><span class="line">        <span class="built_in">add</span>(a,b,c);</span><br><span class="line">        <span class="built_in">add</span>(b,a,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>,r=<span class="number">1e9</span>;</span><br><span class="line">    <span class="comment">//二分答案</span></span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//判断mid是否在绿色满足性质的区间 如果在则说明是二分图</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid))</span><br><span class="line">        r=mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>二分图</category>
      </categories>
      <tags>
        <tag>二分算法+二分图</tag>
      </tags>
  </entry>
  <entry>
    <title>二分图的最大匹配</title>
    <url>/2021/07/13/Algorithm-Improvement/Chapter3---Gragh-Theory/%E4%BA%8C%E5%88%86%E5%9B%BE/%E4%BA%8C%E5%88%86%E5%9B%BE%E7%9A%84%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h1 id="二分图的最大匹配"><a href="#二分图的最大匹配" class="headerlink" title="二分图的最大匹配"></a>二分图的最大匹配</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210713135825.png" alt="image-20210713135825492"></p>
<hr>
<h3 id="二分图的最大匹配-1"><a href="#二分图的最大匹配-1" class="headerlink" title="二分图的最大匹配"></a>二分图的最大匹配</h3><p>从题目中给出的二分图匹配的定义可知，匹配其实也是一张图，并且图中的点数是边数的2倍。</p>
<p>如下图所示：二分图的匹配</p>
<p>红色边组成的 4 个结点、2条边就是这个二分图的一个匹配了；</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210713140235.png" alt="image-20210713140235437"></p>
<p><strong>二分图最大匹配定义</strong>：最大匹配就是找到一个子图，满足是匹配，并且边数（点数）最多。</p>
<p>如下图所示：二分图的最大匹配</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210713140350.png" alt="image-20210713140350842"></p>
<hr>
<h3 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h3><p>匈牙利算法可以用来求解二分图的最大匹配问题。匈牙利算法也被戏称为“相亲算法”，它的大致过程是这样的：</p>
<ul>
<li><p>有两个点集，分别是男生和女生，$X$点集中全部都是男生，$Y$点集中全部都是女生</p>
</li>
<li><p>然后男生取追求女生，如果男生$X_a$对女生$Y_b$有好感，并且女生$Y_b$也有男生$X_a$有好感，那么男生$X_a$就有很大机会可以追到女生$Y_b$，否则如果女生$Y_b$不喜欢男生$X_a$，那么男生$X_a$就不会再追求女生$Y_b$，而是继续去寻找其他女生  （不想当<del>舔狗</del>)</p>
</li>
<li><p>作为一个男人，要主动出击。因此约定都是男生追女生，即开始先从点集$X$出发</p>
</li>
<li><p>每个男生可以选遍所有他喜欢的女生：如果某位女生还是单身并且没有其他男生追求她，那么 女人 拿来吧你，恭喜你，直接配对；如果特别喜欢的这个女生已经有男朋友了，则这个女生会让她男朋友再去找其他女生（爱情就是这么<del>不堪一击</del>)，又转化成了另一个男生去寻找女生的过程，继续递归找；</p>
</li>
<li><p>那么最终的结果就有两种情况：</p>
<ul>
<li><p>由于这个男生的插足，导致最后可能有一个男生被抛弃，这是不道德的行为，所以不能干这种事情！（如下图，结局好惨）</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210713142754.png" alt="image-20210713142754572"></p>
</li>
<li><p>由于这个男人的插足，导致所有的男女关系都进行了一次轮换，但是匹配的对数多了一对；（成功<del>横刀夺爱</del>）</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210713143031.png" alt="image-20210713143030993"></p>
</li>
</ul>
</li>
</ul>
<p>以上就是匈牙利算法的相亲过程，算法很简单也很有趣，教会了<del>恋爱丛林法则</del></p>
<hr>
<h3 id="匈牙利算法实现"><a href="#匈牙利算法实现" class="headerlink" title="匈牙利算法实现"></a>匈牙利算法实现</h3><p>先来给出以下变量的定义：</p>
<ul>
<li><code>st[j]</code>这个是个bool类型数组，用来表示某个女生有没有被男生访问联系过，如果$st[j]=true$，表示$j$这个女生已经某个男生联系过了</li>
<li><code>match[j]</code>是个int类型的数组，用来表示$j$这个女生她现任男友的编号，如果$match[j]=a$，表示$j$这个女生她现任男友的编号为$a$</li>
</ul>
<p>算法流程：</p>
<ul>
<li>将男生和女生分成点集$X$和$Y$</li>
<li>由于是男生掌握主动权，所以只需要建立有向图，从男生节点向女生节点引出有向边即可</li>
<li>从男生点集$X$出发，假设某个男生$u$，遍历$u$这个节点所有的邻接点$v$（即他喜欢的所有女生）<ul>
<li>如果这个女生$v$处于单身状态，$v$还没有匹配，那么此时$(u,v)$就是一组成功的匹配（在一起了），所以匹配的数量+1</li>
<li>如果这个女生$v$虽然有男朋友了，但是她可能对这个男生$u$有点意思，所以让她现任男友$c$去寻找其他女生，假设男生$c$是个<del>海王</del>（本来就是），他确实有很多青青草原，然后他找到了后宫中的女生$d$，最终女生$d$答应了他，于是他俩就在一起了，那么此时女生$v$就处于单身状态，于是男生$u$就成功和她在一起了，可以发现此时又成功匹配了一对情侣，所以匹配数目+1；但是如果后宫中的女生$d$知道男生$c$是海王，拒绝了他，那么男生$c$和她女友$v$说 我还是只爱你一人，因此他俩还是继续在一起，那么很可惜男生$u$还是<del>单身狗</del>。因此这次$u$的匹配失败。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>, M = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n1, n2, m;<span class="comment">//n1表示左侧男生的个数  n2表示右侧女生的个数</span></span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="comment">//match[j]=a,表示女孩j的现有配对男友是a</span></span><br><span class="line"><span class="keyword">int</span> match[N];<span class="comment">//右边女生所对应的左边男孩,即女生现在和哪个男生的在一起</span></span><br><span class="line"><span class="keyword">bool</span> st[N];<span class="comment">//临时预定数组，st[j]=a表示一轮模拟匹配中，女孩j被男孩a预定了。 避免重复搜索女孩</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断x这个男生能不能找到匹配的女生</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//依次遍历自己喜欢的女孩</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];<span class="comment">//获取女孩在图中的顶点的编号</span></span><br><span class="line">        <span class="comment">//如果j这个女孩之前还没有被考虑过，在这一轮模拟匹配中,这个女孩尚未被预定</span></span><br><span class="line">        <span class="keyword">if</span> (!st[j])<span class="comment">//j这个女孩还没有被男生x访问过</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//标记j这个女孩被男生x访问过了</span></span><br><span class="line">            st[j] = <span class="literal">true</span>;<span class="comment">//表示j这个女孩已经被x男孩看上了，被考虑过啦，x男孩已经预定了j这个女孩</span></span><br><span class="line">            <span class="comment">//match[j]==0表示j这个女孩还没有匹配任何男孩，即j女孩还没有男朋友 j目前没有任何可以匹配的节点</span></span><br><span class="line">            <span class="comment">//find(match[j])=true表示j这个女孩虽然已经匹配了某个男孩,但是她匹配的这个男孩是个海王</span></span><br><span class="line">            <span class="comment">//留有后手随时可以找到其他女孩来代替她，那么此时j女孩被甩处于单身状态,j告诉x说我们在一起吧</span></span><br><span class="line">            <span class="comment">//那么执着追j女孩的这个x男子就击败了j女孩的所有暗恋者，有机会了</span></span><br><span class="line">            <span class="comment">//也就是说j有和它匹配的点(现任男友),但是呢这个点(现任男友)能够通过一些办法来找到新的匹配</span></span><br><span class="line">            <span class="keyword">if</span> (match[j] == <span class="number">0</span> || <span class="built_in">find</span>(match[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                match[j] = x;<span class="comment">//表示j女孩已经匹配成功了，现有配对男友是x</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//返回true表示配对成功</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果遍历过x男子所喜欢的女生中，都没能找到合适的，自己中意的全部都被预定了。</span></span><br><span class="line">    <span class="comment">//配对失败。即没有配对成功，则返回false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n1, &amp;n2, &amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a, b);<span class="comment">//虽然是无向图，但是因为是左侧男生去找女朋友，单向追求，所以用“有向图”就行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;<span class="comment">//res表示匹配的数量</span></span><br><span class="line">    <span class="comment">//依次枚举左半部分的男生该去找哪个女孩</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//要保证每个女孩只被考虑一遍</span></span><br><span class="line">        <span class="comment">//因为每次模拟匹配的预定情况都是不一样的所以每轮模拟都要初始化</span></span><br><span class="line">        <span class="comment">//如果不初始化则当男生i进行匹配操作后会修改st的内容  那么会保留这个内容</span></span><br><span class="line">        <span class="comment">//当下一个男生i+1进行匹配操作时 就会用到上一个男生i保留的st的内容  就会出错</span></span><br><span class="line">        <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);<span class="comment">//把每个女孩的匹配状态清空，表示这些女孩还没有被考虑过</span></span><br><span class="line">        <span class="comment">//如果i这个男子成功的找到了匹配的妹子  那么匹配个数+1</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find</span>(i))</span><br><span class="line">            res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>二分图</category>
      </categories>
      <tags>
        <tag>匈牙利算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二分图最大匹配的应用</title>
    <url>/2021/07/14/Algorithm-Improvement/Chapter3---Gragh-Theory/%E4%BA%8C%E5%88%86%E5%9B%BE/%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h1 id="二分图最大匹配的应用"><a href="#二分图最大匹配的应用" class="headerlink" title="二分图最大匹配的应用"></a>二分图最大匹配的应用</h1><hr>
<p>对于二分图最大匹配来说，更重要的是对一些实质问题的转化，比如通过求解二分图最大匹配，我们可以得到一个二分图的最小顶点覆盖，最小边覆盖，最大独立集、最大完全子图、最小路径覆盖 等等。</p>
<p><strong>引理：</strong></p>
<p>在二分图最大匹配中，每条匹配边连接的两个顶点$(u,v)$最多只有一个与非匹配点有连边。</p>
<p><strong>证明：</strong></p>
<p>假设存在一条匹配边连接的两个顶点$(u,v)$，分别存在非匹配边$(u,x)$和$(v,y)$，且$x$和$y$都是匹配点，可以让$(u,v)$断开，从而成为失配边，那么 $(u,x)$和$(v,y)$变成匹配边。因此此时匹配数目相对之前增加了1个，这与最大匹配矛盾。故得证</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210714082435.png" alt="image-20210714082435281"></p>
<p>假设我们已经找到了二分图最大匹配，并且$(1,6)$是匹配边，$(1,8)$和$(3,6)$是非匹配边，其中$3$和$8$是非匹配点，那么可以将$(1,8)$和$(6,3)$变成匹配边，$(1,6)$变成非匹配边，那么就会使得匹配数量+1，因此这与最大匹配矛盾了。</p>
<hr>
<h3 id="最小顶点覆盖"><a href="#最小顶点覆盖" class="headerlink" title="最小顶点覆盖"></a>最小顶点覆盖</h3><p><code>点覆盖</code>的含义：一个点集合$S\subseteq V$，使得每一条边中至少有一个端点是在点集合$S$中</p>
<p><code>最小顶点覆盖</code>的含义：选择最少的点来覆盖所有的边</p>
<p>如下图，最小顶点覆盖是$(2,4,6)$三个点组成的点集。因为顶点2覆盖的边有$(2,5)$和$(2,8)$，顶点4覆盖的边有$(4,7)$和$(4,6)$，顶点6覆盖的边有$(1,6)$和$(3,6)$，可以发现这个顶点集合就已经完全覆盖了图中所有的边，而且它也已经是最小点集了。</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210714084437.png" alt="image-20210714084437304"></p>
<p><strong>结论：二分图最小顶点覆盖 = 二分图最大匹配</strong></p>
<p>要想证明$=$，那么可以先证明$\geq$，然后再证明$\leq$，由夹逼定理可知，就可以证明出$=$了</p>
<p>证明如下：</p>
<p>对于二分图$G$，设匹配图为$M$，最大匹配数为$m$：</p>
<ul>
<li>先来证明二分图的最小顶点覆盖$\geq $二分图的最大匹配。我们可以构造一个点集，这个点集是从最大匹配$M$里面取出来的，对于每一条匹配边，选择那个与非匹配点有连边的点（根据引理，这个点最多只有一个）加入点集$S$；如果不存在非匹配点，也就是说这个二分图其实就是最大匹配，即$M$就是$G$，那么匹配边的两侧端点都是匹配点，因此我们只需要从这一条匹配边中随便选择一个点即可，那么有$m$条匹配边，因此就需要选择$m$个点来覆盖。如上图所示：三条匹配边$(1,6)、(2,5)、(4,7)$，点集$S$构造的时候，$(1,6)$这条边选择$6$这个顶点，$(2,5)$这条边选择$2$这个点，$(4,7)$这条边选择$4$这个点。因此这种对于存在非匹配点的二分图来说，对于这$m$条匹配边，就需要$m$个点来覆盖，还存在非匹配边，那么可能还需要用一些点来覆盖这些匹配边，因此最小顶点集$S$肯定是$\geq m$的，即<strong>二分图的最小顶点覆盖$\geq $二分图的最大匹配</strong>。</li>
<li>再来证明二分图的最小顶点覆盖$\leq $二分图的最大匹配。如果$G$中的边除了$M$中匹配边以外没有其它非匹配边，那么最小顶点覆盖就是$m$。否则，还存在非匹配边，如果这条非匹配边的两个端点都在非匹配点上，那么可以构成一条新的匹配边，从而和最大匹配矛盾；所以这些非匹配边一定是其中一个端点在匹配点上，另一个端点在非匹配点上；令一条非匹配边上的一个端点为$u$，且$u$在非匹配点上，那么如果存在一条边$(u,v)$，点$v$必定是在我们构造出来的点集 $S$中的，于是边$(u,v)$一定可以被这个点集覆盖。所以<strong>二分图的最小顶点覆盖$\leq$二分图的最大匹配</strong>。</li>
</ul>
<p>简单理解为：</p>
<ul>
<li>$m$个点是必须的，即二分图的最小顶点覆盖$\geq $二分图的最大匹配。匹配的这$m$条边，它们的端点各不相同，因此要覆盖这$m$条匹配边，就需至少需要$m$个点。</li>
<li>$m$个点是足够的，即二分图的最小顶点覆盖$\leq $二分图的最大匹配。假设最小顶点覆盖为$n$，那么一定可以构造出$n$条匹配边，又由于我们已经知道了二分图的最大匹配是$m$，也就是说最大匹配边是$m$，因此必定有$n\leq m$。即假设覆盖完这$m$条匹配边后，如果还有某条边$e$还没有被覆盖，那么把$e$加入后会使得匹配数量+1，那么就会大于给定的最大匹配数目$m$，这与二分图最大匹配矛盾。</li>
</ul>
<hr>
<h3 id="最小边覆盖"><a href="#最小边覆盖" class="headerlink" title="最小边覆盖"></a>最小边覆盖</h3><p><code>边覆盖</code>的含义：选一条边就相当于覆盖了它的两个端点。</p>
<p><code>最小边覆盖</code>的含义：选择最少的边集，覆盖所有的点集</p>
<p>如下图所示，最小边覆盖为$E=${$(2,9),(3,8),(5,10),(4,9),(3,11)$}，答案是5。注意：<strong>孤立节点不需要用边来覆盖！</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210714093506.png" alt="image-20210714093506209"></p>
<p><strong>结论：二分图的最小边覆盖 = 顶点总数 - 孤立点数 - 二分图最大匹配</strong></p>
<p>证明：</p>
<p>为了使边数最少，又因为一条边最多能干掉两个点，所以尽量用边干掉两个点。也就是选择有匹配的那些边，因为它们一次能干掉两个节点，而且我们希望有匹配的边越多越好，那么就是最大匹配了，因为最大匹配才会有最多的匹配边。我们设左侧节点数目为$L$，右侧节点数目为$R$，孤立节点数目为$A$，设二分图最大匹配数目为$M$，节点总数就是$V=L+R$。由于孤立节点不需要边覆盖，因此需要考虑的点有$V-A$。</p>
<p>我们先用最大匹配边去干掉两侧的节点，那么就可以干掉$2\times M$个节点，剩下的就是要解决那些没有被匹配的点，那么这些没有被匹配的点的数目为$(V-A)-2\times M$，那么这些没有被匹配的点就需要用边去覆盖，因此还需要$(V-A)-2\times M$条边。因此总的需要最少的边数=$M+(V-A-2\times M)=V-A-M$，即二分图的最小边覆盖=顶点总数-孤立点数-二分图最大匹配。</p>
<p>如上图所示，绿色边表示匹配边，黑色边表示非匹配边。那么匹配边有3条，干掉了$2,3,5,8,9,10$节点，那么还剩下$4,11$没有被干掉，覆盖这两个点还需要2条边，因此最小边覆盖为$3+2=5$，这正好就是$12-4-3=5$</p>
<hr>
<h3 id="最大独立集"><a href="#最大独立集" class="headerlink" title="最大独立集"></a>最大独立集</h3><p><code>最大独立集合含义</code>：选取最多的点，使得图中任意两点都没有关系</p>
<p>如下图所示，最大独立集合为$A=${$1,3,5,7,8$}</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210714095317.png" alt="image-20210714095317247"></p>
<p><strong>结论：二分图的最大独立集 = 顶点总数 - 最小顶点覆盖</strong></p>
<p>证明：</p>
<p>首先，由最小顶点覆盖的含义可知，它已经覆盖了图中的所有边，因此我们把最小顶点集$S$中的顶点都从图中去掉，那么所有的边也就消失了，那么还剩下$V-S$个顶点，这些节点两两之间都不相邻了（因为没有边相连，不存在关联），那么这些剩余的节点就构成了一个独立集（为$A=V-S)$。由这个式子可以知道，因为$V$是定值，要想$A$最大，那么需要$S$最小。又由于最小顶点覆盖已经是最少的能够覆盖图中所有边的点集了，不能再少了，因此当取到最小顶点覆盖时，$S$达到最小，那么剩下的节点就是最大的。因此二分图的最大独立集 = 顶点总数 - 最小顶点覆盖</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210714101105.png" alt="image-20210714101105273"></p>
<hr>
<h3 id="最大完全子图（最大团）"><a href="#最大完全子图（最大团）" class="headerlink" title="最大完全子图（最大团）"></a>最大完全子图（最大团）</h3><p><code>完全图</code>的含义：任意两点都恰有一条边相连的图(任意两点都相邻)</p>
<p><code>完全子图</code>的含义：满足任意两点都恰有一条边相连的<strong>子图</strong>，也叫<strong>团</strong></p>
<p><code>最大完全子图</code>的含义：所有完全子图中<strong>顶点数最大的团</strong>，即<strong>最大团</strong>。最大指的是点数最多。即选取最多的点，使得图中任意两点都有关系</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210714102723.png" alt="image-20210714102723336"></p>
<p>图中{$a,b,d$}，${a,e}$，${c,f,g}$等都是完全子图，但是最大完全子图是${a,b,d,e}$</p>
<p><code>补图</code>的含义：一个$n$阶完全图中去掉原图$G$上的所有边，剩下的所有边所构成的一个图就是该图$G$的补图$G’$</p>
<p>如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210714104214.png" alt="image-20210714104214360"></p>
<p><strong>结论：二分图的最大团 = 补图的最大独立集</strong></p>
<p>证明：</p>
<p>对比最大团的含义和最大独立集的含义，我们知道它俩是相反的，那么我们就可以知道其实二分图的最大独立集的相反就是二分图的最大团。那么我们该怎么表达最大独立集的相反呢？这里就需要用到补图了。设原图为$G$，那么原图的相反其实就是原图的补图$G’$。因此我们想要求出原图$G$的最大团，那么就是要求出补图$G’$的最大独立集。</p>
<p>求最大完全子图的问题，如果不是二分图，这将是一个 NP 问题，但如果是个二分图，我们可以用上面的方法求解</p>
<hr>
<h3 id="有向无环图的最小路径覆盖"><a href="#有向无环图的最小路径覆盖" class="headerlink" title="有向无环图的最小路径覆盖"></a>有向无环图的最小路径覆盖</h3><h4 id="不相交的情况"><a href="#不相交的情况" class="headerlink" title="不相交的情况"></a>不相交的情况</h4><p>定义：选择一些路径，覆盖所有的点集，且各路径的点集之间不允许有交集，要求路径数最少。</p>
<p>如下图所示，得到的路径是：$(1\to2\to4\to5)$，$(6\to7)$，$(3)$。最小（不相交）路径覆盖为3</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210714105315.png" alt="image-20210714105315325"></p>
<p><strong>结论：有向无环图的最小(不相交)路径覆盖 = 原图结点数 - 拆点后二分图最大匹配数</strong></p>
<p>证明：</p>
<ul>
<li><p>初始状态，所有顶点都是一条路径，那么总共有$n$条路径</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210714111347.png" alt="image-20210714111347242"></p>
</li>
<li><p>每当增加一对匹配时，对应到原图中就是用一条边连接了两个节点，并且这两个结点一定不在同一个连通块（下文会证明），那么总的连通块数目减一（比如连接节点1和节点2，那么此时它俩处于同一个连通块，但它俩原来都是独立的连通块），也就是路径数目减一（二分图里找一条匹配边就相当于把两条路径合成了一条路径）；所以找到了几条匹配边，路径数就减少了多少。那么要想使得路径数最少，那么应该有更多的匹配边，因此想到应该是二分图的最大匹配。所以有最小路径覆盖=原图的结点数-拆点后新图的最大匹配数。</p>
</li>
<li><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210714111920.png" alt="image-20210714111920874"></p>
</li>
</ul>
<p>证明：每增加一条匹配边，在原图中的两个点必然不在一个连通块内</p>
<ul>
<li><p>每增加一对匹配边：$u_l\to v_r$，对应原图中就是增加了一条$u\to v$的边，反证法：假设$u$和$v$在同一个连通块内，那么会有如下的四种情况（橙色边为原本的连接情况，红色边为当前增加匹配后增加的新边）：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210714112425.png" alt="image-20210714112425763"></p>
</li>
<li><p>(a)如上图，对于节点$u$来说，它有两条出边，对于节点$v$来说，它有两条入边，但是对于二分图匹配来说，两个节点之间应该是只有一条出边和一条入边，因此这与 二分图匹配的 定义矛盾，因此，这种情况是不合法的</p>
</li>
<li><p>(b)如上图，节点$u,v$产生了圈，形成了环，这与 二分图匹配的 定义矛盾，因此，这种情况是不合法的</p>
</li>
<li><p>(c)如上图，对于节点$u$来说，它有两条出边，分别连向两点不同的节点，这对应到二分图和两个点进行了匹配，但在二分图匹配中，是一夫一妻制，而不能一夫多妻，因此这与 二分图匹配的 定义矛盾，因此，这种情况是不合法的</p>
</li>
<li><p>(d)如上图，对于节点$v$来说，它有两条入边，分别有两个不同的节点指向它，这对应到二分图和两个点进行了匹配，但在二分图匹配中，是一妻一夫制，而不是一妻多夫，因此这与 二分图匹配的 定义矛盾，因此，这种情况是不合法的</p>
</li>
<li><p>基于以上四种情况都不合法，所以每增加一条匹配边，在原图中的两个点必然不在一个连通块内，得证</p>
</li>
</ul>
<p>举个栗子：</p>
<p>首先将每个节点$u$拆成两个节点$u_l$和$u_r$，如果原图存在边$u\to v$，则在拆点后的图上建立边：$u_l\to v_r$。由于原图是有向无环图，所以拆点后的图是一个二分图。如图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210714141226.png" alt="image-20210714141226353"></p>
<p>对拆点后的图求一次二分图最大匹配，得到：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210714141427.png" alt="image-20210714141427393"></p>
<p>那么有向无环图的最小(不相交)路径覆盖 = 原图结点数 -  拆点后二分图最大匹配数=$7-4=3$</p>
<h4 id="相交的情况"><a href="#相交的情况" class="headerlink" title="相交的情况"></a>相交的情况</h4><p>定义：选择一些路径，覆盖所有的点集，且各路径的点集之间允许有交集，要求路径数最少。</p>
<p>举个栗子：</p>
<p>如下图所示，得到的路径为：$(1\to 2\to 4\to 5)$，$(3\to 4\to 6\to 7)$，最小（相交）路径覆盖为2</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210714142307.png" alt="image-20210714142307071"></p>
<p><strong>结论：首先对原图求一次传递闭包得到一个新图，有向无环图的最小(相交)路径覆盖 = 新图结点数 - 拆点后二分图最大匹配数</strong>。</p>
<p>证明：</p>
<p>因为路径之间是允许相交的，所以对于 2 条路径$x\to p\to y$和$a\to p\to b$，那么多建立两条边$(x\to y)$和$(a\to b)$，那么我们发现$x\to y$其实是 $x\to p$，$p\to y$求传递闭包得到的，同理分析$a\to b$也是求传递闭包得到的。对图中所有的这样的边都这样操作一次，相当于求了一个传递闭包。然后再求拆点二分图的最大匹配，就可以当成求最小不相交路径覆盖的情况来求解了。</p>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>二分图最小顶点覆盖 = 二分图最大匹配</li>
<li>二分图的最小边覆盖 = 顶点总数 - 孤立点数 - 二分图最大匹配</li>
<li>二分图的最大独立集 = 顶点总数 - 最小顶点覆盖</li>
<li>有向无环图的最小(不相交)路径覆盖 = 原图结点数 - 拆点后二分图最大匹配数</li>
<li>首先对原图求一次传递闭包得到一个新图，有向无环图的最小(相交)路径覆盖 = 新图结点数 - 拆点后二分图最大匹配数</li>
</ol>
<hr>
]]></content>
      <categories>
        <category>二分图</category>
      </categories>
      <tags>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title>机器任务</title>
    <url>/2021/07/19/Algorithm-Improvement/Chapter3---Gragh-Theory/%E4%BA%8C%E5%88%86%E5%9B%BE/%E6%9C%BA%E5%99%A8%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="机器任务"><a href="#机器任务" class="headerlink" title="机器任务"></a>机器任务</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210719155448.png" alt="image-20210719155448461"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>这一题其实是二分图最大匹配的应用。</p>
<p>结论：<strong>二分图的最小顶点覆盖=二分图的最大匹配</strong></p>
<p>最小顶点覆盖：用最少的顶点来覆盖图中所有的边</p>
<p>二分图最小顶点覆盖的模型特点是：<strong>每条边有2个端点，二者至少选择一个</strong>。我们称之为“2要素”。如果一个题目具有“2要素”的特点，那么就可以尝试抽象成二分图最小顶点覆盖模型来求解</p>
<p>在这道题目中，每个任务要么在机器$A$上以模式$a[i]$执行，要么在机器$B$上以模式$b[i]$执行，二者必选其一。因此，我们可以把机器$A$的$N$种模式作为$N$个顶点放在左部点集合中，把机器$B$的$M$种模式作为$M$个顶点放在右部点集合中，每个任务当作是一条无向边，连接左边的$a[i]$模式（第$a[i]$个节点）和右边的$b[i]$模式（第$b[i]$个节点）。</p>
<p>由于每台机器转换一次模式就需要重启一次，要想使得重启次数最少，那么就需要某种模式它能处理多种任务，即一个节点能够连接多个无向边。那么要使重启次数最少，即用最少的顶点来覆盖掉所有的无向边。那么这就是要求二分图的最小顶点覆盖，根据前面的结论可知，只需要求出二分图的最大匹配即可。</p>
<p>这里有个坑点，两台机器一开始的模式都是0，因此每个任务如果可以在模式为0的情况下都可以直接进行，则不需要进行重启，因此建图时碰到$a[i]$或者$b[i]$为0，则直接跳过不考虑把它建立到图中即可。</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="keyword">int</span> match[N];</span><br><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//遍历机器B中的这m个模式   即寻找右边的女生集合</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果x这个男生还没有访问过i这个女生</span></span><br><span class="line">        <span class="comment">//并且 此时并不是处于模式0</span></span><br><span class="line">        <span class="keyword">if</span>(!st[i]&amp;&amp;g[x][i]==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            st[i]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(match[i]==<span class="number">-1</span>||<span class="built_in">find</span>(match[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                match[i]=x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n),n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//有多组测试数据  因此每次都要进行初始化</span></span><br><span class="line">        <span class="built_in">memset</span>(match,<span class="number">-1</span>,<span class="keyword">sizeof</span> match);</span><br><span class="line">        <span class="built_in">memset</span>(g,<span class="number">0</span>,<span class="keyword">sizeof</span> g);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;m,&amp;k);</span><br><span class="line">        <span class="keyword">while</span>(k--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> id,a,b;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;id,&amp;a,&amp;b);</span><br><span class="line">            <span class="comment">//如果机器A处于模式0或者机器B处于模式0 那么g[a][b]=0;否则g[a][b]=1</span></span><br><span class="line">            <span class="keyword">if</span>(a&amp;&amp;b)</span><br><span class="line">            g[a][b]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//机器A的n个模式看成是左边的男生集合  从男生集合出发进行匹配</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memset</span>(st,<span class="number">0</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(i))</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>二分图</category>
      </categories>
      <tags>
        <tag>最小顶点覆盖</tag>
      </tags>
  </entry>
  <entry>
    <title>捉迷藏</title>
    <url>/2021/07/20/Algorithm-Improvement/Chapter3---Gragh-Theory/%E4%BA%8C%E5%88%86%E5%9B%BE/%E6%8D%89%E8%BF%B7%E8%97%8F/</url>
    <content><![CDATA[<h1 id="捉迷藏"><a href="#捉迷藏" class="headerlink" title="捉迷藏"></a>捉迷藏</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210720123116.png" alt="image-20210720123116058"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>最小路径点覆盖：选择一些路径，覆盖所有点，并且各个路径的节点之间不能有交集，要求路径数最少</p>
<p>最小路径重复点覆盖：选择一些路径，覆盖所有点，但是各个路径的节点之间允许有交集，要求路径数最少</p>
<p>求解最小路径点覆盖的方法：</p>
<p><strong>结论：DAG的最小路径点覆盖=原图节点数-拆点后形成的二分图的最大匹配数</strong></p>
<p>证明：</p>
<p>这里使用的技巧是拆点。假设原图有$n$个节点，将每个节点都复制一份放到右边，假设节点$i$复制后的点为$i’$，我们将原图中的边$(i,j)$转变为新图中的$(i,j’)$。新图必然是一个二分图。</p>
<p>如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210720123914.png" alt="image-20210720123914525"></p>
<p>考虑原图中的任意一条路径转化到新图中是啥样的呢？</p>
<ul>
<li>每条路径转化到新图中一定对应新图的一个匹配，即每个点只会在一条边中。反之也成立</li>
<li>我们可以看到原图中每条路径的终点，对应到新图中的话就是出点没有引出一条出边，即它是新图中左部的非匹配点，例如上图中的节点3。同理左部的每一个非匹配点都对应着原图中的路径。即使是孤立节点也可以看成一个终点，符合要求。我们想要让路径数最少，那么就是让左部的非匹配点数目最少，由于$n=$左部非匹配点数+左部匹配点数，因此必须让左部匹配点数最大，那么也就是找最大匹配，设最大匹配为$m$，因此左部的非匹配点最少为$n-m$，即路径数最少为$n-m$。因此最小路径点覆盖=原图节点数-拆点后形成的二分图的最大匹配数</li>
</ul>
<p>求解最小路径重复点覆盖的方法：</p>
<ul>
<li>对原图$G$求一次传递闭包，得到一张图$G’$</li>
<li>求原图的最小路径重复点覆盖$\iff$ 求新图的最小路径点覆盖</li>
</ul>
<p>证明：</p>
<ol>
<li>充分性：依次考虑原图的每一条符合条件的路径，当我们考察第$i$条路径时，如果路径上的点和前$i-1$条边上的点是重复的，那么直接跳过即可，新图中加了很多边，可以跳过。另外第$i$条路径上的点不可能全部和前$i-1$条边上的点重复，否则第$i$条路径就没有存在的必要了。</li>
<li>必要性：将新图中间接转移过去的边展开成原来的边即可得到原图中的路径。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210720145120.png" alt="image-20210720145120840"></p>
<p>现在我们来理清一下题意：题目中说到 “如果从房子$A$沿着路走下去能够到达$B$，那么在 $A$和 $B$ 里的人是能够相互望见的。”这说明了一条路径中最多只能选择一个点作为藏身点，因为如果选择两个藏身点的话，那么就可以互相看见了。 “cl2 要求这$K$个藏身点的任意两个之间都没有路径相连。”其实就是要求：给定一定DAG图，让我们选择尽可能多的点，使得这些点任意两个点之间都不能相互到达。</p>
<p>题目要求尽可能多的藏身点组成集合，使得任意两点之间都没有边。那这与最小重复点路径覆盖有啥关系嘛？这不应该是最大独立集的含义嘛？但是要注意最大独立集只针对无向图，对于有向图是不适用的。但是题目中说到视线是可以沿着路径无限延展的，似乎在引导我们往传递闭包上面想，而说到传递闭包，那么不就是要求最重复路径点覆盖嘛？</p>
<p>或者我们可以根据下面的这个定理来理清题意：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210720130243.png" alt="image-20210720130243580"></p>
<p>要求尽可能多的藏身点组成集合，使得任意两点之间都没有边这正与最长反链长度相同，而最长反链长度=最小链覆盖。</p>
<p>我们设答案为$K$，最小重复路径点覆盖为cnt：</p>
<ul>
<li>先证明$K\leq cnt$。由于这cnt条路径把所有节点都已经覆盖了，所以选择$K$个点从这cnt条路径上选了，每条路径上最多只能选择一个点，因此必然有$K\leq cnt$。</li>
<li>再证明$K=cnt$。可以采用构造法：我们把这cnt条路径中每条路径的终点都放入这个顶点集合$V$中。设集合<code>next(V)</code>表示：从点集合$V$中的每个点出发可以到达的所有顶点的集合。<ul>
<li>如果$V\cap next(V)=\empty$，那么意味着从$V$中所有节点出发，都不能到达$V$集合内部的顶点。即$V$内部的任意两个节点之间是不能相互到达的。而这个含义正好与我们题意想要求的是一致的。因此，而$V$里面就有cnt个点，因此我们就构造出了包含cnt个点的方案。此时$V$就是合法的答案。</li>
<li>如果$V\cap next(V)\notin \empty$，那么我们从$V$中挑选出任意一个点$v_i$（某条路径的终点），让$v_i$沿着有向边往回走（往起点方向走），走到某个点$v_i’$不属于$next(V)$为止。对于$V$集合中的每一个点$v_i$都进行这样的操作，每个$v_i$都走到$v_i’$不属于$next(V)$为止。那么最终直到$V$和$next(V)$没有交集为止。那么如何证明最终一定可以做到$V$和$next(V)$没有交集呢？如何证明最多走到起点时就能保证$V\cap next(V)=\empty$呢？ 这里采用反证法：假设一直往回走，一直回退到起点，都不能保证某个点$v_i’$不属于$next(V)$，也就是说，走到起点了仍然有某个点$v_i’\in next(V)$，由于$next(V)$表示从多条路径的终点出发所能到达的所有顶点的集合，那么这说明$v_i’$所在的这条路径$e$的起点都是可以被这些路径所到达的，那么这条路径$e$其实就没有存在的价值了。因为我们可以把这条路径$e$接到$next(V)$中某条路径的后面，那么当前路径$e$上的每一个点都可以被覆盖，由于把这条路径接到了某一条路径的后面，因此路径数目少1，这与cnt为最小重复路径点覆盖矛盾。因此，我们就证明了$v_i$它走到某个点就一定会停止，也就是说最终仍然会有$V\cap next(V)=\empty$。因此，我们就证明了$K=cnt$。</li>
</ul>
</li>
</ul>
<p>由于我们证明了$K\leq cnt$并且$K=cnt$，那么最终$K=cnt$。</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">210</span>,M=<span class="number">30010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="comment">//邻接矩阵 g[i][j]=1表示从i节点到j节点连一条有向边</span></span><br><span class="line"><span class="comment">//g[i][j]=0表示从i节点到j节点没没有引出有向边</span></span><br><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line"><span class="keyword">int</span> match[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="comment">//寻找男生x的配对女生</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//遍历x能够联系的所有这n个女生</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//g[x][i]==1表示男生x和女生i之间连了一条有向边  可以联系</span></span><br><span class="line">        <span class="comment">//!st[i]表示男生x之前还没有访问过这个女生i</span></span><br><span class="line">        <span class="keyword">if</span>(g[x][i]&amp;&amp;!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            st[i]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(match[i]==<span class="number">-1</span>||<span class="built_in">find</span>(match[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                match[i]=x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(match,<span class="number">-1</span>,<span class="keyword">sizeof</span> match);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        g[a][b]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对原图G求一遍传递闭包,得到一个新图G&#x27;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                g[i][j]|=g[i][k]&amp;g[k][j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//对这个新图G&#x27;求二分图的最大匹配</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(st,<span class="number">0</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(i))</span><br><span class="line">        res++;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">//最小路径重复点覆盖=总点数-新图G&#x27;的最大匹配      </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,n-res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>二分图</category>
      </categories>
      <tags>
        <tag>最小可重复点覆盖</tag>
      </tags>
  </entry>
  <entry>
    <title>染色法判定二分图</title>
    <url>/2021/07/13/Algorithm-Improvement/Chapter3---Gragh-Theory/%E4%BA%8C%E5%88%86%E5%9B%BE/%E6%9F%93%E8%89%B2%E6%B3%95%E5%88%A4%E5%AE%9A%E4%BA%8C%E5%88%86%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="染色法判定二分图"><a href="#染色法判定二分图" class="headerlink" title="染色法判定二分图"></a>染色法判定二分图</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210713124859.png" alt="image-20210713124859893"></p>
<hr>
<h3 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h3><p>二分图的含义：二分图是有两组点集$X$和$Y$组成的无向图，其中点集$X$中的点之间互相没有关联，点集$Y$中的点之间互相没有关联，但是点集$X$中的点和点集$Y$中的点之间可能存在关联，用一条无向边来表示这种关联。</p>
<p>如下图所示：</p>
<p>橙色节点都属于点集$X$，互相之间没有边相连；蓝色节点都属于点集$Y$，互相之间没有边相连。绿色代表无向边，用来连接点集$X$和点集$Y$中的节点。</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210713125403.png" alt="image-20210713125403160"></p>
<hr>
<h3 id="二分图的判定"><a href="#二分图的判定" class="headerlink" title="二分图的判定"></a>二分图的判定</h3><h4 id="圈的定义"><a href="#圈的定义" class="headerlink" title="圈的定义"></a>圈的定义</h4><p>图论中圈的定义是：任选一个顶点为起点，沿着不重复的边，经过不重复的顶点，之后又回到起点的闭合路径。</p>
<p>如下图所示：</p>
<p>$1-&gt;2-&gt;4-&gt;3-&gt;1$就是一个圈</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210713130025.png" alt="image-20210713130025270"></p>
<ul>
<li>偶数圈就是经过路径中的顶点数为偶数的圈，如上图，$1-&gt;2-&gt;4-&gt;3-&gt;1$</li>
<li>奇数圈就是经过路径中的顶点数为奇数的圈，如下图，$1-&gt;2-&gt;4-&gt;5-&gt;3-&gt;1$</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210713131614.png" alt="image-20210713131614073"></p>
<h4 id="二分图的判定性质"><a href="#二分图的判定性质" class="headerlink" title="二分图的判定性质"></a>二分图的判定性质</h4><p><strong>判定性质：判断一个图是不是二分图，其实就是判断这个图有没有奇圈</strong></p>
<p>如下图所示：</p>
<p>我们把这个图划分成了两个点集$X$和$Y$</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210713130951.png" alt="image-20210713130951633"></p>
<p>但是如果存在奇圈的话，就会变成如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210713131058.png" alt="image-20210713131058769"></p>
<p>因此，我们可以通过观察奇偶性可知，相邻的两个节点的奇偶性一定是不相同的，分别对应到两个不同的点集$X$和$Y$中。那么当存在奇圈时，则说明相邻的这两个节点奇偶性一定是相同的，这与二分图的性质矛盾。</p>
<hr>
<h3 id="染色法判定二分图-1"><a href="#染色法判定二分图-1" class="headerlink" title="染色法判定二分图"></a>染色法判定二分图</h3><p>二分图染色算法的实现是通过判断一个图中是否存在奇圈从而确定它是否是二分图。    </p>
<p>染色法的算法步骤如下：</p>
<ul>
<li><p>设染色只有2种颜色，$color$为1和2</p>
</li>
<li><p>选择当前还没有被染色的节点作为当前节点$u$，给它染上颜色1，即$color[u]=1$</p>
</li>
<li><p>遍历该节点的所有邻接点$v$，并给这些邻接点染色，即$color[v]=3-color[u]$</p>
</li>
<li><p>重复上面两个步骤，直到全部染色完毕</p>
</li>
<li><p>如果染色过程种发生了矛盾，即相邻两个节点的颜色相同，则说明不满足二分图的奇偶性，因此可以判定出该图不是二分图；否则说明全部都成功无矛盾染色，该图是二分图</p>
</li>
</ul>
<p>注意：由于二分图可能是一个非连通图，所以不是只访问一个结点就能遍历到所有结点的，需要对所有结点都进行一次遍历。</p>
<p>染色法可以用dfs和bfs实现，算法思路其实都是一样的</p>
<blockquote>
<p>问题：如何理解dfs染色法中的下列代码呢？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(color[j]==c)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>如上图，假设当前节点是$u$，设$u=4$，设当前节点$u$的被染上的颜色为$c$。我们来看它的邻接点$j=2$。我们发现，其实在前面的时候，节点$1$就已经把节点$2$染过色了，染的颜色为$color[j]$。那么当节点$u$遍历到节点$j$时，发现节点$j$已经被染过色了，那么我们就只需要判断节点$j$的颜色是否与当前节点$u$的颜色相同。如果相同，则不符合二分图的奇偶性，则该图不是二分图；</p>
</blockquote>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><strong>dfs染色法：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//dfs染色法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, M = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="keyword">int</span> color[N];<span class="comment">//给图的每个顶点染色的数组</span></span><br><span class="line"><span class="comment">//构造无向图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//dfs函数是用来判定染色过程中是否出现了矛盾，如果出现了矛盾，则返回false</span></span><br><span class="line"><span class="comment">//如果没有出现矛盾，就返回true</span></span><br><span class="line"><span class="comment">//这里假设染了两种颜色1 和 2</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    color[u] = c;<span class="comment">//u这个顶点染上c的颜色</span></span><br><span class="line">    <span class="comment">//拓展u这个顶点的邻接表，去寻找邻接点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="comment">//如果j顶点还没有被染过色</span></span><br><span class="line">        <span class="keyword">if</span> (!color[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果当这个j顶点染上色之后，就出现了矛盾，那么让flag为false</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(j, <span class="number">3</span> - c))<span class="comment">//3 - c表示所染的颜色一定是在1和2之间</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里说明j之前已经被染过色了 那么判断一下当前节点u的颜色和它的邻接点j的颜色是否相同</span></span><br><span class="line">        <span class="comment">//如果相同则说明一条边的两个顶点都是染相同的颜色,则不满足二分图的奇偶性</span></span><br><span class="line">        <span class="comment">//那么就会出现染色矛盾</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (color[j] == c)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//染色成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="built_in">add</span>(a, b);</span><br><span class="line">        <span class="built_in">add</span>(b, a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;<span class="comment">//flag用来判断染色是否有矛盾，如果出现矛盾,则为false,否则就是true</span></span><br><span class="line">    <span class="comment">//对1号顶点到n号顶点分别染色</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果当前i这个顶点还没有被染色的话  !color[i]表示当前i顶点还没有被染色</span></span><br><span class="line">        <span class="keyword">if</span> (!color[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果当这个i顶点染上色之后，就出现了矛盾，那么让flag为false，然后break退出for循环</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(i, <span class="number">1</span>))<span class="comment">//有两种颜色  颜色1和颜色2</span></span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果染色过程中没有出现矛盾，成功给每个顶点染色了，输出Yes</span></span><br><span class="line">    <span class="keyword">if</span> (flag)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="comment">//否则如果染色过程中出现了矛盾，则输出No</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>bfs染色法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//bfs染色法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, M = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="keyword">int</span> color[N];<span class="comment">//给图的每个顶点染色的数组</span></span><br><span class="line"><span class="comment">//bfs的队列</span></span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line"><span class="comment">//构造无向图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//bfs染色法 c是颜色  0 表示还没有染色 1表示染了一种颜色  2表示染了另一种颜色</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    color[u]=c;     <span class="comment">//给u这个节点染上颜色c</span></span><br><span class="line">    q.<span class="built_in">push</span>(u);      <span class="comment">//将u这个节点加入队列q中</span></span><br><span class="line">    <span class="comment">//当队列不为空时</span></span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//取出队头元素</span></span><br><span class="line">        <span class="keyword">int</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();    <span class="comment">//队头元素已经出队了,弹掉队头元素</span></span><br><span class="line">        <span class="comment">//遍历队头元素t的所有邻接点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//队头元素t的邻接点j</span></span><br><span class="line">            <span class="keyword">int</span> j=e[i];</span><br><span class="line">            <span class="comment">//如果j还没有被染色</span></span><br><span class="line">            <span class="keyword">if</span>(!color[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//由于j是t的邻接点 所以它俩奇偶性不同 染色不一样</span></span><br><span class="line">                color[j]=<span class="number">3</span>-color[t];</span><br><span class="line">                <span class="comment">//将j加入队列q中</span></span><br><span class="line">                q.<span class="built_in">push</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//否则说明j已经被染过色了 但是它的颜色与邻接点t的颜色相同 则不满足奇偶性</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(color[j]==color[t])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a,b);</span><br><span class="line">        <span class="built_in">add</span>(b,a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!color[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">bfs</span>(i,<span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                flag=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>二分图</category>
      </categories>
      <tags>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title>棋盘覆盖</title>
    <url>/2021/07/19/Algorithm-Improvement/Chapter3---Gragh-Theory/%E4%BA%8C%E5%88%86%E5%9B%BE/%E6%A3%8B%E7%9B%98%E8%A6%86%E7%9B%96/</url>
    <content><![CDATA[<h1 id="棋盘覆盖"><a href="#棋盘覆盖" class="headerlink" title="棋盘覆盖"></a>棋盘覆盖</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210719133614.png" alt="image-20210719133614274"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>在状态压缩DP的例题“蒙德里安的梦想”中，我们解决了用$1\times2$的长方形铺满$N\times M$网格的方案数问题。而这里与之不同的是，本题中的棋盘有禁止放置的格子，并且只需要求出能放置的$1\times2$骨牌的最大数量即可。当$N,M$较小时，仍然可以使用状态压缩DP来求解，这里更高效的方法则是构建出二分图匹配的模型。</p>
<p>二分图匹配的模型需要两个基本要素：</p>
<ul>
<li>节点能分成两个独立的集合，每个集合内部有$0$条边</li>
<li>每个节点只能与$1$条匹配边相连</li>
</ul>
<p>我们称为“0要素”和“1要素”。在把实际问题抽象成二分图匹配时，我们就要寻找题目中具有这种“0”和“1”性质的对象，从而发现模型构建的突破口。</p>
<p>在本题中，任意两张骨牌不能重叠，也就是每个格子只能被1张骨牌覆盖。而骨牌的大小为$1\times2$，覆盖$2$个相邻的格子。这恰好与“1要素”相对应。于是，我们可以把棋盘上没有被禁止的格子作为节点，把骨牌作为无向边（两个相邻的格子对应的节点之间连一条无向边）</p>
<p>我们可以发现，对于棋盘来说，相邻的节点它们的横坐标+纵坐标，得到的和 是不同的。因此，我们可以把棋盘黑白染色（行号+列号为偶数的格子被染成白色，行号+列号为奇数的格子被染成黑色），把白色格子都放进一个点集合$V_1$中，把黑色格子都放进另一个点集合$V_2$中。那么两个相同颜色的格子不可能被同一个骨牌覆盖，也就是说同色格子之间没有边相连，即点集合$V_1$内部没有边相连，点集合$V_2$内部没有边相连。这恰好与“0要素”对应。</p>
<p>于是，刚才建立的无向图就是一张二分图。可以把白色格子作为左部节点，黑色格子作为右部节点。如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210719135004.png" alt="image-20210719135004377"></p>
<p>要让骨牌不重叠的情况下尽量多放，就是求上述构建好的二分图的最大匹配。</p>
<p>这里因为涉及到二维坐标问题，那么我们建图时，可以使用二维的邻接矩阵<code>g[N][N]</code>，当$g[i][j]=1$表示这个格子不能放置，当$g[i][j]=0$表示这个格子可以放置。</p>
<p>对于二分图来说，虽然是无向图。但是求二分图的最大匹配时，使用匈牙利算法，是从男生集合出发的，因此只需要当初有向边即可。那么这里我们把白色格子组成的点集合看作是男生集合，把黑色格子组成的点集合看作是女生集合。那么做匈牙利算法时，从$(i+j)%2==0$这个男生集合出发即可。</p>
<p>由于是使用邻接矩阵建图，因此不像邻接表那样的建图方式（邻接表需要add这个建图函数)</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">110</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;PII;</span><br><span class="line"><span class="keyword">int</span> n,t;</span><br><span class="line"><span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line"><span class="comment">//存储女生配对的男友的编号 比如match[i][j]=&#123;2,3&#125; 表示(i,j)这个格子所对应的那个女生她的现配男友的编号为&#123;2,3&#125;这个格子</span></span><br><span class="line">PII match[N][N];</span><br><span class="line"><span class="keyword">bool</span> st[N][N];</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="comment">//匈牙利算法</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//遍历点(x,y)的四个方向</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a=x+dx[i];</span><br><span class="line">        <span class="keyword">int</span> b=y+dy[i];</span><br><span class="line">        <span class="keyword">if</span>(a&gt;=<span class="number">1</span>&amp;&amp;a&lt;=n&amp;&amp;b&gt;=<span class="number">1</span>&amp;&amp;b&lt;=n&amp;&amp;!g[a][b]&amp;&amp;!st[a][b])</span><br><span class="line">        &#123;</span><br><span class="line">            st[a][b]=<span class="literal">true</span>;</span><br><span class="line">            PII t=match[a][b];</span><br><span class="line">            <span class="keyword">if</span>(t.first==<span class="number">-1</span>||<span class="built_in">find</span>(t.first,t.second))</span><br><span class="line">            &#123;</span><br><span class="line">                match[a][b]=&#123;x,y&#125;;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        <span class="comment">//如果不能放置 则g设为1</span></span><br><span class="line">        g[x][y]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(match,<span class="number">-1</span>,<span class="keyword">sizeof</span> match);</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;  <span class="comment">//匹配数量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//(i+j)%2==0表示男生集合  g[i][j]==0表示这个点可以放置</span></span><br><span class="line">            <span class="keyword">if</span>((i+j)%<span class="number">2</span>==<span class="number">0</span>&amp;&amp;g[i][j]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//每一轮男生(i,j)匹配时  都要清空上一个男生进行匹配操作时所遗留下的状态</span></span><br><span class="line">                <span class="built_in">memset</span>(st,<span class="number">0</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">                <span class="comment">//(i,j)这个男生找到了女朋友  匹配数量+1</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">find</span>(i,j))</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>二分图</category>
      </categories>
      <tags>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title>骑士放置</title>
    <url>/2021/07/19/Algorithm-Improvement/Chapter3---Gragh-Theory/%E4%BA%8C%E5%88%86%E5%9B%BE/%E9%AA%91%E5%A3%AB%E6%94%BE%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="骑士放置"><a href="#骑士放置" class="headerlink" title="骑士放置"></a>骑士放置</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210719171846.png" alt="image-20210719171846826"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>最大独立集：选出最多的点，使得选出的点之间没有边</p>
<p>在二分图中，求最大独立集合$\iff$去掉最少的点，使得将所有边都破坏掉$\iff$ 找到最小顶点覆盖$m$$\iff$ 找到最大匹配$m$</p>
<p>结论：最大独立集=总点数-孤立节点数-最小顶点覆盖数</p>
<p>这个题目和“棋盘覆盖”这个题目是类似的，可以对棋盘进行黑白染色，黑色的格子、白色的格子分别作为二分图的左、右部节点。</p>
<p>如果两个格子是“日”字的对角（能互相攻击到），则在这两个格子之间连一条无向边。这个题目是想要求出最多能放多少个不能互相攻击的骑士，由于我们把有攻击的节点都连边了，因此考虑用最少的点来覆盖这些边，那么就会尽可能的剩下多的节点（骑士）了，因此先求出最小顶点覆盖，然后用总点数减去最小顶点覆盖，再减去孤立节点数即可。因此，抽象题意其实就是要求最大独立集。而且，“日”字的两个对角格子的颜色一定不相同。因此，我们建立的图一定是一张二分图。那么我们用匈牙利算法求出二分图的最大匹配，就可以很容易求出二分图的最大独立集了。</p>
<p>如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210719172823.png" alt="image-20210719172823092"></p>
<p>两个格子的马若能互相攻击，则这两个格子之间能连上一条边。若两只马能够互相攻击，则这两只马的格子一定是两种不同颜色的格子。</p>
<p>这里要注意，题目中说了有一些格子禁止放棋子，因此这些格子都会被认为是孤立节点。计算最大独立集时，要记得减去这些孤立节点。</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">110</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;PII;</span><br><span class="line"><span class="keyword">int</span> n,m,t;</span><br><span class="line"><span class="comment">//邻接矩阵 g[i][j]=1表示(i,j)这个格子可以放置  g[i][j]=0表示(i,j)这个格子不可以放置</span></span><br><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line">PII match[N][N];</span><br><span class="line"><span class="keyword">bool</span> st[N][N];</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">8</span>]=&#123;<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">8</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-2</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="comment">//寻找(x,y)这个男生的女友</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//遍历(x,y)这个格子周围的8个方向 即遍历它周围的女生集合</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a=x+dx[i];</span><br><span class="line">        <span class="keyword">int</span> b=y+dy[i];</span><br><span class="line">        <span class="keyword">if</span>(a&gt;=<span class="number">1</span>&amp;&amp;a&lt;=n&amp;&amp;b&gt;=<span class="number">1</span>&amp;&amp;b&lt;=m&amp;&amp;!st[a][b]&amp;&amp;!g[a][b])</span><br><span class="line">        &#123;</span><br><span class="line">            st[a][b]=<span class="literal">true</span>;</span><br><span class="line">            PII t=match[a][b];</span><br><span class="line">            <span class="keyword">if</span>(t.first==<span class="number">-1</span>||<span class="built_in">find</span>(t.first,t.second))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//(a,b)这个格子的女生她的现配成功男友是(x,y)</span></span><br><span class="line">                match[a][b]=&#123;x,y&#125;;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(match,<span class="number">-1</span>,<span class="keyword">sizeof</span> match);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;t);</span><br><span class="line">    <span class="comment">//输入t个不能放置的格子</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        g[a][b]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//(i+j)%2==0表示男生集合</span></span><br><span class="line">            <span class="comment">//g[i][j]==0表示(i,j)这个格子可以放置</span></span><br><span class="line">            <span class="keyword">if</span>((i+j)%<span class="number">2</span>==<span class="number">0</span>&amp;&amp;g[i][j]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">memset</span>(st,<span class="number">0</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">find</span>(i,j))</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最大独立集=总点数-孤立节点数-最小顶点覆盖</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,n*m-t-res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>二分图</category>
      </categories>
      <tags>
        <tag>最大独立集</tag>
      </tags>
  </entry>
  <entry>
    <title>差分约束算法</title>
    <url>/2021/07/11/Algorithm-Improvement/Chapter3---Gragh-Theory/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="差分约束系统"><a href="#差分约束系统" class="headerlink" title="差分约束系统"></a>差分约束系统</h1><hr>
<p>差分约束系统是一种特殊的$N$元一次不等式组。它包含$N$个变量$X_1$~$X_N$以及$M$个约束条件，每个约束条件都是由两个变量做差构成的，形如$X_i-X_j\leq c_k$，其中$c_k$是常数（可以是非负数，也可以是负数），$1\leq i,j\leq N,1\leq k\leq M$。我们要解决的问题就是：求一组解$X_1=a_1,X_2=a_2,\cdots,X_N=a_N$，即解$X=(a_1,a_2,\cdots,a_N)$使得所有约束条件都能得到满足。</p>
<p>差分约束系统的每个约束条件$X_i-X_j\leq c_k$可以变形为$X_i\leq X_j+c_k$，这与单源最短路径问题中的三角不等式$dist[y]\leq dist[x]+z$非常相似，注意这个式子是更新过后的。因此，我们可以把每个变量$X_i$看作是有向图中的一个节点$i$，对于每个约束条件$X_i-X_j\leq c_k$，从节点$j$向节点$i$连一条长度为$c_k$的有向边。</p>
<p><strong>引理：</strong></p>
<p>设$X=(x_1,x_2,\cdots,x_n)$是一个差分约束系统的一个解，$d$为任意常数，那么$X+d=(x_1+d,x_2+d,\cdots,x_n+d)$也是该系统的解。</p>
<p>证明：对于每个$x_i$和$x_j$，有$(x_j+d)-(x_i+d)=x_j-x_i$。因此，若$X$是这个差分约束系统的一个解，那么$X+d$也是这个系统的解</p>
<p>例如：</p>
<ul>
<li>$x_1-x_2\leq 0$</li>
<li>$x_1-x_5\leq -1$</li>
<li>$x_2-x_5\leq 1$</li>
<li>$x_3-x_1\leq 5$</li>
<li>$x_4-x_1\leq 4$</li>
<li>$x_4-x_3\leq -1$</li>
<li>$x_5-x_3\leq -3$</li>
<li>$x_5-x_4\leq -3$</li>
</ul>
<p>该问题的一个解为$X=(-5,-3,0,-1,-4)$，令一个解为$X’=(0,2,5,4,1)$，这两个解是有联系的，$X’$中的每个元素比$X$中的相应元素大5</p>
<p>这也正说明了，如果$X$是一个差分约束系统的解，那么$X+d$也是这个系统的解</p>
<p>假设$\forall i,X_i\leq c$，然后再增加一个超级源点0号节点，令$X_0=0$，令$d=-X_0$，等式两边同时加上$d$，可得$X_i-X_0\leq c-X_0$，即$X_i-X_0\leq c$。这样一来，就多了$N$个形如$X_i-X_0\leq 0$的约束条件，应该从节点0向每个节点$i$连一条长度为0的有向边。</p>
<hr>
<h3 id="约束图"><a href="#约束图" class="headerlink" title="约束图"></a>约束图</h3><p>对于$n$个变量，$m$个约束条件来说，其实就是对应于图论中的$n$个节点，$m$条边。对于$i=1,2,\cdots,n$，图中的每一个顶点$v_i$对应着$n$个未知量中的一个$x_i$，图中的每个有向边对应着关于两个未知量的$m$个不等式的其中一个。</p>
<p>对于一个差分约束系统来说，相应的约束图是一个带权有向图$G=(V,E)$，其中$V=${$v_0,v_1,\cdots,v_n$}，而且$E=${$(v_i,v_j):x_j-x_i\leq b_k$}$\bigcup$ {$(v_0,v_1),(v_0,v_2),\cdots,(v_0,v_n)$}</p>
<p>这里引入超级源点$v_0$是为了保证其他每个顶点$v_1,v_2,\cdots,v_n$均从$v_0$可达。因此，顶点集合$V$由对应于每个未知量$x_i$的顶点$v_i$和附加的顶点$v_0$所组成。边的集合$E$由对应于每个差分约束条件的边与对应于每个未知量$x_i$的边$(v_0,v_i)$所构成。如果$x_j-x_i\leq b_k$是一个差分约束，则边$(v_i,v_j)$的权$w(v_i,v_j)=b_k$。从超级源点$v_0$出发的每条边的权值均为0。</p>
<p>约束图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210707093851.png" alt="image-20210707093808678"></p>
<hr>
<h3 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h3><p>给定一个差分约束系统，设$G=(V,E)$为其相应的约束图。如果$G$不包含负权回路(即负环)，那么</p>
<p>$X=(\delta (v_0,v_1),\delta (v_0,v_2),\delta (v_0,v_3),\cdots,\delta (v_0,v_n))$</p>
<p>是此系统的一个可行解。当且仅当$G$中存在负环时，该系统不存在可行解。</p>
<p>上式中$\delta(v_0,v_1)$表示超级源点$v_0$到节点$v_1$的真实的最短距离，其他同理。跑一边最短路算法后得到的$dist[v_1]$其实就是$\delta(v_0,v_1)$</p>
<p><strong>证明：</strong></p>
<ul>
<li><p>首先来证明，如果$G$中不存在负环时，那么可以求出一个可行解。考察任意边$(v_i,v_j)\in E$，由三角不等式$\delta (v_0,v_j)\leq \delta (v_0,v_i)+w(v_i,v_j)$，即$\delta (v_0,v_j)-\delta (v_0,v_i)\leq w(v_i,v_j)$。因此，设$x_i=\delta (v_0,v_i),x_j=\delta(v_0,v_j)$，带入上式子可知满足对应边$(v_i,v_j)$的差分约束$x_j-x_i\leq w(v_i,v_j)$</p>
</li>
<li><p>接下来再来证明，如果$G$中存在负环，那么差分约束系统不存在可行解。设负权回路为$c=$&lt;$v_1,v_2,\cdots,v_k$&gt;，其中$v_1=v_k$（因为节点$v_0$没有入边，所以它不可能再回路$c$上）。回路$c$对应着如下的差分约束：</p>
<ul>
<li>$x_2-x_1\leq w(v_1,v_2)$</li>
<li>$x_3-x_2\leq w(v_2,v_3)$</li>
<li>$\cdots $</li>
<li>$x_k-x_{k-1}\leq w(v_{k-1},v_k)$</li>
<li>$x_1-x_k\leq w(v_k,v_1)$</li>
</ul>
<p>假设存在满足$k$个不等式的一个解$X$，那么也满足上述$k$个不等式相加所得到的不等式。如果把这些不等式相加，就会发现每个变量$x_i$的正负项相互抵消了，结果左边项和为0，而右边项和为$w(c)$，因此有$0\leq w(c)$。但是由于$c$是一个负权回路，因此有$w(c)&lt;0$，因此得到矛盾$0\leq w(c)&lt;0$，由此得证</p>
</li>
</ul>
<hr>
<p>求不等式组的可行解：</p>
<p>源点需要满足的条件：<strong>从源点出发，一定可以走到所有边</strong></p>
<p>步骤：</p>
<ul>
<li>先将每个不等式$x_i\leq x_j+c_k$，转化为一条从$x_j$走到$x_i$，长度为$c_k$的一条边</li>
<li>找到一个超级源点，使得该源点一定可以遍历到所有边</li>
<li>从源点求一边单源最短路<ul>
<li>如果存在负环，则原不等式组一定无解</li>
<li>如果不存在负环，则$X=(dist[v_1],dist[v_2],\cdots,dist[v_n])$的一个可行解</li>
</ul>
</li>
</ul>
<p>在某些题目中，约束条件形如$X_i-X_j\geq c_k$，我们仍然可以从$j$到$i$连一条长度为$c_k$的有向边，只不过现在应该要计算单源最长路，若图中存在正环则无解。当然，我们也可以把约束条件转换为$X_j-X_i\leq -c_k$，再按照单源最短路进行计算</p>
<hr>
<h3 id="变量的最大值和最小值"><a href="#变量的最大值和最小值" class="headerlink" title="变量的最大值和最小值"></a>变量的最大值和最小值</h3><p>对于给定的一组不等式关系，如何求出每个变量的最大值或者最小值呢？</p>
<blockquote>
<p>什么是最大值或最小值？</p>
<p>这里的意思是说，比如你求出了一个解$X=(x_1,x_2,\cdots,x_n)$，那么$X’=(x_1+d,x_2+d,\cdots,x_n+d)$也是一个解，$X’’=(x_1+2d,x_2+2d,\cdots,x_3+3d)$也是一个解，那么我想知道某个变量$x_i$的最大值，那么到底是取$x_i$还是$x_i+d$还是$x_i+2d$呢？同理，求某个变量$x_i$的最小值也是一样的含义。</p>
</blockquote>
<p>结论：</p>
<ul>
<li>如果求的是最小值，那么应该求单源最长路</li>
<li>如果求的是最大值，那么应该求单源最短路</li>
</ul>
<p><strong>证明：</strong></p>
<p>以求$x_i$的最大值为例：</p>
<p>求所有从$x_i$出发，构成的多个形如如下的不等式链：</p>
<p>$x_i\leq x_j+c_m\leq x_k+c_m+c_n\leq \cdots \leq x_0+c_0+c_4+\cdots +c_n+c_m$，其中$x_0=0,c_0=0$，令$F=$$x_0+c_0+c_4+\cdots +c_n+c_m$</p>
<p>那么$x_i$的最大值，要注意$F$可能多很多个，因此，我们取$F$中最小的那个值，就是$x_i$的最大值</p>
<p>例如$x_i\leq 5,x_i\leq 7,x_i\leq 9$，那么$x_i$的最大值为5。假设$x_i$取最大值为9，那么就不满足$x_i\leq 5$和$x_i\leq 7$了。</p>
<p>把上述转换成图论的问题，其实就是求$dist[i]$的最小值（因为$F$表示的是从起点出发，到达某个点的距离。那么求$F$的最小值，其实就是求单源最短路），那么就可以用最短路来求解。</p>
<p>以求$x_i$的最小值为例：</p>
<p>求所有从$x_i$出发，构成的多个形如如下的不等式链：</p>
<p>$x_i\geq x_j+c_m\geq x_k+c_m+c_n\geq \cdots \geq x_0+c_0+c_4+\cdots +c_n+c_m$，其中$x_0=0,c_0=0$，令$F=$$x_0+c_0+c_4+\cdots +c_n+c_m$</p>
<p>那么$x_i$的最小值，要注意$F$可能多很多个，因此，我们取$F$中最大的那个值，就是$x_i$的最小值</p>
<p>例如$x_i\geq 5,x_i\geq 7,x_i\geq 9$，那么$x_i$的最大值为9。假设$x_i$取最小值为5，那么就不满足$x_i\geq 7$和$x_i\geq 9$了。</p>
<p>下面举个图例：</p>
<ul>
<li>$x_2-x_1\leq c_1$</li>
<li>$x_3-x_2\leq c_2$</li>
<li>$x_3-x_1\leq c_3$</li>
</ul>
<p>那么，我们可以求出这样的：</p>
<ul>
<li>$x_3\leq x_1+c_3$</li>
<li>$x_3\leq x_1+c_1+c_2$</li>
</ul>
<p>可以看出，约束变量$x_3$的有两个条件，如果画到图中，就对应于有2条路径。那么当我们要求$x_3$的最大值时，取的肯定是$x_1+c_3$和$x_1+c_1+c_2$中的最小值，这样才能保证满足这两个约束条件，进而满足题目给定的所有原始的约束条件。</p>
<p>我们添加超级源点$s$即$v_0$，那么有$x_1-x_0\leq c_0$，因此有如下：</p>
<ul>
<li>$x_3\leq x_0+c_0+c_3$</li>
<li>$x_3\leq x_0+c_0+c_1+c_2$</li>
</ul>
<p>其中$x_0=0,c_0=0$</p>
<p>解释一样$x_0+c_0+c_3$的含义：它表示从源点$v_0$到达节点$v_3$所走过的路径上的权值之和。$x_0+c_0+c_1+c_2$也是一样的含义。</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210707094207.png"></p>
<p>对应有两条路径：</p>
<ul>
<li>$v_0\implies v_1\implies v_3$，从源点$v_0$走到节点$v_3$，所走过的路径之和为$c_0+c_3$</li>
<li>$v_0\implies v_1\implies v_2\implies v_3$，从源点$v_0$走到节点$v_3$，所走过的路径之和为$c_0+c_1+c_2$</li>
<li>可以发现，既然我们知道了等式右边的式子含义，其实就是求从源点出发到达某个节点的距离，由于可能存在多条路径，因此有多个值，那么我们只需要根据单源最短路径算法，就可以求出最小的那个值了，设为$F_{min}$。因此，如果想要求某个变量$x_i$的最大值，那么就要满足$Max(x_i)\leq F_{min}$。这也就是说，求变量$x_i$的最大值，等价于跑一下单源最短路，求出最短路径的权值之和</li>
</ul>
<p>因此，相应的就可以知道，要求$x_i$的最小值，其实就是跑一下单源最长路，求出最长路径的权值之和。</p>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>$x_i\geq x_j+c$，则从节点$j$向节点$i$连一条长度为$c$的边，要求变量$x_i$的最小值，则跑一下最长路即可</li>
<li>$x_i\leq x_j+c$，则从节点$j$向节点$i$连一条长度为$c$的边，要求变量$x_i$的最大值，则跑一下最短路即可</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP</title>
    <url>/2021/07/11/Algorithm-Improvement/Chapter3---Gragh-Theory/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/KMP/</url>
    <content><![CDATA[<h1 id="KMP算法详解"><a href="#KMP算法详解" class="headerlink" title="KMP算法详解"></a>KMP算法详解</h1><hr>
<p>求解<code>next[]</code>数组之前要先明白以下数组的概念：</p>
<ul>
<li>前缀：包含首位字符但是不包含末位字符的子串</li>
<li>后缀：包含末位字符但是不包含首位字符的子串</li>
<li><code>next[]</code>数组的含义：当主串S与模式串P的某一位字符不匹配时，模式串P应该回退的位置（数组下标）</li>
<li>$next[i]=j$的含义：即模式串P的前i个字符(包括i)组成的字符串中，最长公共前后缀子串的长度为$j$</li>
</ul>
<p><strong>注意：我们的算法中，字符串的下标都是从1开始，不用下标0，下标为0可以表示空字符。</strong></p>
<p>如下图所示，来看看什么是最长公共前后缀：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210711105744.png" alt="image-20210711105734389"></p>
<ol start="0">
<li>当i=0时，空字符，最长公共前后缀为0</li>
<li>当i=1时，对于单个字符来说，不存在前缀和后缀，因此最长公共前后缀为0</li>
<li>当i=2时，字符串为“AB”，前缀为A，后缀为B，前缀与后缀并不相同，因此最长公共前后缀为0</li>
<li>当i=3时，字符串为“ABC”，前缀为A，AB；后缀为C，BC，前缀与后缀并不相同，因此最长公共前后缀为0</li>
<li>当i=4时，字符串为“ABCA”，前缀为<strong>A</strong>，AB，ABC；后缀为<strong>A</strong>，CA，BCA；有最长的相同的前后缀A，因此最长公共前后缀为1</li>
<li>当i=5时，字符串为“ABCAB”，前缀为A，<strong>AB</strong>，ABC，ABCA；后缀为B，<strong>AB</strong>，CAB，BCAB；有最长的相同的前后缀AB，因此最长公共前后缀为2</li>
<li>当i=6时，字符串“ABCABD”，前缀为A，AB，ABC，ABCA，ABCAB；后缀为D，BD，ABD，CABD，BCABD，前缀与后缀并不相同，因此有相同的前后缀，因此最长公共前后缀为0</li>
</ol>
<p>该栗子中，<code>next[]</code>数组元素的值分别为：</p>
<p>一般来说，我们都可以预定义$next[0]$和$next[1]$都为0</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">next[<span class="number">0</span>]=<span class="number">0</span>;	<span class="comment">//空字符  弃用</span></span><br><span class="line">next[<span class="number">1</span>]=<span class="number">0</span>;	<span class="comment">//单个字符,不存在前缀和后缀,因此next[1]固定为0</span></span><br><span class="line">next[<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">next[<span class="number">3</span>]=<span class="number">0</span>;</span><br><span class="line">next[<span class="number">4</span>]=<span class="number">1</span>;</span><br><span class="line">next[<span class="number">5</span>]=<span class="number">2</span>;</span><br><span class="line">next[<span class="number">6</span>]=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>我们用图示来形象地理解<code>next[]</code>的含义：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210711111510.png" alt="image-20210711111454805"></p>
<p>如上图所示，对于由$i$个字符组成的字符串来说，前面的绿色部分和后面的绿色部分就表示该字符串相同的前缀和后缀，值为$next[i]$</p>
<hr>
<p>那么，我们怎么求解<code>next[]</code>数组呢？</p>
<p>根据<code>next[]</code>数组的含义，可以分为两种情况讨论，找到规律：</p>
<ul>
<li>如果新加入的字符与前一个最长公共前后缀子串的后面一个字符相同时，即$p[j+1]==p[i]$</li>
<li>如果新加入的字符与前一个最长公共前后缀子串的后面一个字符不同时，即$p[j+1]\neq p[i]$</li>
</ul>
<p><strong>讨论第一种情况：如果新加入的字符与前一个最长公共前后缀子串的后面一个字符相同时</strong></p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(p[i]==p[j+<span class="number">1</span>])</span><br><span class="line">    j++;</span><br><span class="line"><span class="comment">//用此时j的值来填充i所指向的这个字符的next数组的内容</span></span><br><span class="line">ne[i]=j;</span><br></pre></td></tr></table></figure>



<p>如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210711112121.png" alt="image-20210711112121418"></p>
<p>新加入的字符为$p[i]$，前一个最长公共前后缀子串的后一个字符是$p[j+1]$，可以发现，$p[j+1]==p[i]$，那么绿色部分就可以扩展一格，那么就是$next[i]=next[i-1]+1$，其实也就是$j=j+1$嘛，因为之前$j=next[i-1]$，然后由于$p[j+1]==p[i]$，那么$next[i]=next[i-1]+1$，就等效于此时$j=j+1$，即$j$++</p>
<p>注意：绿色部分是可以为0的，那么含义就是：最长公共前后缀为0，即不存在相同的前缀和后缀。也就是说此时$j$回退到0，指向了那个空字符</p>
<p><strong>讨论第二种情况：如果新加入的字符与前一个最长公共前后缀子串的后面一个字符不相同时</strong></p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当j没有回退到下标0所在的那个空字符,并且绿色部分内部一直都没有相同的前缀和后缀</span></span><br><span class="line"><span class="keyword">while</span>(j&amp;&amp;p[i]!=p[j+<span class="number">1</span>])</span><br><span class="line">    j=ne[j];</span><br><span class="line"><span class="comment">//用此时j的值来填充i所指向的这个字符的next数组的内容</span></span><br><span class="line">ne[i]=j;</span><br></pre></td></tr></table></figure>



<p>当出现这种情况时，在KMP算法中，就会执行$j=next[j]$，但是很难理解为什么要这么做。</p>
<p>下面我们看这张图：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210711121243.png" alt="image-20210711121242198"></p>
<p>那么蓝色的部分该怎么求解呢？在KMP中，就是用$j=next[j]$，这是回退操作</p>
<p>这个蓝色部分，首先要内容都完全相同，其次还要位于绿色部分的开头和结尾，那么这不就是绿色部分的最长公共前后缀的子串嘛？</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210711122308.png" alt="image-20210711122239056"></p>
<p>更新$j=next[j]$后，又回到原来的问题了，接着判断$p[j+1]$是否与$p[i]$相同就行了</p>
<p>至此，我们弄明白了那个令人费解的回退操作到底是什么意思了，其实就是在当前的这个最长公共前后缀已经不能使用时，那么就继续去寻找这个最长公共前后缀，看看它内部是否也存在最长公共前后缀，就这样一直迭代去寻找，一直尝试到成功或者是最长公共前后缀的长的为0时，就停止迭代循环</p>
<hr>
<p>下面给出求出<code>next[]</code>数组的完整代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ne[<span class="number">0</span>]=<span class="number">0</span>;	<span class="comment">//空字符的最长公共前后缀长度为0</span></span><br><span class="line">ne[<span class="number">1</span>]=<span class="number">0</span>;	<span class="comment">//单个字符不存在前缀和后缀，那么最长公共前后缀长度也为0</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(j&amp;&amp;p[i]!=p[j+<span class="number">1</span>])</span><br><span class="line">        j=ne[j];</span><br><span class="line">    <span class="keyword">if</span>(p[i]==p[j+<span class="number">1</span>])</span><br><span class="line">        j++;</span><br><span class="line">    ne[i]=j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>上面我们求出了<code>next[]</code>数组，那么如何进行主串和模式串的匹配呢？</p>
<p>其实进行主串和模式串的匹配，与求解<code>next[]</code>数组是一样的。</p>
<p>主循环中，$i$是用来遍历主串S的，$j$是用来遍历模式串p的。初始时$i$指向主串的第一个字符，即$i=1$，$j$指向模式串的空字符，即$j=0$。要注意：主串的$i$是不会回退的，它是一直往前遍历，但是模式串的$j$会进行回退操作，即会执行$j=next[j]$。</p>
<p><strong>讨论第一种情况：如果新加入的字符与前一个最长公共前后缀子串的后面一个字符相同时</strong></p>
<p>这里新加入的字符是指主串中的$S[i]$，前一个最长公共前后缀子串的后一个字符是指模式串中的$p[j+1]$，也就是说$S[i]==p[j+1]$，那么此时主串的下标$i$往前移动一位，模式串的下标$j$也往前移动一位</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(s[i]==p[j+<span class="number">1</span>])</span><br><span class="line">    j++;</span><br></pre></td></tr></table></figure>



<p><strong>讨论第二种情况：如果新加入的字符与前一个最长公共前后缀子串的后面一个字符不相同时</strong></p>
<p>这里新加入的字符是指主串中的$S[i]$，前一个最长公共前后缀子串的后一个字符是指模式串中的$p[j+1]$，也就是说$S[i]\neq p[j+1]$，那么此时模式串的$j$就要执行回退操作了，即$j=next[j]$</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(j&amp;&amp;s[i]!=p[j+<span class="number">1</span>])</span><br><span class="line">    j=ne[j];</span><br></pre></td></tr></table></figure>

<p>可以发现，其实进行主串与模式串的匹配时，与求解<code>next[]</code>数组是如出一辙的</p>
<hr>
<h1 id="KMP字符串"><a href="#KMP字符串" class="headerlink" title="KMP字符串"></a>KMP字符串</h1><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210711125013.png" alt="image-20210711125013111"></p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="comment">//n是模式串P的长度  m是主串S的长度</span></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">char</span> p[N];  <span class="comment">//模式串</span></span><br><span class="line"><span class="keyword">char</span> s[M];  <span class="comment">//主串</span></span><br><span class="line"><span class="comment">//next数组</span></span><br><span class="line"><span class="keyword">int</span> ne[N];</span><br><span class="line"><span class="comment">//求解出模式串P的next数组   next数组是对于模式串来说的,主串并不存在next数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ne[<span class="number">0</span>]=<span class="number">0</span>,ne[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;p[i]!=p[j+<span class="number">1</span>])</span><br><span class="line">        j=ne[j];</span><br><span class="line">        <span class="keyword">if</span>(p[i]==p[j+<span class="number">1</span>])</span><br><span class="line">        j++;</span><br><span class="line">        <span class="comment">//用此时j的值来填充i所指向当前这个字符的ne数组的内容</span></span><br><span class="line">        <span class="comment">//next[i] = j 表示下标以i-j为起点，i为终点的后缀和下标以1为起点，j为终点的前缀相等</span></span><br><span class="line">        <span class="comment">//且此字符串的长度最长。用符号表示为p[1~j] == p[i-j~i]</span></span><br><span class="line">        ne[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进行主串S和模式串P的匹配操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//主循环，遍历主串字符 i是用来遍历主串的，j是用来遍历模式串的</span></span><br><span class="line">    <span class="comment">//初始时i指向主串的第一个字符，j指向空字符</span></span><br><span class="line">    <span class="comment">//主串数组和模式串数组都是舍去数组下标0不用，从数组下标1开始存入字符</span></span><br><span class="line">    <span class="comment">//主串的i是不会回溯的，只有模式串的j才能回溯</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;s[i]!=p[j+<span class="number">1</span>])</span><br><span class="line">        j=ne[j];</span><br><span class="line">        <span class="keyword">if</span>(s[i]==p[j+<span class="number">1</span>])</span><br><span class="line">        j++;</span><br><span class="line">        <span class="comment">//如果j能走到n,那么一定是成功匹配了,因为如果不匹配的话,那么进行回退操作</span></span><br><span class="line">        <span class="comment">//j就不会到达n</span></span><br><span class="line">        <span class="keyword">if</span>(j==n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i-n);</span><br><span class="line">            <span class="comment">//这一句可以不用</span></span><br><span class="line">            j=ne[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//模式串和主串的下标都是从1开始</span></span><br><span class="line">    cin &gt;&gt;n&gt;&gt;p+<span class="number">1</span>&gt;&gt;m&gt;&gt;s+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//求解next数组</span></span><br><span class="line">    <span class="built_in">getNext</span>();</span><br><span class="line">    <span class="comment">//进行模式串和主串匹配操作</span></span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>区间</title>
    <url>/2021/07/08/Algorithm-Improvement/Chapter3---Gragh-Theory/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/%E5%8C%BA%E9%97%B4/</url>
    <content><![CDATA[<h1 id="区间"><a href="#区间" class="headerlink" title="区间"></a>区间</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210710143855.png" alt="image-20210710143855592"></p>
<hr>
<h3 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h3><ul>
<li>【1】给定区间<code>[a,b]</code>为$[3,7]$，那么$3\leq x\leq 7$，所以$x$的可选范围为{3，4，5，6，7}，其中要求选出来的$x$的个数必须不少于$c=3$个</li>
<li>【2】给定区间<code>[a,b]</code>为$[8,10]$，那么$8\leq x\leq 10$，所以$x$的可选范围为{8，9，10}，其中要求选出来的$x$的个数必须不少于$c=3$个</li>
<li>【3】给定区间<code>[a,b]</code>为$[6,8]$，那么$6\leq x\leq 8$，所以$x$的可选范围为{6，7，8}，其中要求选出来的$x$的个数必须不少于$c=1$个</li>
<li>【4】给定区间<code>[a,b]</code>为$[1,3]$，那么$1\leq x\leq 3$，所以$x$的可选范围为{1，2，3}，其中要求选出来的$x$的个数必须不少于$c=1$个</li>
<li>【5】给定区间<code>[a,b]</code>为$[10,11]$，那么$10\leq x\leq 11$，所以$x$的可选范围为{10，11}，其中要求选出来的$x$的个数必须不少于$c=1$个</li>
</ul>
<p>题目是意思是说想让我们从【1】、【2】、【3】、【4】、【5】中挑出$x$，组成一个整数集合$Z$，使得集合$Z$中元素的个数最少。那么给我们的启发就是，从【1】到【5】中跳出的这些数$x$应该尽可能的有交集，这样，才能使得选出最少的个数来组成集合$Z$。</p>
<ul>
<li>我们先看【1】和【4】，可以发现有交集元素3，由于【4】要求至少$c=1$，因此从【4】中我们挑出$x=3$就行了；</li>
<li>再来看【1】和【3】，可以发现有交集元素6，7，由于【1】中要求至少$c=3$，因此从【1】中挑选出$x=3,x=7,x=6,x=7$</li>
<li>再来看【2】和【3】，可以发现有交集元素8，由于【3】要求至少选出$c=1$，因此从【3】中我们挑出$x=8$</li>
<li>再来看【2】和【5】，有交集元素10，由于【5】要求至少选出$c=1$，因此从【5】中我们挑出$x=10$，由于【2】要求选出来的$x$的个数必须不少于$c=3$个，因此从【2】中挑出$x=8,9,10$</li>
<li>综上，我们选出来的$x$有<code>[3,6,7,8,9,10]</code>，也就是最少选出6个数，就可以构成一个整数集合$Z$，此时可以满足题目给出的五个限制条件</li>
</ul>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>这题我们需要用到差分约束来求解，同时还需要用到前缀和（这点比较难想）</p>
<p>我们设<code>S[i]</code>来表示从区间$[1,i]$中选出的$x$的个数。这里$0\leq a_i,b_i\leq 50000$，但是呢，由于前缀和需要用到$S[0]$，由定义可知$S[0]=0$，那么我们可以让$a_i,b_i$都+1，即向右平移一个单位，空出0这个位置来表达前缀和$S[0]$，平移之和并不影响最终结果。因此，此时$1\leq a_i,b_i\leq 50001$。</p>
<p>那么题目的意思也就是让我们从区间<code>[1,50001]</code>从选出最少的$x$的个数，来构成整数$Z$的集合。这道题肯定是会有解的，因为最坏情况下，我们把区间$[1,50001]$中的所有数都选择了，那么此时集合$Z$就有50001个元素，因此一定是有解的。那么这个解该怎么表示呢？由于我们不知道具体要选出多少个数，但是我们知道范围上限是50001，也就是$S[50001]$表示的是从区间$[1,50001]$中选出的$x$的最少的个数。因此，我们真正要求解的就是$S[50001]_{min}$</p>
<p>那么这题该怎么用差分约束呢？我们需要根据思路和题目描述自己来找出差分约束的条件：</p>
<ul>
<li>$S_i\geq S_{i-1}，1\leq i\leq 50001$，为什么呢？因为$S_i$表示从区间$[1,i]$中选出的$x$的个数，而$S_{i-1}$表示从区间$[1,i-1]$中选出的$x$的个数，因此$S_i$必定是要$\geq S_{i-1}$的，由定义出发就可以知道</li>
<li>$S_i-S_{i-1}\leq 1$，为什么呢？因为$S_i$表示从区间$[1,i]$中选出的$x$的个数，而$S_{i-1}$表示从区间$[1,i-1]$中选出的$x$的个数，那么$S_i-S_{i-1}$就表示第$i$个数，即整数$i$它被选的个数，由于整数$i$要么没有，如果有的话则最多只会有一个，因此由含义就可以知道选出来的第$i$个数，它被选的个数最多为1</li>
<li>由题目描述”区间$[a,b]$中最少要有$c$个数，可推知：$S_b-S_{a-1}\geq c$</li>
</ul>
<p>由于想要求的是变量$S[50001]$的最小值，运用差分约束，那么就需要跑最长路。将上面三个限制条件重新整理一下：</p>
<ul>
<li>$S_i\geq S_{i-1}+0$，那么就是从节点$S_{i-1}$向节点$S_i$连一条权值为0的边</li>
<li>$S_{i-1}\geq S_i-1$，那么就是从节点$S_{i}$向节点$S_{i-1}$连一条权值为-1的边</li>
<li>$S_b\geq S_{a-1}+c$，那么就是从节点$S_{a-1}$向节点$S_b$连一条权值为$c$的边</li>
</ul>
<p>但是呢，我们还需要思考一下，是否满足差分约束的条件：<strong>从源点出发，是否一定可以走到所有的边</strong>，这是差分约束正确性的前提条件。根据第一个约束条件可知，从$S_{i-1}$节点可以走到节点$S_i$，因此可以从$S_0$走到$S_1$，$S_1$走到$S_2$，$\cdots$，从$S_{50000}$走到$S_{50001}$，因此，从源点出发，是可以走到所有的边的</p>
<blockquote>
<p>问题：为什么这里的边数要开3倍呢？</p>
<p>由第一、二个约束条件可知，$S_{i-1}$和$S_{i}$之间都有边，即双向边，由第三个约束条件可知，则还会连出一条边，因此会有3条边。</p>
</blockquote>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">50010</span>,M=<span class="number">150010</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],w[M],idx;</span><br><span class="line"><span class="comment">//dist[i]表示从起点到节点i的最长距离</span></span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="comment">//循环队列</span></span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"><span class="comment">//判断一个节点是否已经入队了</span></span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    w[idx]=c;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里一定有解，因此并不需要判断是否存在负环了</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//求最长路,则初始化为负无穷</span></span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">-0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">1</span>;</span><br><span class="line">    dist[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    st[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(hh!=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//取出队头元素</span></span><br><span class="line">        <span class="keyword">int</span> t=q[hh++];</span><br><span class="line">        <span class="comment">//循环队列满了</span></span><br><span class="line">        <span class="keyword">if</span>(hh==N)</span><br><span class="line">            hh=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//节点t出队</span></span><br><span class="line">        st[t]=<span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//遍历节点t的所有邻接点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];<span class="comment">//t的邻接点编号j</span></span><br><span class="line">            <span class="keyword">if</span>(dist[j]&lt;dist[t]+w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//通过节点t来更新节点j到起到的最长距离</span></span><br><span class="line">                dist[j]=dist[t]+w[i];</span><br><span class="line">                <span class="comment">//如果节点j还没有入队</span></span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q[tt++]=j;<span class="comment">//节点j入队</span></span><br><span class="line">                    <span class="comment">//队尾指针走到了末尾,则重新回到队头</span></span><br><span class="line">                    <span class="keyword">if</span>(tt==N)</span><br><span class="line">                        tt=<span class="number">0</span>;</span><br><span class="line">                    <span class="comment">//标记节点j已经入队了</span></span><br><span class="line">                    st[j]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化表头为-1</span></span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//给第一、二个约束条件建图</span></span><br><span class="line">        <span class="built_in">add</span>(i<span class="number">-1</span>,i,<span class="number">0</span>);   </span><br><span class="line">        <span class="built_in">add</span>(i,i<span class="number">-1</span>,<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        <span class="comment">//记得向右平移一位</span></span><br><span class="line">        a++,b++;</span><br><span class="line">        <span class="built_in">add</span>(a<span class="number">-1</span>,b,c);   <span class="comment">//给第三个约束条件建图</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//跑以便spfa求出每个节点到起点的最长路</span></span><br><span class="line">    <span class="built_in">spfa</span>();</span><br><span class="line">    <span class="comment">//dist[50001]表示节点S(50001)到起点的最长距离,也就是题目中想要求的最小值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dist[<span class="number">50001</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title>排队布局</title>
    <url>/2021/07/10/Algorithm-Improvement/Chapter3---Gragh-Theory/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/%E6%8E%92%E9%98%9F%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h1 id="排队布局"><a href="#排队布局" class="headerlink" title="排队布局"></a>排队布局</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210710145142.png" alt="image-20210710145142511"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>这题是需要用到差分约束。对于差分约束，我们最主要的是根据题目描述，找出题目中的所有不等式关系，我们设$x_i$表示第$i$头牛的位置：</p>
<ul>
<li>根据“一些奶牛相互间存有好感，它们希望两者之间的距离不超过一个给定的数 L”，可以得到奶牛$a$和奶牛$b$之间至多相隔距离$L$，即有$x_b-x_a\leq L$</li>
<li>根据“一些奶牛相互间非常反感，它们希望两者间的距离不小于一个给定的数 D”，可以得到奶牛$a$和奶牛$b$之间至少相隔距离$D$，即有$x_b-x_a\geq D$</li>
<li>根据“奶牛排在队伍中的顺序和它们的编号是相同的，且同一位置上可以站多头牛”，可以得到$x_{i+1}\geq x_i$</li>
</ul>
<p>那么，我们再来观察题目要求的是$1$号奶牛和$N$号奶牛之间的最大距离，即要求变量$x_n$的最大值。那么，由差分约束可知，需要跑单源最短路，求出最短距离。</p>
<p>但是，我们要考虑，是否满足 <strong>从源点出发，可以到达所有边</strong>这个条件。由于从上面的三个不等式中，并不能看出，从某个点出发，一定能走完所有边。因此，我们就需要添加一个虚拟源点了，所以我们添加超级源点$x_0$，然后从它出发，就可以到达所有边了，那么就可以使用差分约束的方法了。</p>
<p>需要找一个超级源点（记超级源点为$x_0$），发现这里求的距离都是牛之间的相对距离，所以联想到令$x_0=0$，又因为求的是形如$x_i\leq x_j+c$的不等式，所以将所有点放在超级源点$0$号点的左侧就可以得出 $x_i\leq x_0+0$的不等式,这样从源点出发可以遍历所有的点，那么就可以遍历到所有的边。</p>
<p>因此，我们重新整理一下，上面的三个式子，统一写成$\leq$的形式（因为这是差分约束中求变量最大值的写法）：</p>
<ul>
<li>$x_b\leq x_a+L$，则从节点$x_a$向节点$x_b$连一条长度为$L$的边</li>
<li>$x_a\leq x_b-D$，则从节点$x_b$向节点$x_a$连一条长度为$-D$的边</li>
<li>$x_{i}\leq x_{i+1}+0$，则从节点$x_{i+1}$向节点$x_i$连一条长度为0的边</li>
</ul>
<p>对于建立虚拟源点问题，有两种方法：</p>
<ul>
<li>真正开辟一个超级源点0号点，那么此时建立好图后，就有$n+1$个节点</li>
<li>并不需要真正开辟一个虚拟源点，我们只需要刚开始的时候就把所有节点都放入队列中就行了，这种情况就等效于建立一个超级源点了（注意此时仍是$n$个节点，因为并没有把超级源点0号节点建立出来）。如何理解呢？<ul>
<li>我们这么想：对于spfa算法来说，假设我们真正设立了一个超级源点，这个源点连向其余的$n$个节点。那么第一次扩展时，就会把超级源点的所有邻接点都加入队列q中，然后更新这$n$个节点到超级源点的距离为0。也就是说，如果我们真的建立了一个超级源点，那么第一次扩展时，就会把它的所有邻接点（$n$个顶点）都更新最短距离为0。那么这不就等效于 《我们不用真的开辟一个超级源点，而是一开始就把这$n$个顶点都放入spfa算法的队列q中，然后初始化这$n$个点的距离为$0$》嘛？只不过这里并不需要第一次扩展而已啦，想法都是一样的，只不过实现方法有所不同而已</li>
</ul>
</li>
</ul>
<p>下面使用两种方法来分别实现以上的两种想法</p>
<p>然后这一题，有三个问题：</p>
<ul>
<li>对于第一个问题，我们可以跑一遍spfa算法求负环，如果存在负环，那么在说明不存在满足要求的方案，输出-1即可</li>
<li>对于第二个问题，想要求的是“1号牛和n号牛的最小距离是多少？即求$x_n-x_1$”，因此我们可以让1号节点称为起点，即设$x_1=0$，然后用spfa算法求出1号节点到其他各点的最短距离，最终求出$dist[n]$，如果$dist[n]\geq INF$则说明1号奶牛到$n$号奶牛之间不存在约束关系，距离可以无限远，输出-2。</li>
<li>对于第三个问题，如果求出的$dist[n]&lt;INF$，那么就直接输出此时的$dist[n]$即可</li>
</ul>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><strong>算法一：真正开辟一个超级源点0号节点</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>,M=<span class="number">3e4</span>+<span class="number">10</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n,m1,m2;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],w[M],idx;</span><br><span class="line"><span class="comment">//记录每个点到起点的最短距离</span></span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="comment">//spfa算法的循环队列</span></span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"><span class="comment">//记录每个点到起点一共经过了多少条边,用来判断负环</span></span><br><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line"><span class="comment">//用来判断某个节点是否已经放进q队列中</span></span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="comment">//建图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    w[idx]=c;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//spfa算法进行 判断负环和求出最短距离</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span> cnt);</span><br><span class="line">    <span class="built_in">memset</span>(st,<span class="number">0</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">1</span>;</span><br><span class="line">    dist[s]=<span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>]=s;</span><br><span class="line">    st[s]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(hh!=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//取出队头元素</span></span><br><span class="line">        <span class="keyword">int</span> t=q[hh++];</span><br><span class="line">        <span class="comment">//队满</span></span><br><span class="line">        <span class="keyword">if</span>(hh==N)</span><br><span class="line">        hh=<span class="number">0</span>;</span><br><span class="line">        st[t]=<span class="literal">false</span>;<span class="comment">//队头元素出队</span></span><br><span class="line">        <span class="comment">//遍历t的所有邻接点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];<span class="comment">//取出t的邻接点j</span></span><br><span class="line">            <span class="comment">//松弛</span></span><br><span class="line">            <span class="keyword">if</span>(dist[j]&gt;dist[t]+w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j]=dist[t]+w[i];</span><br><span class="line">                <span class="comment">//记录j到起点所走过的边数</span></span><br><span class="line">                cnt[j]=cnt[t]+<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//有n个点,如果此时节点j到起点所经历的边数&gt;=n,则说明有n+1个顶点,则有负环</span></span><br><span class="line">                <span class="keyword">if</span>(cnt[j]&gt;=n)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//如果j还没有放入队列q中</span></span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q[tt++]=j;  <span class="comment">//把j放入队列q中</span></span><br><span class="line">                    <span class="comment">//如果走到队尾</span></span><br><span class="line">                    <span class="keyword">if</span>(tt==N)</span><br><span class="line">                    tt=<span class="number">0</span>;</span><br><span class="line">                    st[j]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//说明不存在负环</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化表头</span></span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m1,&amp;m2);</span><br><span class="line">    <span class="comment">//建立了一个真正的超级源点,因此需要从超级源点0号点到其他n个节点连一条长度为0的边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="built_in">add</span>(<span class="number">0</span>,i,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//第一个约束条件,节点i+1向节点i连一条长度为0的边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    <span class="built_in">add</span>(i+<span class="number">1</span>,i,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(m1--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,L;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;L);</span><br><span class="line">        <span class="comment">//保证b要&gt;=a</span></span><br><span class="line">        <span class="keyword">if</span>(a&gt;b)</span><br><span class="line">        <span class="built_in">swap</span>(a,b);</span><br><span class="line">        <span class="comment">//第二个约束条件,节点a向节点b连一条长度为L的边</span></span><br><span class="line">        <span class="built_in">add</span>(a,b,L);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m2--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,D;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;D);</span><br><span class="line">        <span class="comment">//保证b要&gt;=a</span></span><br><span class="line">        <span class="keyword">if</span>(a&gt;b)</span><br><span class="line">        <span class="built_in">swap</span>(a,b);</span><br><span class="line">        <span class="comment">//第三个约束条件,节点b向节点a连一条长度为-D的边</span></span><br><span class="line">        <span class="built_in">add</span>(b,a,-D);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//存在负环</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">spfa</span>(<span class="number">0</span>))</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把1号节点当作起点</span></span><br><span class="line">        <span class="built_in">spfa</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//说明1号奶牛到N号奶牛的距离可以任意大</span></span><br><span class="line">        <span class="keyword">if</span>(dist[n]==INF)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;-2&quot;</span>);</span><br><span class="line">        <span class="comment">//否则就输出1号奶牛到N号奶牛的最短距离</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dist[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>算法二：不需要开辟一个超级源点0号节点</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>,M=<span class="number">3e4</span>+<span class="number">10</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n,m1,m2;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],w[M],idx;</span><br><span class="line"><span class="comment">//记录每个点到起点的最短距离</span></span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="comment">//spfa算法的循环队列</span></span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"><span class="comment">//记录每个点到起点一共经过了多少条边,用来判断负环</span></span><br><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line"><span class="comment">//用来判断某个节点是否已经放进q队列中</span></span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="comment">//建图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    w[idx]=c;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//spfa算法进行 判断负环和求出最短距离</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span> cnt);</span><br><span class="line">    <span class="built_in">memset</span>(st,<span class="number">0</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//将这num个节点都加入队列中,并且每个节点的最短距离初始化为0,标记每个节点都放入q队列中了</span></span><br><span class="line">    <span class="comment">//那么就等效于开辟了一个超级源点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        q[tt++]=i;</span><br><span class="line">        dist[i]=<span class="number">0</span>;</span><br><span class="line">        st[i]=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(hh!=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//取出队头元素</span></span><br><span class="line">        <span class="keyword">int</span> t=q[hh++];</span><br><span class="line">        <span class="comment">//队满</span></span><br><span class="line">        <span class="keyword">if</span>(hh==N)</span><br><span class="line">        hh=<span class="number">0</span>;</span><br><span class="line">        st[t]=<span class="literal">false</span>;<span class="comment">//队头元素出队</span></span><br><span class="line">        <span class="comment">//遍历t的所有邻接点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];<span class="comment">//取出t的邻接点j</span></span><br><span class="line">            <span class="comment">//松弛</span></span><br><span class="line">            <span class="keyword">if</span>(dist[j]&gt;dist[t]+w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j]=dist[t]+w[i];</span><br><span class="line">                <span class="comment">//记录j到起点所走过的边数</span></span><br><span class="line">                cnt[j]=cnt[t]+<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//有n个点,如果此时节点j到起点所经历的边数&gt;=n,则说明有n+1个顶点,则有负环</span></span><br><span class="line">                <span class="keyword">if</span>(cnt[j]&gt;=n)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//如果j还没有放入队列q中</span></span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q[tt++]=j;  <span class="comment">//把j放入队列q中</span></span><br><span class="line">                    <span class="comment">//如果走到队尾</span></span><br><span class="line">                    <span class="keyword">if</span>(tt==N)</span><br><span class="line">                    tt=<span class="number">0</span>;</span><br><span class="line">                    st[j]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//说明不存在负环</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化表头</span></span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m1,&amp;m2);</span><br><span class="line">    <span class="comment">//第一个约束条件,节点i+1向节点i连一条长度为0的边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    <span class="built_in">add</span>(i+<span class="number">1</span>,i,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(m1--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,L;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;L);</span><br><span class="line">        <span class="comment">//保证b要&gt;=a</span></span><br><span class="line">        <span class="keyword">if</span>(a&gt;b)</span><br><span class="line">        <span class="built_in">swap</span>(a,b);</span><br><span class="line">        <span class="comment">//第二个约束条件,节点a向节点b连一条长度为L的边</span></span><br><span class="line">        <span class="built_in">add</span>(a,b,L);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m2--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,D;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;D);</span><br><span class="line">        <span class="comment">//保证b要&gt;=a</span></span><br><span class="line">        <span class="keyword">if</span>(a&gt;b)</span><br><span class="line">        <span class="built_in">swap</span>(a,b);</span><br><span class="line">        <span class="comment">//第三个约束条件,节点b向节点a连一条长度为-D的边</span></span><br><span class="line">        <span class="built_in">add</span>(b,a,-D);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//存在负环</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">spfa</span>(n))</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把1号节点当作起点</span></span><br><span class="line">        <span class="built_in">spfa</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//说明1号奶牛到N号奶牛的距离可以任意大</span></span><br><span class="line">        <span class="keyword">if</span>(dist[n]==INF)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;-2&quot;</span>);</span><br><span class="line">        <span class="comment">//否则就输出1号奶牛到N号奶牛的最短距离</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dist[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title>糖果</title>
    <url>/2021/07/09/Algorithm-Improvement/Chapter3---Gragh-Theory/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/%E7%B3%96%E6%9E%9C/</url>
    <content><![CDATA[<h1 id="糖果"><a href="#糖果" class="headerlink" title="糖果"></a>糖果</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://gitee.com/linmacos/blog-image/raw/master/img/20210709201853.png" alt="image-20210709201852949"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>从题目描述中可知，这道题主要是要运用差分约束来求解。求至少需要准备多少个糖果，也就是求变量$a_i$的最小值，那么也就是需要跑最长路。</p>
<ul>
<li><p>根据题目描述如果$X=1$，则$A=B$，即有$A\geq B+0$，$B\geq A+0$ 。因此需要从节点$B$向节点$A$连一条权值为0的边，从节点$A$向节点$B$连一条权值为0的边</p>
</li>
<li><p>根据题目描述如果$X=2$，则$B\geq A+1$，因此从节点$A$向节点$B$连一条权值为1的边</p>
</li>
<li><p>根据题目描述如果$X=3$，则$A\geq B+0$，因此从节点$B$向节点$A$连一条权值为0的边</p>
</li>
<li><p>根据题目描述如果$X=4$，则$A\geq B+1$，因此从节点$B$向节点$A$连一条权值为1的边</p>
</li>
<li><p>根据题目描述如果$X=5$，则$B\geq A+0$，因此从节点$A$向节点$B$连一条权值为0的边</p>
</li>
<li><p>同时，由题干”要求每个小朋友都要分到苹果“，因此可以知道$a_i&gt;0$，即$a_i\geq 1$，那么可以添加一个超级源点$a_0$，$a_0$为0。那么$a_i+a_0\geq a_0+1$，即$a_i\geq a_0+1$，因此从超级源点$a_0$向节点$a_i$连一条权值为1的边</p>
</li>
</ul>
<p>注意，当我们用差分约束时，要考虑是否满足“<strong>从源点出发，能够到达所有边</strong>”这个条件。从$a_i\geq a_0+1$可知，可以从源点$0$号节点到达任意的节点$i$，既然可以从源点出发，到达任意节点$i$，那么也就是说，可以到达所有边，因此满足了前提条件。但是要注意，如果知道了从源点出发能够到达所有边，那么则不一定能推出可以到达所有节点，可以有可能某个节点它是孤立的，而剩余的所有节点（含有源点）是连通的。</p>
<ul>
<li>一般来说，如果已知$a_i\geq a_0+c$，那么就说明需要额外建立一个超级源点，并且从超级源点出发能够到达所有边</li>
<li>但是如果已知$a_i\geq a_{i-1}+c$，则不能说明从源点出发能到达所有边。因此也是需要添加超级源点。这样才能使得从超级源点出发能够到达所有边</li>
</ul>
<blockquote>
<p>问题：这里为什么是用栈而不是用循环队列呢？</p>
<p>对于spfa判负环，一般是对STL中的queue或者是手写循环队列。但是这一题比较玄学，用栈竟然是一种优化…</p>
<p>因为队列下标是递增的，进队次数可能会很多，所以访问到的下标可能很大。但栈不管插入多少次，最多只会用前n个位置。</p>
<p>这个优化不太稳定，比较玄学。优化大致上基于如下想法：如果存在一个环，那么用栈来搜索时，会按照深度优先的顺序，那么很快就会沿着环找到起点。</p>
</blockquote>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//这里的边的数目要开3倍,是因为比如点A-&gt;点B,点B-&gt;点A,同时还有超级源点0-&gt;点B</span></span><br><span class="line"><span class="comment">//因此对于点B来说,就有3条边</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],w[M],idx;</span><br><span class="line"><span class="comment">//注意数据范围可能会爆int</span></span><br><span class="line">LL dist[N];</span><br><span class="line"><span class="comment">//数组模拟栈,用来存储spfa算法中入栈的节点</span></span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"><span class="comment">//用来记录从起点到某个点所经过的边的个数</span></span><br><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line"><span class="comment">//判断某个点是否入栈</span></span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    w[idx]=c;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//spfa判负环</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//最长路,因此需要设置为负无穷大</span></span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">-0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="comment">//超级源点到自身距离为0</span></span><br><span class="line">    dist[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//超级源点0号节点入栈</span></span><br><span class="line">    q[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//标记超级源点0号节点入栈</span></span><br><span class="line">    st[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(hh!=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//取出栈顶元素</span></span><br><span class="line">        <span class="keyword">int</span> t=q[--tt];</span><br><span class="line">        <span class="comment">//标记栈顶元素这个节点已经出栈</span></span><br><span class="line">        st[t]=<span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//遍历栈顶元素t的所有邻接点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];<span class="comment">//取出邻接节点j</span></span><br><span class="line">            <span class="comment">//最长路的松弛条件：dist[j]&lt;dist[t]+w[i]</span></span><br><span class="line">            <span class="keyword">if</span>(dist[j]&lt;dist[t]+w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//更新节点j的最短距离</span></span><br><span class="line">                dist[j]=dist[t]+w[i];</span><br><span class="line">                <span class="comment">//从起点到节点j经过了cnt[t]+1条边</span></span><br><span class="line">                cnt[j]=cnt[t]+<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//由于我们建立的图中有超级源点0号节点+n个点=n+1个节点</span></span><br><span class="line">                <span class="comment">//但是如果但cnt[j]&gt;=n+1时,即从起点到节点j经过了n+1条边,则说明有(n+1)+1=n+2个节点</span></span><br><span class="line">                <span class="comment">//这与图中的n+1个节点相矛盾,因此由抽屉原理,知必存在负环</span></span><br><span class="line">                <span class="keyword">if</span>(cnt[j]&gt;=n+<span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//如果j这个节点还没有入栈</span></span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q[tt++]=j;<span class="comment">//将节点j入栈</span></span><br><span class="line">                    st[j]=<span class="literal">true</span>;<span class="comment">//标记节点j已经入栈了</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则,说明不存在负环</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//表头初始化为-1</span></span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x,a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;a,&amp;b);</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">add</span>(b,a,<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">add</span>(a,b,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">2</span>)</span><br><span class="line">            <span class="built_in">add</span>(a,b,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">3</span>)</span><br><span class="line">            <span class="built_in">add</span>(b,a,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">4</span>)</span><br><span class="line">            <span class="built_in">add</span>(b,a,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">add</span>(a,b,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//由于我们添加了超级源点0,因此从0号节点到其他的各个节点i都要建一条边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">add</span>(<span class="number">0</span>,i,<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//存在负环,则差分约束系统无解</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">spfa</span>())</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="comment">//不存在负环,则差分约束系统有解</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        LL res=<span class="number">0</span>;   <span class="comment">//记录最终答案</span></span><br><span class="line">        <span class="comment">//dist[i]表示从超级源点到节点i的最长路,也就是题目中每个小朋友应该在限制要求下分得的糖果</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            res+=dist[i];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title>雇佣收银员</title>
    <url>/2021/07/10/Algorithm-Improvement/Chapter3---Gragh-Theory/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/%E9%9B%87%E4%BD%A3%E6%94%B6%E9%93%B6%E5%91%98/</url>
    <content><![CDATA[<h1 id="雇佣收银员"><a href="#雇佣收银员" class="headerlink" title="雇佣收银员"></a>雇佣收银员</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210710201724.png" alt="image-20210710201724728"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>这题需要用差分约束来求解，具体思路如下：</p>
<p>我们定义以下变量的含义：</p>
<ul>
<li><code>num[i]</code>表示在$t_i$时刻来应聘的人数</li>
<li><code>x[i]</code>表示在$t_i$时刻公司选择雇佣的人数</li>
<li><code>R[i]</code>表示在$t_i$时刻需要的员工的最小需求量</li>
<li><code>S[i]</code>表示满足能在$t_i$时刻上岗工作的公司已经聘用的员工总数。比如当$t_i=24h$时，$S_i=100$，则说明这100个人，它们的工作服务时间段是包括$t_i$的，即在$t_i$时刻他们在岗工作</li>
</ul>
<p>根据以上定义，我们再来梳理一下不等式的关系：</p>
<ul>
<li><p>$0\leq x_i\leq num[i]$，因为聘用的人数不可能大于来应该的人数，因此有$x_i\leq num[i]$，而且公司选择聘用的人数不可能为-1，要么都不聘用，因此有$x_i\geq 0$</p>
</li>
<li><p>$x_{i-7}+x_{i-6}+x_{i-5}+x_{i-4}+x_{i-3}+x_{i-2}+x_{i-1}+x_i\geq R_i$，即公司聘用的能够在$t_i$时刻处于工作服务状态的员工总数，应该$\geq$在$t_i$时刻最小需要的员工总数</p>
<blockquote>
<p> <strong>问题：如何理解$x_{i-7}+x_{i-6}+x_{i-5}+x_{i-4}+x_{i-3}+x_{i-2}+x_{i-1}+x_i$这个式子呢？</strong></p>
<p>由于题目说了，员工一定会连续工作8个小时，即每个员工的工作服务时常为$8h$。那么我们就想，哪些员工他们的工作服务时间段是包括$t_i$这个时刻的呢？如果包括，则说明他们在$t_i$这个时刻，一定可以上岗工作服务。因此$x_{i-7}+x_{i-6}+x_{i-5}+x_{i-4}+x_{i-3}+x_{i-2}+x_{i-1}+x_i$就表示能在$t_i$时刻上岗工作服务的员工总数，那么这个总数就应该要$\geq t_i$时刻需要的员工的最小需求量$R_i$。</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210710211018.png" alt="image-20210710211017955"></p>
</blockquote>
</li>
</ul>
<p>$x_{i-7}+x_{i-6}+x_{i-5}+x_{i-4}+x_{i-3}+x_{i-2}+x_{i-1}+x_i$这个是连加的形式，那么很容易想到用前缀和来表示，即用$S[i]$来表示，其中$1\leq i\leq 24$。由于前缀和需要用到$S[0]$，因此我们需要把时间都向右平移一个单位，即现在时间为$1,2,\cdots,24$而不是再是原来的$0,1,2,\cdots,23$了。</p>
<p>那么则会由如下的不等式关系：</p>
<ul>
<li>$0\leq x_i\leq num[i]$，用前缀和来代替，那么就是$0\leq S_i-S_{i-1}\leq num[i]$</li>
<li>$S_i\geq R_i$</li>
</ul>
<p>由于题目要求的是变量的最小值，那么就需要跑单源最长路，求出最长距离。因此把不等式关系都改写为$x_i\geq x_j+c$的形式：</p>
<ul>
<li>$S_i\geq S_{i-1}+0$</li>
<li>$S_{i-1}\geq S_i-num[i]$</li>
</ul>
<p>对于$S_i\geq R_i$要分类讨论，因为时间它是循环的，当到了24之后就会变为0，又重新开始了。</p>
<ul>
<li><p>当$i\geq 8$时，则有$S_i-S_{i-8}\geq R_i$，分析如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210710213044.png" alt="image-20210710213044097"></p>
</li>
<li><p>当$0&lt;i\leq 7$时，则要分为两部分了。一部分是$1$到$7$这个时间段，由于不足8h，因此说明需要向$24$(包括它)之前的借一些时间，这主要就是因为时间是循环的。那么会得到$S_i+(S_{24}-S_{i+16})\geq R[i]$分析如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210710214154.png" alt="image-20210710214002246"></p>
</li>
</ul>
<p>进一步梳理不等式关系：</p>
<ul>
<li>$S_i\geq S_{i-1}+0$</li>
<li>$S_{i-1}\geq S_i-num[i]$</li>
<li>当$i\geq 8$时，$S_i\geq S_{i-8}+R[i]$</li>
<li>当$0&lt;i\leq 7$时，$S_i\geq S_{i+16}-S_{24}+R[i]$</li>
</ul>
<p>但是我们发现第四个约束条件中，有三个变量，平时我们都是遇到两个变量。其实，我们可以把$S_{24}$当作常量。那么如何把它作为常量呢？由于题目说要求最少需要雇佣多少名收银员，那么其实也就是说要求出$S_{24}$是多少。由于题目说了$0\leq N\leq 1000$，因此最坏情况下是至少聘用了$1000$个人。那么我们可以依次从0开始枚举到1000，我们把枚举的这个值$i$其实就是$S_{24}$，每次枚举一个$i$，都去跑一下spfa，当第一次枚举到某个值时，它满足所有的约束条件，那么这个值就是我们要求的最小的$S_{24}$，找到第一个就直接break。</p>
<p>注意这里当我们枚举到某个$S_{24}=c$时，也要把它写成差分约束的形式，即$S_{24}\geq c$和$S_{24}\leq c$，建立一个超级源点$S_0$（为0），那么有$S_{24}\geq S_0+c$和$S_{0}\geq S_{24}-c$</p>
<p>因此，总结一下，总共有以下的约束条件：</p>
<ul>
<li>$S_i\geq S_{i-1}+0$</li>
<li>$S_{i-1}\geq S_i-num[i]$</li>
<li>当$i\geq 8$时，$S_i\geq S_{i-8}+R[i]$</li>
<li>当$0&lt;i\leq 7$时，$S_i\geq S_{i+16}-S_{24}+R[i]$</li>
<li>$S_{24}\geq S_0+c$</li>
<li>$S_{0}\geq S_{24}-c$</li>
</ul>
<p>由第一个约束条件$S_i\geq S_{i-1}+0$可知，设立一个超级源点0号节点，则可以从超级源点出发，0-&gt;1-&gt;2-&gt;$\cdots$-&gt;$24$，因此可以到达所有节点，那么一定可以到达所有边。所以，这里满足了 “<strong>从源点出发，能遍历到所有边</strong>”这个条件，因此可以用差分约束。</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">30</span>,M=<span class="number">100</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],w[M],idx;</span><br><span class="line"><span class="comment">//R[i]表示i时刻公司需要雇佣的最小的员工的需求量</span></span><br><span class="line"><span class="comment">//num[i]表示i时刻来应聘的员工的数量</span></span><br><span class="line"><span class="keyword">int</span> R[N],num[N];</span><br><span class="line"><span class="comment">//dist[i]表示i节点到起点的最长距离</span></span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="comment">//循环队列q来存储入队节点</span></span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"><span class="comment">//cnt[i]表示从起点到达节点i一共经过了多少条边</span></span><br><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line"><span class="comment">//判断某个节点是否已经加入了q队列中</span></span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="comment">//建图函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    w[idx]=c;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将约束条件建成图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化表头</span></span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    idx=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//S[24]=c,写成了两个约束条件</span></span><br><span class="line">    <span class="built_in">add</span>(<span class="number">0</span>,<span class="number">24</span>,c);</span><br><span class="line">    <span class="built_in">add</span>(<span class="number">24</span>,<span class="number">0</span>,-c);</span><br><span class="line">    <span class="comment">//当0&lt;i&lt;=7时,给这个约束条件建图</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">7</span>;i++)</span><br><span class="line">    <span class="built_in">add</span>(i+<span class="number">16</span>,i,R[i]-c);</span><br><span class="line">    <span class="comment">//当i&gt;=8时,给这个约束条件建图</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">8</span>;i&lt;=<span class="number">24</span>;i++)</span><br><span class="line">    <span class="built_in">add</span>(i<span class="number">-8</span>,i,R[i]);</span><br><span class="line">    <span class="comment">//给S[i]&gt;=S[i-1]+0和S[i-1]&gt;=S[i]-num[i]建图</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">24</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">add</span>(i<span class="number">-1</span>,i,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">add</span>(i,i<span class="number">-1</span>,-num[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//spfa算法用来  判断是否存在正环  和 求出最长距离</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//对于枚举的每一个S[24]都去建图</span></span><br><span class="line">    <span class="built_in">build</span>(c);</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">-0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">memset</span>(st,<span class="number">0</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span> cnt);</span><br><span class="line">    <span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//由于真正地建立了超级源点S[0]</span></span><br><span class="line">    dist[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    st[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(hh!=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=q[hh++];</span><br><span class="line">        <span class="keyword">if</span>(hh==N)</span><br><span class="line">        hh=<span class="number">0</span>;</span><br><span class="line">        st[t]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j]&lt;dist[t]+w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j]=dist[t]+w[i];</span><br><span class="line">                cnt[j]=cnt[t]+<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//本来1~24共有24个节点,但是建立了1个超级源点,因此总共25个节点</span></span><br><span class="line">                <span class="comment">//cnt[j]&gt;=25说明从超级源点到节点j经过了25条边,那么则有26个节点</span></span><br><span class="line">                <span class="comment">//这与实际的25个节点不符合,因此存在正环</span></span><br><span class="line">                <span class="keyword">if</span>(cnt[j]&gt;=<span class="number">25</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q[tt++]=j;</span><br><span class="line">                    <span class="keyword">if</span>(tt==N)</span><br><span class="line">                    tt=<span class="number">0</span>;</span><br><span class="line">                    st[j]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//说明不存在正环  且找到了最小的满足所有约束条件的S[24]</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">24</span>;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;R[i]);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="keyword">sizeof</span> num);</span><br><span class="line">        <span class="keyword">while</span>(n--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">            <span class="comment">//由于前缀和S[0]占用0这个位置,因此我们让时间都向右平移一位</span></span><br><span class="line">            t++;</span><br><span class="line">            num[t]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//用来判断是否有解</span></span><br><span class="line">        <span class="keyword">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">1000</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//枚举找到最小的满足所有约束条件的S[24]</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">spfa</span>(i))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">                flag=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//说明无解</span></span><br><span class="line">        <span class="keyword">if</span>(!flag)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;No Solution&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title>奖金</title>
    <url>/2021/07/21/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/%E5%A5%96%E9%87%91/</url>
    <content><![CDATA[<h1 id="奖金"><a href="#奖金" class="headerlink" title="奖金"></a>奖金</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210721120429.png" alt="image-20210721120429310"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>实际上是一道差分约束的题，要求变量的最小值，也就是取所有下界的最大值，用最长路求解即可。但是呢，如果用差分约束spfa的时间复杂度为$O(km)$~$O(nm)$，可能会被卡。</p>
<p>因为本题中所有的权值都是正值，因此我们可以不用差分约束就求这个最长路。</p>
<p>我们直接拓扑排序得到一张有向无环图DAG$\implies $每一个状态都没有循环依赖 $\implies$没有后效性$\implies$就可以用DP递推求最长路</p>
<p>题目中说到”员工$a$的奖金比员工$b$的奖金高“，因此可以得出$a\geq b+1$，那么我们可以从节点$b$向节点$a$连一条边权为1的边。</p>
<p>由于”每位员工奖金最少为$100$元“，因此就可以看作是建立了一个虚拟源点，该源点到其他各点的距离都为$100$。</p>
<p>这题有两种写法：</p>
<ul>
<li>在拓扑排序中就求出了最长路</li>
<li>先进行拓扑排序得到一张有向无环图DAG，然后在这个DAG上跑一下最长路即可。</li>
</ul>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>在拓扑排序中就求出了最长路</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">10010</span>,M=<span class="number">20010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="keyword">int</span> d[N];       <span class="comment">//存储每个点的入度</span></span><br><span class="line"><span class="keyword">int</span> q[N];       <span class="comment">//存储拓扑序列</span></span><br><span class="line"><span class="keyword">int</span> dist[N];    <span class="comment">//存储最长路</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在进行拓扑排序的同时求出了dist[]</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//求最长路 因此初始化为负无穷</span></span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">-0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!d[i])</span><br><span class="line">        &#123;</span><br><span class="line">            q[++tt]=i;</span><br><span class="line">            <span class="comment">//相当于建立了一个虚拟源点 该虚拟源点到这n个点的距离为100</span></span><br><span class="line">            dist[i]=<span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(hh&lt;=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=q[hh++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(--d[j]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                q[++tt]=j;</span><br><span class="line">                <span class="comment">//j是t的邻接点   t经过边权为1的边后就可以走到了j</span></span><br><span class="line">                dist[j]=dist[t]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tt==n<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="comment">//从b向a连一条边权为1的有向边 </span></span><br><span class="line">        <span class="comment">//由于边权都是1  因此没必要用一个数组w[i]来存储了  直接用1就好了</span></span><br><span class="line">        <span class="built_in">add</span>(b,a);</span><br><span class="line">        d[a]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//说明存在环 则无解</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">topsort</span>())</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Poor Xed&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//计算最长路</span></span><br><span class="line">            res+=dist[i];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);         </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先进行拓扑排序得到一张有向无环图DAG，然后在这个DAG上跑一下最长路</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">10010</span>,M=<span class="number">20010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="keyword">int</span> d[N],q[N],dist[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(!d[i])</span><br><span class="line">            q[++tt]=i;</span><br><span class="line">    <span class="keyword">while</span>(hh&lt;=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=q[hh++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(--d[j]==<span class="number">0</span>)</span><br><span class="line">                q[++tt]=j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;       </span><br><span class="line">    <span class="keyword">return</span> tt==n<span class="number">-1</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="built_in">add</span>(b,a);</span><br><span class="line">        d[a]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">topsort</span>())</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Poor Xed&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//相当于建立了一个虚拟源点 该虚拟源点到这n个点的距离为100</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            dist[i]=<span class="number">100</span>;</span><br><span class="line">        <span class="comment">//对得到的这个拓扑图DAG跑一下最长路</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t=q[i]; <span class="comment">//取出拓扑序列中的节点t</span></span><br><span class="line">            <span class="comment">//遍历t的所有邻接点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=h[t];~k;k=ne[k])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> j=e[k]; <span class="comment">//取出t的邻接点j</span></span><br><span class="line">                <span class="comment">//由于得到的是DAG图,没有后效性,因此可以用dp思想</span></span><br><span class="line">                <span class="comment">//状态转移方程</span></span><br><span class="line">                dist[j]=<span class="built_in">max</span>(dist[j],dist[t]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            res+=dist[i];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>拓扑排序</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>可达性统计</title>
    <url>/2021/07/20/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/%E5%8F%AF%E8%BE%BE%E6%80%A7%E7%BB%9F%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="可达性统计"><a href="#可达性统计" class="headerlink" title="可达性统计"></a>可达性统计</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210720213337.png" alt="image-20210720213336979"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>设从点$x$出发能到达的所有点的集合为<code>f(x)</code>，设$x$连接的所有边为$y_1,y_2,\cdots,y_k$，则有如下式子：</p>
<p>$f(x)=x$ $\cup$ $(\bigcup \limits _{1\leq i\leq k}f(y_i))$</p>
<p>即：从点$x$出发能到达的所有点就是从它连接的所有点出发能到达的所有点加上$x$本身</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210720215025.png" alt="image-20210720215025122"></p>
<p>考虑拓扑排序。在一张图的拓扑序中，对每条边$(x,y)$总有：$x$在$y$之前。根据上述的这个式子，我们发现要想求出$f(x)$，必须要先求出$f(y_i)$，而由于$y_i$是$x$之后的节点，因此我们可以按照拓扑排序的倒序来进行计算。</p>
<p>我们考虑将每个点$f(x)$记作一个$N$位二进制数，其中第$i$位为1，表示可以到达$i$；第$i$位为0，表示不可以到达$i$。那么$f(x)$中1的数量就是从$x$出发能到达的所有点的数量。</p>
<p>我们来考虑一下数据规模，在最坏情况下，拓扑排序是一条链，对于第一个节点，$f(1)=n$，对于第二个节点，$f(2)=n-1$，$\cdots$，对于第$n$个节点，$f(n)=1$。那么总数为$f(1)+f(2)+\cdots+f(n)=n+(n-1)+\cdots+1=\dfrac {n(n-1)}{2}$，$n$最大取到$30000$，所以最坏的总数约为$4.5$亿，如果用二维数组来存储的话，那么内存空间就会爆炸。因此需要把$N$位的二进制数压缩到一个int中，这需要借助STL中的bitset。这样空间复杂度将减少为原来的$\dfrac {1}{32}$，此时变为$14,062,500$是可以接受的。</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210720215049.png" alt="image-20210720215048996"></p>
<p><code>bitset&lt;N&gt;f</code>这里的$f$其实是一维数组；</p>
<p><code>bitset&lt;N&gt;f[N]</code>，这里的$f$其实是二维数组</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">30010</span>,M=<span class="number">30010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="keyword">int</span> d[N];   <span class="comment">//记录每个点的入队</span></span><br><span class="line"><span class="keyword">int</span> q[N];   <span class="comment">//记录拓扑序列</span></span><br><span class="line">bitset&lt;N&gt;f[N];</span><br><span class="line"><span class="comment">//从点a向点b连一条有向边</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!d[i])</span><br><span class="line">        &#123;</span><br><span class="line">            q[++tt]=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(hh&lt;=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=q[hh++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(--d[j]==<span class="number">0</span>)</span><br><span class="line">                q[++tt]=j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a,b);</span><br><span class="line">        d[b]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//求出拓扑序列</span></span><br><span class="line">    <span class="built_in">topsort</span>();</span><br><span class="line">    <span class="comment">//对拓扑序列进行倒序遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x=q[i];</span><br><span class="line">        <span class="comment">//从x这个点出发可以到达x自身  因此f[x][x]=1</span></span><br><span class="line">        f[x][x]=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//遍历x的所有邻接点</span></span><br><span class="line">        <span class="comment">//f[x]|=f(yi)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=h[x];~j;j=ne[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> y=e[j]; <span class="comment">//取出x邻接点的编号y</span></span><br><span class="line">            f[x]|=f[y];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//f[i].count()表示f[i]中1的个数</span></span><br><span class="line">    <span class="comment">//其实也就是从i出发能到达的所有点的数量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[i].<span class="built_in">count</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>拓扑排序</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>标签球</title>
    <url>/2021/07/27/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/%E6%A0%87%E7%AD%BE%E7%90%83/</url>
    <content><![CDATA[<h1 id="标签球"><a href="#标签球" class="headerlink" title="标签球"></a>标签球</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><a href="http://poj.org/problem?id=3687">POJ3687</a></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>注意，题目中输入的是小球的标签号而不是小球的重量，比如有小球标签$A,B,C,D$，如果$B&gt;C&gt;A&gt;D$，那么小球标签$A,B,C,D$所对应的重量等级为$3,1,2,4$。题目其实是想要输出这些小球的重量等级，而不是输出小球的标签编号。</p>
<p>本题并不是要输出小球的标签，而是按标签输出小球的重量，而且<strong>标签小的球的重量要尽可能的小</strong>。</p>
<p>举个栗子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">4</span>	<span class="comment">//节点数、边数</span></span><br><span class="line"><span class="number">5</span> <span class="number">1</span>	<span class="comment">//标签为5的小球比标签为1的小球轻</span></span><br><span class="line"><span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span>    </span><br></pre></td></tr></table></figure>

<p>由于题目说了$a&lt;b$，那么我们把从$a$向$b$连一条有向边所构建得到的这张图 称为正向图，把从$b$向$a$连一条有向边所构建得到的这张图 称为反向图</p>
<p>这里我们画出上面这个栗子的正向图：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210727131221.png" alt="image-20210727131221802"></p>
<p>分析：根据题目描述，如果$a$比$b$轻，我们构建了一条从$a$指向$b$的有向边，根据重量关系可知，节点$3$是最重的，因此令重量<code>weight[3]=5</code>；节点$1$和节点$2$都比节点$3$轻，因为每个小球的重量都不相同，按照标签小的球其重量小的原则，我们先给标签大的小球分配重量，所以这里先处理节点$2$，因此<code>weight[2]=4</code>；节点$4$比节点$2$轻，所以<code>weight[4]=3</code>；节点$1$比节点$3$轻，所以<code>weight[1]=2</code>；节点$5$比节点$1$轻，因此<code>weight[5]=1</code>。</p>
<p>也就是说，当多个节点$a,b,c$同时指向同一个节点$d$时，如果标签号$a&gt;b&gt;c$，那么我们就先给标签大的分配重量，即$weight[a]&gt;weight[b]&gt;weight[c]$。然后一旦处理了节点$a$，就要把节点$a$所在的关系全部处理了，比如上图中处理了节点$2$，就要处理节点$4$，而不是去处理节点$1$。</p>
<p>再举个栗子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span> <span class="number">5</span>	<span class="comment">//节点数 边数</span></span><br><span class="line"><span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">8</span> <span class="number">1</span></span><br><span class="line"><span class="number">7</span> <span class="number">8</span></span><br><span class="line"><span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">8</span>    </span><br></pre></td></tr></table></figure>

<p>构建正向图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210727132457.png" alt="image-20210727132457512"></p>
<p>分析：按照标签小的球重量小的原则，先给标签大的小球分配重量，因此<code>weight[10]=10</code>，<code>weight[9]=9</code>，<code>weight[6]=8</code>，<code>weight[5]=7</code>，<code>weight[3]=6</code>，<code>weight[1]=5</code>。节点$8$和节点$4$都比节点$1$轻，按照标签小的球重量小的原则，先给标签大的小球分配重量，所以先给节点$8$分配重量，因此<code>weight[8]=4</code>；节点$7$和节点$2$比节点$8$轻，先处理节点$7$，因此<code>weight[7]=3</code>；此时只剩下节点$2$和节点$4$，那么先给节点$4$分配重量，因此<code>weight[4]=2</code>，最后给节点$1$分配重量，因此<code>weight[2]=1</code>。</p>
<p>所以得到标签小球$1$到标签小球$10$的重量等级如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">weight[<span class="number">1</span>]=<span class="number">5</span>;</span><br><span class="line">weight[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">weight[<span class="number">3</span>]=<span class="number">6</span>;</span><br><span class="line">weight[<span class="number">4</span>]=<span class="number">2</span>;</span><br><span class="line">weight[<span class="number">5</span>]=<span class="number">7</span>;</span><br><span class="line">weight[<span class="number">6</span>]=<span class="number">8</span>;</span><br><span class="line">weight[<span class="number">7</span>]=<span class="number">3</span>;</span><br><span class="line">weight[<span class="number">8</span>]=<span class="number">4</span>;</span><br><span class="line">weight[<span class="number">9</span>]=<span class="number">9</span>;</span><br><span class="line">weight[<span class="number">10</span>]=<span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>按照标签$1$到$10$输出其重量：5 1 6 2 7 8 3 4 9 10</p>
<p>注意本题有重复边，需要去重，否则会有环，如果存在环则输出-1。</p>
<p><strong>算法设计：</strong></p>
<p>可以采用以下两种方法来解决：</p>
<ul>
<li>建立正向图。$i=n,n-1,\cdots,1$，$j=n,n-1,\cdots,1$，检查第1个出度为0的节点$t$，给其分配重量<code>weight[t]=i</code>，将有边指向它的那些节点的出度都减1，继续下一个循环。如果没有出度为$0$的节点，则说明有环存在，退出。</li>
<li>建立反向图。$i=n,n-1,\cdots,1$，$j=n,n-1,\cdots,1$，检查第1个入度为0的节点$t$，给其分配重量<code>weight[t]=i</code>，将它所指向的节点的入度都减1，继续下一个循环。如果没有入度为$0$的节点，则说明有环存在，退出。</li>
</ul>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>正向图：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">210</span>,M=<span class="number">40010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="comment">//g[i][j]=1表示节点i向节点j连一条有向边</span></span><br><span class="line"><span class="keyword">int</span> g[N][N];    <span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="keyword">int</span> d[N];       <span class="comment">//记录每个节点的出度</span></span><br><span class="line"><span class="comment">//weight[i]表示i号标签小球的重量</span></span><br><span class="line"><span class="keyword">int</span> weight[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//i是重量等级</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=<span class="number">-1</span>;   <span class="comment">//找到第一个出度为0的节点</span></span><br><span class="line">        <span class="comment">//j枚举的是节点的编号</span></span><br><span class="line">        <span class="comment">//由于是按照&quot;节点大的标签小球分配大的重量&quot;原则</span></span><br><span class="line">        <span class="comment">//所以这里先枚举大的标签小球</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=n;j&gt;<span class="number">0</span>;j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!d[j])<span class="comment">//出度为0</span></span><br><span class="line">            &#123;</span><br><span class="line">                t=j;    <span class="comment">//找到第一个出度为0的节点  直接退出</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果循环完所有的节点 都没有找到一个出度为0的节点  则说明有环存在</span></span><br><span class="line">        <span class="keyword">if</span>(t==<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//给节点t分配重量i</span></span><br><span class="line">        weight[t]=i;</span><br><span class="line">        <span class="comment">//将节点t的出度设为-1 表示这个节点已经被分配过重量了</span></span><br><span class="line">        d[t]=<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//遍历j的所有邻接点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(g[j][t])<span class="comment">//将t的所有邻接点j的出度全部减1</span></span><br><span class="line">                d[j]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//没有环存在</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(g,<span class="number">0</span>,<span class="keyword">sizeof</span> g);</span><br><span class="line">        <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">        cin &gt;&gt;n&gt;&gt;m;</span><br><span class="line">        <span class="comment">//读入m条边的信息</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a,b;</span><br><span class="line">            cin &gt;&gt;a&gt;&gt;b;</span><br><span class="line">            <span class="keyword">if</span>(!g[a][b])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//a向b建立一条有向边</span></span><br><span class="line">                g[a][b]=<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//节点a的出度+1</span></span><br><span class="line">                d[a]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//有环存在 则无解 输出-1</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">topsort</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//输出标签小球1~n的重量等级</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,weight[i]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,weight[n]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>反向图：比较符合拓扑排序的模板</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">210</span>,M=<span class="number">40010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="comment">//g[i][j]=1表示节点i向节点j连一条有向边</span></span><br><span class="line"><span class="keyword">int</span> g[N][N];    <span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="keyword">int</span> d[N];       <span class="comment">//记录每个节点的入度</span></span><br><span class="line"><span class="comment">//weight[i]表示i号标签小球的重量</span></span><br><span class="line"><span class="keyword">int</span> weight[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//i是重量等级</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=<span class="number">-1</span>;   <span class="comment">//找到第一个入度为0的节点</span></span><br><span class="line">        <span class="comment">//j枚举的是节点的编号</span></span><br><span class="line">        <span class="comment">//由于是按照&quot;节点大的标签小球分配大的重量&quot;原则</span></span><br><span class="line">        <span class="comment">//所以这里先枚举大的标签小球</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=n;j&gt;<span class="number">0</span>;j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!d[j])<span class="comment">//入度为0</span></span><br><span class="line">            &#123;</span><br><span class="line">                t=j;    <span class="comment">//找到第一个入度为0的节点  直接退出</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果循环完所有的节点 都没有找到一个入度为0的节点  则说明有环存在</span></span><br><span class="line">        <span class="keyword">if</span>(t==<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//给节点t分配重量i</span></span><br><span class="line">        weight[t]=i;</span><br><span class="line">        <span class="comment">//将节点t的入度设为-1 表示这个节点已经被分配过重量了</span></span><br><span class="line">        d[t]=<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//遍历j的所有邻接点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(g[t][j])<span class="comment">//将j的所有邻接点的入度全部减1</span></span><br><span class="line">                d[j]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//没有环存在</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(g,<span class="number">0</span>,<span class="keyword">sizeof</span> g);</span><br><span class="line">        <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">        cin &gt;&gt;n&gt;&gt;m;</span><br><span class="line">        <span class="comment">//读入m条边的信息</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a,b;</span><br><span class="line">            cin &gt;&gt;a&gt;&gt;b;</span><br><span class="line">            <span class="comment">//由于有重边 这里是为了防止重边</span></span><br><span class="line">            <span class="keyword">if</span>(!g[b][a])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//从b向a连一条有向边</span></span><br><span class="line">                g[b][a]=<span class="number">1</span>;</span><br><span class="line">                d[a]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//有环存在 则无解 输出-1</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">topsort</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//输出标签小球1~n的重量等级</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,weight[i]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,weight[n]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>拓扑排序</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>家谱树</title>
    <url>/2021/07/21/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/%E5%AE%B6%E8%B0%B1%E6%A0%91/</url>
    <content><![CDATA[<h1 id="家谱树"><a href="#家谱树" class="headerlink" title="家谱树"></a>家谱树</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210721101434.png" alt="image-20210721101434566"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>这是一道很裸的拓扑排序，直接套拓扑排序模版即可。</p>
<blockquote>
<p>问题：如何输出字典序最小的拓扑排序？</p>
<p>将队列换成优先队列，优先队列取出的元素是当前字典序最小的编号，在出队的时候记录出队的编号即为当前字典序最小的拓扑序，此方法的时间复杂度是$O(logn*(n+m))$</p>
</blockquote>
<p>由于是有向无环图，对于第1个节点来说，最多与后面的$n-1$个节点有边；对于第2个节点来说，最多与后面的$n-2$个节点有边；$\cdots$；对于第$n$个节点来说，有0个连边。因此最多有$\dfrac {n(n-1)}{2}$条边。由于点的个数最多是$N$，所以边的个数最多是$\dfrac {N(N-1)}{2}$</p>
<p>由于这道题目中肯定不会存在环（家庭伦理问题…），因此一定可以得到拓扑序列。</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>手写队列：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">110</span>,M=N*N/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="keyword">int</span> d[N];</span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(!d[i])</span><br><span class="line">            q[++tt]=i;</span><br><span class="line">    <span class="keyword">while</span>(hh&lt;=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=q[hh++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(--d[j]==<span class="number">0</span>)</span><br><span class="line">                q[++tt]=j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> son;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;son),son)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//从i向son连一条有向边</span></span><br><span class="line">            <span class="built_in">add</span>(i,son);</span><br><span class="line">            d[son]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进行一遍拓扑排序</span></span><br><span class="line">    <span class="built_in">topsort</span>();</span><br><span class="line">    <span class="comment">//输出得到的拓扑序列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,q[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运用STL中的队列</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">110</span>,M=N*N/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="keyword">int</span> d[N];</span><br><span class="line"><span class="comment">//seq数组用来存储得到的拓扑序列,cnt是这个数组的下标</span></span><br><span class="line"><span class="keyword">int</span> seq[N],cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt;q;    <span class="comment">//运用STL中的队列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!d[i])</span><br><span class="line">        &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">        <span class="comment">//记录此时的拓扑序列的节点是t</span></span><br><span class="line">        seq[cnt++]=t;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(--d[j]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> son;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;son),son)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">add</span>(i,son);</span><br><span class="line">            d[son]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">topsort</span>();</span><br><span class="line">    <span class="comment">//输出得到的拓扑序列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,seq[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>拓扑排序</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>车站分级</title>
    <url>/2021/07/21/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/%E8%BD%A6%E7%AB%99%E5%88%86%E7%BA%A7/</url>
    <content><![CDATA[<h1 id="车站分级"><a href="#车站分级" class="headerlink" title="车站分级"></a>车站分级</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210721151841.png" alt="image-20210721151841388"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>题目中描述的”如果这趟车次停靠了火车站x，则始发站、终点站之间所有级别大于等于火车站x的都必须停靠“，这句话翻译过来就是<strong>停靠过的车站的等级一定严格大于没有停靠过的车站的等级</strong></p>
<p>因此车站的等级均有严格的大小关系，则不存在环，因此可以用拓扑排序每个车站在图中的大小关系。</p>
<p>有些车站会停车，这些车站的集合设为$A$；有些车站不会停车，这些车站的集合设为$B$。由于A中所有车站的级别都严格大于B中车站的级别，因此有$a_i\geq b_i+1$，$a_i\in A$，$b_i\in B$。另外，由于题目说了车站等级最低是$1$，因此有$a_i\geq 1$。</p>
<ul>
<li>对于$a_i\geq b_i+1$，在差分约束中，其实就是$b_i$向$a_i$连一条权值为1的有向边</li>
<li>对于$a_i\geq 1$，其实就是$a_i\geq X_0+1$，其中$X_0=0$，是超级源点。在差分约束中，其实是$X_0$向$a_i$连一条权值为1的有向边</li>
</ul>
<p>由于本题中的所有点的权值都是大于0，并且一定满足要求=&gt;=&gt;所有车站都等级森严=&gt;=&gt;不存在环=&gt;=&gt;可以拓扑排序得到拓扑图使用递推求解差分约束问题。</p>
<p><strong>整体思路：</strong></p>
<ul>
<li>进行拓扑排序得到一张拓扑图</li>
<li>”至少“$\implies$求变量的最小值$\implies$所有条件的下界中取最大值$\implies$跑最长路。因此我们，根据拓扑序跑最长路递推即可</li>
<li>我们求完最长路之后，会得到$n$个<code>dist[i]</code>。取最大的那个$dist[i]$，那么它就是最高等级，而这个最高等级的等级数就是整张图的级数。为什么呢？因为题目要求”$n$个火车站最少划分的级别数“。假设dist有{2，4，5，8}。说明有四个车站，最高等级是8，说明这四个车站最少划分的等级数是8。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210721155006.png" alt="image-20210721155006523"></p>
<p>我们来考虑如何建边：最坏情况下是有1000趟火车，最多存在1000个火车站，每趟上限最多会有500个停靠站（具体原因下述），那么则有$1000-500=500$个不停靠站，不停站的点都向停站的点连有向边，那么对于一趟车次来说，就会建立$500\times500=250000$条边。有1000趟车次，因此总共有$250000\times1000=2.5\times10^{8}$条边，那么则会超过内存。如果用邻接矩阵存储，需要遍历所有的边，遍历的次数也是$2.5\times10^8$，那么则会超时。</p>
<blockquote>
<p>问题：为什么每趟上限最多会有500个停靠站呢？</p>
<p>停靠过的车站的等级一定严格大于为停靠过的车站的等级，不停站的点都向停站的点连有向边，最坏情况下有1000个点，假设停靠站有$x$个，那么不停站就有$1000-x$个。那么需要总共需要建立的总边数就是$y=x(1000-x)$，从这个二元一次方程中可以看出，当$x=500$时，$y$取到最大值。因此，每趟上限最多会有500个停靠站。</p>
</blockquote>
<p>那么有什么技巧能够减少建立的边数呢？一般对于这种把点分成两部分，从一个点集合向另一个点集合引出边，如果最终边数很多的话。那么是可以使用技巧来优化的：</p>
<p>设左边点集合都是不停靠站，右边点集合都是停靠站，那么我们可以在这两个点集合之间建立<strong>辅助节点</strong>（可以看作是连通两个点集合的交通枢纽）。</p>
<p>如下图所示：</p>
<p>可以发现，优化前，左边点集合为$n=4$，右边点集合为$m=4$，那么总边数为$n\times m=16$。优化后，左边点集合为$n=4$，右边点集合为$m=4$，那么总边数为$n+m=8$。因此，边数减少了。当点数特别多时，那么边数就可以大大减少，从而降低了空间复杂度。</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210721162850.png" alt="image-20210721162850371"></p>
<p>对于这种优化后的建图方式来说，每趟车次需要建边$500+500=1000$条边，有1000趟车次，因此总共需要建立边数为$1000\times1000=1e6$，空间复杂度明显降低了。</p>
<p>也就是说，我们可以在中间建一个辅助节点，左边（非停靠站）向辅助节点连一条权值为0的有向边，辅助节点向右边（停靠站）连一条权值为1的有向边，而这就等价于优化前左边直接向右边连一条权值为1的有向边。</p>
<p>注意本题一共有$m$条线路，每条线路都需要一个辅助节点来连通，而原来就已经有了$n$个节点了，因此总的节点数就是$n+m$。</p>
<p>举个栗子：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210721163916.png" alt="image-20210721163916543"></p>
<p><code>dist[i]</code>表示在拓扑图中，点$i$离起点的最长距离。</p>
<p>由于题目保证所有的火车都满足要求，故该图必定是一张有向无环图，在该图上做一遍拓扑排序求出拓扑序之后，从前往后遍历，求一遍最长路，级别的最大值就是最终的答案</p>
<p>注意，假设图中有$n$个点，我们用$1$到$n$表示原来的点，代码实现中，使用$n+i$表示第$i$个辅助节点（$i$从1开始）</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>写法1：求完拓扑排序后得到一张拓扑图，对这张拓扑图求最长路</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2010</span>,M=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],w[M],idx;</span><br><span class="line"><span class="keyword">int</span> d[N],q[N],dist[N];</span><br><span class="line"><span class="comment">//用来距离哪个车站是停靠站  如果st[i]=true表示第i个车站是停靠站</span></span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="comment">//从a向b连一条权值为c的有向边</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    w[idx]=c;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">    d[b]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进行拓扑排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+m;i++)<span class="comment">//一共有n+m个点</span></span><br><span class="line">        <span class="keyword">if</span>(!d[i])</span><br><span class="line">            q[++tt]=i;</span><br><span class="line">    <span class="keyword">while</span>(hh&lt;=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=q[hh++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(--d[j]==<span class="number">0</span>)</span><br><span class="line">                q[++tt]=j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="comment">//输入m趟车次的信息</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//每次都要情况上一趟车次的停靠站信息</span></span><br><span class="line">        <span class="built_in">memset</span>(st,<span class="number">0</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">        <span class="comment">//起始站和终点站</span></span><br><span class="line">        <span class="keyword">int</span> start=n,end=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;cnt);</span><br><span class="line">        <span class="comment">//读入cnt个停靠站的信息</span></span><br><span class="line">        <span class="keyword">while</span>(cnt--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> stop;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;stop);</span><br><span class="line">            start=<span class="built_in">min</span>(start,stop);</span><br><span class="line">            end=<span class="built_in">max</span>(end,stop);</span><br><span class="line">            <span class="comment">//标记stop这个车站是停靠站</span></span><br><span class="line">            st[stop]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//辅助节点的编号</span></span><br><span class="line">        <span class="keyword">int</span> ver=n+i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=start;j&lt;=end;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果是非停靠站  那么从非停靠站j向辅助节点ver连一条长度为0的有向边</span></span><br><span class="line">            <span class="keyword">if</span>(!st[j])</span><br><span class="line">                <span class="built_in">add</span>(j,ver,<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//如果是停靠站  那么从辅助节点ver向停靠站j连一条长度为1的有向边    </span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">add</span>(ver,j,<span class="number">1</span>);    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进行拓扑排序  得到一张拓扑图</span></span><br><span class="line">    <span class="built_in">topsort</span>();</span><br><span class="line">    <span class="comment">//由于车站等级最低为1级 由差分约束可知 这里是相当于建立了一个超级源点</span></span><br><span class="line">    <span class="comment">//这个超级源点到其他n个节点的距离为1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    dist[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//这张拓扑图中有n+m个节点    求最长路</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n+m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//取出拓扑图中的某个节点t</span></span><br><span class="line">        <span class="keyword">int</span> t=q[i];</span><br><span class="line">        <span class="comment">//遍历t的所有邻接点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//j是t的邻接点</span></span><br><span class="line">            <span class="keyword">int</span> j=e[i];</span><br><span class="line">            <span class="comment">//求出最长路</span></span><br><span class="line">            dist[j]=<span class="built_in">max</span>(dist[j],dist[t]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//找到等级最高的那个dist   那么就是整张图的级数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    res=<span class="built_in">max</span>(res,dist[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>写法2：直接在拓扑排序里求dist</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2010</span> , M = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line"><span class="keyword">int</span> e[M] , ne[M] , w[M] , h[N] , idx;</span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="keyword">int</span> q[N] , d[N];</span><br><span class="line"><span class="keyword">int</span> res;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a , <span class="keyword">int</span> b , <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b , ne[idx] = h[a] , w[idx] = c , h[a] = idx++;</span><br><span class="line">    d[b]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span> , tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n + m ; i++)<span class="comment">//因为加入了辅助节点，所以点数是n+m</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!d[i])</span><br><span class="line">        &#123;</span><br><span class="line">            q[++tt] = i;</span><br><span class="line">            <span class="keyword">if</span>(i &lt;= n) </span><br><span class="line">                dist[i] = <span class="number">1</span>;<span class="comment">//普通节点的初始等级是1，辅助节点的初始等级是0.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = q[hh++];</span><br><span class="line">        <span class="keyword">int</span> temp = (t &gt; n);<span class="comment">//如果是辅助节点连向普通点边权是1，普通节点连向辅助节点边权是0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = h[t] ; ~i ; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(--d[j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + temp;</span><br><span class="line">                q[++tt] = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(h , <span class="number">-1</span> , <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(st , <span class="number">0</span> , <span class="keyword">sizeof</span> st);</span><br><span class="line">        <span class="keyword">int</span> cnt;</span><br><span class="line">        cin &gt;&gt; cnt;</span><br><span class="line">        <span class="keyword">int</span> start = n , end = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(cnt--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> stop;</span><br><span class="line">            cin &gt;&gt; stop;</span><br><span class="line">            start = <span class="built_in">min</span>(start , stop);</span><br><span class="line">            end = <span class="built_in">max</span>(end , stop);</span><br><span class="line">            st[stop] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ver = i + n;<span class="comment">//建立辅助节点</span></span><br><span class="line">        <span class="comment">//遍历从始发站到终点站的信息</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = start ; j &lt;= end;  j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果是非停靠站  那么从非停靠站j向辅助节点ver连一条长度为0的有向边</span></span><br><span class="line">            <span class="keyword">if</span>(!st[j])</span><br><span class="line">                <span class="built_in">add</span>(j,ver,<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//如果是停靠站  那么从辅助节点ver向停靠站j连一条长度为1的有向边    </span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">add</span>(ver,j,<span class="number">1</span>);    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">topsort</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++) </span><br><span class="line">        res = <span class="built_in">max</span>(res , dist[i]);</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<p>写法3：</p>
<p>看到如此鲜明的层级关系，就是拓扑排序了，从未停靠站向停靠站连一条有向边。</p>
<p>此题的要点在于如何计算等级：</p>
<p>利用$dep[son]=dep[father]+1$递推出每一个点在图中是第几层，进而推出了它的等级，然后在计算完一个$dep[i]$时，都用$max$取最大值，最终那个最高等级的等级数就是整张图的级数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>,M=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="comment">//a数组用来记录停靠站的信息  dep数组用来记录拓扑序中的每个节点都处于哪一层,即属于什么等级</span></span><br><span class="line"><span class="keyword">int</span> a[N],dep[N],d[N];</span><br><span class="line"><span class="comment">//st[i]=true表示第i个车站是停靠站</span></span><br><span class="line"><span class="comment">//vst[j][a[p]]表示从非停靠站j向停靠站a[p]连一条有向边</span></span><br><span class="line"><span class="keyword">bool</span> st[N],vst[N][N];</span><br><span class="line"><span class="keyword">int</span> ans;    <span class="comment">//答案</span></span><br><span class="line"><span class="comment">//快读</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> Sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> F=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(c&gt;<span class="string">&#x27;9&#x27;</span> || c&lt;<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            F=<span class="number">-1</span>;</span><br><span class="line">        c=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(c&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; c&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Sum=Sum*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        c=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Sum*F;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">    d[b]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!d[i])</span><br><span class="line">        &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">            <span class="comment">//由于车站等级最低是1级</span></span><br><span class="line">            <span class="comment">//因此那些刚开始时 对于这张图中所有入度为0的节点都是处于同一层</span></span><br><span class="line">            <span class="comment">//即这些入度为0的车站都是相同等级,处于第一层</span></span><br><span class="line">            dep[i]=<span class="number">1</span>;        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">//遍历t的所有邻接点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//j是t的邻接点</span></span><br><span class="line">            <span class="keyword">int</span> j=e[i]; </span><br><span class="line">            <span class="comment">//所有t的邻接点都是处于t的下一层</span></span><br><span class="line">            <span class="comment">//即t的所有邻接点都比节点t的等级多1</span></span><br><span class="line">            dep[j]=dep[t]+<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//找到等级最高的那个就是整张图的级数</span></span><br><span class="line">            ans=<span class="built_in">max</span>(ans,dep[j]);</span><br><span class="line">            <span class="keyword">if</span>(--d[j]==<span class="number">0</span>)</span><br><span class="line">            q.<span class="built_in">push</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span> a);</span><br><span class="line">        <span class="built_in">memset</span>(st,<span class="number">0</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">        <span class="keyword">int</span> start=n,end=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt;</span><br><span class="line">        cin&gt;&gt;cnt;</span><br><span class="line">        <span class="comment">//输入这cnt个停靠站的信息</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=cnt;k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> stop;</span><br><span class="line">            cin &gt;&gt;stop;</span><br><span class="line">            a[k]=stop;</span><br><span class="line">            start=<span class="built_in">min</span>(start,stop);</span><br><span class="line">            end=<span class="built_in">max</span>(end,stop);</span><br><span class="line">            st[stop]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从起始站到终点站</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=start;j&lt;=end;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果j不是停靠站</span></span><br><span class="line">            <span class="keyword">if</span>(!st[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">1</span>;p&lt;=cnt;p++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//如果非停靠站j还没有向停靠站a[p]连过一条有向边</span></span><br><span class="line">                    <span class="keyword">if</span>(!vst[j][a[p]])</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//从非停靠站j向停靠站a[p]连一条有向边</span></span><br><span class="line">                        <span class="built_in">add</span>(j,a[p]);</span><br><span class="line">                        vst[j][a[p]]=<span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">topsort</span>();</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>拓扑排序</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>确定比赛名次</title>
    <url>/2021/07/27/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/%E7%A1%AE%E5%AE%9A%E6%AF%94%E8%B5%9B%E5%90%8D%E6%AC%A1/</url>
    <content><![CDATA[<h1 id="确定比赛名次"><a href="#确定比赛名次" class="headerlink" title="确定比赛名次"></a>确定比赛名次</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=1285">hdu1285</a></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>题意：输出字典序最小的拓扑序列</p>
<p>主要思路：在当前步骤，在所有入度为0的点中输出编号最小的。</p>
<p>考虑用BFS实现拓扑排序：</p>
<p>修改BFS的拓扑排序程序，将普通队列修改成<strong>优先队列Q</strong>，在$Q$中存放入度为0的节点，每次输出编号最小的节点，然后把它的后续节点的入度减1，入度减为0的再放进$Q$中，这样就能输出一个字典序最小的拓扑序列了。</p>
<p>如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210727180249.png" alt="image-20210727175819367"></p>
<p>考虑这题可以使用DFS输出字典序最小的拓扑序列嘛？其实是不行的。上面处理的过程相当于把点按优先级分成了不同的层次，在每个层次都要把这一层入度减为0的点按字典序从小到大输出；而DFS是深度搜索，处理的是上下层之间的关系，不能处理这种同层之间的关系。</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">510</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> g[N][N];    <span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="keyword">int</span> d[N];</span><br><span class="line"><span class="keyword">int</span> seq[N]; <span class="comment">//存储字典序最小的拓扑序列</span></span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//优先队列</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!d[i])</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        seq[cnt++]=t;   <span class="comment">//将t存储拓扑序列中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(g[t][j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(--d[j]==<span class="number">0</span>)</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(g,<span class="number">0</span>,<span class="keyword">sizeof</span> g);</span><br><span class="line">        <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a,b;</span><br><span class="line">            cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">            <span class="keyword">if</span>(!g[a][b])<span class="comment">//防止有重边</span></span><br><span class="line">            &#123;</span><br><span class="line">                g[a][b]=<span class="number">1</span>;</span><br><span class="line">                d[b]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">topsort</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,seq[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,seq[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>拓扑排序</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>秩序</title>
    <url>/2021/07/27/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/%E7%A7%A9%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="秩序"><a href="#秩序" class="headerlink" title="秩序"></a>秩序</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><a href="http://poj.org/problem?id=1270">题目传送门</a></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>题意：给定一个有向无环图，按字典序从小到大输出所有的拓扑序列，题目保证拓扑序列一定存在。</p>
<p>本题并不是裸的拓扑排序，题目要求我们<strong>按照字典序输出所有拓扑序列</strong>，那么我们可以使用回溯法搜索所有的拓扑序列。注意，到达叶子节点时就可以输出这个拓扑序列了，然后回溯时还需要记得恢复现场。</p>
<p>根据样例1，画出如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210727114420.png" alt="image-20210727114420479"></p>
<p>由于题目给出的是字符，但是我们知道图的编号都是整数，因此我们可以把$a$到$z$这26个字符映射成为$0$到$25$这26个整数值，用来表示图中的节点编号。</p>
<p><strong>算法设计：</strong></p>
<ul>
<li>将约束变量列表中的字符都转换为数字并统计其出现次数，然后统计出字符的个数（其实也就是统计图中顶点的个数）</li>
<li>将每对约束都转换为数字，用邻接矩阵存储，并统计入度</li>
<li>用回溯法求解所有拓扑序列并输出</li>
</ul>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">55</span>;</span><br><span class="line"><span class="keyword">int</span> n;  <span class="comment">//图中顶点的总个数</span></span><br><span class="line"><span class="comment">//邻接矩阵 g[i][j]=表示节点i有一条指向节点j的有向边</span></span><br><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line"><span class="comment">//d[i]表示节点i的入度  s[i]表示某个字符出现的次数</span></span><br><span class="line"><span class="keyword">int</span> d[N],s[N];</span><br><span class="line"><span class="comment">//拓扑序列</span></span><br><span class="line"><span class="keyword">int</span> seq[N];</span><br><span class="line"><span class="comment">//u表示当前搜索的节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span><span class="comment">//用回溯法求解出所有的拓扑序列并输出</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//有n个节点 u从0到n-1一共有n个节点</span></span><br><span class="line">    <span class="comment">//因此当u&gt;=n时,说明前面的n个节点都枚举完了  那么就直接输出拓扑序列</span></span><br><span class="line">    <span class="keyword">if</span>(u&gt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,seq[i]+<span class="string">&#x27;a&#x27;</span>);<span class="comment">//转换成字符输出</span></span><br><span class="line">        cout &lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">//回溯</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//i从0到25其实就是对应着枚举从a到z,这样就能保证x出现在y前面或者x出现在z前面</span></span><br><span class="line">    <span class="comment">//即能保证字典序从小到大了</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果当前节点入度为0并且它是出现在约束变量列表中的字符</span></span><br><span class="line">        <span class="keyword">if</span>(!d[i]&amp;&amp;s[i])</span><br><span class="line">        &#123;</span><br><span class="line">            s[i]--; <span class="comment">//出现次数-1</span></span><br><span class="line">            <span class="comment">//遍历节点i的所有邻接点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">26</span>;j++)</span><br><span class="line">                <span class="keyword">if</span>(g[i][j])<span class="comment">//如果节点i有一条指向节点j的有向边,则消除这条边,让j的入度-1</span></span><br><span class="line">                    d[j]--;</span><br><span class="line"></span><br><span class="line">            seq[u]=i;   <span class="comment">//u这个位置填的内容是i 记录拓扑序列中的第u个字符对应的是i</span></span><br><span class="line">            <span class="comment">//递归下一个位置  深搜第u+1个字符</span></span><br><span class="line">            <span class="built_in">dfs</span>(u+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//恢复现场</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">26</span>;j++)</span><br><span class="line">                <span class="keyword">if</span>(g[i][j])<span class="comment">//将i的所有邻接点j的入度都+1</span></span><br><span class="line">                    d[j]++;</span><br><span class="line">            s[i]++; <span class="comment">//恢复该字符在变量列表中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str,ord;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getline</span>(cin,str))<span class="comment">//读入变量列表</span></span><br><span class="line">    &#123;</span><br><span class="line">        n=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(g,<span class="number">0</span>,<span class="keyword">sizeof</span> g);</span><br><span class="line">        <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">        <span class="built_in">memset</span>(s,<span class="number">0</span>,<span class="keyword">sizeof</span> s);</span><br><span class="line">        <span class="comment">//读入约束变量列表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.<span class="built_in">length</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i]!=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                s[str[i]-<span class="string">&#x27;a&#x27;</span>]++;    <span class="comment">//转换为数字统计</span></span><br><span class="line">                n++;    <span class="comment">//记录图中顶点的总个数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">getline</span>(cin,ord);   <span class="comment">//读入约束列表</span></span><br><span class="line">        <span class="comment">//读入约束</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ord.<span class="built_in">length</span>();i+=<span class="number">2</span>)    <span class="comment">//有空格 一次读入两个字符</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//将字符a~z映射成为整数0~25 然后0~25就可以代表图中的节点编号了</span></span><br><span class="line">            <span class="keyword">int</span> a=ord[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            i+=<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> b=ord[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="comment">//表示a-&gt;b有边</span></span><br><span class="line">            g[a][b]=<span class="number">1</span>;  <span class="comment">//用邻接矩阵存储</span></span><br><span class="line">            d[b]++; <span class="comment">//节点b的入度+1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从第0个位置开始搜索  即从图中的第0号节点开始深搜</span></span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">        cout &lt;&lt;endl;    <span class="comment">//每组测试数据过后都要换行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>拓扑排序</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>北极通讯网络</title>
    <url>/2021/07/25/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E6%89%A9%E5%B1%95%E5%BA%94%E7%94%A8/%E5%8C%97%E6%9E%81%E9%80%9A%E8%AE%AF%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="北极通讯网络"><a href="#北极通讯网络" class="headerlink" title="北极通讯网络"></a>北极通讯网络</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210725142226.png" alt="image-20210725142226728"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>抽象一下题意，其实题目是想要求：</p>
<p>找到一个最小的$d$值，使得在删除所有权值大于$d$的边后，所形成的连通块的个数不超过$k$</p>
<p>因为题目中说到“两座村庄之间的距离如果不超过$d$，就可以用该型号的无线电收发机直接通讯”，也就是说，那些距离不超过$d$的节点都是可以直接或者间接连通的，但是那些距离超过$d$的节点之间就不能通过无线电进行通信了，而需要借助卫星设备。</p>
<p>而且，我们发现一个事实：随着$d$值的不断递增，所形成的连通块的个数不断递减。</p>
<p>下面一个图示解释了这个原因：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210725143740.png" alt="image-20210725143740580"></p>
<p>一提到连通块和最小生成树，我们很容易想到Kruskal算法，回顾一下这个算法的流程，其实就是：</p>
<ul>
<li>将边权从小到大排序</li>
<li>依次从小到大扫描每一条边，设这条边的一个端点为$A$，另一个端点为$B$，那么也就是合并$A$所在连通块和$B$所在连通块</li>
</ul>
<p>我们发现第二步本质上就是在维护连通块的个数，而且我们知道Kruskal算法每次选择的边权都是不断递增的，而且随着边权的不断递增，就会不断合并连通块，即<strong>随着边权的递增，所得到的连通块个数不断递减</strong>。而这个性质不正好与我们上面提到的题目事实是完全相同的嘛。</p>
<p>也就是说，题目想要求的最小的距离$d$值，其实就是在Kruskal算法执行过程中的某个时刻，选择了某条边的权值，然后合并这条边后，使得连通块的个数是$k$。即距离$d$值其实就是边权。</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210725144429.png" alt="image-20210725144429219"></p>
<p>因此，我们就直接跑Kruskal算法，然后挑选一条边后，就将这条边的权值赋给$d$，当某一时刻，合并某一条边后，设这条边的权值为$w$，使得所形成的连通块的个数$\leq k$，那么此时的这个$w$就是$d$值的最小值了，直接break即可，不再进行选边操作了。</p>
<p>当然这一题也是可以用二分的，不过需要配合并查集算法：</p>
<p>我们设 性质为：<strong>删除所有边权大于$d$的边后，对所有边权$\leq d$的边进行并查集操作后，所形成的连通块的数量$\leq k$</strong></p>
<p>注意这里是浮点数的二分</p>
<ul>
<li>如果满足这个性质，则$r=mid$</li>
<li>如果不满足这个性质，则$l=mid$</li>
</ul>
<p>如下图解释：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210725155710.png" alt="image-20210725155710521"></p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>写法1：直接用Kruskal算法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//边数M最坏情况下是 无向完全图即n(n-1)/2</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">510</span>,M=N*N/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;PII;</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">double</span> w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge&amp; W)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w&lt;W.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"><span class="comment">//存储每个节点的坐标</span></span><br><span class="line">PII q[M];</span><br><span class="line"><span class="comment">//获取两个点之间的距离  把这个距离当作这两个节点之间的边权</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">get</span><span class="params">(PII A,PII B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dx=A.first-B.first;</span><br><span class="line">    <span class="keyword">int</span> dy=A.second-B.second;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(dx*dx+dy*dy);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x!=p[x])</span><br><span class="line">        p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt=n;  <span class="comment">//起初有n个独立的节点,也就是n个连通块</span></span><br><span class="line">    <span class="built_in">sort</span>(edges,edges+m);</span><br><span class="line">    <span class="comment">//注意这里初始化时是从0开始的 </span></span><br><span class="line">    <span class="comment">//因为我们用到的点是0~n-1而不是1~n</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        p[i]=i;</span><br><span class="line">    <span class="keyword">double</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="built_in">find</span>(edges[i].a);</span><br><span class="line">        <span class="keyword">int</span> b=<span class="built_in">find</span>(edges[i].b);</span><br><span class="line">        <span class="keyword">double</span> w=edges[i].w;</span><br><span class="line">        <span class="keyword">if</span>(a!=b)</span><br><span class="line">        &#123;</span><br><span class="line">            p[a]=b;</span><br><span class="line">            <span class="comment">//记录此时选的那条边的权值</span></span><br><span class="line">            res=w;</span><br><span class="line">            <span class="comment">//合并两个连通块了,因此连通块的数量-1</span></span><br><span class="line">            cnt--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果合并完这条边后,所形成的连通块的个数&lt;=k  那么选中的这条边其实就是最小的d值</span></span><br><span class="line">        <span class="comment">//那么就不需要再 选择后面的边了</span></span><br><span class="line">        <span class="keyword">if</span>(cnt&lt;=k)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="comment">//读入这n个村庄的坐标</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)	<span class="comment">//村庄编号从0到n-1而不是从1到n</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;q[i].first,&amp;q[i].second);</span><br><span class="line">    <span class="comment">//由于是无向边,因此是对称矩阵  那么我们只需要统计下三角的边就行了    </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">double</span> w=<span class="built_in">get</span>(q[i],q[j]);</span><br><span class="line">            edges[m++]=&#123;i,j,w&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> d=<span class="built_in">Kruskal</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>,d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>写法2：二分+并查集</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">510</span>,M=N*N/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps=<span class="number">1e-4</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;PII;</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line">PII q[M];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">double</span> w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Edge &amp;W)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w&lt;W.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">get</span><span class="params">(PII A,PII B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dx=A.first-B.first;</span><br><span class="line">    <span class="keyword">int</span> dy=A.second-B.second;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(dx*dx+dy*dy);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x!=p[x])</span><br><span class="line">        p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断mid是否满足该性质：删除所有边权大于d的边后,对所有边权&lt;=d的边进行并查集操作后</span></span><br><span class="line"><span class="comment">//所形成的连通块的数量&lt;=k</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">double</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//注意这里初始化时是从0开始的 </span></span><br><span class="line">    <span class="comment">//因为我们用到的点是0~n-1而不是1~n</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) </span><br><span class="line">        p[i]=i;</span><br><span class="line">    <span class="comment">//idx记录的是第一个大于权值为mid的那条边所对应的数组下标    </span></span><br><span class="line">    <span class="keyword">int</span> idx;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> w=edges[i].w;</span><br><span class="line">        <span class="comment">//浮点数做差会有精度问题  应该需要加入精度比较</span></span><br><span class="line">        <span class="keyword">if</span>(w&gt;mid+eps)</span><br><span class="line">        &#123;</span><br><span class="line">            idx=i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;  <span class="comment">//用多少条边来连接不同的连通块</span></span><br><span class="line">    <span class="comment">//由于第idx条边是首个权值大于mid的边,因此[0,idx-1]这些边都是权值&lt;=mid的边</span></span><br><span class="line">    <span class="comment">//而我们现在就是要对这些权值&lt;=mid的边进行合并 然后求出连通块的个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;idx;i++)<span class="comment">//注意这里是[0,idx)也就是[0,idx-1]</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="built_in">find</span>(edges[i].a);</span><br><span class="line">        <span class="keyword">int</span> b=<span class="built_in">find</span>(edges[i].b);</span><br><span class="line">        <span class="keyword">if</span>(a!=b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//合并两个连通块需要耗费一条边</span></span><br><span class="line">            res++;</span><br><span class="line">            p[a]=b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//连通块的数目=总点数-耗费的连边数量</span></span><br><span class="line">    <span class="comment">//比如有u,v,w三个节点,起初是独立的三个连通块,耗费一条边连接u,v,那么u和v在同一个连通块中了,num=1;</span></span><br><span class="line">    <span class="comment">//耗费一条边连接(u,v),w,那么u,v,w在同一个连通块中了,num=2;最终只有一个连通块</span></span><br><span class="line">    <span class="comment">//因此连通块数量cnt=总点数n-耗费的连边数量num</span></span><br><span class="line">    <span class="keyword">int</span> cnt=n-res;</span><br><span class="line">    <span class="keyword">return</span> cnt&lt;=k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="comment">//读入这n个村庄的坐标</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)    <span class="comment">//村庄编号从0到n-1而不是从1到n</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;q[i].first,&amp;q[i].second);</span><br><span class="line">    <span class="comment">//由于是无向边,因此是对称矩阵  那么我们只需要统计下三角的边就行了    </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">double</span> w=<span class="built_in">get</span>(q[i],q[j]);</span><br><span class="line">            edges[m++]=&#123;i,j,w&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//给所有边按从小到大排序</span></span><br><span class="line">    <span class="built_in">sort</span>(edges,edges+m);</span><br><span class="line">    <span class="comment">// 二分答案 答案区间是读入的边权的最小值和边权的最大值</span></span><br><span class="line">    <span class="keyword">double</span> l=<span class="number">0</span>,r=edges[m<span class="number">-1</span>].w;</span><br><span class="line">    <span class="comment">//进行浮点数二分</span></span><br><span class="line">    <span class="keyword">while</span>(l+eps&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//check是检查当前的mid是否满足删除所有d&gt;mid的边后，对所有&lt;=mid的边进行合并之后所形成的连通块数目&lt;=k</span></span><br><span class="line">        <span class="comment">//设答案为ans,对于d&gt;=ans的d都是满足的,如果满足,为了求出最小的d,则往左侧收缩</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) </span><br><span class="line">            r=mid;  <span class="comment">//往左侧收缩</span></span><br><span class="line">        <span class="comment">//否则不满足该性质  应该往右边去寻找    </span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            l=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2lf&quot;</span>,l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>最小生成树</category>
      </categories>
      <tags>
        <tag>最小生成树的扩展应用</tag>
      </tags>
  </entry>
  <entry>
    <title>秘密的牛奶运输</title>
    <url>/2021/07/26/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E6%89%A9%E5%B1%95%E5%BA%94%E7%94%A8/%E7%A7%98%E5%AF%86%E7%9A%84%E7%89%9B%E5%A5%B6%E8%BF%90%E8%BE%93/</url>
    <content><![CDATA[<h1 id="秘密的牛奶运输"><a href="#秘密的牛奶运输" class="headerlink" title="秘密的牛奶运输"></a>秘密的牛奶运输</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210726160105.png" alt="image-20210726160105315"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>通读题目，可知这道题其实想要求的是次小生成树。</p>
<p><code>定理</code>：对于一张无向图，如果存在最小生成树和次小生成树，那么对于任何一棵最小生成树来说，都存在一棵次小生成树，并且最小生成树和次小生成树之间只有一条边不同。</p>
<p>严格证明还不会，但是可以举个形象化的栗子：</p>
<p>给出以下定义：</p>
<p><code>树边</code>：最小生成树中的边</p>
<p><code>非树边</code>：不在最小生成树中的边，但是它是原图中真实存在的边</p>
<p>我们设一条非树边为$a$，一条树边为$b$，我们让这条非树边去代替这条树边，记作：$(+a,-b)$。这称为一次可行变换</p>
<p>通过一次可行变换后得到的仍然是一棵生成树，我们称这棵生成树是最初那棵最小生成树的邻集。</p>
<p>也就是说我们想要证明最小生成树和次小生成树之间只有一条边不同，其实也就是要证明只进行一次可行变换就行了。</p>
<p>如下图所示：</p>
<p>其中$a$和$c$是树边，$b$和$d$是非树边，由Kruskal算法可知，树边$a$把连通块$A$和连通块$B$合并成了一个集合（设为$F$)，树边$c$把集合$F$和连通块$C$合并成了一个大的连通块。</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210726161854.png" alt="image-20210726161854785"></p>
<p>假设我们进行一次可行变换，也就是用非树边$b$去代替树边$a$。由Kruskal算法可知，$a$必定是小于$b$的（这里不讨论等于，因为等于的话则随机选择了$a$或者$b$作为最初最下生成树的树边了），可以用反证法，假设$b&lt;a$，那么由算法的正确性可知，一定会选择$b$作为树边合并连通块$A$和连通块$B$，而不会是$a$，但是最小生成树选择了$a$作为树边，因此矛盾，于是必然有$a&lt;b$。现在我们进行一次可行变换，用非树边$b$去代替树边$a$。设最初最小生成树的权值总和为$sum$，那么增加非树边$b$和删除树边$a$后，所得到的仍然是一棵生成树，权值总和为$sum+b-a$，因为$b-a&gt;0$，也就是说这次可行变换产生了一个增量，设增量$\Delta=b-a$，可以知道$sum+(b-a)&gt;sum$，也就是说进行一次可行变换后得到的这棵生成树的权值总和是大于最初那棵最小生成树的权值总和的。</p>
<p>如下图所示：</p>
<p>设最初的最小生成树为$T_0$，用非树边$b$去代替树边$a$进行一次可行变换得到的生成树为$T_1$：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210726212118.png" alt="image-20210726163600462"></p>
<p>假设我们进行两次可行变换，也就是用非树边$b$去代替树边$a$，用非树边$d$代替树边$c$，同理分析可知$b&gt;a$，$d&gt;c$，那么此时得到的生成树设为$T_2$，权值总和为$sum+(b-a)+(d-c)$，由此可知，$T_0&lt;T_1&lt;T_2$，由于$T_0$是最小生成树，那么$T_1$就是次小生成树。因此我们发现如果替换的边越多，得到的生成树的权值远远大于最小生成树，而且也会大于次小生成树。这就直观地说明了<strong>最小生成树和次小生成树之间只有一条边不同</strong></p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210726164147.png" alt="image-20210726164147506"></p>
<p>从上面的分析我们可以知道，要想求次小生成树，其实就是要从非树边中找出一条边，让这条边去替换已经在最小生成树中的树边。设这条非树边的权值为$w$，设已经在最小生成树中的树边的权值为$w[i]$，那么进行这次可行变换后，得到的生成树的权值总和为$X=sum+w-w[i]$。由这个等式可知，要想$X$尽可能小，那么就需要$w[i]$最大。那么问题就转化为如何求这棵最小生成树中的权值最大的那条边。</p>
<p>但是有个问题，如果$w=w[i]$，那么即使我们进行了这次可行变换，所得到的最小生成树权值总和仍然是不变的，因此这并不是严格的次小生成树。为了考虑这种情况，我们还需要求解出这棵最小生成树中的权值第二大的那条边，称为次大边。我们设最大边为$d_1$，次大边为$d_2$。</p>
<ul>
<li>如果$w&gt;d_1$，那么则说明我们可以直接用这条非树边去替换到原来最小生成树中的那条最大边，这样得到的这棵生成树就是次小的。也就是说如果$w&gt;d_1$，需要执行$d_2=d_1$，$d_1=w$。</li>
<li>如果$w=d_1$，则替换没有任何意义，此时啥也不做</li>
<li>如果$w&lt;d_1$，此时就不能用这条非树边去代替那条树边了（否则会得到更小的最小生成树，矛盾了），但是呢，我们可以考虑是否可以用这条非树边去替换掉次大边，如果此时还有$w&gt;d_2$，那么就可以用这条非树边去代表次大边，这样得到的生成树就是次小的。也就是说如果$w&lt;d1$&amp;&amp;$w&gt;d_2$，则执行$d_2=w$。</li>
<li>如果$w=d_2$，由于次大边肯定是小于最大边的，即$d_1&lt;d2$，因此必有$w&lt;d_2$。既然$w=d_2$，那么用这条非树边去替换次大边$d_2$没有任何意义，此时啥也不做。</li>
<li>那么为什么只需要记录最大边和次大边就行了呢？因为如果$w&gt;d_1$，直接进行可行变换即可；如果$w=d_1$，那么接下来次大值，但是呢有个问题就是次大值并不一定会存在你，啥时候会不存在次大值呢？其实也就是所有边的权值都是一样的，那么就不会分为什么最大边和次大边了，也就不存在次大值了。如果次大值不存在，那么所有的$w_i$都与$d_1$相同，那么这次可行替换没有任何意义。因此只有这两种情况，那么只需要记录最大边和次大边就好了。总的来说就是：<ul>
<li>如果$w&gt;d_1$，直接进行可行变换</li>
<li>如果$w=d_1$，接着考虑次大值：<ul>
<li>如果次大值存在，则说明必有$d_2&lt;d_1$，由于$w=d_1$，因此$w&gt;d_2$</li>
<li>如果次大值不存在，则说明所有边的权值都是一样的，那么这次可行替换没有任何意义</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>于是就有如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(w[i]&gt;td1)</span><br><span class="line">&#123;</span><br><span class="line">    td2=td1;</span><br><span class="line">    td1==w[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(w[i]&lt;td1&amp;&amp;w[i]&gt;td2)</span><br><span class="line">    td2=w[i];</span><br></pre></td></tr></table></figure>



<p>那么我们如何求解一棵树中的最大边和次大边呢？</p>
<p>考虑到这题只有$N=500$个点，数据范围不是很大，可以用暴力求解：</p>
<p>依次遍历这$n$个节点，枚举从$1$号点出发，它到其他各点的路径上所经过的边的最大值；接着枚举从$2$号点出发，它到其他各点的路径上所经过的边的最大值，$\cdots$，最后枚举从$n$号点出发，它到其他各点的路径上所经过的边的最大值。那么最终就可以知道任意两点之间路径上的边权的最大值了。再求解任意两点间的边权最大值时就苦于同时求出了次大边。</p>
<p>我们设<code>dist1[a][b]</code>表示任意两点间的边权最大值，<code>dist2[a][b]</code>表示任意两点间的边权次大值。我们可以在$O(n^2)$内求出一棵树中任意两点间边权的最大值和次大值（当然还有更优化的方法比如LCA）。</p>
<blockquote>
<p>问题：<code>dist[][]</code>不是二维数组嘛？为什么传参进入dfs函数时，就传了一维数组<code>dist[]</code>呢？</p>
<p>其实我们在传参进入dfs函数时，虽然只是传了一维数组<code>dist[]</code>，但是我们还传了是第几行$i$。我们知道$dist1[i][j_1]$表示节点$i$和节点$j_1$之间的边权的最大值，$dist1[i][j_2]$表示节点$i$和节点$j_2$之间的边权的最大值。也就是说，当我们传入行号$i$时，只需要传入一维数组<code>dist[]</code>，但是这个一维数组的含义其实就是：<code>dist[i]</code>存储的是所有从$i$出发，所能到达的节点的之间的边权的最大值，即我们更新时，是把整个第$i$行都更新了，而不是只单单更新某个$dist[i][j]$。</p>
</blockquote>
<p>这里还有一点需要注意，在dfs时，由于树中的边是无向边，假设节点$a$和节点$b$之间有一条无向边，设$a$在前面，$b$在后面。当搜到节点$a$时，就遍历了这条无向边了。通过这条无向边遍历到了邻接点$b$。但是当搜到节点$b$时，我们不能让它往回搜索了，也就是不能让它通过这条无向边又去遍历到邻接点$a$，因为这条无向边已经被搜索过了，为了防止一直在这里死循环，可以设置一个<code>father</code>标志记录上一个节点的编号。假设当前搜到节点$i$，设节点$i$是从节点$father$走过来的，然后遍历到它的邻接点$j$，只有当$j\neq father$时，才能保证不往回搜索。</p>
<p>当然也可以用一个st数组来标记每个节点是否已经被搜索过了，防止往回搜索。</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>写法1：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//M是原图中的所有边</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">510</span>,M=<span class="number">10010</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a,b,w;</span><br><span class="line">    <span class="keyword">bool</span> flag;  <span class="comment">//标记是否为树边  如果为true则说明是树边 如果是false则说明是非树边</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge&amp; W)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w&lt;W.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"><span class="comment">//无向边  树中有n个节点,则有n-1条边,所以边数为2(n-1)</span></span><br><span class="line"><span class="comment">//注意这里邻接表中的边是指对这棵最小生成树建图后的边</span></span><br><span class="line"><span class="comment">//而不是指原图中的所有边</span></span><br><span class="line"><span class="keyword">int</span> h[N],e[<span class="number">2</span>*N],ne[<span class="number">2</span>*N],w[<span class="number">2</span>*N],idx;</span><br><span class="line"><span class="comment">//dist1[i][j]表示从节点i和节点j之间路径上的某条边的权值最大,即最大边</span></span><br><span class="line"><span class="comment">//dist2[i][j]表示从节点i和节点j之间路径上的某条边的权值次大,即次大边</span></span><br><span class="line"><span class="keyword">int</span> dist1[N][N],dist2[N][N];</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    w[idx]=c;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x!=p[x])</span><br><span class="line">        p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Kruskal算法求出最小生成树的权值总和</span></span><br><span class="line"><span class="function">LL <span class="title">Kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(edges,edges+m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        p[i]=i;</span><br><span class="line">    LL res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="built_in">find</span>(edges[i].a);</span><br><span class="line">        <span class="keyword">int</span> b=<span class="built_in">find</span>(edges[i].b);</span><br><span class="line">        <span class="keyword">int</span> w=edges[i].w;</span><br><span class="line">        <span class="keyword">if</span>(a!=b)</span><br><span class="line">        &#123;</span><br><span class="line">            p[a]=b;</span><br><span class="line">            res+=w;</span><br><span class="line">            edges[i].flag=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意：Kruskal算法只是能够求出最小生成树的权值总和,但是并没有把这棵最小生成树建图出来</span></span><br><span class="line"><span class="comment">//因此这里的build函数是把这棵最小生成树用图建立出来</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="comment">//枚举这m条边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果是树边,则说明是最小生成树中的边</span></span><br><span class="line">        <span class="keyword">if</span>(edges[i].flag)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a=edges[i].a;</span><br><span class="line">            <span class="keyword">int</span> b=edges[i].b;</span><br><span class="line">            <span class="keyword">int</span> w=edges[i].w;</span><br><span class="line">            <span class="comment">//最小生成树中的边都是无向边</span></span><br><span class="line">            <span class="built_in">add</span>(a,b,w);</span><br><span class="line">            <span class="built_in">add</span>(b,a,w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//暴力解决任意两个点之间的最大边和次大边</span></span><br><span class="line"><span class="comment">//u表示当前的搜索节点  fa表示节点u的上一个节点  即u是从fa走过来的</span></span><br><span class="line"><span class="comment">//maxd1表示最大边  maxd2表示次大边</span></span><br><span class="line"><span class="comment">//d1[i]记录的是从节点i出发所能到达所有节点的最大边 即d1[i]=&#123;d1[i][0],d1[i][1],...,d1[i][n-1]&#125;</span></span><br><span class="line"><span class="comment">//d2[i]记录的是从节点i出发所能到达所有节点的次大边 即d2[i]=&#123;d2[i][0],d2[i][1],...,d2[i][n-1]&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa,<span class="keyword">int</span> maxd1,<span class="keyword">int</span> maxd2,<span class="keyword">int</span> d1[],<span class="keyword">int</span> d2[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    d1[u]=maxd1;    <span class="comment">//把dist1中第u行的所有列都赋值为maxd1   </span></span><br><span class="line">    d2[u]=maxd2;    <span class="comment">//把dist2中第u行的所有列都赋值为maxd2</span></span><br><span class="line">    <span class="comment">//遍历u的所有邻接点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];~i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j=e[i];</span><br><span class="line">        <span class="comment">//避免往回重复搜索</span></span><br><span class="line">        <span class="keyword">if</span>(j!=fa)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> td1=maxd1;  <span class="comment">//td1是最大边</span></span><br><span class="line">            <span class="keyword">int</span> td2=maxd2;  <span class="comment">//td2是次大边</span></span><br><span class="line">            <span class="comment">//非树边w[i]严格大于最小生成树中的最大边td1,则直接进行可行变换即可</span></span><br><span class="line">            <span class="keyword">if</span>(w[i]&gt;td1)</span><br><span class="line">            &#123;</span><br><span class="line">                td2=td1;    <span class="comment">//先更新次大边</span></span><br><span class="line">                td1=w[i];   <span class="comment">//再更新最大边</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//否则,如果非树边w[i]严格小于最小生成树中的最大边td1,但是严格大于最小生成树中的次大边td2</span></span><br><span class="line">            <span class="comment">//那么可以用这条非树边去代替次大边</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(w[i]&lt;td1&amp;&amp;w[i]&gt;td2)</span><br><span class="line">            &#123;</span><br><span class="line">                td2=w[i];   <span class="comment">//更新次大边</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//接着递归搜索从节点j出发</span></span><br><span class="line">            <span class="built_in">dfs</span>(j,u,td1,td2,d1,d2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="comment">//读入m条边的信息</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;w);</span><br><span class="line">        edges[i]=&#123;a,b,w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用Kruskal算法求出最小生成树的权值总和</span></span><br><span class="line">    LL sum=<span class="built_in">Kruskal</span>();</span><br><span class="line">    <span class="comment">//对这棵最小生成树建图</span></span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    <span class="comment">//依次枚举从节点1~节点n出发,任意两点之间的最大边和次大边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">dfs</span>(i,<span class="number">-1</span>,<span class="number">-1e9</span>,<span class="number">-1e9</span>,dist1[i],dist2[i]);</span><br><span class="line">    LL res=<span class="number">1e18</span>;    <span class="comment">//次小生成树的权值总和</span></span><br><span class="line">    <span class="comment">//枚举每一条非树边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!edges[i].flag)<span class="comment">//非树边</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a=edges[i].a;</span><br><span class="line">            <span class="keyword">int</span> b=edges[i].b;</span><br><span class="line">            <span class="keyword">int</span> w=edges[i].w;</span><br><span class="line">            LL t;   <span class="comment">//次小生成树的权值总和</span></span><br><span class="line">            <span class="comment">//非树边w[i]严格大于最小生成树中的最大边dist1[a][b],则直接进行替换最大边</span></span><br><span class="line">            <span class="keyword">if</span>(w&gt;dist1[a][b])</span><br><span class="line">                t=sum+w-dist1[a][b];</span><br><span class="line">            <span class="comment">//否则,非树边严格大于最小生成树中的次大边dist2[a][b],则直接进行替换次大边</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(w&gt;dist2[a][b])</span><br><span class="line">                t=sum+w-dist2[a][b];</span><br><span class="line">            res=<span class="built_in">min</span>(res,t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>写法2：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>, M = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, w;</span><br><span class="line">    <span class="keyword">bool</span> flag;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Edge&amp; t)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; t.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"><span class="keyword">int</span> dist1[N][N], dist2[N][N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="keyword">int</span> h[N], e[N*<span class="number">2</span>], ne[N*<span class="number">2</span>], w[N*<span class="number">2</span>], idx;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x != p[x]) </span><br><span class="line">        p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">Kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(edges,edges+m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        p[i]=i;</span><br><span class="line">    LL res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="built_in">find</span>(edges[i].a);</span><br><span class="line">        <span class="keyword">int</span> b=<span class="built_in">find</span>(edges[i].b);</span><br><span class="line">        <span class="keyword">int</span> w=edges[i].w;</span><br><span class="line">        <span class="keyword">if</span>(a!=b)</span><br><span class="line">        &#123;</span><br><span class="line">            p[a]=b;</span><br><span class="line">            res+=w;</span><br><span class="line">            edges[i].flag=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> u, <span class="keyword">int</span> maxd1, <span class="keyword">int</span> maxd2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dist1[root][u] = maxd1;</span><br><span class="line">    dist2[root][u] = maxd2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (st[j]) </span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        st[j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> td1 = maxd1;</span><br><span class="line">        <span class="keyword">int</span> td2 = maxd2;</span><br><span class="line">        <span class="keyword">if</span> (w[i] &gt; td1) </span><br><span class="line">            td2 = td1, td1 = w[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(w[i]!=td1 &amp;&amp; w[i] &gt; td2) </span><br><span class="line">            td2 = w[i];</span><br><span class="line">        <span class="built_in">dfs</span>(root,j, td1, td2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="comment">//枚举这m条边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果是树边,则说明是最小生成树中的边</span></span><br><span class="line">        <span class="keyword">if</span>(edges[i].flag)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a=edges[i].a;</span><br><span class="line">            <span class="keyword">int</span> b=edges[i].b;</span><br><span class="line">            <span class="keyword">int</span> w=edges[i].w;</span><br><span class="line">            <span class="comment">//最小生成树中的边都是无向边</span></span><br><span class="line">            <span class="built_in">add</span>(a,b,w);</span><br><span class="line">            <span class="built_in">add</span>(b,a,w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        edges[i] = &#123;a, b, c&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    LL sum=<span class="built_in">Kruskal</span>();</span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(i, i, <span class="number">-1e9</span>, <span class="number">-1e9</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    LL res = <span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++ ) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!edges[i].flag)</span><br><span class="line">        &#123;</span><br><span class="line">            LL t;</span><br><span class="line">            <span class="keyword">int</span> a = edges[i].a;</span><br><span class="line">            <span class="keyword">int</span> b = edges[i].b;</span><br><span class="line">            <span class="keyword">int</span> w = edges[i].w;</span><br><span class="line">            <span class="keyword">if</span> (w &gt; dist1[a][b]) </span><br><span class="line">                t = sum - dist1[a][b] + w;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                t = sum - dist2[a][b] + w;</span><br><span class="line">            res = <span class="built_in">min</span>(res, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>最小生成树</category>
      </categories>
      <tags>
        <tag>最小生成树的扩展应用</tag>
      </tags>
  </entry>
  <entry>
    <title>新的开始</title>
    <url>/2021/07/25/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E6%89%A9%E5%B1%95%E5%BA%94%E7%94%A8/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/</url>
    <content><![CDATA[<h1 id="新的开始"><a href="#新的开始" class="headerlink" title="新的开始"></a>新的开始</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210725122343.png" alt="image-20210725122343693"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>这个题目有点特殊，我们把每个矿井都看作图中的一个节点，由于在矿井$i$上建立一个发电站，需要费用$v_i$，也就是说节点上是有权值的。然后题目想要问的是连通所有节点所需要的最小花费，这很明显其实就是想要求最小生成树。</p>
<p>题目中的第一个方法表明了每个节点上是可以有权值的；第二个方法表明了节点之间的边是有权值的。如果只有边权，那么就是我们熟悉的模型，直接求解这个图的最小生成树即可。但是特别之处在于节点也是有权值的，因此我们就不能对这张图直接求解最小生成树了。需要做如下转化：</p>
<p>我们可以建立一个虚拟源点（超级发电站），如果某个矿井$i$上有权值$v_i$，那么我们就转化为虚拟源点到这个节点之间的边权为$v_i$，也就是说我们巧妙地把节点的权值转移到了虚拟源点与该节点之间的边的权值，而且是等效的。那么，我们通过这么做之后，就会得到一张$n+1$个节点的新图，而且这个新图只有边是有权值的，顶点不再带有权值，于是就转化为了我们熟悉的模型，那么就可以对这张新图直接求解最小生成树了。</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210725123841.png" alt="image-20210725123841634"></p>
<p>举个栗子：</p>
<p>拿题目样例解释：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210725124421.png" alt="image-20210725124421133"></p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>写法1：prim算法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">310</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="comment">//prim算法求解最小生成树</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;  <span class="comment">//让所有矿井获得充足电能的最小花费</span></span><br><span class="line">    <span class="comment">//初始化每个节点到S集合的距离为正无穷</span></span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="comment">//初始化虚拟源点到达S集合的距离为0</span></span><br><span class="line">    dist[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//由于最终形成的最小生成树中有n+1个节点</span></span><br><span class="line">    <span class="comment">//每跑一趟循环就能把一个节点加入S集合,有n+1个节点,因此需要跑n+1次循环</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n+<span class="number">1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//t记录的是此时距离S集合最近的点</span></span><br><span class="line">        <span class="keyword">int</span>  t=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span>(!st[j]&amp;&amp;(t==<span class="number">-1</span>||dist[t]&gt;dist[j]))</span><br><span class="line">                t=j;</span><br><span class="line">        <span class="comment">//标记点t已经被加入了S集合</span></span><br><span class="line">        st[t]=<span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//累加最小生成树的权值</span></span><br><span class="line">        res+=dist[t];</span><br><span class="line">        <span class="comment">//枚举节点t的所有邻接点  更新这些点到集合S的距离</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=n;k++)</span><br><span class="line">            dist[k]=<span class="built_in">min</span>(dist[k],g[t][k]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="comment">//将矿井节点上的权值vi转化为虚拟源点与该节点之间的边权</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w);</span><br><span class="line">        <span class="comment">//最小生成树无向图  </span></span><br><span class="line">        g[<span class="number">0</span>][i]=g[i][<span class="number">0</span>]=w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输入矿井i和矿井j之间建立电网的费用</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;g[i][j]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">prim</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>写法2：Kruskal算法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">310</span>,M=N*N;</span><br><span class="line"><span class="keyword">int</span> n,cnt;      <span class="comment">//cnt是总共的边数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a,b,w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge&amp; W)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w&lt;W.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x!=p[x])</span><br><span class="line">        p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sort</span>(edges,edges+cnt);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">        p[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="built_in">find</span>(edges[i].a);</span><br><span class="line">        <span class="keyword">int</span> b=<span class="built_in">find</span>(edges[i].b);</span><br><span class="line">        <span class="keyword">int</span> w=edges[i].w;</span><br><span class="line">        <span class="keyword">if</span>(a!=b)</span><br><span class="line">        &#123;</span><br><span class="line">            p[a]=b;</span><br><span class="line">            res+=w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w);</span><br><span class="line">        edges[cnt++]=&#123;<span class="number">0</span>,i,w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> w;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w);</span><br><span class="line">            edges[cnt++]=&#123;i,j,w&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">Kruskal</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>最小生成树</category>
      </categories>
      <tags>
        <tag>最小生成树的扩展应用</tag>
      </tags>
  </entry>
  <entry>
    <title>走廊泼水节</title>
    <url>/2021/07/25/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E6%89%A9%E5%B1%95%E5%BA%94%E7%94%A8/%E8%B5%B0%E5%BB%8A%E6%B3%BC%E6%B0%B4%E8%8A%82/</url>
    <content><![CDATA[<h1 id="走廊泼水节"><a href="#走廊泼水节" class="headerlink" title="走廊泼水节"></a>走廊泼水节</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210725210138.png" alt="image-20210725210138528"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>题目的意思是：现在有一张图，已知了这张图的最小生成树了，然后我们需要把这张图变成完全图（任意两个节点之间都有边相连），使得这张完全图中的最小生成树仍然与原图的最小生成树是同一颗。把原图变成完全图，就需要加边，题目想要我们求的是加的这些边的权值总和的最小值。</p>
<p>设当前扫描到边$(x,y)$，其权值为$z$，设$x$所在连通块为$S_x$，$y$所在连通块为$S_y$，此时应该合并$S_x$与$S_y$。合并后的$S_x\cup S_y$构成一棵树的结构。</p>
<p>$\forall u\in S_x$，$v\in S_y$，如果$(u,v)\neq(x,y)$，则在最终的完全图中，我们肯定需要在$(u,v)$之间增加一条边。于是，无向边$(u,v)$、$S_x$中从$u$到$x$的路径、无向边$(x,y)$、$S_y$中从$v$到$y$的路径，就形成了一个环，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210725211301.png" alt="image-20210725211301315"></p>
<p>为了保证$(x,y)$一定在最小生成树中，就必须让$(x,y)$是连接集合$S_x$和集合$S_y$的权值最小的边（否则就可以用边$(u,v)$去代替边$(x,y)$形成一棵最小生成树了，这与已有的最小生成树有矛盾）。因此，为了保证所添加的这些边的权值总和最小，那么可以让所有新添加的这些边的权值都为$z+1$。</p>
<p>设集合$S_x$中有$|S_x|$个节点，集合$S_y$中有$|S_y|$个节点，由于完全图是任意两个节点之间都需要有边相连，因此总共需要$|S_x|\times|S_y|$条边，但是由于边$(x,y)$已经是原图中已有的一条连接$S_x$和$S_y$这两个连通块中的一条边了，因此应该从$|S_x|\times|S_y|$减去这条已有的连接边。也就是说，合并$S_x$和$S_y$这两个连通块，需要边数为$|S_x|\times|S_y|-1$，由于每条边的权值都为$z+1$。因此增加的边的权值总和最小是$(z+1)\times$$(|S_x|\times|S_y|-1)$</p>
<blockquote>
<p>问题：为什么新添加的边权一定是$z+1$，而不能是$z$或者小于$z$呢？如何理解$(z+1)\times$$(|S_x|\times|S_y|-1)$这个式子呢？</p>
<p>如下图所示：可以发现，合并了两个连通块后，所形成的这个连通块就已经是完全图了，以此类推，合并完所有的连通块后，所得到的最终那个连通块就是完全图。</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210725214411.png" alt="image-20210725214411648"></p>
</blockquote>
<p>总结一下就是：</p>
<p>假设有两个连通块$A,B$，要扩展为完全图，那么就需要$A$中的每个节点都与$B$中的每个节点相连。对于一条最小生成树上的边$E$，可以看作$E$连接了$A$和$B$这两个连通块，那么要将$A$和$B$连接成一个完全图需要添加的边数就是$cnt[A]\times cnt[B]-1$，减去1就是减去已经存在的$E$这条边，其中$cnt[A]$表示连通块$A$中的节点数，$cnt[B]$表示连通块$B$中的节点数。设$E$的边权为$z$，由上图的可知，新增加的边权不可能$\leq z$，必须是$&gt;z$的。为了让增加的边权总和最小，则需要让新增加的边权为$z+1$就好了。</p>
<p>那么合并这两个连通块的花费就是$(z+1)\times(cnt[A]\times cnt[B]-1)$。设<code>ans</code>是答案，那么在每次合并连通块时，让$ans$累加上花费就好了。</p>
<p>还有一点，题目要求的是最小的完全图，因此采用贪心的策略：先把树上的边按权值从小到大排序，然后依次枚举即可。</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">6010</span>,M=N;</span><br><span class="line"><span class="comment">//n是点数  m是边数</span></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a,b,w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge&amp; W)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w&lt;W.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"><span class="keyword">int</span> cnt[N];     <span class="comment">//cnt[i]表示第i个连通块中点的数量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x!=p[x])</span><br><span class="line">        p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;  <span class="comment">//增加的边的权值总和最小值</span></span><br><span class="line">    <span class="built_in">sort</span>(edges,edges+m);    <span class="comment">//将边权从小到大排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i]=i;     <span class="comment">//初始化并查集  每个点都是独立的连通块</span></span><br><span class="line">        cnt[i]=<span class="number">1</span>;   <span class="comment">//由于每个点都是独立的连通块  所以每个连通块内只有1个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="built_in">find</span>(edges[i].a);</span><br><span class="line">        <span class="keyword">int</span> b=<span class="built_in">find</span>(edges[i].b);</span><br><span class="line">        <span class="keyword">int</span> w=edges[i].w;</span><br><span class="line">        <span class="keyword">if</span>(a!=b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//每次合并两个连通块都会产生(cnt[a]*cnt[b]-1)*(w+1)的开销</span></span><br><span class="line">            <span class="comment">//所以要让res累加这些开销</span></span><br><span class="line">            res+=(cnt[a]*cnt[b]<span class="number">-1</span>)*(w+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//将a这个连通块中所有点的数量都累加到b这个连通块中</span></span><br><span class="line">            cnt[b]+=cnt[a];</span><br><span class="line">            <span class="comment">//将集合a合并到集合b,现在a的祖宗节点是b</span></span><br><span class="line">            p[a]=b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="comment">//根据题目输入可以知道 有n个点 则有n-1条边</span></span><br><span class="line">        m=n<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//读入m条边的信息</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a,b,w;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;w);</span><br><span class="line">            edges[i]=&#123;a,b,w&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> t=<span class="built_in">Kruskal</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>最小生成树</category>
      </categories>
      <tags>
        <tag>最小生成树的扩展应用</tag>
      </tags>
  </entry>
  <entry>
    <title>局域网</title>
    <url>/2021/07/24/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/%E5%B1%80%E5%9F%9F%E7%BD%91/</url>
    <content><![CDATA[<h1 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210724120055.png" alt="image-20210724120055096"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>题意：给定一张有$n$个点，$k$条边的无向有环图，要求删掉其中部分边，且不改变图的连通性的情况下，使得最终的图仍然是连通的不存在环，并且删除的边权之和最大，输出最大的所删边边权权和。从题意我们可以发现：</p>
<p>删边权和最大$\implies$ 剩下边权和最小 $\implies$ 求最小生成树</p>
<p>但是题中并没有说图一定连通，这让这道题恶心了很多。也就是说，图中可能存在多棵树，这些树并不在同一个连通块中。假设有$A_1$，$A_2$，$A_3$这三颗树，它们都是独立的连通块，那么我们需要求出每树的最小生成树，不妨设为$x_1,x_2,x_3$，设这三棵树边权总和为$sum$，那么最终删除的边权之和最大为$sum-(x_1+x_2+x_3)$。</p>
<p>说到连通块，我们很容易想到Kruskal算法，它也是利用连通块思想来求解最小生成树。因此，这题我们可以采用Kruskal算法来求解，对于一棵树来说，如果两个点不在同一个集合中，则说明它是最小生成树中的边，那么就可以累加边权。如果两个点已经在一个集合中了，根据Kruskal算法思想，则不需要累加边权了。</p>
<p>当然这题也是可以用prim算法的。</p>
<p>下面给出一个有多棵树的栗子：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210724122230.png" alt="image-20210724122230651"></p>
<p>如图所示：</p>
<p>将所有边权从小到大排好序，初始化每个节点都是独立集合（独立的连通块），设$ans=0$</p>
<ul>
<li>对于树$A$，节点$1$和节点$2$起初都是独立的集合，那么可以使用并查集进行合并，因此需要累加边权，即$ans+=w$，也就是$ans=0+10=10$，此时树$A$就已经是一个连通块了</li>
<li>对于树$B$，由于$(3,4)$边权小，所有选择这条边，节点$3,4$起初都是独立的集合，那么可以使用并查集进行合并，更新节点$4$的祖宗节点为$3$，因此需要累加边权，即$ans+=w$，也就是$ans=10+11=21$，此时节点$3$和节点$4$就属于同一个连通块了。接着由于$(4,5)$边权小，所以选择这条边，经过上一步的操作后，此时$(3,4)$属于一个连通块，而$5$是独立的一个集合，因此$5$属于另一个连通块，那么可以使用并查集进行合并，更新节点$5$的祖宗节点为$3$，因此需要累加边权，即$ans+=w$，也就是$ans=21+12=33$，此时$(3,4,5)$已经在同一个连通块中了。最后选择$(3,5)$这条边，但是由于$(3,4,5)$已经在同一个连通块中了，所以此时$(3,5)$这条边并不需要累加权值。也就是说$(3,5)$这条边并不是最小生成树上的边。所以$ans$仍为$33$，树$B$的最小生成树的边有$(3,4)$和$(4,5)$</li>
<li>对于树$C$，由于$(7,6)$边权小，所以选择这条边，节点$7,6$起初都是独立的集合，那么可以使用并查集进行合并，更新节点$7$的祖宗节点为$6$，因此需要累加边权，即$ans+=w$，也就是$ans=33+14=47$，那么此时节点$7$和节点$6$就已经在同一个连通块中了。接着考虑$(6,7)$这条边，由于$(6,7)$已经在同一个连通块中了，所以这条边并不需要累加权值。也就是说$(6,7)$这条边并不是最小生成树上的边。所以$ans$仍为$47$，树$C$的最小生成树的边有$(7,6)$</li>
<li>由于这三颗树的边权总和为$sum=75$，而我们已经求出了这三棵树的最小生成树之和为$47$，那么需要删除的边的最大权值为$sum-res=75-47=28$，也就是图中的红色边</li>
</ul>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>写法1：Kruskal算法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">110</span>,M=<span class="number">210</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a,b,w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge&amp; W)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w&lt;W.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x!=p[x])</span><br><span class="line">        p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(edges,edges+m);    <span class="comment">//将边权从小到大排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   <span class="comment">//初始化每个点都是独立的集合</span></span><br><span class="line">        p[i]=i;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;      <span class="comment">//最小生成树的权值</span></span><br><span class="line">    <span class="comment">//由于边已经排好序了  所以这里是优先选择小的边</span></span><br><span class="line">    <span class="comment">//要注意这些边并不都是连通的  (存在多个非连通块)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="built_in">find</span>(edges[i].a);</span><br><span class="line">        <span class="keyword">int</span> b=<span class="built_in">find</span>(edges[i].b);</span><br><span class="line">        <span class="keyword">int</span> w=edges[i].w;</span><br><span class="line">        <span class="comment">//对于每个连通块来说,我们都只会在当两个节点的集合号不同时 才累加权值</span></span><br><span class="line">        <span class="comment">//因为Kruskal算法就是当合并两个集合时,才累加了边权,而如果已经在同一个连通块中了,那么就不会累加</span></span><br><span class="line">        <span class="keyword">if</span>(a!=b)</span><br><span class="line">        &#123;</span><br><span class="line">            p[a]=b;</span><br><span class="line">            <span class="comment">//只有不在同一集合时,才累加权值</span></span><br><span class="line">            res+=w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回最小生成树的权值</span></span><br><span class="line">    <span class="keyword">return</span> res;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;w);</span><br><span class="line">        edges[i]=&#123;a,b,w&#125;;</span><br><span class="line">        <span class="comment">//计算全部边权的总和</span></span><br><span class="line">        sum+=w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t=<span class="built_in">Kruskal</span>();</span><br><span class="line">    <span class="comment">//总和减去最小生成树,那么剩下的其实就是被除去网线的最大值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum-t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写法2：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">110</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="comment">//prim算法需要用到邻接矩阵</span></span><br><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="comment">//dist[i]表示节点i到集合S的距离</span></span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="comment">//st[i]=true表示节点i已经被加入了集合S中</span></span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="comment">//prim算法求解最小生成树</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span>(!st[j]&amp;&amp;(t==<span class="number">-1</span>||dist[t]&gt;dist[j]))</span><br><span class="line">                t=j;</span><br><span class="line">        <span class="keyword">if</span>(i&amp;&amp;dist[t]==INF)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(i)</span><br><span class="line">            res+=dist[t];</span><br><span class="line">        st[t]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">            dist[k]=<span class="built_in">min</span>(dist[k],g[t][k]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(g,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> g);    <span class="comment">//初始化邻接矩阵为正无穷</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">int</span> total;  <span class="comment">//记录输入的所有子树的权值总和</span></span><br><span class="line">    <span class="keyword">while</span>(k--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        <span class="comment">//防止重边和自环</span></span><br><span class="line">        g[a][b]=g[b][a]=<span class="built_in">min</span>(g[a][b],c);</span><br><span class="line">        <span class="comment">//算出整个森林的边权总和</span></span><br><span class="line">        total+=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//由于题目给定的树不一定都是连通的,也就是说可能存在多个互不连通的树,即存在多个连通块</span></span><br><span class="line">    <span class="comment">//依次求解每颗树中的最小生成树</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果还没有处理节点i所在的树,则去求解i所在的这颗树的最小生成树</span></span><br><span class="line">        <span class="keyword">if</span>(!st[i])</span><br><span class="line">            total-=<span class="built_in">prim</span>();  <span class="comment">//用总和减去每一颗树的最小生成树</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,total);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>最小生成树</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>繁忙的都市</title>
    <url>/2021/07/24/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/%E7%B9%81%E5%BF%99%E7%9A%84%E9%83%BD%E5%B8%82/</url>
    <content><![CDATA[<h1 id="繁忙的都市"><a href="#繁忙的都市" class="headerlink" title="繁忙的都市"></a>繁忙的都市</h1><hr>
<h3 id="繁忙的都市-1"><a href="#繁忙的都市-1" class="headerlink" title="繁忙的都市"></a>繁忙的都市</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210724132410.png" alt="image-20210724132410163"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>从题目中可以知道，$n$个交叉路口其实就是$n$个顶点，道路是双向的说明是无向边，把所有的交叉路口直接或间接的连通起来也就是说最终这$n$个节点是连通的，改造的那些道路中分值最大值尽量小也就是说选中的那些道路的边权应该尽可能小。从这些信息中可以知道，这不就是与最小生成树的含义类似嘛？其实题目也是想要求最小生成树中的那个最大边。</p>
<p>我们知道，对于Kruskal算法来说，它将所有边权从小到大排序，然后依次从边权小的开始选择，进行合并，形成一个连通块，最终就会得到一个含有$n-1$条边的连通块。由于选择边是从小到大进行选择的，因此最后选择的那条边一定是最小生成树中的最大边（注意原因就是因为Kruskal算法是贪心本质，每次贪心选择边权最小的）</p>
<p>因此，我们只需要跑以下Kruskal算法，然后每次选择边时，使用变量<code>res</code>来记录就好了，即$res=w$，那最后一次选择的那条边其实就是最小生成树中的最大边了。</p>
<p>当然这题也可以用prim算法来求解，也就是每次将节点加入$S$集合时，都进行$res=max(res,w)$，一直到所有节点都被加入了$S$集合中，那么最终得到的$res$就是最大的边。</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>写法1：Kruskal算法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">310</span>,M=<span class="number">8010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a,b,w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge &amp;W)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w&lt;W.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x!=p[x])</span><br><span class="line">        p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(edges,edges+m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        p[i]=i;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="built_in">find</span>(edges[i].a);</span><br><span class="line">        <span class="keyword">int</span> b=<span class="built_in">find</span>(edges[i].b);</span><br><span class="line">        <span class="keyword">int</span> w=edges[i].w;</span><br><span class="line">        <span class="keyword">if</span>(a!=b)</span><br><span class="line">        &#123;</span><br><span class="line">            p[a]=b;</span><br><span class="line">            <span class="comment">//由于Kruskal算法已经把边权从小到大排序了,因此最后选择的那个最小生成树中的边</span></span><br><span class="line">            <span class="comment">//一定是最大的了    当然也可以写成res=max(res,w);</span></span><br><span class="line">            res=w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最小生成树中含有n个点,那么一定有n-1条边 所以一定会选出n-1条边</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,n<span class="number">-1</span>,res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;w);</span><br><span class="line">        edges[i]=&#123;a,b,w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Kruskal</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>prim算法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">310</span>,M=<span class="number">8010</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span>(!st[j]&amp;&amp;(t==<span class="number">-1</span>||dist[t]&gt;dist[j]))</span><br><span class="line">                t=j;</span><br><span class="line">        <span class="comment">// if(i&amp;&amp;dist[t])</span></span><br><span class="line">        <span class="comment">//     return INF;</span></span><br><span class="line">        <span class="keyword">if</span>(i)</span><br><span class="line">            res=<span class="built_in">max</span>(res,dist[t]);</span><br><span class="line">        st[t]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">            dist[k]=<span class="built_in">min</span>(dist[k],g[t][k]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(g,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> g);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        g[a][b]=g[b][a]=<span class="built_in">min</span>(g[a][b],c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t=<span class="built_in">prim</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,n<span class="number">-1</span>,t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>最小生成树</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>联络员</title>
    <url>/2021/07/24/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/%E8%81%94%E7%BB%9C%E5%91%98/</url>
    <content><![CDATA[<h1 id="联络员"><a href="#联络员" class="headerlink" title="联络员"></a>联络员</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210724150001.png" alt="image-20210724150001282"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>管理员可以看作是节点，所有管理员两两之间需要直接或间接联络 这也就是说明所有顶点都必须连通，通信渠道都是 <strong>双向</strong> 的说明是无向边，题目想要求的是选择权值小的通信渠道，最终连通所有节点。这满足最小生成树的含义，因此可以使用最小生成树。</p>
<p>但是这道题有些特殊，有两种通道，必选与非必选。其实我们可以先处理那些必选边，将那些必选边都弄成连通块，然后把一个连通块看作是”节点“，最后把那些非必选边就看作是这些”节点“之间的连边。</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210724150540.png" alt="image-20210724150540626"></p>
<p>蓝色边表示必须边，绿色边是非必选边。把蓝色边所连通的节点，都看作是一个连通块。那么这该如何实现呢？其实这就是并查集的合并操作嘛，对蓝色边所在的节点都进行并查集操作，找到祖宗节点，然后让这个祖宗节点成为这个连通块的”代表节点“。那么新图就是有”代表节点“和非必选边，那么我们对这个新图求最小生成树即可。</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2010</span>,M=<span class="number">10010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a,b,w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge&amp; W)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w&lt;W.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x!=p[x])</span><br><span class="line">        p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//res表示最小的通信费用</span></span><br><span class="line">    <span class="comment">//k表示新图所含有的边数</span></span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>,k=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        p[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t,a,b,w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;t,&amp;a,&amp;b,&amp;w);</span><br><span class="line">        <span class="comment">//处理必选边</span></span><br><span class="line">        <span class="keyword">if</span>(t==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res+=w; <span class="comment">//累加必选边权值</span></span><br><span class="line">            <span class="comment">//对必选边的节点进行并查集操作  合并到一个集合中,形成连通块</span></span><br><span class="line">            <span class="comment">//祖宗节点当作这个连通块的&quot;代表节点&quot;</span></span><br><span class="line">            <span class="comment">//然后这些&quot;代表节点&quot;和非必选边构成了一个新图</span></span><br><span class="line">            p[<span class="built_in">find</span>(a)]=<span class="built_in">find</span>(b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理非必选边</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            edges[k++]=&#123;a,b,w&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(edges,edges+k);    <span class="comment">//将边权按从小到大排序</span></span><br><span class="line">    <span class="comment">//处理新图中的这k条边  求出最小生成树</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="built_in">find</span>(edges[i].a);</span><br><span class="line">        <span class="keyword">int</span> b=<span class="built_in">find</span>(edges[i].b);</span><br><span class="line">        <span class="keyword">int</span> w=edges[i].w;</span><br><span class="line">        <span class="keyword">if</span>(a!=b)</span><br><span class="line">        &#123;</span><br><span class="line">            p[a]=b;</span><br><span class="line">            res+=w; <span class="comment">//累加最小生成树的权值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>最小生成树</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>最短网络</title>
    <url>/2021/07/24/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/%E6%9C%80%E7%9F%AD%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="最短网络"><a href="#最短网络" class="headerlink" title="最短网络"></a>最短网络</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210724102626.png" alt="image-20210724102626788"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>从题意可知，农夫想要连接所有农场并且想要所使用的光纤最短。这其实就是想要求最小生成树，因为最小生成树一定包含所有节点（即所有农场），而且是连通的（连接所有农场），并且边权之和是最小的（所使用的光纤最短）。因此就是一道裸的最小生成树算法。</p>
<p>求解最小生成树有两种算法：prim算法和Kruskal算法。</p>
<ul>
<li>prim算法一般适用于稠密图，用邻接矩阵存储。而题目又说了对称矩阵，所以这题就可以用prim算法来求解</li>
<li>Kruskal算法一般适用于稀疏图，我们一般用结构体来存储</li>
</ul>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>写法1：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">110</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="comment">//prim算法比较适用于稠密图  稠密图可以用邻居矩阵来存储</span></span><br><span class="line"><span class="comment">//这里采用prim算法  所以用了邻居矩阵</span></span><br><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line"><span class="comment">//dist[i]表示节点i距离S集合的距离</span></span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="comment">//st[i]=true表示节点i已经被加入了S集合</span></span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="comment">//prim算法求最小生成树</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;  <span class="comment">//最小生成树的权值总和</span></span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);  <span class="comment">//距离初始化为无穷大</span></span><br><span class="line">    <span class="comment">//起点1号节点到自身距离为0</span></span><br><span class="line">    dist[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//最终得到的最小生成树中一定有n个节点</span></span><br><span class="line">    <span class="comment">//因此需要循环n次  每个把一个节点加入S集合中</span></span><br><span class="line">    <span class="comment">//最终都会把这n个节点加入S集合中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=<span class="number">-1</span>;   <span class="comment">//寻找不在S集合中,但是距离S集合最近的一个节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span>(!st[j]&amp;&amp;(t==<span class="number">-1</span>||dist[t]&gt;dist[j]))</span><br><span class="line">                t=j;</span><br><span class="line">        <span class="keyword">if</span>(dist[t]==INF)</span><br><span class="line">            <span class="keyword">return</span> INF;</span><br><span class="line">        res+=dist[t];   <span class="comment">//累加最小生成树的权值和</span></span><br><span class="line">        st[t]=<span class="literal">true</span>;   <span class="comment">//标记节点t已经被加入了S集合</span></span><br><span class="line">        <span class="comment">//遍历节点t的所有邻接点  通过t来更新这些邻接点到起点的距离</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">            <span class="keyword">if</span>(!st[k])</span><br><span class="line">                dist[k]=<span class="built_in">min</span>(dist[k],g[t][k]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="comment">//读入邻接矩阵</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;g[i][j]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">prim</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写法2：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">110</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span>(!st[j]&amp;&amp;(t==<span class="number">-1</span>||dist[t]&gt;dist[j]))</span><br><span class="line">                t=j;</span><br><span class="line">        <span class="keyword">if</span>(i&amp;&amp;dist[t]==INF)</span><br><span class="line">            <span class="keyword">return</span> INF;</span><br><span class="line">        <span class="keyword">if</span>(i)</span><br><span class="line">            res+=dist[t];</span><br><span class="line">        st[t]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">            dist[k]=<span class="built_in">min</span>(dist[k],g[t][k]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;g[i][j]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">prim</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>最小生成树</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>次小生成树</title>
    <url>/2021/07/28/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/%E6%AC%A1%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    <content><![CDATA[<h1 id="次小生成树"><a href="#次小生成树" class="headerlink" title="次小生成树"></a>次小生成树</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210728124557.png" alt="image-20210728124557605"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>这题其实与<a href="https://blog.csdn.net/qq_45832461/article/details/119118597">秘密的牛奶运输</a>是完全一样的，都是求解严格次小生成树。只不过在那一题中，我们是用$O(n^2)$的时间复杂度暴力求出了树中任意两点间的距离。但是我们知道LCA可以快速地求解出树中任意两点间的距离。因此，在这一题中，我们将使用LCA来进行优化。</p>
<p>如下图分析：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210728125115.png" alt="image-20210728125115083"></p>
<p>这一题对求解MST中任意两点之间的距离进行了优化处理，即上图中的暴力枚举，将时间复杂度从$O(n^2)$优化到了$O(n\times log(n))$，具体优化过程如下：</p>
<ul>
<li>我们使用$d1[i,j]$表示从节点$i$往上跳$2^j$步路径过程中的边权的最大值，即这个路径上最大边的权值；$d2[i,j]$表示从节点$i$往上跳$2^j$步路径过程中的边权的严格次大值，即这个路径上严格次大边的权值；在向上跳的过程中，记录每次跳跃时的最大值和次大值，那么最终整个路径中的最大值和次大值一定在这些记录的值中，从中求出即可。</li>
<li>那么该如何求解<code>d1[i][j]</code>和<code>d2[i][j]</code>呢？这里其实和求解<code>fa[][]</code>是类似的，可以在BFS的过程中递推求解，如下图：</li>
<li><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210728125743.png" alt="image-20210728125743885"></li>
</ul>
<p><strong>算法设计：</strong></p>
<ul>
<li>使用Kruskal算法求出最小生成树，算出权值总和为$sum$</li>
<li>将这棵最小生成树用图构建出来</li>
<li>在BFS过程中预处理<code>fa[][]</code>和求解出<code>d1[][]</code>和<code>d2[][]</code></li>
<li>依次枚举每条非树边$w$，将其加入树中，一定会形成环，去掉环中树边的最大值或者次大值得到另一棵树，这些树中权值最小的就是次小生成树。</li>
</ul>
<p><strong>注意点：</strong></p>
<ol>
<li>设树边为$w[i]$，非树边为$w$，那么次小生成树为$sum+w-w[i]$，我们设增量$\Delta=w-w[i]$，我们在LCA函数中求出了这个$w$（最大边或次大边），但是函数返回值的其实就是这个增量$\Delta$，而不是$w$，这点要注意哦</li>
<li>对于数组$fa,d1,d2$，由于题目给定最多1e5个点，由于$2^{16}&lt;1e5&lt;2^{17}$，如果第二维取16的话，则不能存储完1e5个点；如果第二维取17的话，虽然说多了，但是可以完全存储1(⊙﹏⊙)个点，因此第二维的大小应该是17，其二进制位是从0到16。</li>
<li>还有一点，题目中给定这个无向图的最大边数$M$是3e5，这是原图的最大边数。但是当我们对已经得到的最小生成树构建图时，由于树中的边是无向边，有$n$个顶点，那么有$n-1$条边，那么构建这个最小生成树的图时需要$2(n-1)$条边，不妨开大点就是$2\times n$条边，当$n$取最大为$N$时，则最多为$2\times N$条边。</li>
</ol>
<blockquote>
<p>问题：为什么跳到了最近公共祖先下一层时，最后只加了最大边$distance[cnt++]=d1[a][0]$，$distance[cnt++]=d1[b][0]$，而没有添加次小边$distance[cnt++]=d2[a][0]$，$distance[cnt++]=d2[b][0]$呢？</p>
<p>此时x和y距离他们的最近公共祖先只有一步了，也就是只有一条边了，显然只有它自身的权值作为最大距离，次大距离初始化为-INF了</p>
<p>但其实写上了也是可以的</p>
</blockquote>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">3e5</span>+<span class="number">10</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">int</span> n,m;    <span class="comment">//点数 边数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a,b,w;</span><br><span class="line">    <span class="keyword">bool</span> flag;  <span class="comment">//判断是否为树边(是否为最小生成树中的边)</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge&amp; W)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w&lt;W.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"><span class="comment">//这个邻接表是用来给最小生成树建图的</span></span><br><span class="line"><span class="keyword">int</span> h[N],e[<span class="number">2</span>*N],ne[<span class="number">2</span>*N],w[<span class="number">2</span>*N],idx;</span><br><span class="line"><span class="keyword">int</span> p[N];   <span class="comment">//并查集的集合数组</span></span><br><span class="line"><span class="keyword">int</span> depth[N];   <span class="comment">//节点的深度</span></span><br><span class="line"><span class="keyword">int</span> fa[N][<span class="number">17</span>],d1[N][<span class="number">17</span>],d2[N][<span class="number">17</span>];  <span class="comment">//d1是最大边 d2是次大边</span></span><br><span class="line"><span class="keyword">int</span> q[N];   <span class="comment">// bfs使用到的队列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    w[idx]=c;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x!=p[x])</span><br><span class="line">        p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Kruskal算法求出这棵最小生成树的权值总和</span></span><br><span class="line"><span class="function">LL <span class="title">Kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(edges,edges+m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        p[i]=i;</span><br><span class="line">    LL res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="built_in">find</span>(edges[i].a);</span><br><span class="line">        <span class="keyword">int</span> b=<span class="built_in">find</span>(edges[i].b);</span><br><span class="line">        <span class="keyword">int</span> w=edges[i].w;</span><br><span class="line">        <span class="keyword">if</span>(a!=b)</span><br><span class="line">        &#123;</span><br><span class="line">            p[a]=b;</span><br><span class="line">            res+=w;</span><br><span class="line">            edges[i].flag=<span class="literal">true</span>; <span class="comment">//标记i这条边是树边</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> res; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Kruskal算法只是求出了最小生成树的权值总和,但是并没有把这棵最小生成树构建出来</span></span><br><span class="line"><span class="comment">//这里是把这棵最小生成树构建成图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(edges[i].flag)<span class="comment">//如果是树边</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a=edges[i].a;</span><br><span class="line">            <span class="keyword">int</span> b=edges[i].b;</span><br><span class="line">            <span class="keyword">int</span> w=edges[i].w;</span><br><span class="line">            <span class="comment">//树中的边都是无向边</span></span><br><span class="line">            <span class="built_in">add</span>(a,b,w);</span><br><span class="line">            <span class="built_in">add</span>(b,a,w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//bfs预处理出fa[][]、d1[][]、d2[][]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> root)</span><span class="comment">//root是根节点  我们这里默认是1号点  其实任意一个点都可以作为根节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(depth,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> depth);</span><br><span class="line">    <span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// depth[0]=0是哨兵  depth[root]=1设置根节点的深度为1</span></span><br><span class="line">    depth[<span class="number">0</span>]=<span class="number">0</span>,depth[root]=<span class="number">1</span>;</span><br><span class="line">    q[<span class="number">0</span>]=root;  <span class="comment">//将根节点入队</span></span><br><span class="line">    <span class="comment">//进行广搜</span></span><br><span class="line">    <span class="keyword">while</span>(hh&lt;=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=q[hh++];  <span class="comment">//取出队头元素</span></span><br><span class="line">        <span class="comment">//遍历t的所有邻接点j</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i]; <span class="comment">//t的某个邻接点j</span></span><br><span class="line">            <span class="keyword">if</span>(depth[j]&gt;depth[t]+<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                depth[j]=depth[t]+<span class="number">1</span>;    <span class="comment">//更新j的深度</span></span><br><span class="line">                q[++tt]=j;  <span class="comment">//将j入队</span></span><br><span class="line">                fa[j][<span class="number">0</span>]=t; <span class="comment">//节点j向上走2^0步就是节点t</span></span><br><span class="line">                <span class="comment">//由于此时节点j到节点t之间只有一条边,那么最大边就是这条边的权值w[i],由于最大边&gt;次大边</span></span><br><span class="line">                <span class="comment">//因此如果只有一条边,那么次大边不存在  我们设置为负无穷</span></span><br><span class="line">                d1[j][<span class="number">0</span>]=w[i];</span><br><span class="line">                d2[j][<span class="number">0</span>]=-INF;</span><br><span class="line">                <span class="comment">//由于已经处理了2^0,那么接下来就是2^1,2^2,...,2^16</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">16</span>;k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> anc=fa[j][k<span class="number">-1</span>]; <span class="comment">//先从j跳2^&#123;k-1&#125;到了anc节点</span></span><br><span class="line">                    fa[j][k]=fa[anc][k<span class="number">-1</span>];  <span class="comment">//然后从anc节点跳2^&#123;k-1&#125;到了fa[j][k]节点</span></span><br><span class="line">                    <span class="comment">//distance数组存储的是从节点j跳2^k到达节点fa[j][k]过程中的最大边和次大边</span></span><br><span class="line">                    <span class="comment">//由于这个过程分为两段：</span></span><br><span class="line">                    <span class="comment">//  (1)从j到anc,这段中的最大边是d1[j][k-1],次大边是d2[j][k-1]</span></span><br><span class="line">                    <span class="comment">//  (2)从anc到fa[j][k],这段中的最大边是d1[anc][k-1],次大边是d2[anc][k-1]</span></span><br><span class="line">                    <span class="comment">//由于我们并不知道这两段中应该选择哪个最大边和次大边,因此我们可以先都存储起来</span></span><br><span class="line">                    <span class="keyword">int</span> distance[<span class="number">4</span>]=&#123;d1[j][k<span class="number">-1</span>],d2[j][k<span class="number">-1</span>],d1[anc][k<span class="number">-1</span>],d2[anc][k<span class="number">-1</span>]&#125;;</span><br><span class="line">                    <span class="comment">//刚开始初始化从j节点到fa[j][k]不可达,因此最大边和次大边都为负无穷</span></span><br><span class="line">                    d1[j][k]=d2[j][k]=-INF;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;<span class="number">4</span>;u++)<span class="comment">//遍历这四个  找到最大边和次大边</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">int</span> d=distance[u];</span><br><span class="line">                        <span class="comment">//如果新边d大于最小生成树中的最大边d1[j][k]  则直接用这个新边去替代这个最大边即可</span></span><br><span class="line">                        <span class="keyword">if</span>(d&gt;d1[j][k])</span><br><span class="line">                        &#123;</span><br><span class="line">                            d2[j][k]=d1[j][k];</span><br><span class="line">                            d1[j][k]=d;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//如果新边d小于最小生成树中的最大边d1[j][k],但是大于最小生成树中的次大边d2[j][k]</span></span><br><span class="line">                        <span class="comment">//那么可以用这个新边去替代这个次大边即可</span></span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(d&lt;d1[j][k]&amp;&amp;d&gt;d2[j][k])</span><br><span class="line">                            d2[j][k]=d;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//次小生成树权值为sum+w-w[i],w是新边,w[i]是最大边,这里LCA返回的是w-w[i]这个增量的值而不是返回w[i]</span></span><br><span class="line"><span class="function">LL <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//缓存数组 记录上跳过程中每段的最大值和次大值</span></span><br><span class="line">    <span class="comment">//由于每个点可能有最大边和次大边,因此数组要开2*N,而不是N</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> distance[<span class="number">2</span>*N];</span><br><span class="line">    <span class="keyword">if</span>(depth[a]&lt;depth[b])</span><br><span class="line">        <span class="built_in">swap</span>(a,b);</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;  <span class="comment">// 记录跳跃的次数，每跳一次，会记录两个数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">16</span>;k&gt;=<span class="number">0</span>;k--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(depth[fa[a][k]]&gt;=depth[b])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//记录节点a的最大边和次大边</span></span><br><span class="line">            distance[cnt++]=d1[a][k];</span><br><span class="line">            distance[cnt++]=d2[a][k];</span><br><span class="line">            a=fa[a][k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a!=b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">16</span>;k&gt;=<span class="number">0</span>;k--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(fa[a][k]!=fa[b][k])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//记录节点a和节点b的最大边和次大边</span></span><br><span class="line">                distance[cnt++]=d1[a][k];</span><br><span class="line">                distance[cnt++]=d2[a][k];</span><br><span class="line">                distance[cnt++]=d1[b][k];</span><br><span class="line">                distance[cnt++]=d2[b][k];</span><br><span class="line">                a=fa[a][k];</span><br><span class="line">                b=fa[b][k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//到这里,说明已经跳到了最大公共祖先的下一层,那么此时只需要再向上跳一步就可以到达了LCA</span></span><br><span class="line">        distance[cnt++]=d1[a][<span class="number">0</span>];</span><br><span class="line">        distance[cnt++]=d1[b][<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//下面的这个写上也是可以的</span></span><br><span class="line">        <span class="comment">// distance[cnt++]=d2[a][0];</span></span><br><span class="line">        <span class="comment">// distance[cnt++]=d2[b][0]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> dist1=-INF,dist2=INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> d=distance[i];</span><br><span class="line">        <span class="keyword">if</span>(d&gt;dist1)</span><br><span class="line">        &#123;</span><br><span class="line">            dist2=dist1;</span><br><span class="line">            dist1=d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(d&lt;dist1&amp;&amp;d&gt;dist2)</span><br><span class="line">            dist2=d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(w&gt;dist1)</span><br><span class="line">        <span class="keyword">return</span> w-dist1;</span><br><span class="line">    <span class="keyword">if</span>(w&gt;dist2)</span><br><span class="line">        <span class="keyword">return</span> w-dist2;</span><br><span class="line">    <span class="keyword">return</span> INF; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> root=<span class="number">1</span>; <span class="comment">//根节点  我们选择1号节点</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)<span class="comment">//读入m条边的信息</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;w);</span><br><span class="line">        edges[i]=&#123;a,b,w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    LL sum=<span class="built_in">Kruskal</span>();   <span class="comment">//求出这棵最小生成树的权值总和</span></span><br><span class="line">    <span class="comment">//这里是把这棵最小生成树构建成图</span></span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    <span class="built_in">bfs</span>(root);</span><br><span class="line">    LL res=<span class="number">1e18</span>;</span><br><span class="line">    <span class="comment">//枚举将每一条非树边去替代最小生成树中的最大边或次大边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!edges[i].flag)<span class="comment">//非树边</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a=edges[i].a;</span><br><span class="line">            <span class="keyword">int</span> b=edges[i].b;</span><br><span class="line">            <span class="keyword">int</span> w=edges[i].w;</span><br><span class="line">            <span class="comment">//有x条非树边,则会有x个res值,这里取最小的那个,那么就是次小生成树的权值总和了</span></span><br><span class="line">            res=<span class="built_in">min</span>(res,sum+<span class="built_in">LCA</span>(a,b,w));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>最近公共祖先</category>
      </categories>
      <tags>
        <tag>LCA+次小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>连接格点</title>
    <url>/2021/07/24/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/%E8%BF%9E%E6%8E%A5%E6%A0%BC%E7%82%B9/</url>
    <content><![CDATA[<h1 id="连接格点"><a href="#连接格点" class="headerlink" title="连接格点"></a>连接格点</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210724180555.png" alt="image-20210724180555744"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>通过阅读题目，设有$n$行$m$列，那么总共有$n\times m$个点，就相当于图中有$n\times m$个顶点。然后想用一些边，来使得所有顶点都能够连通，并且这些边权之和最小。那么这与最小生成树的含义是相同的。因此，透过题意我们知道其实就是想要求最小生成树。</p>
<p>但是题目还是有点特殊的，一条纵向的连线花费一个单位，一条横向的连线花费两个单位，也就是说边权只能是1或者2，而且某些点之间已经有连线了，也就是说有些顶点已经有边连接起来了。</p>
<p>我们将已有连线的这些点所形成的各个连通块都分别看作是一个个”新的节点”，设有x个”新的节点”，现在需要用 边 来连接这x个”新的节点”，并且使得所用边的权值总和最小。有x个”新的节点”,那么就需要x-1条边才能来连通,因为竖边的花费少,所以就先尽量用竖边,然后剩下的用横边,也就是贪心。</p>
<p>由于有连通块和并查集，因此我们使用Kruskal算法来求解最小生成树。但是我们这里并不对所有边排序。因为：有$n\times(m-1)$条横边，有$m\times(n-1)$条竖边，因此最多有$n\times(m-1)+m\times(n-1)=2nm-n-m$，$n$和$m$最坏取到$1000$，所以最多有$2\times1000\times1000-1000-1000=1998000$，约两百万条边。如果给这两百万条边排序的话，时间其实也是可以的，但是这里提供一种更加优化的方法：</p>
<p>由于Kruskal算法是排序后，优先选择边权小的那些边，然后再选择边权大的那些边。那么我们这里这么做：</p>
<p>优先挑选了边权为1的边作为最小生成树中的边,然后再挑选边权为2的边作为最小生成树中的边，可以发现这种做法中选边也是按边权从小到大进行，这其实就等效于排序了。</p>
<p>因此，我们只需要先尽量选择那些边权为1的竖边来建图，然后再选择那些边权为2的横边来建图，那么就可以不需要排序了，这样就省去了给所有边排序的时间。</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 在求解MST的过程之中，我们首先连好竖向的边，然后再连横向边.我们通过并差集解决这个问题.</span></span><br><span class="line"><span class="comment"> * 我们将已有连线的这些点所形成的各个连通块都分别看作是一个个&quot;新的节点&quot;,设有x个&quot;新的节点&quot;</span></span><br><span class="line"><span class="comment"> * 现在需要用 边 来连接这x个&quot;新的节点&quot;,并且使得所用边的权值总和最小</span></span><br><span class="line"><span class="comment"> * 有x个&quot;新的节点&quot;,那么就需要x-1条边才能来连通,因为竖边的花费少,所以就先尽量用竖边,然后剩下的用横边,也就是贪心</span></span><br><span class="line"><span class="comment"> * 过程分三个阶段:</span></span><br><span class="line"><span class="comment"> *      (1)先将已经连好的边加入并差集</span></span><br><span class="line"><span class="comment"> *      (2)然后是枚举所有竖向相邻的点</span></span><br><span class="line"><span class="comment"> *      (3)最后是横向相连的点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//N是点的数量  M的边的数量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> A=<span class="number">1010</span>,N=A*A,M=<span class="number">2</span>*A*A;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"><span class="comment">//将二维坐标转换成一维编号</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x<span class="number">-1</span>)*m+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x!=p[x])</span><br><span class="line">        p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n*m;i++)</span><br><span class="line">        p[i]=i;</span><br><span class="line">    <span class="keyword">int</span> x1,y1,x2,y2;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="built_in">get</span>(x1,y1);</span><br><span class="line">        <span class="keyword">int</span> b=<span class="built_in">get</span>(x2,y2);</span><br><span class="line">        p[<span class="built_in">find</span>(a)]=<span class="built_in">find</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里进行Kruskal算法时 为什么不需要对边排序呢？</span></span><br><span class="line">    <span class="comment">//因为我们是优先挑选了边权为1的边作为最小生成树中的边,然后再挑选边权为2的边作为最小生成树中的边</span></span><br><span class="line">    <span class="comment">//因此其实就相当于对边权排序了,因为Kruskal算法也是按边权从小到大先选择边权小的边,然后再选择边权大的边</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//先处理边权为1的竖边</span></span><br><span class="line">    <span class="comment">//这里不能写成i&lt;=n   因为我们用到了i+1 因此当i=n时,i+1就是n+1了,就会越界</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//a和b这上下两个点就构成了一条竖边</span></span><br><span class="line">            <span class="keyword">int</span> a=<span class="built_in">get</span>(i,j);</span><br><span class="line">            <span class="keyword">int</span> b=<span class="built_in">get</span>(i+<span class="number">1</span>,j);</span><br><span class="line">            <span class="keyword">int</span> pa=<span class="built_in">find</span>(a);</span><br><span class="line">            <span class="keyword">int</span> pb=<span class="built_in">find</span>(b);</span><br><span class="line">            <span class="keyword">if</span>(pa!=pb)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//累加边权为1的竖边</span></span><br><span class="line">                res+=<span class="number">1</span>;</span><br><span class="line">                p[pa]=pb;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//再处理边权为2的横边</span></span><br><span class="line">    <span class="comment">//这里不能写成j&lt;=m   因为我们用到了j+1 因此当j=m时,j+1就是m+1了,就会越界</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//a和b这左右两个点就构成了一条横边</span></span><br><span class="line">            <span class="keyword">int</span> a=<span class="built_in">get</span>(i,j);</span><br><span class="line">            <span class="keyword">int</span> b=<span class="built_in">get</span>(i,j+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> pa=<span class="built_in">find</span>(a);</span><br><span class="line">            <span class="keyword">int</span> pb=<span class="built_in">find</span>(b);</span><br><span class="line">            <span class="keyword">if</span>(pa!=pb)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//累加边权为2的横边</span></span><br><span class="line">                res+=<span class="number">2</span>;</span><br><span class="line">                p[pa]=pb;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>最小生成树</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>祖孙询问</title>
    <url>/2021/07/21/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/%E7%A5%96%E5%AD%99%E8%AF%A2%E9%97%AE/</url>
    <content><![CDATA[<h1 id="祖孙询问"><a href="#祖孙询问" class="headerlink" title="祖孙询问"></a>祖孙询问</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210721211507.png" alt="image-20210721211507323"></p>
<hr>
<h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p>最近公共祖先（LCA）是指有根树中距离两个节点最近的公共祖先。祖先是指从当前节点到树根路径上的所有节点。</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210721211850.png" alt="image-20210721211850774"></p>
<p>$u$和$v$的公共祖先是指一个节点它既是$u$的祖先，又是$v$的祖先。$u$和$v$的最近公共祖先是指距离$u$和$v$最近的祖先。如果$v$是$u$的祖先，那么$u$和$v$的最近公共祖先就是$v$。</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210721212059.png" alt="image-20210721212059201"></p>
<p>我们可以使用LCA来求解树上任意两点之间的距离。求$u$和$v$这两个之间的距离时，设为$L$，如果$u$和$v$的最近公共祖先为lca，则$u$和$v$之间的距离为$u$到树根的距离$dist[u]$加上$v$到树根的距离$dist[v]$再减去2倍的lca到树根的距离$2\times dist[lca]$。即有：$L=dist[u]+dist[v]-2\times dist[lca]$。</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210721212512.png" alt="image-20210721212511915"></p>
<p>从图中可以看出$u$到lca的距离加上$v$到lca的距离，其实就是我们想要求的$u$和$v$之间的距离。设$u$到lca的距离$L_1$，设$v$到lca的距离为$L_2$。可知：$dist[u]=L_1+dist[lca]$，所以$L_1=dist[u]-dist[lca]$；$dist[v]=L_2+dist[lca]$，所以$L_2=dist[v]-dist[lca]$。所以$L=L_1+L_2=dist[u]-dist[lca]+dist[v]-dist[lca]=dist[u]+dist[v]-2\times dist[lca]$</p>
<h4 id="树上倍增法"><a href="#树上倍增法" class="headerlink" title="树上倍增法"></a>树上倍增法</h4><p><code>F[i,j]</code>表示$i$的$2^j$辈祖先，即$i$节点向根节点走$2^j$步所到达的那个节点。</p>
<p>$u$节点向上走$2^0$步，则为$u$的父节点$x$，$F[u,0]=x$；$u$节点向上走$2^1$步，到达节点$y$，$F[u,1]=y$；$u$节点向上走$2^2$步，到达节点$z$，$F[u,2]=z$；$u$节点向上走$2^3$步，节点不存在，$F[u,3]=0$；</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210721213504.png" alt="image-20210721213503867"></p>
<p><code>F[i,j]</code>表示$i$的$2^j$辈祖先，即$i$节点向根节点走$2^j$步所到达的那个节点。那么该如何走到$F[i,j]$这个节点呢？可以分为两个步骤：</p>
<ul>
<li>$i$节点先向根节点走$2^{j-1}$步得到$F[i,j-1]$</li>
<li>然后再从$F[i,j-1]$这个节点出发向根节点走$2^{j-1}$步，得到<code>F[F[i,j-1],j-1]</code>，那么此时走到的节点即为$F[i,j-1]$</li>
</ul>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210721213844.png" alt="image-20210721213844186"></p>
<p>递推公式：<code>F[i,j]=F[F[i][j-1],j-1]</code>，$i=1,2,\cdots,n$，$j=0,,1,2,\cdots,k$，$2^k\leq n$，$k=logn$</p>
<p><strong>树上倍增法的两个关键步骤</strong>：</p>
<ol>
<li>先将两个点跳到同一层</li>
<li>让两个点同时向上跳，一直跳到它们的<strong>最近公共祖先的下一层</strong>为止</li>
</ol>
<p>也就是说先让深度大的$y$向上走到与$x$处于同一深度，然后$x,y$一起向上走。但是这里是按照倍增思想走的，而不是一步一步往上走的，因此速度比较快。</p>
<p>现在来思考两个问题：</p>
<ul>
<li>怎么让深度大的$y$向上走与$x$处于同一深度呢？</li>
<li>$x$和$y$一起向上走，怎么找到最近的公共祖先呢？</li>
</ul>
<p>先来解决第一个问题：怎么让深度大的$y$向上走与$x$处于同一深度呢？</p>
<p>假设$y$的深度比$x$的深度大，需要$y$向上走到与$x$处于同一深度，$k=3$，则求解过程如下：</p>
<ul>
<li>$y$向上走$2^3$步，如果此时到达节点的深度比$x$的深度小（说明跳的太远了，跳到了$x$的上面了），那么什么也不做</li>
<li>减小增量，$y$向上走$2^2$步，如果此时到达节点的深度比$x$的深度大（说明此时还处于$x$的下面），则$y$向上移动，令$y=F[y][2]$</li>
<li>减小增量，$y$向上走$2^1$步，如果此时到达节点的深度比$x$的深度相等（说明此时它俩处于同一深度），则$y$向上移动，令$y=F[y][1]$</li>
<li>减小增量，$y$向上走$2^0$步，如果此时到达节点的深度比$x$的深度小，那么什么也不做。由于上一次$y$已经与$x$处于同一深度了，而这次啥也没做，因此$y$仍然与$x$处于同一深度。</li>
</ul>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210721215346.png" alt="image-20210721215345942"></p>
<p>总结：</p>
<p>按照增量递减的方式，如果到达节点的深度比$x$的深度还要小，则什么也不做；如果到达节点的深度$\geq x$的深度时，则$y$向上移动，令$y=F[y][2]$，一直循环到增量为0，那么最后一定会有$x$和$y$处于同一深度。</p>
<p>再来解决第二个问题：$x$和$y$一起向上走，怎么找到最近的公共祖先呢？</p>
<p>假设$x,y$已经处于同一深度了，现在一起向上走，$k=3$，则其求解过程如下：</p>
<ul>
<li>$x$和$y$同时向上走$2^3$步，如果到达的节点相同，说明是公共祖先节点，但是不能保证是最近公共祖先，于是什么也不做</li>
<li>减少增量，$x,y$同时向上走$2^2$步，如果此时到达的节点不相同，则说明肯定不是最近公共祖先节点，那么此时$x,y$都要向上移动，令$x=F[x][2]$，$y=F[y][2]$</li>
<li><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210721220405.png" alt="image-20210721220404938"></li>
<li>减少增量，$x,y$同时向上走$2^1$步，如果此时到达的节点不同，那么此时$x,y$都要向上移动，令$x=F[x][1]$，$y=F[y][1]$</li>
<li>减少增量，$x$和$y$同时向上走$2^0$步，如果到达的节点相同，什么也不做</li>
<li>因此经过这么做，那么最终我们一定让$x,y$都处于它俩的最近公共祖先的下一层了。此时$x,y$的父节点就是最近公共祖先节点了，那么最终只需要$x$或者$y$向上走一步就可以到达最近公共祖先了。即最终的$F[x][0]$或者$F[y][0]$就是答案</li>
<li><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210721220600.png" alt="image-20210721220600144"></li>
</ul>
<p>完整的求解过程如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210721220655.png" alt="image-20210721220655472"></p>
<p>总结：按照增量递减的方式，如果到达的节点相同时，说明是公共祖先，但是不能保证就是最近公共祖先节点，所以什么也不做；如果到达的节点不相同，那么$x,y$同时往上走，一直到增量为0。此时$x,y$的父节点就是最近公共祖先节点了。</p>
<blockquote>
<p>问题：为什么碰到$F[x][k]==F[y][k]$时什么都不做，而且为什么此时就是公共祖先而不能是最近公共祖先呢？</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210722134122.png" alt="image-20210722134122538"></p>
<p>增量从大到小逐渐递减，设$k=2$，那么$F[x][2]=F[y][2]=0$，但是很明显，此时的$0$号节点只是它俩的公共祖先而已，此时我们啥也不做，也就是说$x$和$y$仍然原地踏步，并没有发生跳跃；然后$k$–，此时$k=1$，那么$F[x][1]=F[y][1]=2$，但是很明显，此时的$2$号节点只是它俩的公共祖先而已，此时我们啥也不做，也就是说$x$和$y$仍然原地踏步，并没有发生跳跃；然后$k$–，此时$k=0$，那么$F[x][0]=F[y][0]=4$，注意此时我们可以直观地看出来$4$是它俩的最近公共祖先，但是由于$F[x][0]=F[y][0]$，因此我们也是什么也不做，也就是说$x$和$y$仍然原地踏步，并没有发生跳跃；然后$k$–，此时$k$为-1，退出循环了。那么，我们发现$x$和$y$确实就是在最近公共祖先的下一层！所以最后$x$或者$y$再向上跳一步就到了最近公共祖先节点了，即$F[x][0]$或者$F[y][0]$就是答案了。</p>
</blockquote>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>主要就是利用树上倍增法来求解$LCA$，</p>
<p>这里最多有$N=40000$个节点，那么$2^k\leq40000$，所以$k\leq16$。也就是说我们要给这个<code>F[N][]</code>数组的第二维开的大小应该是$16$，即有$16$位二进制。</p>
<p>还有就是我们用$depth[0]=0$来当作哨兵，它有什么用处呢？假设从$i$开始跳$2^j$步，那么有可能此时已经跳出了整棵树的根节点，那么<code>fa[fa[j][k-1]][k-1]=0</code>，那么到达的那个虚无节点$fa[i][j]=0$，于是$depth[fa[i][j]]=depth[0]=0$。</p>
<blockquote>
<p>如何理解处理超过根节点呢？</p>
<p>举个栗子：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210722140317.png" alt="image-20210722140317627"></p>
<p>因为我们没有对根节点$fa[1][0]$赋值，所以它使用的是全局变量，于是$fa[1][0]=0$。可以知道，$fa[2][0]=1$。假设从$2$节点跳了$2^1$步，那么就会跳出根节点，此时的处理是这样的：$fa[2][1]=fa[fa[2][0]][0]=fa[1][0]=0$，那么$depth[fa[1][0]=depth[0]$，但是此时$depth[0]$还没有定义，那么我们可以给它定义为0，此时就可以表示跳出了根节点了。</p>
</blockquote>
<p>还有个细节要注意，我们是让深度更大的先往上跳到与深度较小的节点处于同一层。我们不妨假设$a$是深度较大的，$b$是深度较小的，那么如果$depth(a)&lt;depth(b)$，则交换，也就是说必须保证$a$的深度是$\geq b$的深度，然后对$a$往上跳。</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//对于树来说 有n个顶点 则有n-1条边  </span></span><br><span class="line"><span class="comment">//由于题目说了是无向边,所以最多有2(n-1)条边</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">40010</span>,M=N*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="comment">//记录每个节点的在树中的深度</span></span><br><span class="line"><span class="keyword">int</span> depth[N];</span><br><span class="line"><span class="comment">//fa[i][j]表示从i节点出发跳2^j步后所到达的节点</span></span><br><span class="line"><span class="keyword">int</span> fa[N][<span class="number">16</span>];</span><br><span class="line"><span class="comment">//宽搜的队列</span></span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//采用bfs,在构建这棵有根树的过程中,预处理出fa[i][j],预处理的时间复杂度是nlogn</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化深度为无穷大</span></span><br><span class="line">    <span class="built_in">memset</span>(depth,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> depth);</span><br><span class="line">    <span class="comment">//由于已知了q[0]是根节点  所以这里直接让tt=0了</span></span><br><span class="line">    <span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>]=root;</span><br><span class="line">    <span class="comment">//哨兵 如果跳超过了根节点,那么就设那些超过根节点的虚无节点的深度为0</span></span><br><span class="line">    depth[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//根节点的深度为1</span></span><br><span class="line">    depth[root]=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//进行宽搜</span></span><br><span class="line">    <span class="keyword">while</span>(hh&lt;=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=q[hh++];<span class="comment">//取出队头元素</span></span><br><span class="line">        <span class="comment">//遍历t的所有邻接点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];<span class="comment">//取出t的邻接点j</span></span><br><span class="line">            <span class="comment">//说明j还没有倍搜索过</span></span><br><span class="line">            <span class="keyword">if</span>(depth[j]&gt;depth[t]+<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//更新顶点j的深度</span></span><br><span class="line">                depth[j]=depth[t]+<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//将j加入队列中</span></span><br><span class="line">                q[++tt]=j;</span><br><span class="line">                <span class="comment">//由于赋值后depth[j]=depth[t]+1 说明j的深度大于t的深度</span></span><br><span class="line">                <span class="comment">//那么从j出发跳2^0步后,到达的节点就是t</span></span><br><span class="line">                fa[j][<span class="number">0</span>]=t;</span><br><span class="line">                <span class="comment">//上面已经处理了从j出发跳2^0步了</span></span><br><span class="line">                <span class="comment">//这里是处理从j出发跳2^1,2^2,...,2^15步所能到达的节点</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">15</span>;k++)</span><br><span class="line">                    fa[j][k]=fa[fa[j][k<span class="number">-1</span>]][k<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树上倍增法求出顶点a和顶点b的最近公共祖先</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//约定顶点a的深度必须&gt;=顶点b的深度,否则就要交换</span></span><br><span class="line">    <span class="keyword">if</span>(depth[a]&lt;depth[b])</span><br><span class="line">        <span class="built_in">swap</span>(a,b);</span><br><span class="line">    <span class="comment">//让深度较大的顶点a先往上跳到与深度较小的顶点b处于同一层(有可能a跳到了b身上)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">15</span>;k&gt;=<span class="number">0</span>;k--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=fa[a][k];</span><br><span class="line">        <span class="comment">//此时跳到了tmp这个节点 如果这节点的深度&gt;=顶点b的深度</span></span><br><span class="line">        <span class="comment">//说明tmp这个节点还没有跳超过顶点b这一层   那么则让a跳到tmp这个节点</span></span><br><span class="line">        <span class="keyword">if</span>(depth[tmp]&gt;=depth[b])</span><br><span class="line">            a=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里说明a跳到了b身上 此时两个重合 最近公共祖先就是a或者b</span></span><br><span class="line">    <span class="keyword">if</span>(a==b)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="comment">//如果能到这里,就说明a跳到了与b处于同一层</span></span><br><span class="line">    <span class="comment">//那么此时让a和b同时往上跳</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">15</span>;k&gt;=<span class="number">0</span>;k--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//说明它俩跳到的顶点不相同,那么不是公共祖先,则必然不可能是LCA</span></span><br><span class="line">        <span class="keyword">if</span>(fa[a][k]!=fa[b][k])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//让a跳到fa[a][k]这个顶点</span></span><br><span class="line">            a=fa[a][k];</span><br><span class="line">            <span class="comment">//让b跳到fa[b][k]这个顶点</span></span><br><span class="line">            b=fa[b][k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//退出循环后,a和b一定是跳到了它俩的最近公共祖先节点的下一层</span></span><br><span class="line">    <span class="comment">//那么此时它俩再向上跳2^0=1步就可以找到LCA了</span></span><br><span class="line">    <span class="comment">//因此最终返回 fa[a][0] 或者 fa[b][0]  都是可以的</span></span><br><span class="line">    <span class="keyword">return</span> fa[a][<span class="number">0</span>];      </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="comment">//整棵树的根节点</span></span><br><span class="line">    <span class="keyword">int</span> root=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="comment">//根据题目意思,如果b为-1,那么a就是整棵树的根节点</span></span><br><span class="line">        <span class="keyword">if</span>(b==<span class="number">-1</span>)</span><br><span class="line">            root=a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//建立无向边</span></span><br><span class="line">            <span class="built_in">add</span>(a,b);</span><br><span class="line">            <span class="built_in">add</span>(b,a);</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在构建这棵有根树的过程中,预处理出fa[i][j]</span></span><br><span class="line">    <span class="built_in">bfs</span>(root);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">    <span class="comment">//处理m个询问</span></span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="comment">//找到顶点a和顶点b的最近公共祖先</span></span><br><span class="line">        <span class="keyword">int</span> p=<span class="built_in">LCA</span>(a,b);</span><br><span class="line">        <span class="comment">//如果a是它俩的最近公共祖先</span></span><br><span class="line">        <span class="keyword">if</span>(p==a)</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="comment">//如果b是它俩的最近公共祖先    </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p==b)</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>最近公共祖先</category>
      </categories>
      <tags>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title>距离</title>
    <url>/2021/07/22/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/%E8%B7%9D%E7%A6%BB/</url>
    <content><![CDATA[<h1 id="距离"><a href="#距离" class="headerlink" title="距离"></a>距离</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210722165410.png" alt="image-20210722165410424"></p>
<hr>
<h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><h4 id="tarjan算法"><a href="#tarjan算法" class="headerlink" title="tarjan算法"></a>tarjan算法</h4><p>由于tarjan发明了很多算法，特别是在图论领域，因此很多算法都直接被称为了tarjan算法，需要注意区分的是，这里的tarjan算法是用来解决LCA问题的离线算法。</p>
<p>所谓的<strong>在线做法</strong>和<strong>离线做法</strong>都是针对有<strong>询问</strong>这种类型的题目。</p>
<ul>
<li>在线算法：每读入一个询问，都需要运行一次程序立即得到本次查询的答案。若一次查询需要$O(logn)$，则$m$次查询需要$O(mlogn)$</li>
<li>离线算法：读入所有询问，然后运行一次程序就可以得到所有查询的答案。</li>
</ul>
<p>tarjan算法利用并查集优越的时空复杂性，可以在$O(n+m)$时间内解决LCA问题。</p>
<blockquote>
<p>问题：为什么tarjan算法利用并查集就可以求出LCA呢？</p>
<p>如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210722170818.png" alt="image-20210722170818667"></p>
<p>从图中可以看出，节点$u$与子树$A$中的节点，它俩的最近公共祖先是根节点$root$，而且我们发现一个很强的性质就是：子树$A$中的每个节点的祖宗节点刚好就是$root$；节点$u$与子树$B$中的每个节点，它俩最近公共祖先是那个被涂色的节点，而这个节点LCA刚好就是节点子树$B$中每个节点的祖宗节点，也就是说$v$节点的祖宗节点是那个被涂色节点，而 从图中易知$u$和$v$的最近公共祖先恰好就是那个被涂色的节点。</p>
<p>因此，当我们遍历完$u$时，查询有关$u$的询问，比如$v$，然后使用并查集找到节点$v$的集合号，那么就是$u$和$v$的最近公共祖先LCA了。</p>
</blockquote>
<p>下面是tarjan算法求解LCA的过程：</p>
<ul>
<li>初始化集合号数组和访问数组，即<code>fa[i]=i</code>，<code>vis[i]=0</code>，这里$vis[i]=0$表示$i$这个节点还没有被访问过，$vis[i]=1$表示$i$这个节点已经被访问过了</li>
<li>从节点$u$出发进行深度优先遍历，标记$vis[u]=1$，深搜$u$所有还未被访问的邻接点，在遍历的过程中更新距离，回退时更新节点的集合号（祖宗节点）</li>
<li>当节点$u$的所有邻接点全部遍历完毕时，检查关于$u$的所有询问，若存在一个查询$u,v$，并且$vis[v]=1$，那么就利用并查集查找节点$v$的集合号，找到它的祖宗节点，那么这个祖宗节点就是$u$和$v$的最近公共祖先节点。</li>
</ul>
<p>举个栗子：</p>
<p>在树中求$5、6$的最近公共祖先，求解过程如下：</p>
<p>【1】初始化所有节点的集合号等于自己，访问数组都设置为还没有被访问过，即$fa[i]=i$，$vis[i]=0$</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210722180943.png" alt="image-20210722180942823"></p>
<p>【2】随意选择一个节点进行深搜，这里选择从根节点开始深度优先遍历，在遍历的过程中，将访问过的节点都设置为$vis[i]=1$</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210722181052.png" alt="image-20210722181051956"></p>
<p>【3】$8$号节点的所有邻接点都已经访问完毕了，没有与$8$相关的查询，则回退到$6$，更新$fa[8]=6$</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210722181120.png" alt="image-20210722181120440"></p>
<p>【4】遍历$6$号节点的下一个邻接点$9$，标记$vis[9]=1$，$9$号节点的所有邻接点都已经访问完毕了，没有与$9$相关的查询，则回退到$6$，更新$fa[9]=6$</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210722181141.png" alt="image-20210722181141114"></p>
<p>【5】$6$号节点的所有邻接点都已经访问完毕了，有与$6$相关的查询（查询$5$和$6$），但是由于此时$vis[5]\neq1$，并不满足$vis[u]=1$并且$vis[v]=1$（这里$u=6,v=5$），所以啥也不做，然后回退到$4$，更新$fa[6]=4$</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210722181335.png" alt="image-20210722181334949"></p>
<p>【6】$4$号节点的所有邻接点都已经访问完毕了，没有与$4$相关的查询，回退到$2$，更新$fa[4]=2$</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210722181412.png" alt="image-20210722181412378"></p>
<p>【7】遍历$2$号节点的下一个邻接点$5$，标记$vis[5]=1$，继续深度优先遍历到$7$，标记$vis[7]=1$，$7$号节点的所有邻接点都已经访问完毕了，没有与$7$相关的查询，回退到$5$，更新$fa[7]=5$</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210722181422.png" alt="image-20210722181421905"></p>
<p>【8】$5$号节点的所有邻接点都已经访问完毕了，有与$5$相关的查询（查询$5$和$6$），并且$vis[6]=1$，满足$vis[u]=1$并且$vis[v]=1$（这里$u=5,v=6$），那么就需要执行并查集，找到节点$v$的集合号。回退到$2$，更新$fa[5]=2$。设找到节点$v$的祖宗为$x$，那么$x$就是节点$u$和节点$v$的最近公共祖先</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210722181530.png" alt="image-20210722181530072"></p>
<p>【9】从$6$号节点开始利用并查集查找祖宗的过程如下：首先判断$6$的集合号$fa[6]=4$，找到$4$的集合号$fa[4]=2$，找到$2$的集合号$fa[2]=2$，所以找到祖宗（集合号为其自身）后返回，在回溯过程中更新祖宗到当前节点路径上所有节点的集合号，即更新$6、4$的父节点为$fa[4]=2$，$fa[6]=2$。那么此时$fa[6]=2$，即$2$号节点就是$5$号节点和$6$号节点的最近公共祖先</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210722181540.png" alt="image-20210722181540652"></p>
<p><strong>总结：</strong></p>
<p>在当前节点$u$的所有邻接点都已经访问完毕时，检查与$u$相关的查询$v$，注意此时$vis[u]$已经是1了，如果$vis[v]\neq1$，那么什么也不做；如果$vis[v]=1$，则利用并查集查找$v$的祖宗节点。最终$LCA(u,v)=fa[v]$。实际上，$u$的祖宗就是$u$向上查找第1个邻接点未访问完的节点，因为它的$fa[]$还没有更新，仍满足$fa[i]=i$，它就是$v$的祖宗。</p>
<p><strong>算法实现：</strong></p>
<p>并查集算法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x!=p[x])</span><br><span class="line">        p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tarjan算法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];~i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j=e[i];</span><br><span class="line">        <span class="keyword">if</span>(vis[j])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        dist[j]=dist[u]+w[i];</span><br><span class="line">        <span class="built_in">tarjan</span>(j);</span><br><span class="line">        fa[j]=u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;query[u].<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//query[u][i]存储的是第i次询问时,与u相关的查询号  将其赋值给v</span></span><br><span class="line">        <span class="keyword">int</span> v=query[u][i];</span><br><span class="line">        <span class="comment">//query_id[u][i]存储的是第i次查询</span></span><br><span class="line">        <span class="keyword">int</span> id=query_id[u][i];</span><br><span class="line">        <span class="keyword">if</span>(vis[v])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> lca=<span class="built_in">find</span>(v);</span><br><span class="line">            ans[id]=dist[u]+dist[v]<span class="number">-2</span>*dist[lca];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>这道题就直接利用上面所讲述的方法，使用tarjan+并查集算法来解决LCA的离线算法。</p>
<p>树上任意两点之间的距离公式：$L=dist[u]+divt[v]-2\times dist[lca]$</p>
<p>$dist[u]$表示节点$u$到整棵树的根节点的距离；</p>
<p>$dist[v]$表示节点$v$到整棵树的根节点的距离；</p>
<p>$dist[lca]$，其中$lca$是节点$u$和节点$v$的最近公共祖先，表示节点$lca$到整棵树的根节点的距离；</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//这是一棵树  有N个节点 则有N-1条边 由于是无向边  所以要开2倍</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">10010</span>,M=<span class="number">2</span>*N;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;PII;</span><br><span class="line"><span class="keyword">int</span> n,m;    <span class="comment">//n是点数  m是询问次数</span></span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],w[M],idx;</span><br><span class="line"><span class="keyword">int</span> dist[N];    <span class="comment">//距离</span></span><br><span class="line"><span class="keyword">int</span> p[N];       <span class="comment">//并查集的集合号数组</span></span><br><span class="line"><span class="keyword">int</span> res[M];     <span class="comment">//存储询问的结果</span></span><br><span class="line"><span class="keyword">int</span> st[N];      <span class="comment">//标记当前节点是否已经被访问过  st[i]=1表示i节点被访问过了</span></span><br><span class="line"><span class="comment">//query[u]是存放关于节点u的查询信息</span></span><br><span class="line"><span class="comment">//query[u].first存放的是与u相关的那个查询是啥(比如说查询5 6  那么u就是5  query[5].first就是6)</span></span><br><span class="line"><span class="comment">//query[u].second存放的就是这次询问是第几次</span></span><br><span class="line">vector&lt;PII&gt;query[N]; <span class="comment">//存放查询数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//并查集查找x的祖宗节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x!=p[x])</span><br><span class="line">        p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建边</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    w[idx]=c;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//tarjan算法解决LCA的离线查询</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//标记节点u已经被访问过了</span></span><br><span class="line">    st[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//遍历节点u的所有邻接点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];~i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//j是u的邻接节点</span></span><br><span class="line">        <span class="keyword">int</span> j=e[i];</span><br><span class="line">        <span class="comment">//如果节点j还没有被访问过</span></span><br><span class="line">        <span class="keyword">if</span>(!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//更新顶点j的距离</span></span><br><span class="line">            dist[j]=dist[u]+w[i];</span><br><span class="line">            <span class="comment">//以下两句不能调换  因为调换后 经过find函数会进行路径压缩 更新了节点  导致错误</span></span><br><span class="line">            <span class="comment">//然后对顶点j进行深度优先遍历</span></span><br><span class="line">            <span class="built_in">tarjan</span>(j);</span><br><span class="line">            <span class="comment">//回退时更新顶点j的父节点为u</span></span><br><span class="line">            p[j]=u;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果有查询的话</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> item:query[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v=item.first;   <span class="comment">//取出与u相关的查询v</span></span><br><span class="line">        <span class="keyword">int</span> id=item.second; <span class="comment">//这是第几次查询</span></span><br><span class="line">        <span class="comment">//如果节点v之前已经遍历过了  </span></span><br><span class="line">        <span class="comment">//那么满足st[u]=1并且st[v]=1</span></span><br><span class="line">        <span class="keyword">if</span>(st[v])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//对节点v进行并查集操作  找到它的祖宗节点</span></span><br><span class="line">            <span class="comment">//那么这个祖宗节点就是节点u和节点v的最近公共祖先</span></span><br><span class="line">            <span class="keyword">int</span> lca=<span class="built_in">find</span>(v);</span><br><span class="line">            <span class="comment">//记录这次查询的结果 也就是树上节点u和节点v之间的距离</span></span><br><span class="line">            res[id]=dist[u]+dist[v]<span class="number">-2</span>*dist[lca];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="comment">//读入n-1个数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        <span class="comment">//建立无向边</span></span><br><span class="line">        <span class="built_in">add</span>(a,b,c);</span><br><span class="line">        <span class="built_in">add</span>(b,a,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读入m次询问</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="comment">//如果a==b 即查询自身到自身的距离 那肯定是0  那就直接使用全局res数组的0就好了</span></span><br><span class="line">        <span class="comment">//因此当a!=b时  才记录</span></span><br><span class="line">        <span class="keyword">if</span>(a!=b)</span><br><span class="line">        &#123;</span><br><span class="line">            query[a].<span class="built_in">push_back</span>(&#123;b,i&#125;);</span><br><span class="line">            query[b].<span class="built_in">push_back</span>(&#123;a,i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化每个点都是独立的集合</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        p[i]=i;</span><br><span class="line">    <span class="comment">//这里选择从根节点1进行深度优先遍历,进行tarjan算法</span></span><br><span class="line">    <span class="built_in">tarjan</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//输出这m次查询的结果</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>最近公共祖先</category>
      </categories>
      <tags>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title>闇の連鎖</title>
    <url>/2021/07/28/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/%E9%97%87%E3%81%AE%EF%A6%9A%E9%8E%96/</url>
    <content><![CDATA[<h1 id="闇の連鎖"><a href="#闇の連鎖" class="headerlink" title="闇の連鎖"></a>闇の連鎖</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210728165603.png" alt="image-20210728165603872"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>题意：有$n-1$条主要边构成一棵树，然后有$m$条附加边，当把其中一条附加边添加到主要边构成的树中，则会与树上$x,y$之间的路径上一起形成一个环。我们需要砍掉一条主要边和一条附加边，使得这棵树不再连通，成为两个独立的部分。我们需要统计有多少种不同的方案，使得这棵树不连通。</p>
<p>显然， “主要边” 构成一棵树，而一条 “附加边” 必然会和其两端的LCA形成环，如图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210728170420.png" alt="image-20210728170420786"></p>
<p>那么，对于每一条主要边，存在三种情况：</p>
<ol>
<li><p>没有被任何环覆盖</p>
<p>如下图所示：红色表示附加边，粉红色表示一条主要边，这条主要边并不在 这条附加边所形成的环中</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210728170657.png" alt="image-20210728170657069"></p>
</li>
<li><p>只被一个环给覆盖</p>
<p>如下图所示：红色表示附加边，粉红色表示一条主要边，这条主要边在 这条附加边所形成的环中</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210728170818.png" alt="image-20210728170817976"></p>
</li>
<li><p>被2个及以上的环覆盖</p>
<p>如下图所示：红色表示附加边，粉红色表示一条主要边，这条主要边在 两条附加边所形成的两个环中</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210728170943.png" alt="image-20210728170943256"></p>
</li>
</ol>
<ul>
<li>对于情况一，枚举的那个主要边并不在环中，很明显，我们只要把这条主要边删除，那么这个图必然是不连通的。由于题目要求必须砍掉一条主要边和砍掉一条附加边。现在砍掉了这条枚举到的主要边，那么还需要砍掉一条附加边。由于有$m$条附加边，因此我们有$m$种选择，所以此时就有$m$种方案。所以让答案ans累加上m即可，$ans+=m$</li>
<li>对于情况二，枚举的那个主要边在环中，可以发现，如果我们把这条主要边删除，要想让图不连通，必然还要再删除这条附加边，因此这是唯一的一种方案了（即必然是砍掉这条枚举到的主要边和这个附加边），所以让答案ans累加上1即可，$ans+=1$</li>
<li>对于情况三，枚举的那个主要边在两个及以上的环中，以两个环为栗子，可以发现，如果我们把这条主要边砍掉，即使再砍掉一条附加边，这张图仍然是连通的，因此必须砍掉两条附加边，才能使得这张图变得不连通，但是题目要求只能砍掉一条主要边和砍掉一条附加边。因此，对于这种情况，不能得出方案，所以不需要累加答案。</li>
</ul>
<p>那么我们怎么统计每条边被环覆盖的次数呢？也就是说，我们如何统计附加边$(x,y)$所在的那个环中每条边上的权值呢？每条边上的权值表示被附加边覆盖的次数。</p>
<p>也就是我们如何让从点$x$出发经过它俩的lca然后到达节点$y$所经过的每一条边都+c呢？这其实可以用<strong>树上差分</strong>来做。</p>
<p>$d[x]$、$d[y]$ 会对它们到根节点上的每一条边都+c，$d[lca]$会对它们到根节点上的每一条边都-2c，那么这样最终的效果就是：让$x$到lca中和$y$到lca中的每条边都+c</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210728180813.png" alt="image-20210728180813869"></p>
<p>树上差分可以分为以下三种：</p>
<ul>
<li>按点差分</li>
<li>按边差分</li>
<li>按深度差分</li>
</ul>
<p>我们这里是按边差分，因为我们想知道每条边上的覆盖次数（可以认为是这条边的边权）。但是呢，一般按边差分不好做，我们都是将边权转换为点权，然后用按点差分来做。我们知道，每个节点最多只有1个父节点，也就是向上连的边只有1条，所以我们把一条边的边权下放到它的子节点的点权上（注意根节点没有点权，因为根节点上面没有边，所以没有边权下放给根节点），这样我们就转化到按点差分了。我们可以采用DFS对这棵树进行深搜，在回溯时，把子树$v$中的所有节点上的权值都累加到节点$u$上，设总和为$sum$，节点$v$的父节点是$u$，那么$sum$其实就是节点$u$和节点$v$之间的边权了，那么也就是覆盖次数了。</p>
<p>如下图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210728181112.png" alt="image-20210728181112585"></p>
<p>以节点$z$所在的子树为栗子，将节点$z$下面的所有点权$d[i]$累加然后统计到节点$z$上，设总和为$sum$，那么节点$p$和节点$z$之间的边权其实就是$sum$。</p>
<p>注意点：对于数组<code>fa[][]</code>，因为点数最多是1e5，由于$2^{16}&lt;1e5&lt;2^{17}$，所以第二维的大小应该取到17，这样才能弄完全部1e5个点。因此$fa$的第二维有0~16一共17个数，第二维需要设置为17。</p>
<p>虽然说题目中有附加边，但是我们建图时，只是把主要边给建立出来，并没有把附加边建到图中去。由于最多有$N$个点，这是树，是无向边，因此最多有$M=2\times N$条边。</p>
<p><strong>算法设计：</strong></p>
<ul>
<li>先将主要边用图建立出来</li>
<li>进行bfs预处理出<code>fa[][]</code></li>
<li>枚举每一条附加边，对于附加边所在环上的所有主要边其两端的点权都+1，预处理出差分数组<code>d[]</code></li>
<li>进行dfs，枚举每一条主要边，进行树上差分得到每条主要边上的权值。查看每条主要边上的权值：<ul>
<li>如果$c=0$，则说明这条主要边并不在附加边所形成的环中，就是情况一，所以答案$ans+=m$</li>
<li>如果$c=1$，则说明这条主要边在附加边所形成的环中，就是情况二，所以答案$ans+=1$</li>
<li>如果$c&gt;1$，则说明这条主要边处于多条附加边所形成的多个环中，就是情况三，不用累加答案</li>
</ul>
</li>
</ul>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">2</span>*N;</span><br><span class="line"><span class="keyword">int</span> n,m;    <span class="comment">//点数 附加边数</span></span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],w[M],idx;</span><br><span class="line"><span class="keyword">int</span> depth[N];</span><br><span class="line"><span class="keyword">int</span> d[N];   <span class="comment">//存储每个点的差分 树上差分，每个点上的权值，可以转化为边上的权值</span></span><br><span class="line"><span class="keyword">int</span> q[N];   <span class="comment">//bfs使用到的队列</span></span><br><span class="line"><span class="keyword">int</span> fa[N][<span class="number">17</span>];  </span><br><span class="line"><span class="keyword">int</span> ans;    <span class="comment">//方案数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//预处理出fa[][]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(depth,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> depth);</span><br><span class="line">    depth[<span class="number">0</span>]=<span class="number">0</span>,depth[root]=<span class="number">1</span>;</span><br><span class="line">    q[<span class="number">0</span>]=root;</span><br><span class="line">    <span class="keyword">while</span>(hh&lt;=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=q[hh++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(depth[j]&gt;depth[t]+<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                depth[j]=depth[t]+<span class="number">1</span>;</span><br><span class="line">                q[++tt]=j;</span><br><span class="line">                fa[j][<span class="number">0</span>]=t;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">16</span>;k++)</span><br><span class="line">                    fa[j][k]=fa[fa[j][k<span class="number">-1</span>]][k<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(depth[a]&lt;depth[b])</span><br><span class="line">        <span class="built_in">swap</span>(a,b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">16</span>;k&gt;=<span class="number">0</span>;k--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(depth[fa[a][k]]&gt;=depth[b])</span><br><span class="line">        &#123;</span><br><span class="line">            a=fa[a][k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a==b)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">16</span>;k&gt;=<span class="number">0</span>;k--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(fa[a][k]!=fa[b][k])</span><br><span class="line">        &#123;</span><br><span class="line">            a=fa[a][k];</span><br><span class="line">            b=fa[b][k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[a][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回以节点u为根的子树中各节点的权值总和</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> father)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=d[u];   <span class="comment">//记录节点u的点权</span></span><br><span class="line">    <span class="comment">//遍历节点u的所有邻接点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];~i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j=e[i]; <span class="comment">//邻接点j</span></span><br><span class="line">        <span class="keyword">if</span>(j!=father)   <span class="comment">///避免向上重复搜索已经遍历过的边</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//递归搜索以j为根的子树中个节点的权值总和</span></span><br><span class="line">            <span class="keyword">int</span> c=<span class="built_in">dfs</span>(j,u);</span><br><span class="line">            <span class="comment">//最终在回溯时就会算出以节点u为根的子树中各节点的权值总和c</span></span><br><span class="line">            <span class="comment">//而这个c其实就是节点u与它的父节点之间的边权</span></span><br><span class="line">            <span class="keyword">if</span>(c==<span class="number">0</span>)    <span class="comment">//如果为0则说明这条主要边并不在附加边所形成的环中</span></span><br><span class="line">                ans+=m;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="number">1</span>)<span class="comment">//如果为1则说明这条主要边在附加边所形成的环中</span></span><br><span class="line">                ans++;</span><br><span class="line">            <span class="comment">//相当于res=d[u]+dfs(j,u) 最开始res记录的是节点u的点权</span></span><br><span class="line">            <span class="comment">//而dfs(j,u)就是把节点u以下的全部节点的点权都累加到节点u身上</span></span><br><span class="line">            <span class="comment">//因此最终节点u的点权就是它自身拥有的d[u]+别上给它的c</span></span><br><span class="line">            res+=c; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回以节点u为根的子树中各节点的权值总和</span></span><br><span class="line">    <span class="comment">//其实也就是返回节点u和它的父节点之间的这条边的边权 及被附加边覆盖的次数</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> root=<span class="number">1</span>; <span class="comment">//树的根节点   我们设1号点为根节点  任意点都是可以的</span></span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)  <span class="comment">//读入n-1条 主要边</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="comment">//建图时只包括主要边  而没有把附加边建出来</span></span><br><span class="line">        <span class="built_in">add</span>(a,b),<span class="built_in">add</span>(b,a);  <span class="comment">//无向图</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//预处理出fa[][]</span></span><br><span class="line">    <span class="built_in">bfs</span>(root);</span><br><span class="line">    <span class="comment">//依次枚举每一条附加边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="comment">//找到当前枚举的这条附加边的两个端点的最近公共祖先</span></span><br><span class="line">        <span class="keyword">int</span> lca=<span class="built_in">LCA</span>(a,b);</span><br><span class="line">        <span class="comment">//差分</span></span><br><span class="line">        d[a]++,d[b]++,d[lca]-=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>最近公共祖先</category>
      </categories>
      <tags>
        <tag>LCA+树上差分</tag>
      </tags>
  </entry>
  <entry>
    <title>tarjan</title>
    <url>/2021/07/30/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/tarjan/</url>
    <content><![CDATA[<h1 id="tarjan算法求有向图的强连通分量"><a href="#tarjan算法求有向图的强连通分量" class="headerlink" title="tarjan算法求有向图的强连通分量"></a>tarjan算法求有向图的强连通分量</h1><hr>
<h3 id="连通性的相关知识"><a href="#连通性的相关知识" class="headerlink" title="连通性的相关知识"></a>连通性的相关知识</h3><h4 id="无向图的连通分量"><a href="#无向图的连通分量" class="headerlink" title="无向图的连通分量"></a>无向图的连通分量</h4><p>在无向图中，如果从节点$v_i$到节点$v_j$有路径，则称节点$v_i$和节点$v_j$是连通的。如果图中任意两个节点之间都是连通的，则称图$G$为连通图。</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210730140441.png" alt="image-20210730140441026"></p>
<p>无向图$G$的<strong>极大连通子图</strong>被称为图$G$的连通分量。极大连通子图是图$G$的连通子图，如果再向其中加入一个节点，则该子图就不再是连通的。连通图的连通分量就是它自身；非连通图则有两个及以上的连通分量。</p>
<p>如下图所示，有3个连通分量：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210730141251.png" alt="image-20210730141251304"></p>
<h4 id="有向图的强连通分量"><a href="#有向图的强连通分量" class="headerlink" title="有向图的强连通分量"></a>有向图的强连通分量</h4><p>在有向图中，如果图中的任意两个节点从$v_i$到$v_j$都有路径，且从$v_j$到$v_i$也有路径，则称图$G$为强连通图。</p>
<p>有向图$G$的<strong>极大强连通子图</strong>被称为图$G$的强连通分量。极大强连通子图是图$G$的强连通子图，如果再向其中加入一个节点，则该子图就不再是强连通的。</p>
<p>如下图所示，(a)是强连通图，(b)不是强连通图，(c)是(b)的强连通分量：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210730141824.png" alt="image-20210730141824251"></p>
<hr>
<h3 id="tarjan算法"><a href="#tarjan算法" class="headerlink" title="tarjan算法"></a>tarjan算法</h3><p>首先引入时间戳和追溯点的概念</p>
<ul>
<li>时间戳：<code>dfn[u]</code>表示节点$u$深度优先遍历的序号（也就是节点$u$被访问的时间点）</li>
<li>追溯点：<code>low[u]</code>表示节点$u$或者节点$u$的子孙能够通过<strong>非父子边</strong>追溯到的dfn最小的节点序号，即回到最早的过去（也就是节点$u$通过有向边可回溯到的最早的时间点）</li>
</ul>
<p>这里有必要说以下dfs遍历的两种方式：</p>
<ul>
<li>方式一：先访问当前节点，然后再递归访问相邻节点（这类似于树的先序遍历）</li>
<li>方式二：先递归相邻节点，到达叶子节点后回溯时再依次访问路径中的节点（这类似于树的后序遍历）</li>
</ul>
<p>如下图所示，这两种方式输出的结果是不同的：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210730143215.png" alt="image-20210730143214955"></p>
<p>在tarjan算法中，采用的是方式二</p>
<p>举个栗子，在深度优先搜索中，每个点的时间戳和追溯点的求解过程如下：</p>
<p>我们用栈stk来存储访问的节点</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210730145108.png" alt="image-20210730145108651"></p>
<p>初始时，$dfn[u]=low[u]$，从节点$1$开始深搜，如果该节点的邻接点还没有被访问过，则一直递归进行深度优先遍历，$1\to2\to3\to5\to6\to4$，此时栈中内容为{1，2，3，5，6，4}，此时节点$4$的邻接点$1$已经被访问过了，并且节点$1$并不是节点$4$的父节点，节点$4$的父节点是节点$6$（深度优先搜索树上的父节点），那么这条边$4\to1$就是一条非父子边，那么节点$4$顺着这条非父子边能回到最早的节点是节点$1$，那么此时就需要修改节点$4$它的追溯点为$dfn[1]$。我们知道$dfn[1]$必然是小于$low[4]$的，因为节点$1$先于节点$4$被访问，它的时间戳小。所以我们可以直接用$low[4]=dfn[1]$，但是为了严谨，一般都是用$low[4]=min(low[4],dfn[1])$</p>
<blockquote>
<p>但是有个问题，设当前访问节点$u=4$，遍历到它的邻接点$v=1$，要执行$low[u]=min(low[u],dfn[v])$的前提是节点$v$它此刻还是在栈中，为什么呢？</p>
<p>如上图所示，当节点$4$要访问节点$1$时，此时栈内的元素为{1，2，3，5，6，4}，可以发现节点$v=1$还在栈中，也就是说节点$u=4$可以通过这条非父子边到达节点$v=1$。如果节点$v=1$不在栈中，那么可以认为此时节点$u=4$与节点$v=1$这条非父子边是不存在的。既然非父子边不存在，那么就不能通过非父子边回溯到更早，于是也就不能更新节点$u$的时间戳。</p>
</blockquote>
<p>在上面分析中，我们知道了$low[4]=min(low[4],dfn[1])=1$，接下来就要开始回溯了。回溯时需要执行$low[u]=min(low[u],low[v])$，为什么呢？因为既然子孙能够回到更早过去，那么其祖先节点也可以回到更早的过去，于是回溯时此刻$u=6,v=4$，更新$low[6]=min(low[6],low[4])=1$，以此类推，更新节点$5,3,2$的时间戳。</p>
<p>我们可以知道{1，2，3，5，6，4}是一个强连通分量了。同理分析，从节点$1$开始深搜，如果该节点的邻接点还没有被访问过，则一直递归进行深度优先遍历，$1\to2\to3\to5\to7$，此时栈中内容为{1，2，3，5，7}。当前节点$u=7$，可以知道它没有非父子边，所以它不能通过非父子边回溯到更早的过去。于是它自己就是一个强连通分量{7}。</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210730151852.png" alt="image-20210730151852176"></p>
<blockquote>
<p>那么我们什么时候才能输出这个强连通分量呢？</p>
<p>当回溯时，一直回溯到某个节点，它的时间戳<code>dfn[u]</code>与追溯点<code>low[u]</code>是相同时，就可以输出这个强连通分量了。因为此时说明这个节点$u$它不再能够通过非父子边回溯到更早的过去了。</p>
</blockquote>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="comment">//用栈stk来存储强连通分量中的节点</span></span><br><span class="line"><span class="keyword">int</span> stk[N],top;</span><br><span class="line"><span class="comment">//num是时间戳</span></span><br><span class="line"><span class="keyword">int</span> dfn[N],low[N],num;</span><br><span class="line"><span class="comment">//scc_cnt是记录这是第几个强连通分量</span></span><br><span class="line"><span class="comment">//id数组用来存储某个节点是属于哪个强连通分量</span></span><br><span class="line"><span class="comment">//cnt用来记录某个强连通分量中的节点个数</span></span><br><span class="line"><span class="keyword">int</span> id[N],cnt[N],scc_cnt;</span><br><span class="line"><span class="comment">//判断某个节点是否在栈中</span></span><br><span class="line"><span class="keyword">bool</span> in_stk[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u]=low[u]=++num;</span><br><span class="line">    stk[++top]=u;</span><br><span class="line">    in_stk[u]=<span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;调用tarjan(%d) dfn[%d]=low[%d]=%d,栈顶stk[%d]=%d\n&quot;</span>,u,u,u,num,top,u);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];~i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j=e[i];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(j);</span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[u],low[j]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;回溯 %d-&gt;%d low[%d]=%d\n&quot;</span>,j,u,u,low[u]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(in_stk[j])</span><br><span class="line">        &#123;</span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[u],dfn[j]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;有环 %d-&gt;%d low[%d]=%d\n&quot;</span>,u,j,u,low[u]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;判断if(%d==%d)?\n&quot;</span>,dfn[u],low[u]);</span><br><span class="line">    <span class="keyword">if</span>(dfn[u]==low[u])</span><br><span class="line">    &#123;</span><br><span class="line">        scc_cnt++;</span><br><span class="line">        <span class="keyword">int</span> y;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输出第%d个强连通分量:&#123;&quot;</span>,scc_cnt);</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            y=stk[top--];</span><br><span class="line">            in_stk[y]=<span class="literal">false</span>;</span><br><span class="line">            id[y]=scc_cnt;</span><br><span class="line">            cnt[scc_cnt]++;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,y);</span><br><span class="line">        &#125;<span class="keyword">while</span>(y!=u);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&#125;\n输出此时栈顶stk[%d]=%d\n\n&quot;</span>,top,stk[top]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    cin &gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        cin &gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="built_in">add</span>(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i])</span><br><span class="line">            <span class="built_in">tarjan</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如上图中的栗子来说，输出结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210730152417.png" alt="image-20210730152417469"></p>
<ul>
<li>第一个连通分量为{7}</li>
<li>第二个连通分量为{4,6,5,4,2,1}</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>tarjan</category>
      </categories>
      <tags>
        <tag>tarjan求有向图的强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title>最大半连通子图</title>
    <url>/2021/07/30/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/%E6%9C%80%E5%A4%A7%E5%8D%8A%E8%BF%9E%E9%80%9A%E5%AD%90%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="最大半连通子图"><a href="#最大半连通子图" class="headerlink" title="最大半连通子图"></a>最大半连通子图</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210730214958.png" alt="image-20210730214958237"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>根据题目给出的 导出子图、半连通子图、最大半连通子图的定义可知，强连通图一定是半连通子图。由于题目要求的是最大半连通图，又由于强连通分量中任意两个点之间都是可以相互到达的，因此，我们最好选择强连通分量。然后我们可以对强连通分量进行缩点，但是这里要注意，我们要把缩点后的图给真的建立出来。我们在缩点后，会得到一张DAG图，在DAG上找到一个最长链（所谓最长是指链上的点最多），这条链上的点的数目就是最大半连通子图的点的数目。因为是拓扑图，所以可以采用递推的方式求解最大半连通子图中点的数目以及对应的方案数，本质上是一个DP。</p>
<p>下面给出<code>f[]</code>和<code>g[]</code>的定义：</p>
<ul>
<li><code>f[i]</code>表示以第 i 个点为终点的最长链节点数量之和</li>
<li><code>g[i]</code>表示让$f[i]$取到最大值时对应的方案数，也就是说有$g[i]$条最长链，可以使$f[i]$取得最大值</li>
</ul>
<p>由于这是DAG，没有后效性，因此可以用dp思想进行递推，如果存在一条从$i$到$j$的边，则状态转移如下：</p>
<ul>
<li>如果$f[j]+cnt[i]&gt;f[i]$，那么更新$f[i]=f[j]+cnt[i]$，由于只是增加了点数，并没有产生新方案，因此$g[i]=g[j]$</li>
<li>如果$f[j]+cnt[i]=f[i]$，虽然相等，但是这是两种不同的方案，因此$g[i]=g[i]+g[j]$</li>
</ul>
<p>这里求方案数的思想与 背包问题求方案数 是一样的，<a href="https://blog.csdn.net/qq_45832461/article/details/115560882">背包问题求方案数</a></p>
<p>这里还需要注意，这条最长链不能有分叉，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210730222120.png" alt="image-20210730222120447"></p>
<p>使用两个表头分别存储原图<code>h[]</code>和缩点后的新图<code>hs[]</code>，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210730222216.png" alt="image-20210730222216652"></p>
<p>这里还需要注意重边，根据最大半连通子图的含义可知，区别不同的最大半连通子图关键在于 <strong>点的不同</strong> 而不是边的不同，也就是说如果对于两个节点$i,j$，它俩之间有很多边，在求解DAG最长链时就会把这些边都当作不同的路径了，所以很产生很多方案。但是由于都是节点$i,j$，因此点是相同的，于是这就不能算作是不同的最大半连通子图。如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210730222908.png" alt="image-20210730222908554"></p>
<p>为了消除重边的影响，我们需要对边进行判重，这里使用哈希表进行判重。我们把边都哈希成不同的整数，这里的哈希函数是$a* 1000000ll + b$。为什么呢？</p>
<p>因为题目中给出了点数最多是1e6，也就是说点的编号最大是1e6。那么边的编号只能从1e6+1开始了。由于节点$a,b$的编号必然不同，因此设置$a* 1000000ll + b$就可以让边的编号从1e6+1开始取并且还不相同了。这样就可以消除重边的影响了。</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="comment">//h[]原图的表头  hs[]缩点后得到的这张DAG图的表头</span></span><br><span class="line"><span class="keyword">int</span> h[N],hs[N],e[M],ne[M],idx;</span><br><span class="line"><span class="comment">//表示节点u深度优先遍历的序号（也就是节点u被访问的时间点）</span></span><br><span class="line"><span class="comment">//表示节点u或节点u的子孙能够通过非父子边追溯到的dfn最小的节点序号</span></span><br><span class="line"><span class="comment">//即回到最早的过去（也就是节点u通过有向边可回溯到的最早的时间点）</span></span><br><span class="line"><span class="comment">//num表示时间戳</span></span><br><span class="line"><span class="keyword">int</span> dfn[N],low[N],num;</span><br><span class="line"><span class="comment">//a=id[x]表示x这个节点属于a这个强连通分量</span></span><br><span class="line"><span class="comment">//cnt[i]=100表示i这个强连通分量有100个节点</span></span><br><span class="line"><span class="comment">//scc表示强连通分量的编号 scc=3表示第3个强连通分量 最终也只有scc个强连通分量</span></span><br><span class="line"><span class="keyword">int</span> id[N],cnt[N],scc;</span><br><span class="line"><span class="comment">//栈用来存储访问的节点  top是栈顶指针</span></span><br><span class="line"><span class="keyword">int</span> stk[N],top; </span><br><span class="line"><span class="comment">//din存储每个节点的入度 dout存储每个节点的出度 </span></span><br><span class="line"><span class="keyword">int</span> din[N],dout[N];</span><br><span class="line"><span class="comment">//in_stk[i]=true表示节点i还在栈中</span></span><br><span class="line"><span class="keyword">bool</span> in_stk[N];</span><br><span class="line"><span class="comment">//f[i]表示以第 i 个点为终点的最长链节点数量之和</span></span><br><span class="line"><span class="comment">//g[i]表示让f[i]取到最大值时对应的方案数</span></span><br><span class="line">LL f[N],g[N];</span><br><span class="line"><span class="keyword">int</span> n,m,mod;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> h[],<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u]=low[u]=++num;    <span class="comment">//给节点u分配一个时间戳</span></span><br><span class="line">    stk[++top]=u;           <span class="comment">//将节点u入栈</span></span><br><span class="line">    in_stk[u]=<span class="literal">true</span>;         <span class="comment">//标记节点u在栈中</span></span><br><span class="line">    <span class="comment">//遍历节点u的所有邻接点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];~i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j=e[i]; <span class="comment">//u的邻接点j</span></span><br><span class="line">        <span class="comment">//根据分析得出：先会执行else if中的更新语句,才会执行if中的回溯过程中的更新语句</span></span><br><span class="line">        <span class="comment">//如果节点j还没有被访问过</span></span><br><span class="line">        <span class="keyword">if</span>(!dfn[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(j);<span class="comment">//递归访问j</span></span><br><span class="line">            <span class="comment">//回溯是更新从节点j往回到节点u这条路径上的所有节点的low值</span></span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[u],low[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则说明节点j已经被访问过了 看j是否还在栈中</span></span><br><span class="line">        <span class="comment">//如果还在栈中 那么就说明形成了环 即存在强连通分量</span></span><br><span class="line">        <span class="comment">//当走到这里时说明j先于u被访问,因此u可以追溯到更早的过去</span></span><br><span class="line">        <span class="comment">//于是用更早的dfn[j]来更新low[u]</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(in_stk[j])</span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[u],dfn[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//退无可退 即此时u不能追溯到更早的过去了 那么它就是这个强连通分量的入口</span></span><br><span class="line">    <span class="keyword">if</span>(dfn[u]==low[u])</span><br><span class="line">    &#123;</span><br><span class="line">        scc++;  <span class="comment">//强连通分量的个数+1</span></span><br><span class="line">        <span class="keyword">int</span> y;</span><br><span class="line">        <span class="comment">//输出这个强连通分量中所包含的节点</span></span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            y=stk[top--];       <span class="comment">//强连通分量的节点y</span></span><br><span class="line">            in_stk[y]=<span class="literal">false</span>;    <span class="comment">//标记节点y不在栈中</span></span><br><span class="line">            id[y]=scc;      <span class="comment">//节点y属于scc这个强连通分量</span></span><br><span class="line">            cnt[scc]++;     <span class="comment">//scc这个强连通分量中的节点个数增加了y这个节点</span></span><br><span class="line">        &#125;<span class="keyword">while</span>(y!=u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">memset</span>(hs,<span class="number">-1</span>,<span class="keyword">sizeof</span> hs);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;mod);</span><br><span class="line">    <span class="comment">//建立原图</span></span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="built_in">add</span>(h,a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i])</span><br><span class="line">            <span class="built_in">tarjan</span>(i);</span><br><span class="line"></span><br><span class="line">    unordered_set&lt;LL&gt;S; <span class="comment">//哈希表  对边判重 消除重边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//遍历节点i的所有邻接点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=h[i];~j;j=ne[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> k=e[j]; <span class="comment">//i的邻接点k</span></span><br><span class="line">            <span class="keyword">int</span> a=id[i];    <span class="comment">//节点i所在的强连通分量 也就是缩点后得到的某个节点a</span></span><br><span class="line">            <span class="keyword">int</span> b=id[k];    <span class="comment">//节点k所在的强连通分量 也就是缩点后得到的某个节点b</span></span><br><span class="line">            <span class="comment">//节点a,b之间这条边的编号哈希成&gt;1000000的一个整数值</span></span><br><span class="line">            LL hash=a*<span class="number">1000000ll</span>+b;</span><br><span class="line">            <span class="comment">//如果a和b都不在同一个强连通分量中并且这条边还没有出现过</span></span><br><span class="line">            <span class="keyword">if</span>(a!=b&amp;&amp;!S.<span class="built_in">count</span>(hash))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//将缩点后的这张DAG图真的建立出来</span></span><br><span class="line">                <span class="built_in">add</span>(hs,a,b);</span><br><span class="line">                S.<span class="built_in">insert</span>(hash);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//tarjan求完后，scc的编号递减顺序就是拓扑序列</span></span><br><span class="line">    <span class="comment">//预处理出f[]和g[]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=scc;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!f[i])   <span class="comment">//如果当前点没有更新，就进行初始化</span></span><br><span class="line">        &#123;</span><br><span class="line">            f[i]=cnt[i];</span><br><span class="line">            g[i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历节点i的所有邻接点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=hs[i];~j;j=ne[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> k=e[j]; <span class="comment">//i的邻接点k</span></span><br><span class="line">            <span class="comment">//通过i能够更新k  只是让f[k]变多了 并没有产生新的方案</span></span><br><span class="line">            <span class="keyword">if</span>(f[k]&lt;f[i]+cnt[k])</span><br><span class="line">            &#123;</span><br><span class="line">                f[k]=f[i]+cnt[k];</span><br><span class="line">                g[k]=g[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//比如f[k]=8  f[i]=5 cnt[k]=3 那么&#123;8&#125;和&#123;5,3&#125;就是两种不同的方案</span></span><br><span class="line">            <span class="comment">//使得节点k的f值都是8  于是如果相同的话就会产生新方案</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(f[k]==f[i]+cnt[k])</span><br><span class="line">                g[k]=(g[k]+g[i])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//maxf是记录最大的f[]  sum是记录最大的g[]</span></span><br><span class="line">    <span class="keyword">int</span> maxf=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=scc;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(f[i]&gt;maxf)</span><br><span class="line">        &#123;</span><br><span class="line">            maxf=f[i];</span><br><span class="line">            sum=g[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(f[i]==maxf)</span><br><span class="line">            sum=(sum+g[i])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,maxf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>有向图的强连通分量</category>
      </categories>
      <tags>
        <tag>tarjan求有向图的强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title>受欢迎的牛</title>
    <url>/2021/07/30/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/%E5%8F%97%E6%AC%A2%E8%BF%8E%E7%9A%84%E7%89%9B/</url>
    <content><![CDATA[<h1 id="受欢迎的牛"><a href="#受欢迎的牛" class="headerlink" title="受欢迎的牛"></a>受欢迎的牛</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210730155213.png" alt="image-20210730155213679"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p><a href="https://blog.csdn.net/qq_45832461/article/details/119248937">tarjan算法</a></p>
<p>题意：求出被所有牛（除自己外）都喜欢的”明星“数量。</p>
<p>有向图的强连通分量有个非常重要的作用：可以把一张图转变为有向无环图DAG。而求解有向图的强连通分量可以使用tarjan算法。</p>
<p>因为，当我们求出一个强连通分量时，可以把这个强连通分量进行缩点操作，缩成一个点，然后再把这个节点与其他节点连边，这样就可以得到一张DAG图。既然是有向无环图，那么就可以运用拓扑排序算法了。但是其实并不需要进行拓扑排序，因为tarjan算法本质是递归，当到了叶子节点时，算出一个连通分量，给它一个编号num，那么叶子节点所在的这个连通分量就是第一个，即num=1。然后回溯，再回溯过程中又求出了另一些连通分量，此时num++，也就是说，从后往前强连通分量的编号是递增的，这非常像DFS版的拓扑排序。而DFS版的拓扑排序的话，就是逆序输出就可以得到从前往后的拓扑序列了。对于tarjan来说，其实也是类似的，我们只需要从大到小输出强连通分量的编号num即可，因此不需要进行拓扑排序了。</p>
<p>对于这题来说，我们发现，使用tarjan算法后得到一张DAG图，如果图中出度为0的节点个数&gt;1，那么则无解了，如果图中出度为0的节点个数=1，则有解。</p>
<p>如下图所示：</p>
<p>如果$A$认为$B$受欢迎，则从$A$向$B$连一条有向边</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210730161045.png" alt="image-20210730161045557"></p>
<p>那么该如何统计结果呢？如上图，这里3是指缩点后的节点3，它其实代表的是第3个强连通分量，假设是$1\to2\to3$，可以知道第3个强连通分量中的牛都受到欢迎。因此，我们只需要统计出度为0的那个强连通分量中的牛的数量，那么就是答案了。</p>
<p>这题我们并不需要把缩点后的图建立出来，我们只需要求出每一个强连通分量，并给它们编上号。对于两个节点$i,k$，$i$和$k$是邻接点的关系，假设$i\to k$，我们先查看它们属于哪一个强连通分量，我们用数组<code>id[]</code>来记录某个节点属于哪个强连通分量。假设节点$i$属于强连通分量$a=id[i]$，节点$k$属于强连通分量$b=id[k]$，那么有两种情况：</p>
<ul>
<li>如果$a=b$，则说明节点$i,k$属于同一个强连通分量，由于我们把一个强连通分量看成了一个缩点，那么它里面的节点就不需要谈论出度了。</li>
<li>如果$a\neq b$，则说明节点$i,k$不属于同一个强连通分量，那么统计强连通分量$a$的出度，即$d[a]$+ +</li>
</ul>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e4</span>+<span class="number">10</span>,M=<span class="number">5e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="comment">//表示节点u深度优先遍历的序号（也就是节点u被访问的时间点）</span></span><br><span class="line"><span class="comment">//表示节点u或节点u的子孙能够通过非父子边追溯到的dfn最小的节点序号</span></span><br><span class="line"><span class="comment">//即回到最早的过去（也就是节点u通过有向边可回溯到的最早的时间点）</span></span><br><span class="line"><span class="comment">//num表示时间戳</span></span><br><span class="line"><span class="keyword">int</span> dfn[N],low[N],num;</span><br><span class="line"><span class="comment">//a=id[x]表示x这个节点属于a这个强连通分量</span></span><br><span class="line"><span class="comment">//cnt[i]=100表示i这个强连通分量有100个节点</span></span><br><span class="line"><span class="comment">//scc表示强连通分量的编号 scc=3表示第3个强连通分量 最终也只有scc个强连通分量</span></span><br><span class="line"><span class="keyword">int</span> id[N],cnt[N],scc;</span><br><span class="line"><span class="comment">//栈用来存储访问的节点  top是栈顶指针</span></span><br><span class="line"><span class="keyword">int</span> stk[N],top; </span><br><span class="line"><span class="comment">//存储每个节点的出度</span></span><br><span class="line"><span class="keyword">int</span> dout[N];</span><br><span class="line"><span class="comment">//in_stk[i]=true表示节点i还在栈中</span></span><br><span class="line"><span class="keyword">bool</span> in_stk[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u]=low[u]=++num;    <span class="comment">//给节点u分配一个时间戳</span></span><br><span class="line">    stk[++top]=u;           <span class="comment">//将节点u入栈</span></span><br><span class="line">    in_stk[u]=<span class="literal">true</span>;         <span class="comment">//标记节点u在栈中</span></span><br><span class="line">    <span class="comment">//遍历节点u的所有邻接点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];~i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j=e[i]; <span class="comment">//u的邻接点j</span></span><br><span class="line">        <span class="comment">//根据分析得出：先会执行else if中的更新语句,才会执行if中的回溯过程中的更新语句</span></span><br><span class="line">        <span class="comment">//如果节点j还没有被访问过</span></span><br><span class="line">        <span class="keyword">if</span>(!dfn[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(j);<span class="comment">//递归访问j</span></span><br><span class="line">            <span class="comment">//回溯是更新从节点j往回到节点u这条路径上的所有节点的low值</span></span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[u],low[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则说明节点j已经被访问过了 看j是否还在栈中</span></span><br><span class="line">        <span class="comment">//如果还在栈中 那么就说明形成了环 即存在强连通分量</span></span><br><span class="line">        <span class="comment">//当走到这里时说明j先于u被访问,因此u可以追溯到更早的过去</span></span><br><span class="line">        <span class="comment">//于是用更早的dfn[j]来更新low[u]</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(in_stk[j])</span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[u],dfn[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//退无可退 即此时u不能追溯到更早的过去了 那么它就是这个强连通分量的入口</span></span><br><span class="line">    <span class="keyword">if</span>(dfn[u]==low[u])</span><br><span class="line">    &#123;</span><br><span class="line">        scc++;  <span class="comment">//强连通分量的个数+1</span></span><br><span class="line">        <span class="keyword">int</span> y;</span><br><span class="line">        <span class="comment">//输出这个强连通分量中所包含的节点</span></span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            y=stk[top--];       <span class="comment">//强连通分量的节点y</span></span><br><span class="line">            in_stk[y]=<span class="literal">false</span>;    <span class="comment">//标记节点y不在栈中</span></span><br><span class="line">            id[y]=scc;      <span class="comment">//节点y属于scc这个强连通分量</span></span><br><span class="line">            cnt[scc]++;     <span class="comment">//scc这个强连通分量中的节点个数增加了y这个节点</span></span><br><span class="line">        &#125;<span class="keyword">while</span>(y!=u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a,b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行tarjan算法</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i])</span><br><span class="line">            <span class="built_in">tarjan</span>(i);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//统计新图中点的出度 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//遍历节点i的所有邻接点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=h[i];~j;j=ne[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> k=e[j]; <span class="comment">//节点i的邻接点k</span></span><br><span class="line">            <span class="comment">//查看节点i和节点k分别属于哪个强连通分量</span></span><br><span class="line">            <span class="keyword">int</span> a=id[i];</span><br><span class="line">            <span class="keyword">int</span> b=id[k];</span><br><span class="line">            <span class="comment">//如果它俩属于不同的强连通分量,由于是i&gt;k</span></span><br><span class="line">            <span class="comment">//所以a这个强连通分量的出度+1</span></span><br><span class="line">            <span class="keyword">if</span>(a!=b)</span><br><span class="line">                dout[a]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//zeros记录出度为0的节点个数</span></span><br><span class="line">    <span class="comment">//sum存储所有出度为0的强连通分量的点的数量</span></span><br><span class="line">    <span class="keyword">int</span> zeros=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=scc;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果第i个强连通分量出度为0</span></span><br><span class="line">        <span class="keyword">if</span>(!dout[i])</span><br><span class="line">        &#123;</span><br><span class="line">            zeros++;</span><br><span class="line">            sum+=cnt[i];    <span class="comment">//加上第i个强连通分量的点的个数</span></span><br><span class="line">            <span class="comment">//如果存在出度为0的节点个数&gt;1,则某一头牛必然不会受到另一头牛的喜欢</span></span><br><span class="line">            <span class="comment">//与题意不符合</span></span><br><span class="line">            <span class="keyword">if</span>(zeros&gt;<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sum=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>有向图的强连通分量</category>
      </categories>
      <tags>
        <tag>tarjan求有向图的强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title>学校网络</title>
    <url>/2021/07/30/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/%E5%AD%A6%E6%A0%A1%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="学校网络"><a href="#学校网络" class="headerlink" title="学校网络"></a>学校网络</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210730181223.png" alt="image-20210730181223122"></p>
<hr>
<h3 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h3><p>抽象一下题意：</p>
<ul>
<li>第一问：最少发送给几个学校，就可以让软件传送到所有学校</li>
<li>第二问：最少添加几条有向边，才能实现发送给任意一个学校，所有学校都能接受到。即最少添加多少条有向边，可以使得图中任意两个节点之间连通，把任意一张有向图变成强连通图。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210730181858.png" alt="image-20210730181858796"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>对于第一问，最少发送给几个学校，就可以让软件传送到所有学校呢？实际上，就是求解强连通分量并缩点后得到的这张DAG图中有多少个入度为0的点，即”零入度点“（这里的点已经是把强连通分量进行缩点操作后得到的点）。为什么呢？首先，”零入度点“无法被其他学校支援，因此必须把软件分配给”零入度点“；其次，若同时向所有”零入度点“提供新软件，则新软件可以从这些点出发沿着网络传送到所有学校（因为这是DAG图，从起点出发，必然能遍历整张有向无环图）。综上所述，第一问，其实就是求解有向无环图中”零入度点“的个数。</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210730183258.png" alt="image-20210730183258072"></p>
<p>使用tarjan算法求解有3个强连通分量，然后进行缩点操作，此时这张DAG图中只有三个顶点，可以发现”零入度点“是红色点，只有一个，即入度为0的强连通分量只有一个，因此我们只需要发送给这个强连通分量中的任意一个学校就行了，即1、2、5小红的任意一个学校。</p>
<p>接下来求解第二问：最少添加几条有向边，才能实现发送给任意一个学校，所有学校都能接受到？也就是说，每个强连通分量都必须既有入度，又有出度。对入度为0的强连通分量，至少要添加一个入度；对出度为0的强连通分量，至少要添加一个出度。添加的边数为$max(p,q)$。</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210730184005.png" alt="image-20210730184005042"></p>
<p>特别地，如果整张图本身就是一个强连通图，那么缩点后，就只是一个点了，由于强连通图形成了环，因此任意两个点之间必然可达，因此不需要添加边，所以答案为0。</p>
<p>接下来给出$max(p,q)$的可行性证明：</p>
<p>设缩点后的这张DAG图，起点（入度为0，即零入度点）的集合为$P$，终点（出度为0，即零出度点）的集合为$Q$，注意这里的P和Q只是统计刚开始这张DAG图中的入度为0的节点和出度为0的节点，并不是向拓扑排序那样还统计进行拓扑排序过程中那些入度为0的点和出度为0的点。分为以下两种情况讨论：</p>
<ul>
<li><p>$|P|\leq|Q|$</p>
<ul>
<li><p>如果$|P|=1$，则只有一个起点，由DAG图的性质可知，可以从起点走到所有的终点，因此要向让图中任意两点之间都连通，则只需要让这$|Q|$个终点向起点连一条有向边即可。因此需要添加的边数为$|Q|$个。</p>
</li>
<li><p>如果$|P|\geq 2$，则有$|Q|\geq|P|\geq2$，此时至少存在2个起点$p_1,p_2$，2个终点$q_1,q_2$，满足从$p_1$能走到$q_1$，从$p_2$能走到$q_2$。反证法：如果不存在两个起点能走到不同的终点，含义就是说这两个起点只能走向同一个终点，也就是说推出了只有一个终点，但是我们知道终点至少有2个，发生矛盾，故得证。如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210730185405.png" alt="image-20210730185405683"></p>
</li>
<li><p>那么我们可以从$q_1$向$p_2$添加一条有向边，这样就会使得“零入度点”和”零出度点“减少一个，即$|P|、|Q|$都少了1，设$|P|$添加了$x$后，可以使得$|P|$中节点个数减为1，那么有$|P|-x=1$，所以$x=|P|-1$，也就是说我们需要添加$|P|-1$条边，就可以使得$|P|$减为1，设此时的集合为$|P’|=1$，那么我们就转换为$|P’|=1$的情况了。同理分析可得此时$|Q’|=|Q|-(|P|-1)$，由于$|P’|=1$这种情况需要添加$|Q’|$条边。因此我们需要添加总的边数为$|P|-1+|Q|-(|P|-1)=|Q|$。</p>
</li>
</ul>
</li>
<li><p>$|Q|\leq |P|$，对称分析，这与情况1相同，此时答案为$|P|$。</p>
</li>
<li><p>因此第二问的答案就是$max(P,Q)$</p>
</li>
</ul>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">110</span>,M=N*N;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="comment">//表示节点u深度优先遍历的序号（也就是节点u被访问的时间点）</span></span><br><span class="line"><span class="comment">//表示节点u或节点u的子孙能够通过非父子边追溯到的dfn最小的节点序号</span></span><br><span class="line"><span class="comment">//即回到最早的过去（也就是节点u通过有向边可回溯到的最早的时间点）</span></span><br><span class="line"><span class="comment">//num表示时间戳</span></span><br><span class="line"><span class="keyword">int</span> dfn[N],low[N],num;</span><br><span class="line"><span class="comment">//a=id[x]表示x这个节点属于a这个强连通分量</span></span><br><span class="line"><span class="comment">//cnt[i]=100表示i这个强连通分量有100个节点</span></span><br><span class="line"><span class="comment">//scc表示强连通分量的编号 scc=3表示第3个强连通分量 最终也只有scc个强连通分量</span></span><br><span class="line"><span class="keyword">int</span> id[N],cnt[N],scc;</span><br><span class="line"><span class="comment">//栈用来存储访问的节点  top是栈顶指针</span></span><br><span class="line"><span class="keyword">int</span> stk[N],top; </span><br><span class="line"><span class="comment">//din存储每个节点的入度 dout存储每个节点的出度 </span></span><br><span class="line"><span class="keyword">int</span> din[N],dout[N];</span><br><span class="line"><span class="comment">//in_stk[i]=true表示节点i还在栈中</span></span><br><span class="line"><span class="keyword">bool</span> in_stk[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u]=low[u]=++num;    <span class="comment">//给节点u分配一个时间戳</span></span><br><span class="line">    stk[++top]=u;           <span class="comment">//将节点u入栈</span></span><br><span class="line">    in_stk[u]=<span class="literal">true</span>;         <span class="comment">//标记节点u在栈中</span></span><br><span class="line">    <span class="comment">//遍历节点u的所有邻接点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];~i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j=e[i]; <span class="comment">//u的邻接点j</span></span><br><span class="line">        <span class="comment">//根据分析得出：先会执行else if中的更新语句,才会执行if中的回溯过程中的更新语句</span></span><br><span class="line">        <span class="comment">//如果节点j还没有被访问过</span></span><br><span class="line">        <span class="keyword">if</span>(!dfn[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(j);<span class="comment">//递归访问j</span></span><br><span class="line">            <span class="comment">//回溯是更新从节点j往回到节点u这条路径上的所有节点的low值</span></span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[u],low[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则说明节点j已经被访问过了 看j是否还在栈中</span></span><br><span class="line">        <span class="comment">//如果还在栈中 那么就说明形成了环 即存在强连通分量</span></span><br><span class="line">        <span class="comment">//当走到这里时说明j先于u被访问,因此u可以追溯到更早的过去</span></span><br><span class="line">        <span class="comment">//于是用更早的dfn[j]来更新low[u]</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(in_stk[j])</span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[u],dfn[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//退无可退 即此时u不能追溯到更早的过去了 那么它就是这个强连通分量的入口</span></span><br><span class="line">    <span class="keyword">if</span>(dfn[u]==low[u])</span><br><span class="line">    &#123;</span><br><span class="line">        scc++;  <span class="comment">//强连通分量的个数+1</span></span><br><span class="line">        <span class="keyword">int</span> y;</span><br><span class="line">        <span class="comment">//输出这个强连通分量中所包含的节点</span></span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            y=stk[top--];       <span class="comment">//强连通分量的节点y</span></span><br><span class="line">            in_stk[y]=<span class="literal">false</span>;    <span class="comment">//标记节点y不在栈中</span></span><br><span class="line">            id[y]=scc;      <span class="comment">//节点y属于scc这个强连通分量</span></span><br><span class="line">            cnt[scc]++;     <span class="comment">//scc这个强连通分量中的节点个数增加了y这个节点</span></span><br><span class="line">        &#125;<span class="keyword">while</span>(y!=u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    cin &gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">while</span>(cin &gt;&gt;j,j)</span><br><span class="line">            <span class="built_in">add</span>(i,j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行tarjan算法</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i])</span><br><span class="line">            <span class="built_in">tarjan</span>(i);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//预处理这个DAG图中入度为0和出度为0的节点个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=h[i];~j;j=ne[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> k=e[j];</span><br><span class="line">            <span class="keyword">int</span> a=id[i];</span><br><span class="line">            <span class="keyword">int</span> b=id[k];</span><br><span class="line">            <span class="keyword">if</span>(a!=b)</span><br><span class="line">            &#123;</span><br><span class="line">                dout[a]++;</span><br><span class="line">                din[b]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//统计这个DAG图中入度为0和出度为0的节点个数</span></span><br><span class="line">    <span class="comment">//p是零入度点的个数  q是零出度点的个数</span></span><br><span class="line">    <span class="keyword">int</span> p=<span class="number">0</span>,q=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=scc;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!din[i])</span><br><span class="line">            p++;</span><br><span class="line">        <span class="keyword">if</span>(!dout[i])</span><br><span class="line">            q++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,p);</span><br><span class="line">    <span class="keyword">if</span>(scc==<span class="number">1</span>)  <span class="comment">//只有一个强连通分量 则不需要添加新边</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">max</span>(p,q));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>有向图的强连通分量</category>
      </categories>
      <tags>
        <tag>tarjan求有向图的强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title>食物链</title>
    <url>/2021/07/15/Algorithm-Improvement/Chapter4---Advanced%20Data%20Structure/%E5%B9%B6%E6%9F%A5%E9%9B%86/%E9%A3%9F%E7%89%A9%E9%93%BE/</url>
    <content><![CDATA[<h1 id="食物链"><a href="#食物链" class="headerlink" title="食物链"></a>食物链</h1><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210715205916.png" alt="image-20210715205849019"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>这题刚开始看的时候，都想不到会用到并查集。那么，我们就来分析一下，为什么需要用到并查集呢？</p>
<p>题目中提到，只有三类动物，但是每类动物中可能有很多个，每个动物都会有各自的编号。并且$A$吃$B$，$B$吃$C$，$C$吃$A$，这三类动物的食物链构成了有趣的环形。我们设如果$x$吃了$y$，则记录表示为$y\to x$。那么$A$吃$B$，$B$吃$C$，$C$吃$A$，可以表达为$B\to A,C\to B,A\to C$，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210715230906.png" alt="image-20210715230906789"></p>
<p>题目会给出一些信息，那么我们如何根据这些信息来判断各个动物之间的关系呢？是同类呢还是天敌关系呢？</p>
<p>我们把这些动物看成是军人，假设有$100$个军人，我们想知道每个军人是什么等级。</p>
<ul>
<li>如果我们是两两比较军人的关系，那么需要$O(n^2)$才能知道每个军人是什么等级</li>
<li>但是如果我们知道编号为$1$的军人它是司令，然后知道了剩下的$99$个军人与司令的关系，那么就可以在$O(n)$内知道每个军人是什么等级了。比如$2$号说：我比司令低一级，那么$2$号军人的等级就是军长，$5$号军人说：我比司令低两级，那么$5$号军人的等级就是师长。如果$90$号军人说：我比司令低一级，那么$90$号军人的等级就是军长。那么$2$号和$90$就是同类，处于同一个等级。不要被编号迷惑了，可以理解为$2$号成为军长的时间较早，$90$号成为军长较晚，但是他俩都是军长，是同类，处于同一个等级。</li>
</ul>
<p>因此，我们可以把司令看作是一个根节点，那么我们怎么知道每个点与司令这个根节点的关系呢？这其实就需要用到并查集呢！想要知道每个点与司令这个根节点的关系，其实就类似于并查集中的路径压缩。因此，我们可以使用并查集来查询和合并食物链中动物之间的关系。</p>
<p>这里给出<code>d[]</code>数组的解释：</p>
<p><code>d[i]</code>的含义：表示第$i$个动物在食物链中的深度，其实也就是第$i$个动物到它父节点的距离。</p>
<p>设根节点的深度为0，我们有以下定义：</p>
<ul>
<li>如果某类动物，它到根节点距离为0，则表明该类动物与根节点这类动物是同一类动物</li>
<li>如果某类动物，它到根节点距离为1，则表明根节点被该类动物吃</li>
<li>如果某类动物，它到根节点距离为2，则表明该类动物可以吃上一种情况的动物，而且该类动物被根节点吃（因为三类动物形成环）</li>
</ul>
<p>在本题中，我们可以用深度来表达动物在食物链中的关系。由于本题只有三种类型的动物，这三类动物的食物链构成了有趣的环形。$A$吃$B$，$B$吃$C$，$C$吃$A$，那么深度也只有$0,1,2$，因此当深度$\geq3$时，则可以通过模$3$运算，将其转换成$0,1,2$中的某一个。</p>
<p>现在来思考一个问题，我们 <strong>在查找时如何更新深度</strong>？</p>
<p>首先，通过并查集的查询操作，找到祖宗节点，当集合号等于自身时回溯，在回溯过程中需要更新集合号为祖宗的集合号，并且要更新当前节点的深度累加其父节点的深度。当深度$\geq3$时，则可以通过模$3$运算即可。即$d[x]=(d[x]+d[f_x])%3$</p>
<blockquote>
<p>如何理解$d[x]=(d[x]+d[f_x])%3$这个式子呢？</p>
<p>如图：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210718000800.png" alt="image-20210718000753778"></p>
</blockquote>
<p>当输入1吃2、2吃3、3吃4时，并查集如下左图所示。当查询1的集合号时，首先找到祖宗节点4，回溯时更新3号节点的深度为1，集合号为4；更新2号节点的深度为2，集合号为4；更新1号节点的深度为0，集合号为4，如下右图所示：</p>
<ul>
<li>对于3号节点来说，路径压缩前，它的父节点是4，距离为1，所以$d[x]=d[3]=1$；路径压缩后，找到集合的根节点是4号节点，那么3号节点的父节点就是4，距离为1，所以$d[x]=d[3]=1$，其父节点的深度其实就是4号节点到4号节点的深度，所以$d[f_x]=0$；所以路径压缩后，3号节点的深度为$d[3]=(d[x]+d[f_x])%3=(1+0)%3=1$</li>
<li>对于2号节点来说，路径压缩前，它的父节点是3，距离为1，所以$d[x]=d[2]=1$；路径压缩后，找到集合的根节点是4号节点，那么路径压缩后2号节点的父节点就是4，其父节点的深度其实就是3号节点到4号节点的深度，所以$d[f_x]=1$；所以路径压缩后，2号节点的深度为$d[2]=(d[x]+d[f_x])%3=(1+1)%3=2$</li>
<li>对于1号节点来说，路径压缩前，它的父节点是2，距离为1，所以$d[x]=d[2]=1$；路径压缩后，找到集合的根节点是4号节点，那么路径压缩后1号节点的父节点就是4，其父节点的深度其实就是2号节点到4号节点的深度，所以$d[f_x]=2$；所以路径压缩后，1号节点的深度为$d[1]=(d[x]+d[f_x])%3=(1+2)%3=0$</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210718002228.png" alt="image-20210718002227975"></p>
<p>再来考虑一个问题：<strong>合并时如何更新深度呢</strong>？</p>
<p>假设节点$x$的集合号为$a$，节点$y$的集合号为$b$，如果$a\neq b$，则合并集合号$p[a]=b$，更新$a$的深度为$d[a]=(d[y]-d[x]+c-1)%3$。如何理解这个式子呢？</p>
<p>路径压缩后，节点$x$到祖宗节点$a$的距离为$d[x]$，节点$y$到祖宗节点$b$的距离为$d[y]$，那么如果合并集合号$p[a]=b$后？那么如何求节点$a$到它的祖宗节点$b$的距离呢？</p>
<p>由于$a\neq b$，说明$x$和$y$不在同一个集合中，所以才需要用到合并操作。</p>
<ul>
<li><p>当$x$和$y$是同类时，根据<code>d[]</code>的定义可知，同类的深度差为0。即$d[x]+?$与$dy$是相等的。因此有如下式子推导：</p>
<p>$dx+?=dy$$\iff$</p>
<p>$dx+?=dy+0$$\iff$</p>
<p>$?=dy-dx+0$$\iff$</p>
<p>$?=(dy-dx+3+0)%3$       由于$x$和$y$是同类， 根据题意，此时$c=1$，我们可以发现式子中的0其实就是$c-1=1-1=0$。因此用$c-1$代替0即可</p>
<p>$\iff ?=(dy-dx+3+c-1)%3$   这里$dy-dx+3$之所以要加3是因为有可能$dy-dx$是负数，导致最终结果是负数，负数不能取模，所以需要转换为正数。模3是因为该食物链为环形</p>
</li>
<li><p>当$x$和$y$是异类时，不妨假设$x$吃$y$，根据<code>d[]</code>的定义可知，合并集合后，$x$到祖宗节点的距离 比 $y$到祖宗节点的距离 多1。即$d[x]+?$与$dy+1$是相等的。因此有如下式子推导：</p>
<p>$dx+?=dy+1$$\iff$</p>
<p>$?=(dy-dx+1)$$\iff$</p>
<p>$?=(dy-dx+3+1)%3$     由于$x$和$y$是异类，$x$吃$y$， 根据题意，此时$c=2$，我们可以发现式子中的1其实就是$c-1=2-1=1$。因此用$c-1$代替1即可</p>
<p>$\iff ?=(dy-dx+3+c-1)%3$  这里$dy-dx+3$之所以要加3是因为有可能$dy-dx$是负数，导致最终结果是负数，负数不能取模，所以需要转换为正数。模3是因为该食物链为环形</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210718094601.png" alt="image-20210718094601633">      </p>
</li>
</ul>
<p>举个栗子：</p>
<p>输入6吃2，两个节点属于不同的集合，其中6号节点属于4号集合，6号节点属于7号集合，执行合并，那么$p[7]=4$，更新7号节点的深度为$d[7]=(d[2]-d[6]+3+2-1)%3=2$，合并更新图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210718210130.png" alt="image-20210718210130274"></p>
<p>当下次查询6号节点的集合号时，找到它的祖宗节点4，回溯时同时更新6号节点的深度为$d[6]=(d[6]+d[7])%3=0$，查询更新图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210718210557.png" alt="image-20210718210557278"></p>
<p>因此，我们来总结以下就是，如果$x$的集合号$a$与$y$的集合号$b$不相同，则说明它俩不在同一个集合中，这是才需要用到并查集的合并操作。根据以上分析推导可知，最终合并时更新深度其实就只有一个式子：$?=(dy-dx+3+c-1)%3$ </p>
<p>最后再来看一个问题，<strong>深度满足什么关系是真话</strong>？</p>
<p>这里判断是否为真话或假话，是在$x$和$y$属于同一个集合中讨论的，因为属于同一个集合的话，则不需要合并操作，那么就没有未知变量$d[a]$，不需要求未知变量，而且在这里的全部变量都是已知的，因此我们可以用这些已知变量推导出一些式子，然后我们判断这些式子是否正确就可以判断是否为真话还是假话了。因此可以在这里讨论真假话：</p>
<ul>
<li><p>如果$x$和$y$是同类，那么深度差为0，那么有如下式子推导：</p>
<p>$dx=dy\iff$</p>
<p>$dx=dy+0\iff$</p>
<p>$dx-dy=0\iff$</p>
<p>$(dx-dy+3)%3=0$    由于$x$和$y$是同类， 根据题意，此时$c=1$，我们可以发现式子中的0其实就是$c-1=1-1=0$。因此用$c-1$代替0即可</p>
<p>$\iff (dx-dy+3)%3=c-1$   也就是说当$x$和$y$在同一个集合，然后$x$和$y$是同类时，如果满足$(dx-dy+3)%3$与$c-1$相等，则说明是真话，否则就是假话</p>
</li>
<li><p>如果$x$和$y$是异类，假设$x$吃$y$，那么深度差为$d[x]-d[y]=1$或者$d[x]-d[y]=-2$。如上图所示，1吃2，那么深度差为$d[1]-d[2]=0-2=-2$；2吃3，那么深度差为$d[2]-d[3]=2-1=1$，对于深度差为-2的话，我们可以先加上3，然后就会变为1了，接着在模3即可，对于深度差为1的话，我们先加上3，然后就会变为4，接着再模3即可。那么有如下式子推导：</p>
<p>$dx=dy+1\iff$</p>
<p>$dx-dy=1\iff$</p>
<p>$(dx-dy+3)%3=1\iff $    由于$x$和$y$是异类，$x$吃$y$，根据题意，此时$c=2$，我们可以发现式子中的1其实就是$c-1=2-1=1$。因此用$c-1$代替1即可</p>
<p>$(dx-dy+3)%3=c-1$   也就是说当$x$和$y$在同一个集合，然后$x$和$y$是异类时，如果满足$(dx-dy+3)%3$与$c-1$相等，则说明是真话，否则就是假话</p>
<p>因此，从上面分析可知，在同一个集合中，不论是同类还是被吃关系，公式统一为$(dx-dy+3)%3=c-1$，如果不满足此等式，则为假话</p>
<p><strong>算法设计</strong>：</p>
<ol>
<li>若$x$或$y$大于$n$，或者$c=2$并且$x==y$，则为假话</li>
<li>执行c x y指令时，首先查询$x$和$y$的集合号。查询集合号回归时，更新这条路径上每个节点的深度，$d[x]=(d[x]+d[f_x])%3$。设$x$的集合号为$a$，$y$的集合号为$b$，则分以下两种情况讨论：<ul>
<li>当$a\neq b$时，说明$x$和$y$不在同一个集合中，那么需要合并$p[a]=b$，更新$a$的深度为$d[a]=(d[y]-d[x]+3+c-1)%3$</li>
<li>当$a=b$时，说明$x$和$y$在同一个集合中，如果$(d[x]-d[y]+3)%3!=c-1$，则为假话</li>
</ul>
</li>
</ol>
<p><strong>算法实现：</strong></p>
<p>（1）初始化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    p[i]=i;</span><br><span class="line">      d[i]=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>（2）查找集合号。查询$x,y$的集合号，在返回过程中，除了要统一路径上每个节点的集合号外，还要更新$d[x]$的值（将当前节点的$d$值($d[x]$)累加其父节点的$d$值$d[f_x]$模3）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x!=p[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u=<span class="built_in">find</span>(p[x]);</span><br><span class="line">        d[x]=(d[x]+d[p[x]])%<span class="number">3</span>;</span><br><span class="line">        p[x]=u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>（3）判断假话数量。对输入的每一条指令，如果$x$或$y$大于$n$，或者$c=2$并且$x==y$，则为假话，$total$++；否则查询集合号，设$x$的集合号为$a$，$y$的集合号为$b$，当$a\neq b$时，合并集合号$p[a]=b$，更新$a$的深度为$d[a]=(d[y]-d[x]+3+c-1)%3$，当$a=b$时，说明$x$和$y$在同一个集合中，如果$(d[x]-d[y]+3)%3!=c-1$，则为假话，$total++$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(k--)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;c,&amp;x,&amp;y);</span><br><span class="line">    <span class="keyword">if</span>(x&gt;n||y&gt;n||(c==<span class="number">2</span>&amp;&amp;x==y))</span><br><span class="line">        total++;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="built_in">find</span>(x);</span><br><span class="line">        <span class="keyword">int</span> b=<span class="built_in">find</span>(y);</span><br><span class="line">        <span class="keyword">if</span>(a==b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((dx-dy+<span class="number">3</span>)%<span class="number">3</span>!=c<span class="number">-1</span>)</span><br><span class="line">                total++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p[a]=b;</span><br><span class="line">            d[a]=(d[y]-d[x]+<span class="number">3</span>+c<span class="number">-1</span>)%<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 50010</span></span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="keyword">int</span> total;</span><br><span class="line"><span class="keyword">int</span> p[N],d[N];</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">//每个点都是独立的集合  集合号为它自身</span></span><br><span class="line">		p[i]=i;</span><br><span class="line">        <span class="comment">//每个节点到它自身的距离为0  即自身深度为0</span></span><br><span class="line">		d[i]=<span class="number">0</span>;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在查询点x的祖宗节点过程中  更新d[x]的新值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x!=p[x])</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">//寻找节点x的父节点</span></span><br><span class="line">		<span class="keyword">int</span> u=<span class="built_in">find</span>(p[x]);</span><br><span class="line">        <span class="comment">//更新d[x]的值</span></span><br><span class="line">		d[x]=(d[x]+d[p[x]])%<span class="number">3</span>;</span><br><span class="line">        <span class="comment">//回溯时进行了路径压缩,记录每个节点x的祖宗节点为u</span></span><br><span class="line">        p[x]=u;</span><br><span class="line">	&#125; 	</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="comment">//先进行初始化操作</span></span><br><span class="line">	<span class="built_in">init</span>();</span><br><span class="line">	<span class="keyword">while</span>(k--)</span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="keyword">int</span> c,x,y;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;c,&amp;x,&amp;y);</span><br><span class="line">        <span class="comment">//x或y大于n,或者是x吃y,并且x==y,即同类吃同类  则为假话</span></span><br><span class="line">		<span class="keyword">if</span>(x&gt;n||y&gt;n||(c==<span class="number">2</span>&amp;&amp;x==y))</span><br><span class="line">			total++;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> a=<span class="built_in">find</span>(x);  <span class="comment">//查询节点x的集合号(祖宗节点)</span></span><br><span class="line">			<span class="keyword">int</span> b=<span class="built_in">find</span>(y);  <span class="comment">//查询节点y的集合号(祖宗节点)</span></span><br><span class="line">            <span class="comment">//如果集合号相同,说明x和y在同一个集合中,那么不需要合并</span></span><br><span class="line">			<span class="keyword">if</span>(a==b)</span><br><span class="line">			&#123;</span><br><span class="line">                <span class="comment">//如果d[x]-d[y]+3)%3不等于c-1,则为假话</span></span><br><span class="line">				<span class="keyword">if</span>((d[x]-d[y]+<span class="number">3</span>)%<span class="number">3</span>!=c<span class="number">-1</span>)</span><br><span class="line">					total++;</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">//否则说明集合号不同,说明x和y不在同一个集合中,那么就需要进行合并操作了</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				p[a]=b; <span class="comment">//a的父节点是b</span></span><br><span class="line">                <span class="comment">//更新节点a到父节点的距离d[a]</span></span><br><span class="line">				d[a]=(d[y]-d[x]+<span class="number">3</span>+c<span class="number">-1</span>)%<span class="number">3</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,total);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
</li>
</ul>
]]></content>
      <categories>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>银河</title>
    <url>/2021/07/31/Algorithm-Improvement/Chapter3---Gragh-Theory/%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/%E9%93%B6%E6%B2%B3/</url>
    <content><![CDATA[<h1 id="银河"><a href="#银河" class="headerlink" title="银河"></a>银河</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210731115115.png" alt="image-20210731115115142"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>这题其实与<a href="https://blog.csdn.net/qq_45832461/article/details/118653628">糖果</a> 是一模一样的，只不过我们在那题中使用的是玄学栈+spfa的差分约束算法来求解的。</p>
<p>我们可以借助差分约束的思想，求这$N$个恒星亮度值总和至少有多大，要想总和最小，则必须要求每个恒星亮度最小，也就是求变量$a_i$的最小值，所有的$a_i$最小，这$N$个恒星亮度值总和也就是最小的了。求变量的最小，那么也就是需要跑最长路。</p>
<ul>
<li>根据题目描述如果$X=1$，则$A=B$，即有$A\geq B+0$，$B\geq A+0$ 。因此需要从节点$B$向节点$A$连一条权值为0的边，从节点$A$向节点$B$连一条权值为0的边</li>
<li>根据题目描述如果$X=2$，则$B\geq A+1$，因此从节点$A$向节点$B$连一条权值为1的边</li>
<li>根据题目描述如果$X=3$，则$A\geq B+0$，因此从节点$B$向节点$A$连一条权值为0的边</li>
<li>根据题目描述如果$X=4$，则$A\geq B+1$，因此从节点$B$向节点$A$连一条权值为1的边</li>
<li>根据题目描述如果$X=5$，则$B\geq A+0$，因此从节点$A$向节点$B$连一条权值为0的边</li>
<li>同时，由题干”要求每个小朋友都要分到苹果“，因此可以知道$a_i&gt;0$，即$a_i\geq 1$，那么可以添加一个超级源点$a_0$，$a_0$为0。那么$a_i+a_0\geq a_0+1$，即$a_i\geq a_0+1$，因此从超级源点$a_0$向节点$a_i$连一条权值为1的边</li>
</ul>
<p>然而，本题数据范围达到了$10^5$级别，并且数据较强，直接使用spfa算法求最长路并判断是否存在正环会超时，那么就需要更加高效的算法了。</p>
<p>仔细观察，我们根据差分约束系统建立的有向图中，边权只有0和1这两种情况。根据差分约束思想可知，这个题无解的条件是图中存在正环。我们知道一个强连通分量它是一个环，如果一个强连通分量中存在至少一条边的权值&gt;0，则这个强连通分量就是一个正环，那么该题目无解。为什么呢？因为假设这个强连通分量有一条边权为1的边，然后该强连通分量中的其他边的权值都0，那么无限在这个强连通分量中转圈，每转一圈，总和+1，那可以在这个环内无限转圈，那么最终总和就为正无穷，那刚好就符合正环的定义。</p>
<p>因此，得出以下结论：</p>
<ul>
<li>如果图中存在环，那么环内所有边的权值都必须为0，此时该题才能有解</li>
<li>如果图中存在环，那么环内至少存在一条边的权值&gt;0，此时该题无解</li>
</ul>
<p>因此，我们可以使用tarjan算法求出强连通分量，只要强连通分量内部存在长度为1的边，则直接判定无解。</p>
<p>如果有解，那么每个强连通分量内部各个恒星到超级源点0的距离都是相等的，也就是说此时每个强连通分量内部各个恒星的亮度是相等的。如下图解释：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210731121249.png" alt="image-20210731121249452"></p>
<p>那么我们就可以用tarjan算法求出强连通分量，然后执行”缩点“，得到一张边权为0或1的有向无环图。强连通分量编号scc从大到小遍历就是拓扑序了，那么可以对这张DAG按照拓扑序进行递推求解最长路了，即可以在$O(N+M)$时间内求出到达每个强连通分量的最长路，那么就是该强连通分量内所有恒星的最小亮度。</p>
<p>设某个强连通分量scc中有$x$个节点，设某个节点$y$到超级源点的最长路是$a$，那么这$x$个节点到超级源点的最长路的权值总和就是$x\times a$。</p>
<p><strong>算法设计：</strong></p>
<ul>
<li>使用tarjan算法求出强连通分量</li>
<li>缩点得到一张DAG图，并把这张有向无环图建立出来</li>
<li>依据拓扑序递推求解最长路</li>
</ul>
<p>需要建立的边数：如果$M$取到最大值1e5，由于$A\to B$，也可以$B\to A$，因此需要2e5条边，同时还要从虚拟源点向这$N$个点建立一条权值为1的边，因此还需要1e5条边，于是需要2e5+1e5=3e5条边。但这是原图需要的总边数，我们还需要考虑新图DAG的边数，那么开2倍的3e5就好了。因此总共需要的边数就是$6\times10^5$条边</p>
<p>注意：由于每颗恒星的亮度是递增的，结果有可能爆int，因此需要开long long 来存储。</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">6e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N],hs[N],e[M],ne[M],w[M],idx;</span><br><span class="line"><span class="comment">//表示节点u深度优先遍历的序号（也就是节点u被访问的时间点）</span></span><br><span class="line"><span class="comment">//表示节点u或节点u的子孙能够通过非父子边追溯到的dfn最小的节点序号</span></span><br><span class="line"><span class="comment">//即回到最早的过去（也就是节点u通过有向边可回溯到的最早的时间点）</span></span><br><span class="line"><span class="comment">//num表示时间戳</span></span><br><span class="line"><span class="keyword">int</span> dfn[N],low[N],num;</span><br><span class="line"><span class="comment">//a=id[x]表示x这个节点属于a这个强连通分量</span></span><br><span class="line"><span class="comment">//cnt[i]=100表示i这个强连通分量有100个节点</span></span><br><span class="line"><span class="comment">//scc表示强连通分量的编号 scc=3表示第3个强连通分量 最终也只有scc个强连通分量</span></span><br><span class="line"><span class="keyword">int</span> id[N],cnt[N],scc;</span><br><span class="line"><span class="comment">//栈用来存储访问的节点  top是栈顶指针</span></span><br><span class="line"><span class="keyword">int</span> stk[N],top; </span><br><span class="line"><span class="comment">//din存储每个节点的入度 dout存储每个节点的出度 </span></span><br><span class="line"><span class="keyword">int</span> din[N],dout[N];</span><br><span class="line"><span class="comment">//in_stk[i]=true表示节点i还在栈中</span></span><br><span class="line"><span class="keyword">bool</span> in_stk[N];</span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> h[],<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u]=low[u]=++num;    <span class="comment">//给节点u分配一个时间戳</span></span><br><span class="line">    stk[++top]=u;           <span class="comment">//将节点u入栈</span></span><br><span class="line">    in_stk[u]=<span class="literal">true</span>;         <span class="comment">//标记节点u在栈中</span></span><br><span class="line">    <span class="comment">//遍历节点u的所有邻接点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];~i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j=e[i]; <span class="comment">//u的邻接点j</span></span><br><span class="line">        <span class="comment">//根据分析得出：先会执行else if中的更新语句,才会执行if中的回溯过程中的更新语句</span></span><br><span class="line">        <span class="comment">//如果节点j还没有被访问过</span></span><br><span class="line">        <span class="keyword">if</span>(!dfn[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(j);<span class="comment">//递归访问j</span></span><br><span class="line">            <span class="comment">//回溯是更新从节点j往回到节点u这条路径上的所有节点的low值</span></span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[u],low[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则说明节点j已经被访问过了 看j是否还在栈中</span></span><br><span class="line">        <span class="comment">//如果还在栈中 那么就说明形成了环 即存在强连通分量</span></span><br><span class="line">        <span class="comment">//当走到这里时说明j先于u被访问,因此u可以追溯到更早的过去</span></span><br><span class="line">        <span class="comment">//于是用更早的dfn[j]来更新low[u]</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(in_stk[j])</span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[u],dfn[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//退无可退 即此时u不能追溯到更早的过去了 那么它就是这个强连通分量的入口</span></span><br><span class="line">    <span class="keyword">if</span>(dfn[u]==low[u])</span><br><span class="line">    &#123;</span><br><span class="line">        scc++;  <span class="comment">//强连通分量的个数+1</span></span><br><span class="line">        <span class="keyword">int</span> y;</span><br><span class="line">        <span class="comment">//输出这个强连通分量中所包含的节点</span></span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            y=stk[top--];       <span class="comment">//强连通分量的节点y</span></span><br><span class="line">            in_stk[y]=<span class="literal">false</span>;    <span class="comment">//标记节点y不在栈中</span></span><br><span class="line">            id[y]=scc;      <span class="comment">//节点y属于scc这个强连通分量</span></span><br><span class="line">            cnt[scc]++;     <span class="comment">//scc这个强连通分量中的节点个数增加了y这个节点</span></span><br><span class="line">        &#125;<span class="keyword">while</span>(y!=u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">memset</span>(hs,<span class="number">-1</span>,<span class="keyword">sizeof</span> hs);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="comment">//从超级源点0向其他n个节点连一条长度为1的有向边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">add</span>(h,<span class="number">0</span>,i,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t,a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;t,&amp;a,&amp;b);</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">add</span>(h,a,b,<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">add</span>(h,b,a,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="number">2</span>)</span><br><span class="line">            <span class="built_in">add</span>(h,a,b,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="number">3</span>)</span><br><span class="line">            <span class="built_in">add</span>(h,b,a,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="number">4</span>)</span><br><span class="line">            <span class="built_in">add</span>(h,b,a,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="number">5</span>)</span><br><span class="line">            <span class="built_in">add</span>(h,a,b,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//由于超级源点可达其他的n个节点  因此直接从超级源点0开始执行tarjan算法即可</span></span><br><span class="line">    <span class="built_in">tarjan</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//给这个DAG建图</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)<span class="comment">//从超级源点0到节点n</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//遍历节点i的所有邻接点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=h[i];~j;j=ne[j])  <span class="comment">//j是边</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> k=e[j]; <span class="comment">//k是i的邻接点</span></span><br><span class="line">            <span class="keyword">int</span> a=id[i];</span><br><span class="line">            <span class="keyword">int</span> b=id[k];</span><br><span class="line">            <span class="comment">//如果节点a和节点b在同一个强连通分量</span></span><br><span class="line">            <span class="keyword">if</span>(a==b)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//如果同一个强连通分量中有长度大于1的边,则说明该强连通分量是一个正环  无解</span></span><br><span class="line">                <span class="keyword">if</span>(w[j]&gt;<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    flag=<span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果节点a和节点b不在同一个强连通分量  则建图</span></span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="built_in">add</span>(hs,a,b,w[j]);   <span class="comment">//w[j]是j这条边的的权值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//无解</span></span><br><span class="line">    <span class="keyword">if</span>(!flag)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//scc从大到小就是拓扑序</span></span><br><span class="line">        <span class="comment">//按照拓扑序递推求解最长路</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=scc;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//遍历节点i的所有邻接点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=hs[i];~j;j=ne[j]) <span class="comment">//j是边</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> k=e[j]; <span class="comment">//k是i的邻接点</span></span><br><span class="line">                dist[k]=<span class="built_in">max</span>(dist[k],dist[i]+w[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        LL res=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//累加每个点到超级源点的最长路</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=scc;i++)</span><br><span class="line">            res+=(LL)dist[i]*cnt[i];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>有向图的强连通分量</category>
      </categories>
      <tags>
        <tag>tarjan求有向图的强连通分量</tag>
      </tags>
  </entry>
</search>
