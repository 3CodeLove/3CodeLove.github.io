<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>二分图的最大匹配</title>
    <url>/2021/07/13/%E7%AE%97%E6%B3%95%E6%8F%90%E9%AB%98%E8%AF%BE/%E7%AC%AC%E4%B8%89%E7%AB%A0---%E5%9B%BE%E8%AE%BA/%E4%BA%8C%E5%88%86%E5%9B%BE/%E4%BA%8C%E5%88%86%E5%9B%BE%E7%9A%84%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h1 id="二分图的最大匹配"><a href="#二分图的最大匹配" class="headerlink" title="二分图的最大匹配"></a>二分图的最大匹配</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210713135825.png" alt="image-20210713135825492"></p>
<hr>
<h3 id="二分图的最大匹配-1"><a href="#二分图的最大匹配-1" class="headerlink" title="二分图的最大匹配"></a>二分图的最大匹配</h3><p>从题目中给出的二分图匹配的定义可知，匹配其实也是一张图，并且图中的点数是边数的2倍。</p>
<p>如下图所示：二分图的匹配</p>
<p>红色边组成的 4 个结点、2条边就是这个二分图的一个匹配了；</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210713140235.png" alt="image-20210713140235437"></p>
<p><strong>二分图最大匹配定义</strong>：最大匹配就是找到一个子图，满足是匹配，并且边数（点数）最多。</p>
<p>如下图所示：二分图的最大匹配</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210713140350.png" alt="image-20210713140350842"></p>
<hr>
<h3 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h3><p>匈牙利算法可以用来求解二分图的最大匹配问题。匈牙利算法也被戏称为“相亲算法”，它的大致过程是这样的：</p>
<ul>
<li><p>有两个点集，分别是男生和女生，$X$点集中全部都是男生，$Y$点集中全部都是女生</p>
</li>
<li><p>然后男生取追求女生，如果男生$X_a$对女生$Y_b$有好感，并且女生$Y_b$也有男生$X_a$有好感，那么男生$X_a$就有很大机会可以追到女生$Y_b$，否则如果女生$Y_b$不喜欢男生$X_a$，那么男生$X_a$就不会再追求女生$Y_b$，而是继续去寻找其他女生  （不想当<del>舔狗</del>)</p>
</li>
<li><p>作为一个男人，要主动出击。因此约定都是男生追女生，即开始先从点集$X$出发</p>
</li>
<li><p>每个男生可以选遍所有他喜欢的女生：如果某位女生还是单身并且没有其他男生追求她，那么 女人 拿来吧你，恭喜你，直接配对；如果特别喜欢的这个女生已经有男朋友了，则这个女生会让她男朋友再去找其他女生（爱情就是这么<del>不堪一击</del>)，又转化成了另一个男生去寻找女生的过程，继续递归找；</p>
</li>
<li><p>那么最终的结果就有两种情况：</p>
<ul>
<li><p>由于这个男生的插足，导致最后可能有一个男生被抛弃，这是不道德的行为，所以不能干这种事情！（如下图，结局好惨）</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210713142754.png" alt="image-20210713142754572"></p>
</li>
<li><p>由于这个男人的插足，导致所有的男女关系都进行了一次轮换，但是匹配的对数多了一对；（成功<del>横刀夺爱</del>）</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210713143031.png" alt="image-20210713143030993"></p>
</li>
</ul>
</li>
</ul>
<p>以上就是匈牙利算法的相亲过程，算法很简单也很有趣，教会了<del>恋爱丛林法则</del></p>
<hr>
<h3 id="匈牙利算法实现"><a href="#匈牙利算法实现" class="headerlink" title="匈牙利算法实现"></a>匈牙利算法实现</h3><p>先来给出以下变量的定义：</p>
<ul>
<li><code>st[j]</code>这个是个bool类型数组，用来表示某个女生有没有被男生访问联系过，如果$st[j]=true$，表示$j$这个女生已经某个男生联系过了</li>
<li><code>match[j]</code>是个int类型的数组，用来表示$j$这个女生她现任男友的编号，如果$match[j]=a$，表示$j$这个女生她现任男友的编号为$a$</li>
</ul>
<p>算法流程：</p>
<ul>
<li>将男生和女生分成点集$X$和$Y$</li>
<li>由于是男生掌握主动权，所以只需要建立有向图，从男生节点向女生节点引出有向边即可</li>
<li>从男生点集$X$出发，假设某个男生$u$，遍历$u$这个节点所有的邻接点$v$（即他喜欢的所有女生）<ul>
<li>如果这个女生$v$处于单身状态，$v$还没有匹配，那么此时$(u,v)$就是一组成功的匹配（在一起了），所以匹配的数量+1</li>
<li>如果这个女生$v$虽然有男朋友了，但是她可能对这个男生$u$有点意思，所以让她现任男友$c$去寻找其他女生，假设男生$c$是个<del>海王</del>（本来就是），他确实有很多青青草原，然后他找到了后宫中的女生$d$，最终女生$d$答应了他，于是他俩就在一起了，那么此时女生$v$就处于单身状态，于是男生$u$就成功和她在一起了，可以发现此时又成功匹配了一对情侣，所以匹配数目+1；但是如果后宫中的女生$d$知道男生$c$是海王，拒绝了他，那么男生$c$和她女友$v$说 我还是只爱你一人，因此他俩还是继续在一起，那么很可惜男生$u$还是<del>单身狗</del>。因此这次$u$的匹配失败。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>, M = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n1, n2, m;<span class="comment">//n1表示左侧男生的个数  n2表示右侧女生的个数</span></span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="comment">//match[j]=a,表示女孩j的现有配对男友是a</span></span><br><span class="line"><span class="keyword">int</span> match[N];<span class="comment">//右边女生所对应的左边男孩,即女生现在和哪个男生的在一起</span></span><br><span class="line"><span class="keyword">bool</span> st[N];<span class="comment">//临时预定数组，st[j]=a表示一轮模拟匹配中，女孩j被男孩a预定了。 避免重复搜索女孩</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断x这个男生能不能找到匹配的女生</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//依次遍历自己喜欢的女孩</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];<span class="comment">//获取女孩在图中的顶点的编号</span></span><br><span class="line">        <span class="comment">//如果j这个女孩之前还没有被考虑过，在这一轮模拟匹配中,这个女孩尚未被预定</span></span><br><span class="line">        <span class="keyword">if</span> (!st[j])<span class="comment">//j这个女孩还没有被男生x访问过</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//标记j这个女孩被男生x访问过了</span></span><br><span class="line">            st[j] = <span class="literal">true</span>;<span class="comment">//表示j这个女孩已经被x男孩看上了，被考虑过啦，x男孩已经预定了j这个女孩</span></span><br><span class="line">            <span class="comment">//match[j]==0表示j这个女孩还没有匹配任何男孩，即j女孩还没有男朋友 j目前没有任何可以匹配的节点</span></span><br><span class="line">            <span class="comment">//find(match[j])=true表示j这个女孩虽然已经匹配了某个男孩,但是她匹配的这个男孩是个海王</span></span><br><span class="line">            <span class="comment">//留有后手随时可以找到其他女孩来代替她，那么此时j女孩被甩处于单身状态,j告诉x说我们在一起吧</span></span><br><span class="line">            <span class="comment">//那么执着追j女孩的这个x男子就击败了j女孩的所有暗恋者，有机会了</span></span><br><span class="line">            <span class="comment">//也就是说j有和它匹配的点(现任男友),但是呢这个点(现任男友)能够通过一些办法来找到新的匹配</span></span><br><span class="line">            <span class="keyword">if</span> (match[j] == <span class="number">0</span> || <span class="built_in">find</span>(match[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                match[j] = x;<span class="comment">//表示j女孩已经匹配成功了，现有配对男友是x</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//返回true表示配对成功</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果遍历过x男子所喜欢的女生中，都没能找到合适的，自己中意的全部都被预定了。</span></span><br><span class="line">    <span class="comment">//配对失败。即没有配对成功，则返回false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n1, &amp;n2, &amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a, b);<span class="comment">//虽然是无向图，但是因为是左侧男生去找女朋友，单向追求，所以用“有向图”就行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;<span class="comment">//res表示匹配的数量</span></span><br><span class="line">    <span class="comment">//依次枚举左半部分的男生该去找哪个女孩</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//要保证每个女孩只被考虑一遍</span></span><br><span class="line">        <span class="comment">//因为每次模拟匹配的预定情况都是不一样的所以每轮模拟都要初始化</span></span><br><span class="line">        <span class="comment">//如果不初始化则当男生i进行匹配操作后会修改st的内容  那么会保留这个内容</span></span><br><span class="line">        <span class="comment">//当下一个男生i+1进行匹配操作时 就会用到上一个男生i保留的st的内容  就会出错</span></span><br><span class="line">        <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);<span class="comment">//把每个女孩的匹配状态清空，表示这些女孩还没有被考虑过</span></span><br><span class="line">        <span class="comment">//如果i这个男子成功的找到了匹配的妹子  那么匹配个数+1</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find</span>(i))</span><br><span class="line">            res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>二分图</category>
      </categories>
      <tags>
        <tag>匈牙利算法</tag>
      </tags>
  </entry>
  <entry>
    <title>染色法判定二分图</title>
    <url>/2021/07/13/%E7%AE%97%E6%B3%95%E6%8F%90%E9%AB%98%E8%AF%BE/%E7%AC%AC%E4%B8%89%E7%AB%A0---%E5%9B%BE%E8%AE%BA/%E4%BA%8C%E5%88%86%E5%9B%BE/%E6%9F%93%E8%89%B2%E6%B3%95%E5%88%A4%E5%AE%9A%E4%BA%8C%E5%88%86%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="染色法判定二分图"><a href="#染色法判定二分图" class="headerlink" title="染色法判定二分图"></a>染色法判定二分图</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210713124859.png" alt="image-20210713124859893"></p>
<hr>
<h3 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h3><p>二分图的含义：二分图是有两组点集$X$和$Y$组成的无向图，其中点集$X$中的点之间互相没有关联，点集$Y$中的点之间互相没有关联，但是点集$X$中的点和点集$Y$中的点之间可能存在关联，用一条无向边来表示这种关联。</p>
<p>如下图所示：</p>
<p>橙色节点都属于点集$X$，互相之间没有边相连；蓝色节点都属于点集$Y$，互相之间没有边相连。绿色代表无向边，用来连接点集$X$和点集$Y$中的节点。</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210713125403.png" alt="image-20210713125403160"></p>
<hr>
<h3 id="二分图的判定"><a href="#二分图的判定" class="headerlink" title="二分图的判定"></a>二分图的判定</h3><h4 id="圈的定义"><a href="#圈的定义" class="headerlink" title="圈的定义"></a>圈的定义</h4><p>图论中圈的定义是：任选一个顶点为起点，沿着不重复的边，经过不重复的顶点，之后又回到起点的闭合路径。</p>
<p>如下图所示：</p>
<p>$1-&gt;2-&gt;4-&gt;3-&gt;1$就是一个圈</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210713130025.png" alt="image-20210713130025270"></p>
<ul>
<li>偶数圈就是经过路径中的顶点数为偶数的圈，如上图，$1-&gt;2-&gt;4-&gt;3-&gt;1$</li>
<li>奇数圈就是经过路径中的顶点数为奇数的圈，如下图，$1-&gt;2-&gt;4-&gt;5-&gt;3-&gt;1$</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210713131614.png" alt="image-20210713131614073"></p>
<h4 id="二分图的判定性质"><a href="#二分图的判定性质" class="headerlink" title="二分图的判定性质"></a>二分图的判定性质</h4><p><strong>判定性质：判断一个图是不是二分图，其实就是判断这个图有没有奇圈</strong></p>
<p>如下图所示：</p>
<p>我们把这个图划分成了两个点集$X$和$Y$</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210713130951.png" alt="image-20210713130951633"></p>
<p>但是如果存在奇圈的话，就会变成如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210713131058.png" alt="image-20210713131058769"></p>
<p>因此，我们可以通过观察奇偶性可知，相邻的两个节点的奇偶性一定是不相同的，分别对应到两个不同的点集$X$和$Y$中。那么当存在奇圈时，则说明相邻的这两个节点奇偶性一定是相同的，这与二分图的性质矛盾。</p>
<hr>
<h3 id="染色法判定二分图-1"><a href="#染色法判定二分图-1" class="headerlink" title="染色法判定二分图"></a>染色法判定二分图</h3><p>二分图染色算法的实现是通过判断一个图中是否存在奇圈从而确定它是否是二分图。    </p>
<p>染色法的算法步骤如下：</p>
<ul>
<li><p>设染色只有2种颜色，$color$为1和2</p>
</li>
<li><p>选择当前还没有被染色的节点作为当前节点$u$，给它染上颜色1，即$color[u]=1$</p>
</li>
<li>遍历该节点的所有邻接点$v$，并给这些邻接点染色，即$color[v]=3-color[u]$</li>
<li>重复上面两个步骤，直到全部染色完毕</li>
<li>如果染色过程种发生了矛盾，即相邻两个节点的颜色相同，则说明不满足二分图的奇偶性，因此可以判定出该图不是二分图；否则说明全部都成功无矛盾染色，该图是二分图</li>
</ul>
<p>注意：由于二分图可能是一个非连通图，所以不是只访问一个结点就能遍历到所有结点的，需要对所有结点都进行一次遍历。</p>
<p>染色法可以用dfs和bfs实现，算法思路其实都是一样的</p>
<blockquote>
<p>问题：如何理解dfs染色法中的下列代码呢？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(color[j]==c)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>如上图，假设当前节点是$u$，设$u=4$，设当前节点$u$的被染上的颜色为$c$。我们来看它的邻接点$j=2$。我们发现，其实在前面的时候，节点$1$就已经把节点$2$染过色了，染的颜色为$color[j]$。那么当节点$u$遍历到节点$j$时，发现节点$j$已经被染过色了，那么我们就只需要判断节点$j$的颜色是否与当前节点$u$的颜色相同。如果相同，则不符合二分图的奇偶性，则该图不是二分图；</p>
</blockquote>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><strong>dfs染色法：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//dfs染色法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, M = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="keyword">int</span> color[N];<span class="comment">//给图的每个顶点染色的数组</span></span><br><span class="line"><span class="comment">//构造无向图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//dfs函数是用来判定染色过程中是否出现了矛盾，如果出现了矛盾，则返回false</span></span><br><span class="line"><span class="comment">//如果没有出现矛盾，就返回true</span></span><br><span class="line"><span class="comment">//这里假设染了两种颜色1 和 2</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    color[u] = c;<span class="comment">//u这个顶点染上c的颜色</span></span><br><span class="line">    <span class="comment">//拓展u这个顶点的邻接表，去寻找邻接点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="comment">//如果j顶点还没有被染过色</span></span><br><span class="line">        <span class="keyword">if</span> (!color[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果当这个j顶点染上色之后，就出现了矛盾，那么让flag为false</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(j, <span class="number">3</span> - c))<span class="comment">//3 - c表示所染的颜色一定是在1和2之间</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里说明j之前已经被染过色了 那么判断一下当前节点u的颜色和它的邻接点j的颜色是否相同</span></span><br><span class="line">        <span class="comment">//如果相同则说明一条边的两个顶点都是染相同的颜色,则不满足二分图的奇偶性</span></span><br><span class="line">        <span class="comment">//那么就会出现染色矛盾</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (color[j] == c)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//染色成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="built_in">add</span>(a, b);</span><br><span class="line">        <span class="built_in">add</span>(b, a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;<span class="comment">//flag用来判断染色是否有矛盾，如果出现矛盾,则为false,否则就是true</span></span><br><span class="line">    <span class="comment">//对1号顶点到n号顶点分别染色</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果当前i这个顶点还没有被染色的话  !color[i]表示当前i顶点还没有被染色</span></span><br><span class="line">        <span class="keyword">if</span> (!color[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果当这个i顶点染上色之后，就出现了矛盾，那么让flag为false，然后break退出for循环</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(i, <span class="number">1</span>))<span class="comment">//有两种颜色  颜色1和颜色2</span></span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果染色过程中没有出现矛盾，成功给每个顶点染色了，输出Yes</span></span><br><span class="line">    <span class="keyword">if</span> (flag)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="comment">//否则如果染色过程中出现了矛盾，则输出No</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bfs染色法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//bfs染色法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, M = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="keyword">int</span> color[N];<span class="comment">//给图的每个顶点染色的数组</span></span><br><span class="line"><span class="comment">//bfs的队列</span></span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line"><span class="comment">//构造无向图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//bfs染色法 c是颜色  0 表示还没有染色 1表示染了一种颜色  2表示染了另一种颜色</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    color[u]=c;     <span class="comment">//给u这个节点染上颜色c</span></span><br><span class="line">    q.<span class="built_in">push</span>(u);      <span class="comment">//将u这个节点加入队列q中</span></span><br><span class="line">    <span class="comment">//当队列不为空时</span></span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//取出队头元素</span></span><br><span class="line">        <span class="keyword">int</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();    <span class="comment">//队头元素已经出队了,弹掉队头元素</span></span><br><span class="line">        <span class="comment">//遍历队头元素t的所有邻接点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//队头元素t的邻接点j</span></span><br><span class="line">            <span class="keyword">int</span> j=e[i];</span><br><span class="line">            <span class="comment">//如果j还没有被染色</span></span><br><span class="line">            <span class="keyword">if</span>(!color[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//由于j是t的邻接点 所以它俩奇偶性不同 染色不一样</span></span><br><span class="line">                color[j]=<span class="number">3</span>-color[t];</span><br><span class="line">                <span class="comment">//将j加入队列q中</span></span><br><span class="line">                q.<span class="built_in">push</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//否则说明j已经被染过色了 但是它的颜色与邻接点t的颜色相同 则不满足奇偶性</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(color[j]==color[t])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a,b);</span><br><span class="line">        <span class="built_in">add</span>(b,a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!color[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">bfs</span>(i,<span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                flag=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>二分图</category>
      </categories>
      <tags>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title>差分约束算法</title>
    <url>/2021/07/11/%E7%AE%97%E6%B3%95%E6%8F%90%E9%AB%98%E8%AF%BE/%E7%AC%AC%E4%B8%89%E7%AB%A0---%E5%9B%BE%E8%AE%BA/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="差分约束系统"><a href="#差分约束系统" class="headerlink" title="差分约束系统"></a>差分约束系统</h1><hr>
<p>差分约束系统是一种特殊的$N$元一次不等式组。它包含$N$个变量$X_1$~$X_N$以及$M$个约束条件，每个约束条件都是由两个变量做差构成的，形如$X_i-X_j\leq c_k$，其中$c_k$是常数（可以是非负数，也可以是负数），$1\leq i,j\leq N,1\leq k\leq M$。我们要解决的问题就是：求一组解$X_1=a_1,X_2=a_2,\cdots,X_N=a_N$，即解$X=(a_1,a_2,\cdots,a_N)$使得所有约束条件都能得到满足。</p>
<p>差分约束系统的每个约束条件$X_i-X_j\leq c_k$可以变形为$X_i\leq X_j+c_k$，这与单源最短路径问题中的三角不等式$dist[y]\leq dist[x]+z$非常相似，注意这个式子是更新过后的。因此，我们可以把每个变量$X_i$看作是有向图中的一个节点$i$，对于每个约束条件$X_i-X_j\leq c_k$，从节点$j$向节点$i$连一条长度为$c_k$的有向边。</p>
<p><strong>引理：</strong></p>
<p>设$X=(x_1,x_2,\cdots,x_n)$是一个差分约束系统的一个解，$d$为任意常数，那么$X+d=(x_1+d,x_2+d,\cdots,x_n+d)$也是该系统的解。</p>
<p>证明：对于每个$x_i$和$x_j$，有$(x_j+d)-(x_i+d)=x_j-x_i$。因此，若$X$是这个差分约束系统的一个解，那么$X+d$也是这个系统的解</p>
<p>例如：</p>
<ul>
<li>$x_1-x_2\leq 0$</li>
<li>$x_1-x_5\leq -1$</li>
<li>$x_2-x_5\leq 1$</li>
<li>$x_3-x_1\leq 5$</li>
<li>$x_4-x_1\leq 4$</li>
<li>$x_4-x_3\leq -1$</li>
<li>$x_5-x_3\leq -3$</li>
<li>$x_5-x_4\leq -3$</li>
</ul>
<p>该问题的一个解为$X=(-5,-3,0,-1,-4)$，令一个解为$X’=(0,2,5,4,1)$，这两个解是有联系的，$X’$中的每个元素比$X$中的相应元素大5</p>
<p>这也正说明了，如果$X$是一个差分约束系统的解，那么$X+d$也是这个系统的解</p>
<p>假设$\forall i,X_i\leq c$，然后再增加一个超级源点0号节点，令$X_0=0$，令$d=-X_0$，等式两边同时加上$d$，可得$X_i-X_0\leq c-X_0$，即$X_i-X_0\leq c$。这样一来，就多了$N$个形如$X_i-X_0\leq 0$的约束条件，应该从节点0向每个节点$i$连一条长度为0的有向边。</p>
<hr>
<h3 id="约束图"><a href="#约束图" class="headerlink" title="约束图"></a>约束图</h3><p>对于$n$个变量，$m$个约束条件来说，其实就是对应于图论中的$n$个节点，$m$条边。对于$i=1,2,\cdots,n$，图中的每一个顶点$v_i$对应着$n$个未知量中的一个$x_i$，图中的每个有向边对应着关于两个未知量的$m$个不等式的其中一个。</p>
<p>对于一个差分约束系统来说，相应的约束图是一个带权有向图$G=(V,E)$，其中$V=${$v_0,v_1,\cdots,v_n$}，而且$E=${$(v_i,v_j):x_j-x_i\leq b_k$}$\bigcup$ {$(v_0,v_1),(v_0,v_2),\cdots,(v_0,v_n)$}</p>
<p>这里引入超级源点$v_0$是为了保证其他每个顶点$v_1,v_2,\cdots,v_n$均从$v_0$可达。因此，顶点集合$V$由对应于每个未知量$x_i$的顶点$v_i$和附加的顶点$v_0$所组成。边的集合$E$由对应于每个差分约束条件的边与对应于每个未知量$x_i$的边$(v_0,v_i)$所构成。如果$x_j-x_i\leq b_k$是一个差分约束，则边$(v_i,v_j)$的权$w(v_i,v_j)=b_k$。从超级源点$v_0$出发的每条边的权值均为0。</p>
<p>约束图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210707093851.png" alt="image-20210707093808678"></p>
<hr>
<h3 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h3><p>给定一个差分约束系统，设$G=(V,E)$为其相应的约束图。如果$G$不包含负权回路(即负环)，那么</p>
<p>$X=(\delta (v_0,v_1),\delta (v_0,v_2),\delta (v_0,v_3),\cdots,\delta (v_0,v_n))$</p>
<p>是此系统的一个可行解。当且仅当$G$中存在负环时，该系统不存在可行解。</p>
<p>上式中$\delta(v_0,v_1)$表示超级源点$v_0$到节点$v_1$的真实的最短距离，其他同理。跑一边最短路算法后得到的$dist[v_1]$其实就是$\delta(v_0,v_1)$</p>
<p><strong>证明：</strong></p>
<ul>
<li><p>首先来证明，如果$G$中不存在负环时，那么可以求出一个可行解。考察任意边$(v_i,v_j)\in E$，由三角不等式$\delta (v_0,v_j)\leq \delta (v_0,v_i)+w(v_i,v_j)$，即$\delta (v_0,v_j)-\delta (v_0,v_i)\leq w(v_i,v_j)$。因此，设$x_i=\delta (v_0,v_i),x_j=\delta(v_0,v_j)$，带入上式子可知满足对应边$(v_i,v_j)$的差分约束$x_j-x_i\leq w(v_i,v_j)$</p>
</li>
<li><p>接下来再来证明，如果$G$中存在负环，那么差分约束系统不存在可行解。设负权回路为$c=$&lt;$v_1,v_2,\cdots,v_k$&gt;，其中$v_1=v_k$（因为节点$v_0$没有入边，所以它不可能再回路$c$上）。回路$c$对应着如下的差分约束：</p>
<ul>
<li>$x_2-x_1\leq w(v_1,v_2)$</li>
<li>$x_3-x_2\leq w(v_2,v_3)$</li>
<li>$\cdots $</li>
<li>$x_k-x_{k-1}\leq w(v_{k-1},v_k)$</li>
<li>$x_1-x_k\leq w(v_k,v_1)$</li>
</ul>
<p>假设存在满足$k$个不等式的一个解$X$，那么也满足上述$k$个不等式相加所得到的不等式。如果把这些不等式相加，就会发现每个变量$x_i$的正负项相互抵消了，结果左边项和为0，而右边项和为$w(c)$，因此有$0\leq w(c)$。但是由于$c$是一个负权回路，因此有$w(c)&lt;0$，因此得到矛盾$0\leq w(c)&lt;0$，由此得证</p>
</li>
</ul>
<hr>
<p>求不等式组的可行解：</p>
<p>源点需要满足的条件：<strong>从源点出发，一定可以走到所有边</strong></p>
<p>步骤：</p>
<ul>
<li>先将每个不等式$x_i\leq x_j+c_k$，转化为一条从$x_j$走到$x_i$，长度为$c_k$的一条边</li>
<li>找到一个超级源点，使得该源点一定可以遍历到所有边</li>
<li>从源点求一边单源最短路<ul>
<li>如果存在负环，则原不等式组一定无解</li>
<li>如果不存在负环，则$X=(dist[v_1],dist[v_2],\cdots,dist[v_n])$的一个可行解</li>
</ul>
</li>
</ul>
<p>在某些题目中，约束条件形如$X_i-X_j\geq c_k$，我们仍然可以从$j$到$i$连一条长度为$c_k$的有向边，只不过现在应该要计算单源最长路，若图中存在正环则无解。当然，我们也可以把约束条件转换为$X_j-X_i\leq -c_k$，再按照单源最短路进行计算</p>
<hr>
<h3 id="变量的最大值和最小值"><a href="#变量的最大值和最小值" class="headerlink" title="变量的最大值和最小值"></a>变量的最大值和最小值</h3><p>对于给定的一组不等式关系，如何求出每个变量的最大值或者最小值呢？</p>
<blockquote>
<p>什么是最大值或最小值？</p>
<p>这里的意思是说，比如你求出了一个解$X=(x_1,x_2,\cdots,x_n)$，那么$X’=(x_1+d,x_2+d,\cdots,x_n+d)$也是一个解，$X’’=(x_1+2d,x_2+2d,\cdots,x_3+3d)$也是一个解，那么我想知道某个变量$x_i$的最大值，那么到底是取$x_i$还是$x_i+d$还是$x_i+2d$呢？同理，求某个变量$x_i$的最小值也是一样的含义。</p>
</blockquote>
<p>结论：</p>
<ul>
<li>如果求的是最小值，那么应该求单源最长路</li>
<li>如果求的是最大值，那么应该求单源最短路</li>
</ul>
<p><strong>证明：</strong></p>
<p>以求$x_i$的最大值为例：</p>
<p>求所有从$x_i$出发，构成的多个形如如下的不等式链：</p>
<p>$x_i\leq x_j+c_m\leq x_k+c_m+c_n\leq \cdots \leq x_0+c_0+c_4+\cdots +c_n+c_m$，其中$x_0=0,c_0=0$，令$F=$$x_0+c_0+c_4+\cdots +c_n+c_m$</p>
<p>那么$x_i$的最大值，要注意$F$可能多很多个，因此，我们取$F$中最小的那个值，就是$x_i$的最大值</p>
<p>例如$x_i\leq 5,x_i\leq 7,x_i\leq 9$，那么$x_i$的最大值为5。假设$x_i$取最大值为9，那么就不满足$x_i\leq 5$和$x_i\leq 7$了。</p>
<p>把上述转换成图论的问题，其实就是求$dist[i]$的最小值（因为$F$表示的是从起点出发，到达某个点的距离。那么求$F$的最小值，其实就是求单源最短路），那么就可以用最短路来求解。</p>
<p>以求$x_i$的最小值为例：</p>
<p>求所有从$x_i$出发，构成的多个形如如下的不等式链：</p>
<p>$x_i\geq x_j+c_m\geq x_k+c_m+c_n\geq \cdots \geq x_0+c_0+c_4+\cdots +c_n+c_m$，其中$x_0=0,c_0=0$，令$F=$$x_0+c_0+c_4+\cdots +c_n+c_m$</p>
<p>那么$x_i$的最小值，要注意$F$可能多很多个，因此，我们取$F$中最大的那个值，就是$x_i$的最小值</p>
<p>例如$x_i\geq 5,x_i\geq 7,x_i\geq 9$，那么$x_i$的最大值为9。假设$x_i$取最小值为5，那么就不满足$x_i\geq 7$和$x_i\geq 9$了。</p>
<p>下面举个图例：</p>
<ul>
<li>$x_2-x_1\leq c_1$</li>
<li>$x_3-x_2\leq c_2$</li>
<li>$x_3-x_1\leq c_3$</li>
</ul>
<p>那么，我们可以求出这样的：</p>
<ul>
<li>$x_3\leq x_1+c_3$</li>
<li>$x_3\leq x_1+c_1+c_2$</li>
</ul>
<p>可以看出，约束变量$x_3$的有两个条件，如果画到图中，就对应于有2条路径。那么当我们要求$x_3$的最大值时，取的肯定是$x_1+c_3$和$x_1+c_1+c_2$中的最小值，这样才能保证满足这两个约束条件，进而满足题目给定的所有原始的约束条件。</p>
<p>我们添加超级源点$s$即$v_0$，那么有$x_1-x_0\leq c_0$，因此有如下：</p>
<ul>
<li>$x_3\leq x_0+c_0+c_3$</li>
<li>$x_3\leq x_0+c_0+c_1+c_2$</li>
</ul>
<p>其中$x_0=0,c_0=0$</p>
<p>解释一样$x_0+c_0+c_3$的含义：它表示从源点$v_0$到达节点$v_3$所走过的路径上的权值之和。$x_0+c_0+c_1+c_2$也是一样的含义。</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210707094207.png" alt=""></p>
<p>对应有两条路径：</p>
<ul>
<li>$v_0\implies v_1\implies v_3$，从源点$v_0$走到节点$v_3$，所走过的路径之和为$c_0+c_3$</li>
<li>$v_0\implies v_1\implies v_2\implies v_3$，从源点$v_0$走到节点$v_3$，所走过的路径之和为$c_0+c_1+c_2$</li>
<li>可以发现，既然我们知道了等式右边的式子含义，其实就是求从源点出发到达某个节点的距离，由于可能存在多条路径，因此有多个值，那么我们只需要根据单源最短路径算法，就可以求出最小的那个值了，设为$F_{min}$。因此，如果想要求某个变量$x_i$的最大值，那么就要满足$Max(x_i)\leq F_{min}$。这也就是说，求变量$x_i$的最大值，等价于跑一下单源最短路，求出最短路径的权值之和</li>
</ul>
<p>因此，相应的就可以知道，要求$x_i$的最小值，其实就是跑一下单源最长路，求出最长路径的权值之和。</p>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>$x_i\geq x_j+c$，则从节点$j$向节点$i$连一条长度为$c$的边，要求变量$x_i$的最小值，则跑一下最长路即可</li>
<li>$x_i\leq x_j+c$，则从节点$j$向节点$i$连一条长度为$c$的边，要求变量$x_i$的最大值，则跑一下最短路即可</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP</title>
    <url>/2021/07/11/%E7%AE%97%E6%B3%95%E6%8F%90%E9%AB%98%E8%AF%BE/%E7%AC%AC%E4%B8%89%E7%AB%A0---%E5%9B%BE%E8%AE%BA/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/KMP/</url>
    <content><![CDATA[<h1 id="KMP算法详解"><a href="#KMP算法详解" class="headerlink" title="KMP算法详解"></a>KMP算法详解</h1><hr>
<p>求解<code>next[]</code>数组之前要先明白以下数组的概念：</p>
<ul>
<li>前缀：包含首位字符但是不包含末位字符的子串</li>
<li>后缀：包含末位字符但是不包含首位字符的子串</li>
<li><code>next[]</code>数组的含义：当主串S与模式串P的某一位字符不匹配时，模式串P应该回退的位置（数组下标）</li>
<li>$next[i]=j$的含义：即模式串P的前i个字符(包括i)组成的字符串中，最长公共前后缀子串的长度为$j$</li>
</ul>
<p><strong>注意：我们的算法中，字符串的下标都是从1开始，不用下标0，下标为0可以表示空字符。</strong></p>
<p>如下图所示，来看看什么是最长公共前后缀：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210711105744.png" alt="image-20210711105734389"></p>
<ol>
<li>当i=0时，空字符，最长公共前后缀为0</li>
<li>当i=1时，对于单个字符来说，不存在前缀和后缀，因此最长公共前后缀为0</li>
<li>当i=2时，字符串为“AB”，前缀为A，后缀为B，前缀与后缀并不相同，因此最长公共前后缀为0</li>
<li>当i=3时，字符串为“ABC”，前缀为A，AB；后缀为C，BC，前缀与后缀并不相同，因此最长公共前后缀为0</li>
<li>当i=4时，字符串为“ABCA”，前缀为<strong>A</strong>，AB，ABC；后缀为<strong>A</strong>，CA，BCA；有最长的相同的前后缀A，因此最长公共前后缀为1</li>
<li>当i=5时，字符串为“ABCAB”，前缀为A，<strong>AB</strong>，ABC，ABCA；后缀为B，<strong>AB</strong>，CAB，BCAB；有最长的相同的前后缀AB，因此最长公共前后缀为2</li>
<li>当i=6时，字符串“ABCABD”，前缀为A，AB，ABC，ABCA，ABCAB；后缀为D，BD，ABD，CABD，BCABD，前缀与后缀并不相同，因此有相同的前后缀，因此最长公共前后缀为0</li>
</ol>
<p>该栗子中，<code>next[]</code>数组元素的值分别为：</p>
<p>一般来说，我们都可以预定义$next[0]$和$next[1]$都为0</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">next[<span class="number">0</span>]=<span class="number">0</span>;	<span class="comment">//空字符  弃用</span></span><br><span class="line">next[<span class="number">1</span>]=<span class="number">0</span>;	<span class="comment">//单个字符,不存在前缀和后缀,因此next[1]固定为0</span></span><br><span class="line">next[<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">next[<span class="number">3</span>]=<span class="number">0</span>;</span><br><span class="line">next[<span class="number">4</span>]=<span class="number">1</span>;</span><br><span class="line">next[<span class="number">5</span>]=<span class="number">2</span>;</span><br><span class="line">next[<span class="number">6</span>]=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>我们用图示来形象地理解<code>next[]</code>的含义：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210711111510.png" alt="image-20210711111454805"></p>
<p>如上图所示，对于由$i$个字符组成的字符串来说，前面的绿色部分和后面的绿色部分就表示该字符串相同的前缀和后缀，值为$next[i]$</p>
<hr>
<p>那么，我们怎么求解<code>next[]</code>数组呢？</p>
<p>根据<code>next[]</code>数组的含义，可以分为两种情况讨论，找到规律：</p>
<ul>
<li>如果新加入的字符与前一个最长公共前后缀子串的后面一个字符相同时，即$p[j+1]==p[i]$</li>
<li>如果新加入的字符与前一个最长公共前后缀子串的后面一个字符不同时，即$p[j+1]\neq p[i]$</li>
</ul>
<p><strong>讨论第一种情况：如果新加入的字符与前一个最长公共前后缀子串的后面一个字符相同时</strong></p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(p[i]==p[j+<span class="number">1</span>])</span><br><span class="line">    j++;</span><br><span class="line"><span class="comment">//用此时j的值来填充i所指向的这个字符的next数组的内容</span></span><br><span class="line">ne[i]=j;</span><br></pre></td></tr></table></figure>
<p>如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210711112121.png" alt="image-20210711112121418"></p>
<p>新加入的字符为$p[i]$，前一个最长公共前后缀子串的后一个字符是$p[j+1]$，可以发现，$p[j+1]==p[i]$，那么绿色部分就可以扩展一格，那么就是$next[i]=next[i-1]+1$，其实也就是$j=j+1$嘛，因为之前$j=next[i-1]$，然后由于$p[j+1]==p[i]$，那么$next[i]=next[i-1]+1$，就等效于此时$j=j+1$，即$j$++</p>
<p>注意：绿色部分是可以为0的，那么含义就是：最长公共前后缀为0，即不存在相同的前缀和后缀。也就是说此时$j$回退到0，指向了那个空字符</p>
<p><strong>讨论第二种情况：如果新加入的字符与前一个最长公共前后缀子串的后面一个字符不相同时</strong></p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当j没有回退到下标0所在的那个空字符,并且绿色部分内部一直都没有相同的前缀和后缀</span></span><br><span class="line"><span class="keyword">while</span>(j&amp;&amp;p[i]!=p[j+<span class="number">1</span>])</span><br><span class="line">    j=ne[j];</span><br><span class="line"><span class="comment">//用此时j的值来填充i所指向的这个字符的next数组的内容</span></span><br><span class="line">ne[i]=j;</span><br></pre></td></tr></table></figure>
<p>当出现这种情况时，在KMP算法中，就会执行$j=next[j]$，但是很难理解为什么要这么做。</p>
<p>下面我们看这张图：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210711121243.png" alt="image-20210711121242198"></p>
<p>那么蓝色的部分该怎么求解呢？在KMP中，就是用$j=next[j]$，这是回退操作</p>
<p>这个蓝色部分，首先要内容都完全相同，其次还要位于绿色部分的开头和结尾，那么这不就是绿色部分的最长公共前后缀的子串嘛？</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210711122308.png" alt="image-20210711122239056"></p>
<p>更新$j=next[j]$后，又回到原来的问题了，接着判断$p[j+1]$是否与$p[i]$相同就行了</p>
<p>至此，我们弄明白了那个令人费解的回退操作到底是什么意思了，其实就是在当前的这个最长公共前后缀已经不能使用时，那么就继续去寻找这个最长公共前后缀，看看它内部是否也存在最长公共前后缀，就这样一直迭代去寻找，一直尝试到成功或者是最长公共前后缀的长的为0时，就停止迭代循环</p>
<hr>
<p>下面给出求出<code>next[]</code>数组的完整代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ne[<span class="number">0</span>]=<span class="number">0</span>;	<span class="comment">//空字符的最长公共前后缀长度为0</span></span><br><span class="line">ne[<span class="number">1</span>]=<span class="number">0</span>;	<span class="comment">//单个字符不存在前缀和后缀，那么最长公共前后缀长度也为0</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(j&amp;&amp;p[i]!=p[j+<span class="number">1</span>])</span><br><span class="line">        j=ne[j];</span><br><span class="line">    <span class="keyword">if</span>(p[i]==p[j+<span class="number">1</span>])</span><br><span class="line">        j++;</span><br><span class="line">    ne[i]=j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>上面我们求出了<code>next[]</code>数组，那么如何进行主串和模式串的匹配呢？</p>
<p>其实进行主串和模式串的匹配，与求解<code>next[]</code>数组是一样的。</p>
<p>主循环中，$i$是用来遍历主串S的，$j$是用来遍历模式串p的。初始时$i$指向主串的第一个字符，即$i=1$，$j$指向模式串的空字符，即$j=0$。要注意：主串的$i$是不会回退的，它是一直往前遍历，但是模式串的$j$会进行回退操作，即会执行$j=next[j]$。</p>
<p><strong>讨论第一种情况：如果新加入的字符与前一个最长公共前后缀子串的后面一个字符相同时</strong></p>
<p>这里新加入的字符是指主串中的$S[i]$，前一个最长公共前后缀子串的后一个字符是指模式串中的$p[j+1]$，也就是说$S[i]==p[j+1]$，那么此时主串的下标$i$往前移动一位，模式串的下标$j$也往前移动一位</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(s[i]==p[j+<span class="number">1</span>])</span><br><span class="line">    j++;</span><br></pre></td></tr></table></figure>
<p><strong>讨论第二种情况：如果新加入的字符与前一个最长公共前后缀子串的后面一个字符不相同时</strong></p>
<p>这里新加入的字符是指主串中的$S[i]$，前一个最长公共前后缀子串的后一个字符是指模式串中的$p[j+1]$，也就是说$S[i]\neq p[j+1]$，那么此时模式串的$j$就要执行回退操作了，即$j=next[j]$</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(j&amp;&amp;s[i]!=p[j+<span class="number">1</span>])</span><br><span class="line">    j=ne[j];</span><br></pre></td></tr></table></figure>
<p>可以发现，其实进行主串与模式串的匹配时，与求解<code>next[]</code>数组是如出一辙的</p>
<hr>
<h1 id="KMP字符串"><a href="#KMP字符串" class="headerlink" title="KMP字符串"></a>KMP字符串</h1><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210711125013.png" alt="image-20210711125013111"></p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="comment">//n是模式串P的长度  m是主串S的长度</span></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">char</span> p[N];  <span class="comment">//模式串</span></span><br><span class="line"><span class="keyword">char</span> s[M];  <span class="comment">//主串</span></span><br><span class="line"><span class="comment">//next数组</span></span><br><span class="line"><span class="keyword">int</span> ne[N];</span><br><span class="line"><span class="comment">//求解出模式串P的next数组   next数组是对于模式串来说的,主串并不存在next数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ne[<span class="number">0</span>]=<span class="number">0</span>,ne[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;p[i]!=p[j+<span class="number">1</span>])</span><br><span class="line">        j=ne[j];</span><br><span class="line">        <span class="keyword">if</span>(p[i]==p[j+<span class="number">1</span>])</span><br><span class="line">        j++;</span><br><span class="line">        <span class="comment">//用此时j的值来填充i所指向当前这个字符的ne数组的内容</span></span><br><span class="line">        <span class="comment">//next[i] = j 表示下标以i-j为起点，i为终点的后缀和下标以1为起点，j为终点的前缀相等</span></span><br><span class="line">        <span class="comment">//且此字符串的长度最长。用符号表示为p[1~j] == p[i-j~i]</span></span><br><span class="line">        ne[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进行主串S和模式串P的匹配操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//主循环，遍历主串字符 i是用来遍历主串的，j是用来遍历模式串的</span></span><br><span class="line">    <span class="comment">//初始时i指向主串的第一个字符，j指向空字符</span></span><br><span class="line">    <span class="comment">//主串数组和模式串数组都是舍去数组下标0不用，从数组下标1开始存入字符</span></span><br><span class="line">    <span class="comment">//主串的i是不会回溯的，只有模式串的j才能回溯</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;s[i]!=p[j+<span class="number">1</span>])</span><br><span class="line">        j=ne[j];</span><br><span class="line">        <span class="keyword">if</span>(s[i]==p[j+<span class="number">1</span>])</span><br><span class="line">        j++;</span><br><span class="line">        <span class="comment">//如果j能走到n,那么一定是成功匹配了,因为如果不匹配的话,那么进行回退操作</span></span><br><span class="line">        <span class="comment">//j就不会到达n</span></span><br><span class="line">        <span class="keyword">if</span>(j==n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i-n);</span><br><span class="line">            <span class="comment">//这一句可以不用</span></span><br><span class="line">            j=ne[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//模式串和主串的下标都是从1开始</span></span><br><span class="line">    cin &gt;&gt;n&gt;&gt;p+<span class="number">1</span>&gt;&gt;m&gt;&gt;s+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//求解next数组</span></span><br><span class="line">    <span class="built_in">getNext</span>();</span><br><span class="line">    <span class="comment">//进行模式串和主串匹配操作</span></span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>排队布局</title>
    <url>/2021/07/10/%E7%AE%97%E6%B3%95%E6%8F%90%E9%AB%98%E8%AF%BE/%E7%AC%AC%E4%B8%89%E7%AB%A0---%E5%9B%BE%E8%AE%BA/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/%E6%8E%92%E9%98%9F%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h1 id="排队布局"><a href="#排队布局" class="headerlink" title="排队布局"></a>排队布局</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210710145142.png" alt="image-20210710145142511"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>这题是需要用到差分约束。对于差分约束，我们最主要的是根据题目描述，找出题目中的所有不等式关系，我们设$x_i$表示第$i$头牛的位置：</p>
<ul>
<li>根据“一些奶牛相互间存有好感，它们希望两者之间的距离不超过一个给定的数 L”，可以得到奶牛$a$和奶牛$b$之间至多相隔距离$L$，即有$x_b-x_a\leq L$</li>
<li>根据“一些奶牛相互间非常反感，它们希望两者间的距离不小于一个给定的数 D”，可以得到奶牛$a$和奶牛$b$之间至少相隔距离$D$，即有$x_b-x_a\geq D$</li>
<li>根据“奶牛排在队伍中的顺序和它们的编号是相同的，且同一位置上可以站多头牛”，可以得到$x_{i+1}\geq x_i$</li>
</ul>
<p>那么，我们再来观察题目要求的是$1$号奶牛和$N$号奶牛之间的最大距离，即要求变量$x_n$的最大值。那么，由差分约束可知，需要跑单源最短路，求出最短距离。</p>
<p>但是，我们要考虑，是否满足 <strong>从源点出发，可以到达所有边</strong>这个条件。由于从上面的三个不等式中，并不能看出，从某个点出发，一定能走完所有边。因此，我们就需要添加一个虚拟源点了，所以我们添加超级源点$x_0$，然后从它出发，就可以到达所有边了，那么就可以使用差分约束的方法了。</p>
<p>需要找一个超级源点（记超级源点为$x_0$），发现这里求的距离都是牛之间的相对距离，所以联想到令$x_0=0$，又因为求的是形如$x_i\leq x_j+c$的不等式，所以将所有点放在超级源点$0$号点的左侧就可以得出 $x_i\leq x_0+0$的不等式,这样从源点出发可以遍历所有的点，那么就可以遍历到所有的边。</p>
<p>因此，我们重新整理一下，上面的三个式子，统一写成$\leq$的形式（因为这是差分约束中求变量最大值的写法）：</p>
<ul>
<li>$x_b\leq x_a+L$，则从节点$x_a$向节点$x_b$连一条长度为$L$的边</li>
<li>$x_a\leq x_b-D$，则从节点$x_b$向节点$x_a$连一条长度为$-D$的边</li>
<li>$x_{i}\leq x_{i+1}+0$，则从节点$x_{i+1}$向节点$x_i$连一条长度为0的边</li>
</ul>
<p>对于建立虚拟源点问题，有两种方法：</p>
<ul>
<li>真正开辟一个超级源点0号点，那么此时建立好图后，就有$n+1$个节点</li>
<li>并不需要真正开辟一个虚拟源点，我们只需要刚开始的时候就把所有节点都放入队列中就行了，这种情况就等效于建立一个超级源点了（注意此时仍是$n$个节点，因为并没有把超级源点0号节点建立出来）。如何理解呢？<ul>
<li>我们这么想：对于spfa算法来说，假设我们真正设立了一个超级源点，这个源点连向其余的$n$个节点。那么第一次扩展时，就会把超级源点的所有邻接点都加入队列q中，然后更新这$n$个节点到超级源点的距离为0。也就是说，如果我们真的建立了一个超级源点，那么第一次扩展时，就会把它的所有邻接点（$n$个顶点）都更新最短距离为0。那么这不就等效于 《我们不用真的开辟一个超级源点，而是一开始就把这$n$个顶点都放入spfa算法的队列q中，然后初始化这$n$个点的距离为$0$》嘛？只不过这里并不需要第一次扩展而已啦，想法都是一样的，只不过实现方法有所不同而已</li>
</ul>
</li>
</ul>
<p>下面使用两种方法来分别实现以上的两种想法</p>
<p>然后这一题，有三个问题：</p>
<ul>
<li>对于第一个问题，我们可以跑一遍spfa算法求负环，如果存在负环，那么在说明不存在满足要求的方案，输出-1即可</li>
<li>对于第二个问题，想要求的是“1号牛和n号牛的最小距离是多少？即求$x_n-x_1$”，因此我们可以让1号节点称为起点，即设$x_1=0$，然后用spfa算法求出1号节点到其他各点的最短距离，最终求出$dist[n]$，如果$dist[n]\geq INF$则说明1号奶牛到$n$号奶牛之间不存在约束关系，距离可以无限远，输出-2。</li>
<li>对于第三个问题，如果求出的$dist[n]&lt;INF$，那么就直接输出此时的$dist[n]$即可</li>
</ul>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><strong>算法一：真正开辟一个超级源点0号节点</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>,M=<span class="number">3e4</span>+<span class="number">10</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n,m1,m2;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],w[M],idx;</span><br><span class="line"><span class="comment">//记录每个点到起点的最短距离</span></span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="comment">//spfa算法的循环队列</span></span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"><span class="comment">//记录每个点到起点一共经过了多少条边,用来判断负环</span></span><br><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line"><span class="comment">//用来判断某个节点是否已经放进q队列中</span></span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="comment">//建图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    w[idx]=c;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//spfa算法进行 判断负环和求出最短距离</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span> cnt);</span><br><span class="line">    <span class="built_in">memset</span>(st,<span class="number">0</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">1</span>;</span><br><span class="line">    dist[s]=<span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>]=s;</span><br><span class="line">    st[s]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(hh!=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//取出队头元素</span></span><br><span class="line">        <span class="keyword">int</span> t=q[hh++];</span><br><span class="line">        <span class="comment">//队满</span></span><br><span class="line">        <span class="keyword">if</span>(hh==N)</span><br><span class="line">        hh=<span class="number">0</span>;</span><br><span class="line">        st[t]=<span class="literal">false</span>;<span class="comment">//队头元素出队</span></span><br><span class="line">        <span class="comment">//遍历t的所有邻接点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];<span class="comment">//取出t的邻接点j</span></span><br><span class="line">            <span class="comment">//松弛</span></span><br><span class="line">            <span class="keyword">if</span>(dist[j]&gt;dist[t]+w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j]=dist[t]+w[i];</span><br><span class="line">                <span class="comment">//记录j到起点所走过的边数</span></span><br><span class="line">                cnt[j]=cnt[t]+<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//有n个点,如果此时节点j到起点所经历的边数&gt;=n,则说明有n+1个顶点,则有负环</span></span><br><span class="line">                <span class="keyword">if</span>(cnt[j]&gt;=n)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//如果j还没有放入队列q中</span></span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q[tt++]=j;  <span class="comment">//把j放入队列q中</span></span><br><span class="line">                    <span class="comment">//如果走到队尾</span></span><br><span class="line">                    <span class="keyword">if</span>(tt==N)</span><br><span class="line">                    tt=<span class="number">0</span>;</span><br><span class="line">                    st[j]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//说明不存在负环</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化表头</span></span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m1,&amp;m2);</span><br><span class="line">    <span class="comment">//建立了一个真正的超级源点,因此需要从超级源点0号点到其他n个节点连一条长度为0的边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="built_in">add</span>(<span class="number">0</span>,i,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//第一个约束条件,节点i+1向节点i连一条长度为0的边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    <span class="built_in">add</span>(i+<span class="number">1</span>,i,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(m1--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,L;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;L);</span><br><span class="line">        <span class="comment">//保证b要&gt;=a</span></span><br><span class="line">        <span class="keyword">if</span>(a&gt;b)</span><br><span class="line">        <span class="built_in">swap</span>(a,b);</span><br><span class="line">        <span class="comment">//第二个约束条件,节点a向节点b连一条长度为L的边</span></span><br><span class="line">        <span class="built_in">add</span>(a,b,L);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m2--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,D;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;D);</span><br><span class="line">        <span class="comment">//保证b要&gt;=a</span></span><br><span class="line">        <span class="keyword">if</span>(a&gt;b)</span><br><span class="line">        <span class="built_in">swap</span>(a,b);</span><br><span class="line">        <span class="comment">//第三个约束条件,节点b向节点a连一条长度为-D的边</span></span><br><span class="line">        <span class="built_in">add</span>(b,a,-D);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//存在负环</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">spfa</span>(<span class="number">0</span>))</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把1号节点当作起点</span></span><br><span class="line">        <span class="built_in">spfa</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//说明1号奶牛到N号奶牛的距离可以任意大</span></span><br><span class="line">        <span class="keyword">if</span>(dist[n]==INF)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;-2&quot;</span>);</span><br><span class="line">        <span class="comment">//否则就输出1号奶牛到N号奶牛的最短距离</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dist[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>算法二：不需要开辟一个超级源点0号节点</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>,M=<span class="number">3e4</span>+<span class="number">10</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n,m1,m2;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],w[M],idx;</span><br><span class="line"><span class="comment">//记录每个点到起点的最短距离</span></span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="comment">//spfa算法的循环队列</span></span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"><span class="comment">//记录每个点到起点一共经过了多少条边,用来判断负环</span></span><br><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line"><span class="comment">//用来判断某个节点是否已经放进q队列中</span></span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="comment">//建图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    w[idx]=c;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//spfa算法进行 判断负环和求出最短距离</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span> cnt);</span><br><span class="line">    <span class="built_in">memset</span>(st,<span class="number">0</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//将这num个节点都加入队列中,并且每个节点的最短距离初始化为0,标记每个节点都放入q队列中了</span></span><br><span class="line">    <span class="comment">//那么就等效于开辟了一个超级源点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        q[tt++]=i;</span><br><span class="line">        dist[i]=<span class="number">0</span>;</span><br><span class="line">        st[i]=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(hh!=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//取出队头元素</span></span><br><span class="line">        <span class="keyword">int</span> t=q[hh++];</span><br><span class="line">        <span class="comment">//队满</span></span><br><span class="line">        <span class="keyword">if</span>(hh==N)</span><br><span class="line">        hh=<span class="number">0</span>;</span><br><span class="line">        st[t]=<span class="literal">false</span>;<span class="comment">//队头元素出队</span></span><br><span class="line">        <span class="comment">//遍历t的所有邻接点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];<span class="comment">//取出t的邻接点j</span></span><br><span class="line">            <span class="comment">//松弛</span></span><br><span class="line">            <span class="keyword">if</span>(dist[j]&gt;dist[t]+w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j]=dist[t]+w[i];</span><br><span class="line">                <span class="comment">//记录j到起点所走过的边数</span></span><br><span class="line">                cnt[j]=cnt[t]+<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//有n个点,如果此时节点j到起点所经历的边数&gt;=n,则说明有n+1个顶点,则有负环</span></span><br><span class="line">                <span class="keyword">if</span>(cnt[j]&gt;=n)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//如果j还没有放入队列q中</span></span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q[tt++]=j;  <span class="comment">//把j放入队列q中</span></span><br><span class="line">                    <span class="comment">//如果走到队尾</span></span><br><span class="line">                    <span class="keyword">if</span>(tt==N)</span><br><span class="line">                    tt=<span class="number">0</span>;</span><br><span class="line">                    st[j]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//说明不存在负环</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化表头</span></span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m1,&amp;m2);</span><br><span class="line">    <span class="comment">//第一个约束条件,节点i+1向节点i连一条长度为0的边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    <span class="built_in">add</span>(i+<span class="number">1</span>,i,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(m1--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,L;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;L);</span><br><span class="line">        <span class="comment">//保证b要&gt;=a</span></span><br><span class="line">        <span class="keyword">if</span>(a&gt;b)</span><br><span class="line">        <span class="built_in">swap</span>(a,b);</span><br><span class="line">        <span class="comment">//第二个约束条件,节点a向节点b连一条长度为L的边</span></span><br><span class="line">        <span class="built_in">add</span>(a,b,L);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m2--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,D;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;D);</span><br><span class="line">        <span class="comment">//保证b要&gt;=a</span></span><br><span class="line">        <span class="keyword">if</span>(a&gt;b)</span><br><span class="line">        <span class="built_in">swap</span>(a,b);</span><br><span class="line">        <span class="comment">//第三个约束条件,节点b向节点a连一条长度为-D的边</span></span><br><span class="line">        <span class="built_in">add</span>(b,a,-D);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//存在负环</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">spfa</span>(n))</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把1号节点当作起点</span></span><br><span class="line">        <span class="built_in">spfa</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//说明1号奶牛到N号奶牛的距离可以任意大</span></span><br><span class="line">        <span class="keyword">if</span>(dist[n]==INF)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;-2&quot;</span>);</span><br><span class="line">        <span class="comment">//否则就输出1号奶牛到N号奶牛的最短距离</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dist[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title>区间</title>
    <url>/2021/07/08/%E7%AE%97%E6%B3%95%E6%8F%90%E9%AB%98%E8%AF%BE/%E7%AC%AC%E4%B8%89%E7%AB%A0---%E5%9B%BE%E8%AE%BA/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/%E5%8C%BA%E9%97%B4/</url>
    <content><![CDATA[<h1 id="区间"><a href="#区间" class="headerlink" title="区间"></a>区间</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210710143855.png" alt="image-20210710143855592"></p>
<hr>
<h3 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h3><ul>
<li>【1】给定区间<code>[a,b]</code>为$[3,7]$，那么$3\leq x\leq 7$，所以$x$的可选范围为{3，4，5，6，7}，其中要求选出来的$x$的个数必须不少于$c=3$个</li>
<li>【2】给定区间<code>[a,b]</code>为$[8,10]$，那么$8\leq x\leq 10$，所以$x$的可选范围为{8，9，10}，其中要求选出来的$x$的个数必须不少于$c=3$个</li>
<li>【3】给定区间<code>[a,b]</code>为$[6,8]$，那么$6\leq x\leq 8$，所以$x$的可选范围为{6，7，8}，其中要求选出来的$x$的个数必须不少于$c=1$个</li>
<li>【4】给定区间<code>[a,b]</code>为$[1,3]$，那么$1\leq x\leq 3$，所以$x$的可选范围为{1，2，3}，其中要求选出来的$x$的个数必须不少于$c=1$个</li>
<li>【5】给定区间<code>[a,b]</code>为$[10,11]$，那么$10\leq x\leq 11$，所以$x$的可选范围为{10，11}，其中要求选出来的$x$的个数必须不少于$c=1$个</li>
</ul>
<p>题目是意思是说想让我们从【1】、【2】、【3】、【4】、【5】中挑出$x$，组成一个整数集合$Z$，使得集合$Z$中元素的个数最少。那么给我们的启发就是，从【1】到【5】中跳出的这些数$x$应该尽可能的有交集，这样，才能使得选出最少的个数来组成集合$Z$。</p>
<ul>
<li>我们先看【1】和【4】，可以发现有交集元素3，由于【4】要求至少$c=1$，因此从【4】中我们挑出$x=3$就行了；</li>
<li>再来看【1】和【3】，可以发现有交集元素6，7，由于【1】中要求至少$c=3$，因此从【1】中挑选出$x=3,x=7,x=6,x=7$</li>
<li>再来看【2】和【3】，可以发现有交集元素8，由于【3】要求至少选出$c=1$，因此从【3】中我们挑出$x=8$</li>
<li>再来看【2】和【5】，有交集元素10，由于【5】要求至少选出$c=1$，因此从【5】中我们挑出$x=10$，由于【2】要求选出来的$x$的个数必须不少于$c=3$个，因此从【2】中挑出$x=8,9,10$</li>
<li>综上，我们选出来的$x$有<code>[3,6,7,8,9,10]</code>，也就是最少选出6个数，就可以构成一个整数集合$Z$，此时可以满足题目给出的五个限制条件</li>
</ul>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>这题我们需要用到差分约束来求解，同时还需要用到前缀和（这点比较难想）</p>
<p>我们设<code>S[i]</code>来表示从区间$[1,i]$中选出的$x$的个数。这里$0\leq a_i,b_i\leq 50000$，但是呢，由于前缀和需要用到$S[0]$，由定义可知$S[0]=0$，那么我们可以让$a_i,b_i$都+1，即向右平移一个单位，空出0这个位置来表达前缀和$S[0]$，平移之和并不影响最终结果。因此，此时$1\leq a_i,b_i\leq 50001$。</p>
<p>那么题目的意思也就是让我们从区间<code>[1,50001]</code>从选出最少的$x$的个数，来构成整数$Z$的集合。这道题肯定是会有解的，因为最坏情况下，我们把区间$[1,50001]$中的所有数都选择了，那么此时集合$Z$就有50001个元素，因此一定是有解的。那么这个解该怎么表示呢？由于我们不知道具体要选出多少个数，但是我们知道范围上限是50001，也就是$S[50001]$表示的是从区间$[1,50001]$中选出的$x$的最少的个数。因此，我们真正要求解的就是$S[50001]_{min}$</p>
<p>那么这题该怎么用差分约束呢？我们需要根据思路和题目描述自己来找出差分约束的条件：</p>
<ul>
<li>$S_i\geq S_{i-1}，1\leq i\leq 50001$，为什么呢？因为$S_i$表示从区间$[1,i]$中选出的$x$的个数，而$S_{i-1}$表示从区间$[1,i-1]$中选出的$x$的个数，因此$S_i$必定是要$\geq S_{i-1}$的，由定义出发就可以知道</li>
<li>$S_i-S_{i-1}\leq 1$，为什么呢？因为$S_i$表示从区间$[1,i]$中选出的$x$的个数，而$S_{i-1}$表示从区间$[1,i-1]$中选出的$x$的个数，那么$S_i-S_{i-1}$就表示第$i$个数，即整数$i$它被选的个数，由于整数$i$要么没有，如果有的话则最多只会有一个，因此由含义就可以知道选出来的第$i$个数，它被选的个数最多为1</li>
<li>由题目描述”区间$[a,b]$中最少要有$c$个数，可推知：$S_b-S_{a-1}\geq c$</li>
</ul>
<p>由于想要求的是变量$S[50001]$的最小值，运用差分约束，那么就需要跑最长路。将上面三个限制条件重新整理一下：</p>
<ul>
<li>$S_i\geq S_{i-1}+0$，那么就是从节点$S_{i-1}$向节点$S_i$连一条权值为0的边</li>
<li>$S_{i-1}\geq S_i-1$，那么就是从节点$S_{i}$向节点$S_{i-1}$连一条权值为-1的边</li>
<li>$S_b\geq S_{a-1}+c$，那么就是从节点$S_{a-1}$向节点$S_b$连一条权值为$c$的边</li>
</ul>
<p>但是呢，我们还需要思考一下，是否满足差分约束的条件：<strong>从源点出发，是否一定可以走到所有的边</strong>，这是差分约束正确性的前提条件。根据第一个约束条件可知，从$S_{i-1}$节点可以走到节点$S_i$，因此可以从$S_0$走到$S_1$，$S_1$走到$S_2$，$\cdots$，从$S_{50000}$走到$S_{50001}$，因此，从源点出发，是可以走到所有的边的</p>
<blockquote>
<p>问题：为什么这里的边数要开3倍呢？</p>
<p>由第一、二个约束条件可知，$S_{i-1}$和$S_{i}$之间都有边，即双向边，由第三个约束条件可知，则还会连出一条边，因此会有3条边。</p>
</blockquote>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">50010</span>,M=<span class="number">150010</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],w[M],idx;</span><br><span class="line"><span class="comment">//dist[i]表示从起点到节点i的最长距离</span></span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="comment">//循环队列</span></span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"><span class="comment">//判断一个节点是否已经入队了</span></span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    w[idx]=c;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里一定有解，因此并不需要判断是否存在负环了</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//求最长路,则初始化为负无穷</span></span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">-0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">1</span>;</span><br><span class="line">    dist[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    st[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(hh!=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//取出队头元素</span></span><br><span class="line">        <span class="keyword">int</span> t=q[hh++];</span><br><span class="line">        <span class="comment">//循环队列满了</span></span><br><span class="line">        <span class="keyword">if</span>(hh==N)</span><br><span class="line">            hh=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//节点t出队</span></span><br><span class="line">        st[t]=<span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//遍历节点t的所有邻接点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];<span class="comment">//t的邻接点编号j</span></span><br><span class="line">            <span class="keyword">if</span>(dist[j]&lt;dist[t]+w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//通过节点t来更新节点j到起到的最长距离</span></span><br><span class="line">                dist[j]=dist[t]+w[i];</span><br><span class="line">                <span class="comment">//如果节点j还没有入队</span></span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q[tt++]=j;<span class="comment">//节点j入队</span></span><br><span class="line">                    <span class="comment">//队尾指针走到了末尾,则重新回到队头</span></span><br><span class="line">                    <span class="keyword">if</span>(tt==N)</span><br><span class="line">                        tt=<span class="number">0</span>;</span><br><span class="line">                    <span class="comment">//标记节点j已经入队了</span></span><br><span class="line">                    st[j]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化表头为-1</span></span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//给第一、二个约束条件建图</span></span><br><span class="line">        <span class="built_in">add</span>(i<span class="number">-1</span>,i,<span class="number">0</span>);   </span><br><span class="line">        <span class="built_in">add</span>(i,i<span class="number">-1</span>,<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        <span class="comment">//记得向右平移一位</span></span><br><span class="line">        a++,b++;</span><br><span class="line">        <span class="built_in">add</span>(a<span class="number">-1</span>,b,c);   <span class="comment">//给第三个约束条件建图</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//跑以便spfa求出每个节点到起点的最长路</span></span><br><span class="line">    <span class="built_in">spfa</span>();</span><br><span class="line">    <span class="comment">//dist[50001]表示节点S(50001)到起点的最长距离,也就是题目中想要求的最小值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dist[<span class="number">50001</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title>糖果</title>
    <url>/2021/07/09/%E7%AE%97%E6%B3%95%E6%8F%90%E9%AB%98%E8%AF%BE/%E7%AC%AC%E4%B8%89%E7%AB%A0---%E5%9B%BE%E8%AE%BA/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/%E7%B3%96%E6%9E%9C/</url>
    <content><![CDATA[<h1 id="糖果"><a href="#糖果" class="headerlink" title="糖果"></a>糖果</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://gitee.com/linmacos/blog-image/raw/master/img/20210709201853.png" alt="image-20210709201852949"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>从题目描述中可知，这道题主要是要运用差分约束来求解。求至少需要准备多少个糖果，也就是求变量$a_i$的最小值，那么也就是需要跑最长路。</p>
<ul>
<li><p>根据题目描述如果$X=1$，则$A=B$，即有$A\geq B+0$，$B\geq A+0$ 。因此需要从节点$B$向节点$A$连一条权值为0的边，从节点$A$向节点$B$连一条权值为0的边</p>
</li>
<li><p>根据题目描述如果$X=2$，则$B\geq A+1$，因此从节点$A$向节点$B$连一条权值为1的边</p>
</li>
<li><p>根据题目描述如果$X=3$，则$A\geq B+0$，因此从节点$B$向节点$A$连一条权值为0的边</p>
</li>
<li><p>根据题目描述如果$X=4$，则$A\geq B+1$，因此从节点$B$向节点$A$连一条权值为1的边</p>
</li>
<li><p>根据题目描述如果$X=5$，则$B\geq A+0$，因此从节点$A$向节点$B$连一条权值为0的边</p>
</li>
<li><p>同时，由题干”要求每个小朋友都要分到苹果“，因此可以知道$a_i&gt;0$，即$a_i\geq 1$，那么可以添加一个超级源点$a_0$，$a_0$为0。那么$a_i+a_0\geq a_0+1$，即$a_i\geq a_0+1$，因此从超级源点$a_0$向节点$a_i$连一条权值为1的边</p>
</li>
</ul>
<p>注意，当我们用差分约束时，要考虑是否满足“<strong>从源点出发，能够到达所有边</strong>”这个条件。从$a_i\geq a_0+1$可知，可以从源点$0$号节点到达任意的节点$i$，既然可以从源点出发，到达任意节点$i$，那么也就是说，可以到达所有边，因此满足了前提条件。但是要注意，如果知道了从源点出发能够到达所有边，那么则不一定能推出可以到达所有节点，可以有可能某个节点它是孤立的，而剩余的所有节点（含有源点）是连通的。</p>
<ul>
<li>一般来说，如果已知$a_i\geq a_0+c$，那么就说明需要额外建立一个超级源点，并且从超级源点出发能够到达所有边</li>
<li>但是如果已知$a_i\geq a_{i-1}+c$，则不能说明从源点出发能到达所有边。因此也是需要添加超级源点。这样才能使得从超级源点出发能够到达所有边</li>
</ul>
<blockquote>
<p>问题：这里为什么是用栈而不是用循环队列呢？</p>
<p>对于spfa判负环，一般是对STL中的queue或者是手写循环队列。但是这一题比较玄学，用栈竟然是一种优化…</p>
<p>因为队列下标是递增的，进队次数可能会很多，所以访问到的下标可能很大。但栈不管插入多少次，最多只会用前n个位置。</p>
<p>这个优化不太稳定，比较玄学。优化大致上基于如下想法：如果存在一个环，那么用栈来搜索时，会按照深度优先的顺序，那么很快就会沿着环找到起点。</p>
</blockquote>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//这里的边的数目要开3倍,是因为比如点A-&gt;点B,点B-&gt;点A,同时还有超级源点0-&gt;点B</span></span><br><span class="line"><span class="comment">//因此对于点B来说,就有3条边</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],w[M],idx;</span><br><span class="line"><span class="comment">//注意数据范围可能会爆int</span></span><br><span class="line">LL dist[N];</span><br><span class="line"><span class="comment">//数组模拟栈,用来存储spfa算法中入栈的节点</span></span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"><span class="comment">//用来记录从起点到某个点所经过的边的个数</span></span><br><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line"><span class="comment">//判断某个点是否入栈</span></span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    w[idx]=c;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//spfa判负环</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//最长路,因此需要设置为负无穷大</span></span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">-0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="comment">//超级源点到自身距离为0</span></span><br><span class="line">    dist[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//超级源点0号节点入栈</span></span><br><span class="line">    q[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//标记超级源点0号节点入栈</span></span><br><span class="line">    st[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(hh!=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//取出栈顶元素</span></span><br><span class="line">        <span class="keyword">int</span> t=q[--tt];</span><br><span class="line">        <span class="comment">//标记栈顶元素这个节点已经出栈</span></span><br><span class="line">        st[t]=<span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//遍历栈顶元素t的所有邻接点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];<span class="comment">//取出邻接节点j</span></span><br><span class="line">            <span class="comment">//最长路的松弛条件：dist[j]&lt;dist[t]+w[i]</span></span><br><span class="line">            <span class="keyword">if</span>(dist[j]&lt;dist[t]+w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//更新节点j的最短距离</span></span><br><span class="line">                dist[j]=dist[t]+w[i];</span><br><span class="line">                <span class="comment">//从起点到节点j经过了cnt[t]+1条边</span></span><br><span class="line">                cnt[j]=cnt[t]+<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//由于我们建立的图中有超级源点0号节点+n个点=n+1个节点</span></span><br><span class="line">                <span class="comment">//但是如果但cnt[j]&gt;=n+1时,即从起点到节点j经过了n+1条边,则说明有(n+1)+1=n+2个节点</span></span><br><span class="line">                <span class="comment">//这与图中的n+1个节点相矛盾,因此由抽屉原理,知必存在负环</span></span><br><span class="line">                <span class="keyword">if</span>(cnt[j]&gt;=n+<span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//如果j这个节点还没有入栈</span></span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q[tt++]=j;<span class="comment">//将节点j入栈</span></span><br><span class="line">                    st[j]=<span class="literal">true</span>;<span class="comment">//标记节点j已经入栈了</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则,说明不存在负环</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//表头初始化为-1</span></span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x,a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;a,&amp;b);</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">add</span>(b,a,<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">add</span>(a,b,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">2</span>)</span><br><span class="line">            <span class="built_in">add</span>(a,b,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">3</span>)</span><br><span class="line">            <span class="built_in">add</span>(b,a,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">4</span>)</span><br><span class="line">            <span class="built_in">add</span>(b,a,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">add</span>(a,b,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//由于我们添加了超级源点0,因此从0号节点到其他的各个节点i都要建一条边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">add</span>(<span class="number">0</span>,i,<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//存在负环,则差分约束系统无解</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">spfa</span>())</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="comment">//不存在负环,则差分约束系统有解</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        LL res=<span class="number">0</span>;   <span class="comment">//记录最终答案</span></span><br><span class="line">        <span class="comment">//dist[i]表示从超级源点到节点i的最长路,也就是题目中每个小朋友应该在限制要求下分得的糖果</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            res+=dist[i];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title>雇佣收银员</title>
    <url>/2021/07/10/%E7%AE%97%E6%B3%95%E6%8F%90%E9%AB%98%E8%AF%BE/%E7%AC%AC%E4%B8%89%E7%AB%A0---%E5%9B%BE%E8%AE%BA/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/%E9%9B%87%E4%BD%A3%E6%94%B6%E9%93%B6%E5%91%98/</url>
    <content><![CDATA[<h1 id="雇佣收银员"><a href="#雇佣收银员" class="headerlink" title="雇佣收银员"></a>雇佣收银员</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210710201724.png" alt="image-20210710201724728"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>这题需要用差分约束来求解，具体思路如下：</p>
<p>我们定义以下变量的含义：</p>
<ul>
<li><code>num[i]</code>表示在$t_i$时刻来应聘的人数</li>
<li><code>x[i]</code>表示在$t_i$时刻公司选择雇佣的人数</li>
<li><code>R[i]</code>表示在$t_i$时刻需要的员工的最小需求量</li>
<li><code>S[i]</code>表示满足能在$t_i$时刻上岗工作的公司已经聘用的员工总数。比如当$t_i=24h$时，$S_i=100$，则说明这100个人，它们的工作服务时间段是包括$t_i$的，即在$t_i$时刻他们在岗工作</li>
</ul>
<p>根据以上定义，我们再来梳理一下不等式的关系：</p>
<ul>
<li><p>$0\leq x_i\leq num[i]$，因为聘用的人数不可能大于来应该的人数，因此有$x_i\leq num[i]$，而且公司选择聘用的人数不可能为-1，要么都不聘用，因此有$x_i\geq 0$</p>
</li>
<li><p>$x_{i-7}+x_{i-6}+x_{i-5}+x_{i-4}+x_{i-3}+x_{i-2}+x_{i-1}+x_i\geq R_i$，即公司聘用的能够在$t_i$时刻处于工作服务状态的员工总数，应该$\geq$在$t_i$时刻最小需要的员工总数</p>
<blockquote>
<p> <strong>问题：如何理解$x_{i-7}+x_{i-6}+x_{i-5}+x_{i-4}+x_{i-3}+x_{i-2}+x_{i-1}+x_i$这个式子呢？</strong></p>
<p>由于题目说了，员工一定会连续工作8个小时，即每个员工的工作服务时常为$8h$。那么我们就想，哪些员工他们的工作服务时间段是包括$t_i$这个时刻的呢？如果包括，则说明他们在$t_i$这个时刻，一定可以上岗工作服务。因此$x_{i-7}+x_{i-6}+x_{i-5}+x_{i-4}+x_{i-3}+x_{i-2}+x_{i-1}+x_i$就表示能在$t_i$时刻上岗工作服务的员工总数，那么这个总数就应该要$\geq t_i$时刻需要的员工的最小需求量$R_i$。</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210710211018.png" alt="image-20210710211017955"></p>
</blockquote>
</li>
</ul>
<p>$x_{i-7}+x_{i-6}+x_{i-5}+x_{i-4}+x_{i-3}+x_{i-2}+x_{i-1}+x_i$这个是连加的形式，那么很容易想到用前缀和来表示，即用$S[i]$来表示，其中$1\leq i\leq 24$。由于前缀和需要用到$S[0]$，因此我们需要把时间都向右平移一个单位，即现在时间为$1,2,\cdots,24$而不是再是原来的$0,1,2,\cdots,23$了。</p>
<p>那么则会由如下的不等式关系：</p>
<ul>
<li>$0\leq x_i\leq num[i]$，用前缀和来代替，那么就是$0\leq S_i-S_{i-1}\leq num[i]$</li>
<li>$S_i\geq R_i$</li>
</ul>
<p>由于题目要求的是变量的最小值，那么就需要跑单源最长路，求出最长距离。因此把不等式关系都改写为$x_i\geq x_j+c$的形式：</p>
<ul>
<li>$S_i\geq S_{i-1}+0$</li>
<li>$S_{i-1}\geq S_i-num[i]$</li>
</ul>
<p>对于$S_i\geq R_i$要分类讨论，因为时间它是循环的，当到了24之后就会变为0，又重新开始了。</p>
<ul>
<li><p>当$i\geq 8$时，则有$S_i-S_{i-8}\geq R_i$，分析如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210710213044.png" alt="image-20210710213044097"></p>
</li>
<li><p>当$0&lt;i\leq 7$时，则要分为两部分了。一部分是$1$到$7$这个时间段，由于不足8h，因此说明需要向$24$(包括它)之前的借一些时间，这主要就是因为时间是循环的。那么会得到$S_i+(S_{24}-S_{i+16})\geq R[i]$分析如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210710214154.png" alt="image-20210710214002246"></p>
</li>
</ul>
<p>进一步梳理不等式关系：</p>
<ul>
<li>$S_i\geq S_{i-1}+0$</li>
<li>$S_{i-1}\geq S_i-num[i]$</li>
<li>当$i\geq 8$时，$S_i\geq S_{i-8}+R[i]$</li>
<li>当$0&lt;i\leq 7$时，$S_i\geq S_{i+16}-S_{24}+R[i]$</li>
</ul>
<p>但是我们发现第四个约束条件中，有三个变量，平时我们都是遇到两个变量。其实，我们可以把$S_{24}$当作常量。那么如何把它作为常量呢？由于题目说要求最少需要雇佣多少名收银员，那么其实也就是说要求出$S_{24}$是多少。由于题目说了$0\leq N\leq 1000$，因此最坏情况下是至少聘用了$1000$个人。那么我们可以依次从0开始枚举到1000，我们把枚举的这个值$i$其实就是$S_{24}$，每次枚举一个$i$，都去跑一下spfa，当第一次枚举到某个值时，它满足所有的约束条件，那么这个值就是我们要求的最小的$S_{24}$，找到第一个就直接break。</p>
<p>注意这里当我们枚举到某个$S_{24}=c$时，也要把它写成差分约束的形式，即$S_{24}\geq c$和$S_{24}\leq c$，建立一个超级源点$S_0$（为0），那么有$S_{24}\geq S_0+c$和$S_{0}\geq S_{24}-c$</p>
<p>因此，总结一下，总共有以下的约束条件：</p>
<ul>
<li>$S_i\geq S_{i-1}+0$</li>
<li>$S_{i-1}\geq S_i-num[i]$</li>
<li>当$i\geq 8$时，$S_i\geq S_{i-8}+R[i]$</li>
<li>当$0&lt;i\leq 7$时，$S_i\geq S_{i+16}-S_{24}+R[i]$</li>
<li>$S_{24}\geq S_0+c$</li>
<li>$S_{0}\geq S_{24}-c$</li>
</ul>
<p>由第一个约束条件$S_i\geq S_{i-1}+0$可知，设立一个超级源点0号节点，则可以从超级源点出发，0-&gt;1-&gt;2-&gt;$\cdots$-&gt;$24$，因此可以到达所有节点，那么一定可以到达所有边。所以，这里满足了 “<strong>从源点出发，能遍历到所有边</strong>”这个条件，因此可以用差分约束。</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">30</span>,M=<span class="number">100</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],w[M],idx;</span><br><span class="line"><span class="comment">//R[i]表示i时刻公司需要雇佣的最小的员工的需求量</span></span><br><span class="line"><span class="comment">//num[i]表示i时刻来应聘的员工的数量</span></span><br><span class="line"><span class="keyword">int</span> R[N],num[N];</span><br><span class="line"><span class="comment">//dist[i]表示i节点到起点的最长距离</span></span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="comment">//循环队列q来存储入队节点</span></span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"><span class="comment">//cnt[i]表示从起点到达节点i一共经过了多少条边</span></span><br><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line"><span class="comment">//判断某个节点是否已经加入了q队列中</span></span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="comment">//建图函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    w[idx]=c;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将约束条件建成图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化表头</span></span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    idx=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//S[24]=c,写成了两个约束条件</span></span><br><span class="line">    <span class="built_in">add</span>(<span class="number">0</span>,<span class="number">24</span>,c);</span><br><span class="line">    <span class="built_in">add</span>(<span class="number">24</span>,<span class="number">0</span>,-c);</span><br><span class="line">    <span class="comment">//当0&lt;i&lt;=7时,给这个约束条件建图</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">7</span>;i++)</span><br><span class="line">    <span class="built_in">add</span>(i+<span class="number">16</span>,i,R[i]-c);</span><br><span class="line">    <span class="comment">//当i&gt;=8时,给这个约束条件建图</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">8</span>;i&lt;=<span class="number">24</span>;i++)</span><br><span class="line">    <span class="built_in">add</span>(i<span class="number">-8</span>,i,R[i]);</span><br><span class="line">    <span class="comment">//给S[i]&gt;=S[i-1]+0和S[i-1]&gt;=S[i]-num[i]建图</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">24</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">add</span>(i<span class="number">-1</span>,i,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">add</span>(i,i<span class="number">-1</span>,-num[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//spfa算法用来  判断是否存在正环  和 求出最长距离</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//对于枚举的每一个S[24]都去建图</span></span><br><span class="line">    <span class="built_in">build</span>(c);</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">-0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">memset</span>(st,<span class="number">0</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span> cnt);</span><br><span class="line">    <span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//由于真正地建立了超级源点S[0]</span></span><br><span class="line">    dist[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    st[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(hh!=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=q[hh++];</span><br><span class="line">        <span class="keyword">if</span>(hh==N)</span><br><span class="line">        hh=<span class="number">0</span>;</span><br><span class="line">        st[t]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j]&lt;dist[t]+w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j]=dist[t]+w[i];</span><br><span class="line">                cnt[j]=cnt[t]+<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//本来1~24共有24个节点,但是建立了1个超级源点,因此总共25个节点</span></span><br><span class="line">                <span class="comment">//cnt[j]&gt;=25说明从超级源点到节点j经过了25条边,那么则有26个节点</span></span><br><span class="line">                <span class="comment">//这与实际的25个节点不符合,因此存在正环</span></span><br><span class="line">                <span class="keyword">if</span>(cnt[j]&gt;=<span class="number">25</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q[tt++]=j;</span><br><span class="line">                    <span class="keyword">if</span>(tt==N)</span><br><span class="line">                    tt=<span class="number">0</span>;</span><br><span class="line">                    st[j]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//说明不存在正环  且找到了最小的满足所有约束条件的S[24]</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">24</span>;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;R[i]);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="keyword">sizeof</span> num);</span><br><span class="line">        <span class="keyword">while</span>(n--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">            <span class="comment">//由于前缀和S[0]占用0这个位置,因此我们让时间都向右平移一位</span></span><br><span class="line">            t++;</span><br><span class="line">            num[t]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//用来判断是否有解</span></span><br><span class="line">        <span class="keyword">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">1000</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//枚举找到最小的满足所有约束条件的S[24]</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">spfa</span>(i))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">                flag=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//说明无解</span></span><br><span class="line">        <span class="keyword">if</span>(!flag)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;No Solution&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title>单词环</title>
    <url>/2021/07/12/%E7%AE%97%E6%B3%95%E6%8F%90%E9%AB%98%E8%AF%BE/%E7%AC%AC%E4%B8%89%E7%AB%A0---%E5%9B%BE%E8%AE%BA/%E8%B4%9F%E7%8E%AF/%E5%8D%95%E8%AF%8D%E7%8E%AF/</url>
    <content><![CDATA[<h1 id="单词环"><a href="#单词环" class="headerlink" title="单词环"></a>单词环</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210712192242.png" alt="image-20210712192242017"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>这题主要是要用到spfa判断正环+01分数规划+spfa玄学优化</p>
<p>我们先来思考一下该怎么建图呢？</p>
<p>如果按照常规思路，我们把一个字符串看作一个节点，那么题目最多有$10^5$个节点，那么会最多会有多少条边呢？我们来考虑最坏情况，这$10^5$个字符串都是相同的，以3个完全相同的字符串为栗子，比如：</p>
<ul>
<li>【1】$aaaaa$</li>
<li>【2】$aaaaa$</li>
<li>【3】$aaaaa$</li>
</ul>
<p>可以发现对于【1】来说，它可以接到【2】和【3】上，那么有$3-1=2$种可能，也就是说要从【1】引出两条有向边，分别指向【2】和【3】。同理分析可知，如果$10^5$个字符串都相同，则对于每个字符串来说，都会引出$10^5-1$条边，为了方便起见，就看作是引出$10^5$条边。有$10^5$个节点，每个节点会引出$10^5$条有向边，因此总共有$10^5\times 10^5=10^{10}$条有向边。很明显，点数为$10^5$，边数为$10^{10}$，存储空间要爆炸。因此，我们需要思考该怎么建图呢？</p>
<p>从题目描述中，我们可以知道，一个字符串除了前面的2个字符和后面的2个字符有用之外，字符串中间的其他所有字符都没有用，因此，我们可以这样建图：</p>
<p>直接hash前面的两个字符和后面的两个字符作为节点，该字符串的长度作为这两个节点之间的边的权值。对于一个字符串来说，它后面的两个字符，每个字符都有26种可能，因此这两个字符产生了$26\times26=676$种可能，也就是最多会有$676$个节点。例如题目中的第一个字符串$ababc$，它后面的$bc$就确定了图中的一个顶点，第二个字符串$bckjaca$，它后面的$ca$就确定了图中的一个顶点，第三个字符串$caahoynaab$，它后面的$ab$就确定了图中的一个顶点。也就是说对于后面两个字符所确定的一种可能，都会对应地确定了图中的一个顶点。那么有$26\times 26$种可能，也就是确定了图中最多会有$676$个顶点。由之前分析可知，每个节点最多很引出$10^5$条有向边。因此这种建图方式最多会引出$676\times 10^5=6.76\times 10^7$条有向边，空间还算好一些。</p>
<p>如下图解释题目中的栗子：</p>
<p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210712194716.png" alt="image-20210712194716858"></p>
<p>知道了该怎么建图后，我们再来思考题目要求的是什么？题目想要求的是形成环的这个串它的平均长度最大，转换到我们建好的图中，意思就是：边权之和/节点个数 最大。即$\dfrac {\sum w_i}{\sum 1}$要最大</p>
<p>要求这个值最大，满足单调性，很明显这就是一个01分数规划问题，那么就可以使用二分算法来二分答案了。我们设某一时刻二分出来的答案为$mid$（但不保证这就是最终正确想要的最大的那个答案），如果当前这个答案$mid$不够大，则说明还可以更大，即</p>
<p>$\dfrac {\sum w_i}{\sum 1}&gt;mid$</p>
<p>$\iff$ $\sum w_i&gt;mid*\sum 1$</p>
<p>$\iff$ $\sum w_i-mid*\sum 1&gt;0$</p>
<p>$\iff$$\sum w_i-\sum mid*1&gt;0$</p>
<p>$\iff$ $\sum (w_i-mid*1)$</p>
<p>那么也就是说，对于每一条边，给它赋权值为$w_i-mid*1$，如果存在正环，也就意味着有一个环的权值和大于0，也就是$\sum (w_i-mid\times 1)&gt;0$，就意味着$mid$需要更大，由于是单调递增的，那么此时就应该执行$L=mid$，否则就是执行$R=mid$。</p>
<p>这里还要思考一下二分的区间是啥？由于$\sum w_i$和$\sum 1$都是正数，因此相除的话一定是大于0的，注意这里是浮点数相除哦！因此左范围一定大于0。由$\dfrac {\sum w_i}{\sum 1}$式子可知，要想取最大，则分子要最大，分子要最小，由于最多有$10^5$条边，每条边的权值最大是$1000$，所以$\sum w_i$最大是$1000\times 10^5$。由于最多有$10^5$条边，所以至少有$10^5$个节点，所以$\sum 1$最小为$10^5$，于是$\dfrac {\sum w_i}{\sum 1}=\dfrac {1000\times 10^5}{10^5}$最大为$1000$。因此答案区间就是$(0,1000]$。</p>
<p>题目说了不一定存在环串，那么我们该怎么知道呢？从$w_i-mid\times1$可知，这是一个递减的线性函数，当$mid$取0时，有最大值，因此我们可以先尝试$mid=0$，如果$w_i-mid\times 1\leq 0$，那么$\sum w_i-mid\times 1\leq0$，因此对于剩下的所有节点，必定是$\sum w_i-mid\times 1\leq0$，但是这个式子显然与$\sum (w_i-mid\times 1)&gt;0$这个存在正环的式子不矛盾。因此，只要带入$mid=0$，验证一下看看这个式子$\sum (w_i-mid*1)$是否满足正环，如果不满足，那么全部都不满足，输出无解，否则说明可以求解。</p>
<p>一般来说，如果题目要求保留$k$位小数，那么我们一般把精度多控制两位，即精度位$eps=1e^{-(k+2)}$</p>
<blockquote>
<p>问题：如何理解一下代码呢？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> left=(s[<span class="number">0</span>]-<span class="string">&#x27;a&#x27;</span>)*<span class="number">26</span>+(s[<span class="number">1</span>]-<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">int</span> right=(s[len<span class="number">-2</span>]-<span class="string">&#x27;a&#x27;</span>)*<span class="number">26</span>+s[len<span class="number">-1</span>]-<span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>我们这里是以字符串的前面两个字符和后面两个字符来作为节点，那么这个节点该怎么编号呢？其实我们可以利用字符串hash的思想，把这两个字符hash成对应的一个整数值。比如字符串$ababc$前面的两个字符$ab$其实就是$(‘a’-‘a’)\times 26^1+(‘b’-‘a’)\times 26^0=1$，所以字符$ab$这个节点的编号就是1；比如字符$ababc$后面的两个字符$bc$其实就是$(‘b’-‘a’)\times 26^1+(‘c’-‘a’)\times 26^0=28$，所以字符$bc$这个节点的编号就是28</p>
</blockquote>
<p>这里还有一个spfa判环的玄学优化（不太常用）：</p>
<p>当图中所有顶点的更新次数（入队次数)<code>count</code>大于图中顶点的个数的2倍时，则认为存在环。如果2倍不行，那就长度3倍、4倍…  这玩意很玄学</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">700</span>, M = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps=<span class="number">1e-4</span>;  <span class="comment">//控制精度</span></span><br><span class="line"><span class="keyword">int</span> h[N], e[M], w[M], ne[M], idx;</span><br><span class="line"><span class="keyword">double</span> dist[N];</span><br><span class="line"><span class="keyword">int</span> q[N], cnt[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="comment">//建图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    w[idx] = c;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//spfa判正环</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">double</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">-0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> cnt);</span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//图中最多有676个顶点,一开始就把原图中的所有顶点都放入队列q中</span></span><br><span class="line">    <span class="comment">//就等效于建立了一个虚拟源点和其他676个节点的新图</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">676</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        q[tt ++ ] = i;</span><br><span class="line">        <span class="comment">//初始化该虚拟源点到其他676个节点的权值为0</span></span><br><span class="line">        dist[i]=<span class="number">0</span>;</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;  <span class="comment">//统计图中所有节点的更新次数即所有节点的入队次数</span></span><br><span class="line">    <span class="keyword">while</span> (hh != tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = q[hh ++ ];</span><br><span class="line">        <span class="keyword">if</span> (hh == N) </span><br><span class="line">        hh = <span class="number">0</span>;</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &lt; dist[t] + w[i] - mid)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i] - mid;</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">                count++;    <span class="comment">//更新次数+1  即入队次数+1</span></span><br><span class="line">                <span class="comment">//一般经验上来说是count &gt;2N 但是这里点数少,边数实在太多了 </span></span><br><span class="line">                <span class="comment">//那么就3N,4N...一直尝试吧</span></span><br><span class="line">                <span class="keyword">if</span> (count&gt; <span class="number">10</span>*N) </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 经验上的trick</span></span><br><span class="line">                <span class="comment">//说明存在正环</span></span><br><span class="line">                <span class="keyword">if</span> (cnt[j] &gt;= N) </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q[tt ++ ] = j;</span><br><span class="line">                    <span class="keyword">if</span> (tt == N) tt = <span class="number">0</span>;</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//说明不存在正环</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">1010</span>]; <span class="comment">//字符串</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T), T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//初始化表头</span></span><br><span class="line">        <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//T个字符串</span></span><br><span class="line">        <span class="keyword">while</span>(T--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">            <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">            <span class="keyword">if</span> (len &gt;= <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//该字符串的前面两个字符  hash 成一个整数值 作为 一个节点的编号</span></span><br><span class="line">                <span class="keyword">int</span> left = (str[<span class="number">0</span>] - <span class="string">&#x27;a&#x27;</span>) * <span class="number">26</span> + str[<span class="number">1</span>] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="comment">//该字符串的后面两个字符  hash 成一个整数值 作为 一个节点的编号</span></span><br><span class="line">                <span class="keyword">int</span> right = (str[len - <span class="number">2</span>] - <span class="string">&#x27;a&#x27;</span>) * <span class="number">26</span> + str[len - <span class="number">1</span>] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="comment">//从left节点想right节点连一条长度为len的有向边</span></span><br><span class="line">                <span class="built_in">add</span>(left, right, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果把0带进去计算都不能得到正环的话,那么1,2,...,1000就不可能得到正环</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">check</span>(<span class="number">0</span>)) </span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;No solution&quot;</span>);</span><br><span class="line">        <span class="comment">//说明还是可以得到正环的</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">double</span> l = <span class="number">0</span>, r = <span class="number">1000</span>;</span><br><span class="line">            <span class="comment">//二分答案</span></span><br><span class="line">            <span class="keyword">while</span> (l+eps&lt;r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">                <span class="comment">//由于答案是单调递增的 </span></span><br><span class="line">                <span class="comment">//所以当满足性质时  往右侧收缩 寻找答案</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) </span><br><span class="line">                l = mid;</span><br><span class="line">                <span class="comment">//否则不满足性质  往左侧收缩 寻找答案</span></span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//输出最终的答案</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>负环</category>
      </categories>
      <tags>
        <tag>负环</tag>
      </tags>
  </entry>
  <entry>
    <title>观光奶牛</title>
    <url>/2021/07/12/%E7%AE%97%E6%B3%95%E6%8F%90%E9%AB%98%E8%AF%BE/%E7%AC%AC%E4%B8%89%E7%AB%A0---%E5%9B%BE%E8%AE%BA/%E8%B4%9F%E7%8E%AF/%E8%A7%82%E5%85%89%E5%A5%B6%E7%89%9B/</url>
    <content><![CDATA[<h1 id="观光奶牛"><a href="#观光奶牛" class="headerlink" title="观光奶牛"></a>观光奶牛</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210712160410.png" alt="image-20210712160410274"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>一般来说，求 点权之和/边权之和 的最值问题，都属于01分数规划问题。</p>
<p>图论的01分数规划问题的步骤：</p>
<ul>
<li>确认答案区间，然后用二分算法，判断性质</li>
<li>借助二分出来的中点，推导出性质的公式</li>
<li>套用图论模板</li>
</ul>
<p>本题要求我们求一个环内$\dfrac {\sum f_i}{\sum t_i}$的最大值，而这个答案本身就是具有单调性，因此可以用二分算法，来二分出最终的答案。</p>
<p>首先来确定答案的区间：</p>
<p>我们设$c =\dfrac {\sum f_i}{\sum t_i}$</p>
<ul>
<li>要想求出区间的左范围，那么分子应该最小，分母应该最大，那么分子应该取一个点，该点的点权为1；分母应该取5000条边，边权为1000，那么此时$c=\dfrac {1\times1}{5000\times1000}$，很难明显，这个$c$不为0，肯定是大于0的，注意这里不能理解为C++中的整除会向下取整，这里应该理解为浮点数的除法，因为题目说了要保留两位小数。因此，我们确定了左范围是大于0的</li>
<li>要想求出区间的右范围，那么分子应该最大，分母应该最小，那么分子应该取1000个点，每个点的点权都为1000；由于有了1000个点，那么对于环来说，至少得是1000条边（注意不可能说有1000个点，然后取1条边，这样不能形成环），这1000条边的权值都为1，那么此时$c=\dfrac {1000\times1000}{1000\times1}=1000$。因此，我们确定了右范围是1000</li>
<li>所以，答案区间就是<code>(0,1000]</code></li>
</ul>
<p>由于我们发现答案区间是单调递增的，也就是说具有单调性，那么就可以用二分算法，来快速地求出$c$。我们设$L=0,R=1000$，假设某个时刻，我们设中点为$mid$，那么：</p>
<p>$\dfrac {\sum f_i}{\sum t_i}&gt;mid$</p>
<p>$\iff$ $\sum f_i&gt;mid*\sum t_i$</p>
<p>$\iff$ $\sum f_i-mid*\sum t_i&gt;0$</p>
<p>$\iff$ $\sum (f_i-mid*t_i)&gt;0$</p>
<p>根据上述推导的公式可知，对于满足要求的$mid$，就是要满足图中存在一个<code>环</code>，它的$\sum (f_i-mid*t_i)&gt;0$ ，要求一个环，它的权值之和大于0，这不就是想让我们求正环嘛？</p>
<p>因此，原问题就转换为 求图中是否存在一个正环 的问题了</p>
<p>我们每次二分出一个$mid$，然后$check(mid)$，如果它满足上面的这个式子，那么由于答案是单调递增的，我们想要求出最大的$mid$，因此此时左范围$L$应该往右侧收缩，即$L=mid$，不可能让右范围往左收缩吧，即不可能是$R=mid$（如果这样的话，那么更新过后的区间的最大值不就小于$mid$了嘛，这就不可能找到最大值了）。因此一旦二分出的$mid$满足上述式子，那么就往右侧收缩$L=mid$，这样会更快地逼近最大值；如果二分出的这个$mid$不满足上述式子，则说明答案肯定比当前二分的$mid$还小，那么就要往左侧收缩$R=mid$，因为右边已经不可能了。</p>
<p>浮点数的二分比较简单，就是执行$L=mid$或者$R=mid$。</p>
<p>这里还有个问题，就是我们该怎么处理点权和边权呢？我们以前都只是见过有边权的情况。其实，我们可以把节点的点权放到它的出边上，那么此时就只有边权的情况了，不存在点权。为什么可以这么做呢？</p>
<ul>
<li>假设同时存在点权和边权，那么所有点权之和为$\sum f_i$，所有边权之和为$\sum t_i$，因此，总的权值之和为$\sum f_i+\sum t_i$</li>
<li>假设把点权放到出边上，此时只有边权，那么某个出边的权值为$f_i+t_i$，因此，总的权值之和为$\sum (f_i+t_i)$</li>
<li>由于$\sum$是可以分开的，因此$\sum(f_i+t_i)=\sum f_i+\sum t_i$</li>
</ul>
<p>有了上面的处理之和，我们建图就会更加方便了，只需要处理边权就好了。</p>
<p>我们来看这个式子 $\sum(f_i-mid\times t_i)$，那么其实就是$\sum (f_i+(-mid\times t_i))&gt;0=\sum f_i+\sum-mid\times t_i$，也就是说把原来的边权$t_i$换成了$f_i-mid\times t_i$来存储了，把每个点的权值都放入它的出边中。</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>,M=<span class="number">5010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="comment">//点权</span></span><br><span class="line"><span class="keyword">int</span> wf[N];</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],wt[M],idx;  <span class="comment">//wt是边权</span></span><br><span class="line"><span class="keyword">int</span> q[N],cnt[N];</span><br><span class="line"><span class="keyword">double</span> dist[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    wt[idx]=c;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//spfa判断正环</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">double</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">-0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">memset</span>(st,<span class="number">0</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span> cnt);</span><br><span class="line">    <span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//一开始将原图中所有点加入队列q中就  等效于建立了一个带有虚拟源点的新图 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        q[tt++]=i;</span><br><span class="line">        dist[i]=<span class="number">0</span>;</span><br><span class="line">        st[i]=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(hh!=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=q[hh++];</span><br><span class="line">        <span class="keyword">if</span>(hh==N)</span><br><span class="line">        hh=<span class="number">0</span>;</span><br><span class="line">        st[t]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];</span><br><span class="line">            <span class="comment">//wf[t]-mid*wt[i]是将点权放到了边上</span></span><br><span class="line">            <span class="keyword">if</span>(dist[j]&lt;dist[t]+wf[t]-mid*wt[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j]=dist[t]+wf[t]-mid*wt[i];</span><br><span class="line">                cnt[j]=cnt[t]+<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//说明存在正环</span></span><br><span class="line">                <span class="keyword">if</span>(cnt[j]&gt;=n)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q[tt++]=j;</span><br><span class="line">                    <span class="keyword">if</span>(tt==N)</span><br><span class="line">                    tt=<span class="number">0</span>;</span><br><span class="line">                    st[j]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//说明不存在正环</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;wf[i]);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a,b,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> l=<span class="number">0</span>,r=<span class="number">1e4</span>;</span><br><span class="line">    <span class="comment">//二分找到答案</span></span><br><span class="line">    <span class="keyword">while</span>(l+<span class="number">1e-4</span>&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//满足条件 则向右侧收缩</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid))</span><br><span class="line">        l=mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        r=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>,l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>负环</category>
      </categories>
      <tags>
        <tag>负环</tag>
      </tags>
  </entry>
  <entry>
    <title>虫洞</title>
    <url>/2021/07/11/%E7%AE%97%E6%B3%95%E6%8F%90%E9%AB%98%E8%AF%BE/%E7%AC%AC%E4%B8%89%E7%AB%A0---%E5%9B%BE%E8%AE%BA/%E8%B4%9F%E7%8E%AF/%E8%99%AB%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="虫洞"><a href="#虫洞" class="headerlink" title="虫洞"></a>虫洞</h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://cdn.jsdelivr.net/gh//3CodeLove/Images@main/20210711231829.png" alt="image-20210711231829264"></p>
<hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>这题主要是要读懂题目，刚开始读不懂，后来再理解这题其实就是一个裸的求负环。</p>
<p>虫洞它是单向边，路径是双向边，因此建图时，图中就会既有单项边，又有双向边。”通过虫洞，它可以回到过去的某个时刻“这句话的意思其实就是说明虫洞的单向边是负值</p>
<p>读懂题目的意思后，用spfa求负环就好了</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//边数=路径的双向边2500*2+虫洞的单向边200=5200</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">510</span>,M=<span class="number">5210</span>;</span><br><span class="line"><span class="comment">//n表示田地的数量  m1表示路径的数量  m2表示虫洞单向边的数量</span></span><br><span class="line"><span class="keyword">int</span> n,m1,m2;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],w[M],idx;</span><br><span class="line"><span class="keyword">int</span> q[N],cnt[N],dist[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="comment">//建图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    w[idx]=c;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//spfa求负环</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//有多组测试数据 要初始化</span></span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);  <span class="comment">//求负环时  对于dist数组没有任何要求,不用初始化都可以</span></span><br><span class="line">    <span class="built_in">memset</span>(st,<span class="number">0</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span> cnt);</span><br><span class="line">    <span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//在新图中添加一个虚拟源点就等效于 一开始将原图中的所有节点都加入循环队列q中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        q[tt++]=i;</span><br><span class="line">        <span class="comment">//这里从初始化为0 其实含义就是：在新图中,虚拟源点到其他n个节点连一条长度为0的边</span></span><br><span class="line">        dist[i]=<span class="number">0</span>;</span><br><span class="line">        st[i]=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(hh!=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=q[hh++];</span><br><span class="line">        <span class="keyword">if</span>(hh==N)</span><br><span class="line">        hh=<span class="number">0</span>;</span><br><span class="line">        st[t]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j]&gt;dist[t]+w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j]=dist[t]+w[i];</span><br><span class="line">                cnt[j]=cnt[t]+<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//存在负环  那么他可以回到过去</span></span><br><span class="line">                <span class="keyword">if</span>(cnt[j]&gt;=n) </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q[tt++]=j;</span><br><span class="line">                    <span class="keyword">if</span>(tt==N)</span><br><span class="line">                    tt=<span class="number">0</span>;</span><br><span class="line">                    st[j]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//说明不存在负环  那么他不可用回到过去</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">        idx=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m1,&amp;m2);</span><br><span class="line">        <span class="comment">//给路径的双向边建图</span></span><br><span class="line">        <span class="keyword">while</span>(m1--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a,b,c;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">            <span class="built_in">add</span>(a,b,c);</span><br><span class="line">            <span class="built_in">add</span>(b,a,c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//给虫洞的单向边建图</span></span><br><span class="line">        <span class="keyword">while</span>(m2--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a,b,c;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">            <span class="comment">//注意边的权值是-c</span></span><br><span class="line">            <span class="built_in">add</span>(a,b,-c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//存在负环 则可以回到过去</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">spfa</span>())</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">        <span class="comment">//不存在负环 则不可以回到过去</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>负环</category>
      </categories>
      <tags>
        <tag>负环</tag>
      </tags>
  </entry>
</search>
